;AS.C V0.1, Source: N1.S, Output: N1.LST, N1.COM

0000                                                     
0000                ; A.COM CComp V0.7, Arglen: 5, Argv: AS.C, Source: AS.C, Output asm: AS.S
0000                ;PROTECTED: 0 V86 OFF.  32bit: ON. 
0000                org  256 ; NASM ON
0000 E9 00 00      *jmp main
0003                
0003                ;-1 char Version1[]="AS.C V0.07";//BAS.BAT, AS TE, NAS.BAT
0003                
0003 41 53 2E 43 20 Version1 db "AS.C V0.07",0
000E                
000E                ;-2 #include "DECL.C"
000E                
000E                ;Use include file: DECL.C
000E                
000E                ;-1 char LIST;              //listing on/off     
000E                
000E 00             LIST db 0
000F                
000F                ;-2 #define SYMBOLMAX    31
000F                
000F                
000F                ;-3 char Symbol[SYMBOLMAX]; //next symbol to decode
000F                
000F 00 00 00 00 00 Symbol resb 31
002E                
002E                ;-4 char SymbolUpper[SYMBOLMAX];//set toupper in getName
002E                
002E 00 00 00 00 00 SymbolUpper resb 31
004D                
004D                ;-5 unsigned int SymbolInt; //integer value set in getDigit
004D                
004D 00 00          SymbolInt dw 0
004F                
004F                ;-6 #define INPUTBUFMAX 127
004F                
004F                
004F                ;-7 char InputBuf[INPUTBUFMAX];//filled in getLine, no overflow test
004F                
004F 00 00 00 00 00 InputBuf resb 127
00CE                
00CE                ;-8 unsigned char *InputPtr;//position in InputBuf
00CE                
00CE 00 00          InputPtr dw 0
00D0                
00D0                ;-9 char namein [67];       //input file name  .S
00D0                
00D0 00 00 00 00 00 namein resb 67
0113                
0113                ;-10 char namelst[67];       //list file name   .LST
0113                
0113 00 00 00 00 00 namelst resb 67
0156                
0156                ;-11 char namebin[67];       //output file name .COM
0156                
0156 00 00 00 00 00 namebin resb 67
0199                
0199                ;-12 int  asm_fd;            //input file descriptor
0199                
0199 00 00          asm_fd dw 0
019B                
019B                ;-13 int lst_fd;             //list file descriptor
019B                
019B 00 00          lst_fd dw 0
019D                
019D                ;-14 int bin_fd;             //output file descriptor
019D                
019D 00 00          bin_fd dw 0
019F                
019F                ;-15 int DOS_ERR=0;          //global var
019F                
019F 00 00          DOS_ERR dw 0
01A1                
01A1                ;-16 int ErrorCount=0;       //number of errors
01A1                
01A1 00 00          ErrorCount dw 0
01A3                
01A3                ;-17 int DOS_NoBytes;        //number of bytes read (0 or 1)
01A3                
01A3 00 00          DOS_NoBytes dw 0
01A5                
01A5                ;-18 char DOS_ByteRead;      //the byte just read by DOS
01A5                
01A5 00             DOS_ByteRead db 0
01A6                
01A6                ;-19 
01A6                
01A6                
01A6                ;-20 unsigned int PC=0;      //program counter
01A6                
01A6 00 00          PC dw 0
01A8                
01A8                ;-21 unsigned int Origin=0;  //ORG nn
01A8                
01A8 00 00          Origin dw 0
01AA                
01AA                ;-22 unsigned int PCStart;   //PC at start of line by PrintLine()
01AA                
01AA 00 00          PCStart dw 0
01AC                
01AC                ;-23 char isLabel;           //by getName()
01AC                
01AC 00             isLabel db 0
01AD                
01AD                ;-24 #define DIGIT    1      //0-9
01AD                
01AD                
01AD                ;-25 #define LETTERE  2      //a-z A-Z @ . _
01AD                
01AD                
01AD                ;-26 #define ALNUME   3      //a-z A-Z @ . _  0-9
01AD                
01AD                
01AD                ;-27 #define NOALNUME 4      //other char
01AD                
01AD                
01AD                ;-28 char TokeType;          //0, DIGIT, LETTERE, ALNUME, NOALNUME
01AD                
01AD 00             TokeType db 0
01AE                
01AE                ;-29 #define BYTE     1
01AE                
01AE                
01AE                ;-30 #define WORD     2
01AE                
01AE                
01AE                ;-31 #define DWORD    3
01AE                
01AE                
01AE                ;-32 #define SEGREG   4
01AE                
01AE                
01AE                ;-33 #define IMM      1      //const  ,123
01AE                
01AE                
01AE                ;-34 #define REG      2      //       ,BX    mode=11
01AE                
01AE                
01AE                ;-35 #define ADR      3      //DIRECT: VALUE  ,var1  mod=00, r/m=110
01AE                
01AE                
01AE                ;-36 #define MEM      4      //[var1],[BX+SI],[table+BX],[bp-4] disp0,8,16
01AE                
01AE                
01AE                ;-37 char Op;                //1. operand: 0, IMM, REG, ADR, MEM  
01AE                
01AE 00             Op db 0
01AF                
01AF                ;-38 char Op2;               //2. operand
01AF                
01AF 00             Op2 db 0
01B0                
01B0                ;-39 char CodeType;          //1-207 by searchSymbol(), must be byte size
01B0                
01B0 00             CodeType db 0
01B1                
01B1                ;-40 char Code1;             //1. Opcode
01B1                
01B1 00             Code1 db 0
01B2                
01B2                ;-41 char Code2;             //2. Opcode
01B2                
01B2 00             Code2 db 0
01B3                
01B3                ;-42 char Code3;             //3. Opcode
01B3                
01B3 00             Code3 db 0
01B4                
01B4                ;-43 char R2No;              //0 - 7 AL, CL, ...  set in testReg()  
01B4                
01B4 00             R2No db 0
01B5                
01B5                ;-44 char R1No;              //temp for 1. register
01B5                
01B5 00             R1No db 0
01B6                
01B6                ;-45 char R2Type;            //0=no reg, BYTE, WORD, DWORD, SEGREG
01B6                
01B6 00             R2Type db 0
01B7                
01B7                ;-46 char R1Type;            //temp for 1. register 
01B7                
01B7 00             R1Type db 0
01B8                
01B8                ;-47 char OpSize;            //0, BYTE, WORD, DWORD by getCodeSize()
01B8                
01B8 00             OpSize db 0
01B9                
01B9                ;-48 char wflag;             //wordflag: 0=byte, 1=word/dword
01B9                
01B9 00             wflag db 0
01BA                
01BA                ;-49 char dflag;             //directionflag: 1=to reg MOV,ALU    
01BA                
01BA 00             dflag db 0
01BB                
01BB                ;-50 char sflag;             //sign extended, imm8 to word PUSH,ALU,IMUL3 
01BB                
01BB 00             sflag db 0
01BC                
01BC                ;-51 char rm;                //combination of index and base reg
01BC                
01BC 00             rm db 0
01BD                
01BD                ;-52 char isDirect;          //set in process and getMeM, need in WriteEA
01BD                
01BD 00             isDirect db 0
01BE                
01BE                ;-53 int disp;               //displacement      0-8 bytes
01BE                
01BE 00 00          disp dw 0
01C0                
01C0                ;-54 unsigned int imme;      //immediate         0-8 bytes
01C0                
01C0 00 00          imme dw 0
01C2                
01C2                ;-55 
01C2                
01C2                
01C2                ;-56 #define OPMAXLEN 5
01C2                
01C2                
01C2                ;-57 char OpPos[OPMAXLEN];   //array for one opcode to list
01C2                
01C2 00 00 00 00 00 OpPos resb 5
01C7                
01C7                ;-58 int OpPrintIndex;       //0-OPMAXLEN, pos to print opcode, by genCode8
01C7                
01C7 00 00          OpPrintIndex dw 0
01C9                
01C9                ;-59 char *OpCodePtr;        //position in OpCodeTable by searchSymbol
01C9                
01C9 00 00          OpCodePtr dw 0
01CB                
01CB                ;-60 char PrintRA;           //print * for forward relocative jmp
01CB                
01CB 00             PrintRA db 0
01CC                
01CC                ;-61 
01CC                
01CC                
01CC                ;-62 #define LABELNAMESMAX 969//next number - SYMBOLMAX
01CC                
01CC                
01CC                ;-63 char LabelNames[1000];  //space for names of all labels
01CC                
01CC 00 00 00 00 00 LabelNames resb 1000
05B4                
05B4                ;-64 char *LabelNamePtr;     //first free position
05B4                
05B4 00 00          LabelNamePtr dw 0
05B6                
05B6                ;-65 #define LABELADRMAX 100
05B6                
05B6                
05B6                ;-66 unsigned int LabelAddr[LABELADRMAX];//addr of each label
05B6                
05B6 00 00 00 00 00 LabelAddr resw 100
067E                
067E                ;-67 int LabelMaxIx=0;       //actual # of stored labels. 1 to LABELADRMAX-1
067E                
067E 00 00          LabelMaxIx dw 0
0680                
0680                ;-68 int LabelIx;            //actual # of just searched label
0680                
0680 00 00          LabelIx dw 0
0682                
0682                ;-69 
0682                
0682                
0682                ;-70 #define JMPCALLMAX 500  //max. jmp and call
0682                
0682                
0682                ;-71 #define JMPCALLNAMESMAX 1969//next number - SYMBOLMAX
0682                
0682                
0682                ;-72 char JmpCallNames[2000];//space for names of jmp, call
0682                
0682 00 00 00 00 00 JmpCallNames resb 2000
0E52                
0E52                ;-73 char *JmpCallNamePtr;   //first free position 
0E52                
0E52 00 00          JmpCallNamePtr dw 0
0E54                
0E54                ;-74 unsigned int JmpCallAddr[JMPCALLMAX];//addr to be fixed
0E54                
0E54 00 00 00 00 00 JmpCallAddr resw 500
123C                
123C                ;-75 int JmpCallMaxIx=0;     //actual # of jmp, call. 1 to JMPCALLMAX-1
123C                
123C 00 00          JmpCallMaxIx dw 0
123E                
123E                ;-76  
123E                
123E                
123E                ;-77 #define FILEBINMAX 2000 
123E                
123E                
123E                ;-78 char FileBin  [FILEBINMAX];//output binary file
123E                
123E 00 00 00 00 00 FileBin resb 2000
1A0E                
1A0E                ;-79 unsigned int BinLen=0;  //length of binary file
1A0E                
1A0E 00 00          BinLen dw 0
1A10                
1A10                ;-80 
1A10                
1A10                
1A10                ;-81 char *arglen=0x80;      // for main only
1A10                
1A10 80 00          arglen dw 128
1A12                
1A12                ;-82 char *argv=0x82;        // for main only
1A12                
1A12 82 00          argv dw 130
1A14                ;Back to main program: AS.C
1A14                
1A14                ;-3 #include "OPTABL.C"   
1A14                
1A14                ;Use include file: OPTABL.C
1A14                
1A14                ;-1 char I_START=0xF1;
1A14                
1A14 F1             I_START db 241
1A15                
1A15                ;-2 //OpName, 0, CodeType, OpCode1-n, F1h
1A15                
1A15                
1A15                ;-3 //  1:   1 byte opcode
1A15                
1A15                
1A15                ;-4 char I_PUSHA[]={'P','U','S','H','A',0,  1,0x60,   0xF1};
1A15                
1A15 50 55 53 48 41 I_PUSHA db 80,85,83,72,65,0,1,96,241
1A1E                
1A1E                ;-5 char I_POPA[]= {'P','O','P','A',0,      1,0x61,   0xF1};
1A1E                
1A1E 50 4F 50 41 00 I_POPA db 80,79,80,65,0,1,97,241
1A26                
1A26                ;-6 char I_NOP[]=  {'N','O','P',0,          1,0x90,   0xF1};
1A26                
1A26 4E 4F 50 00 01 I_NOP db 78,79,80,0,1,144,241
1A2D                
1A2D                ;-7 char I_CBW[]=  {'C','B','W',0,          1,0x98,   0xF1};
1A2D                
1A2D 43 42 57 00 01 I_CBW db 67,66,87,0,1,152,241
1A34                
1A34                ;-8 char I_CWDE[]= {'C','W','D','E',0,      1,0x98,   0xF1};
1A34                
1A34 43 57 44 45 00 I_CWDE db 67,87,68,69,0,1,152,241
1A3C                
1A3C                ;-9 char I_CWD[]=  {'C','W','D',0,          1,0x99,   0xF1};
1A3C                
1A3C 43 57 44 00 01 I_CWD db 67,87,68,0,1,153,241
1A43                
1A43                ;-10 char I_CDQ[]=  {'C','D','Q',0,          1,0x99,   0xF1};
1A43                
1A43 43 44 51 00 01 I_CDQ db 67,68,81,0,1,153,241
1A4A                
1A4A                ;-11 char I_WAIT[]= {'W','A','I','T',0,      1,0x9B,   0xF1};
1A4A                
1A4A 57 41 49 54 00 I_WAIT db 87,65,73,84,0,1,155,241
1A52                
1A52                ;-12 char I_PUSHF[]={'P','U','S','H','F',0,  1,0x9C,   0xF1};
1A52                
1A52 50 55 53 48 46 I_PUSHF db 80,85,83,72,70,0,1,156,241
1A5B                
1A5B                ;-13 char I_POPF[]= {'P','O','P','F',0,      1,0x9D,   0xF1};
1A5B                
1A5B 50 4F 50 46 00 I_POPF db 80,79,80,70,0,1,157,241
1A63                
1A63                ;-14 char I_SAHF[]= {'S','A','H','F',0,      1,0x9E,   0xF1};
1A63                
1A63 53 41 48 46 00 I_SAHF db 83,65,72,70,0,1,158,241
1A6B                
1A6B                ;-15 char I_LAHF[]= {'L','A','H','F',0,      1,0x9F,   0xF1};
1A6B                
1A6B 4C 41 48 46 00 I_LAHF db 76,65,72,70,0,1,159,241
1A73                
1A73                ;-16 char I_MOVSB[]={'M','O','V','S','B',0,  1,0xA4,   0xF1};
1A73                
1A73 4D 4F 56 53 42 I_MOVSB db 77,79,86,83,66,0,1,164,241
1A7C                
1A7C                ;-17 char I_MOVSW[]={'M','O','V','S','W',0,  1,0xA5,   0xF1};
1A7C                
1A7C 4D 4F 56 53 57 I_MOVSW db 77,79,86,83,87,0,1,165,241
1A85                
1A85                ;-18 char I_CMPSB[]={'C','M','P','S','B',0,  1,0xA6,   0xF1};
1A85                
1A85 43 4D 50 53 42 I_CMPSB db 67,77,80,83,66,0,1,166,241
1A8E                
1A8E                ;-19 char I_CMPSW[]={'C','M','P','S','W',0,  1,0xA7,   0xF1};
1A8E                
1A8E 43 4D 50 53 57 I_CMPSW db 67,77,80,83,87,0,1,167,241
1A97                
1A97                ;-20 char I_STOSB[]={'S','T','O','S','B',0,  1,0xAA,   0xF1};
1A97                
1A97 53 54 4F 53 42 I_STOSB db 83,84,79,83,66,0,1,170,241
1AA0                
1AA0                ;-21 char I_STOSW[]={'S','T','O','S','W',0,  1,0xAB,   0xF1};
1AA0                
1AA0 53 54 4F 53 57 I_STOSW db 83,84,79,83,87,0,1,171,241
1AA9                
1AA9                ;-22 char I_LODSB[]={'L','O','D','S','B',0,  1,0xAC,   0xF1};
1AA9                
1AA9 4C 4F 44 53 42 I_LODSB db 76,79,68,83,66,0,1,172,241
1AB2                
1AB2                ;-23 char I_LODSW[]={'L','O','D','S','W',0,  1,0xAD,   0xF1};
1AB2                
1AB2 4C 4F 44 53 57 I_LODSW db 76,79,68,83,87,0,1,173,241
1ABB                
1ABB                ;-24 char I_SCASB[]={'S','C','A','S','B',0,  1,0xAE,   0xF1};
1ABB                
1ABB 53 43 41 53 42 I_SCASB db 83,67,65,83,66,0,1,174,241
1AC4                
1AC4                ;-25 char I_SCASW[]={'S','C','A','S','W',0,  1,0xAF,   0xF1};
1AC4                
1AC4 53 43 41 53 57 I_SCASW db 83,67,65,83,87,0,1,175,241
1ACD                
1ACD                ;-26 char I_LEAVE[]={'L','E','A','V','E',0,  1,0xC9,   0xF1};
1ACD                
1ACD 4C 45 41 56 45 I_LEAVE db 76,69,65,86,69,0,1,201,241
1AD6                
1AD6                ;-27 char I_INT3[]= {'I','N','T','3',0,      1,0xCC,   0xF1};
1AD6                
1AD6 49 4E 54 33 00 I_INT3 db 73,78,84,51,0,1,204,241
1ADE                
1ADE                ;-28 char I_INTO[]= {'I','N','T','O',0,      1,0xCE,   0xF1};
1ADE                
1ADE 49 4E 54 4F 00 I_INTO db 73,78,84,79,0,1,206,241
1AE6                
1AE6                ;-29 char I_IRET[]= {'I','R','E','T',0,      1,0xCF,   0xF1};
1AE6                
1AE6 49 52 45 54 00 I_IRET db 73,82,69,84,0,1,207,241
1AEE                
1AEE                ;-30 char I_XLAT[]= {'X','L','A','T',0,      1,0xD7,   0xF1};
1AEE                
1AEE 58 4C 41 54 00 I_XLAT db 88,76,65,84,0,1,215,241
1AF6                
1AF6                ;-31 char I_LOCK[]= {'L','O','C','K',0,      1,0xF0,   0xF1};
1AF6                
1AF6 4C 4F 43 4B 00 I_LOCK db 76,79,67,75,0,1,240,241
1AFE                
1AFE                ;-32 char I_REPNE[]={'R','E','P','N','E',0,  1,0xF2,   0xF1};
1AFE                
1AFE 52 45 50 4E 45 I_REPNE db 82,69,80,78,69,0,1,242,241
1B07                
1B07                ;-33 char I_REPNZ[]={'R','E','P','N','Z',0,  1,0xF2,   0xF1};
1B07                
1B07 52 45 50 4E 5A I_REPNZ db 82,69,80,78,90,0,1,242,241
1B10                
1B10                ;-34 char I_REPE[]= {'R','E','P','E',0,      1,0xF3,   0xF1};
1B10                
1B10 52 45 50 45 00 I_REPE db 82,69,80,69,0,1,243,241
1B18                
1B18                ;-35 char I_REPZ[]= {'R','E','P','Z',0,      1,0xF3,   0xF1};
1B18                
1B18 52 45 50 5A 00 I_REPZ db 82,69,80,90,0,1,243,241
1B20                
1B20                ;-36 char I_HLT[]=  {'H','L','T',0,          1,0xF4,   0xF1};
1B20                
1B20 48 4C 54 00 01 I_HLT db 72,76,84,0,1,244,241
1B27                
1B27                ;-37 char I_CLC[]=  {'C','L','C',0,          1,0xF8,   0xF1};//clear carry
1B27                
1B27 43 4C 43 00 01 I_CLC db 67,76,67,0,1,248,241
1B2E                
1B2E                ;-38 char I_STC[]=  {'S','T','C',0,          1,0xF9,   0xF1};//set carry
1B2E                
1B2E 53 54 43 00 01 I_STC db 83,84,67,0,1,249,241
1B35                
1B35                ;-39 char I_CLI[]=  {'C','L','I',0,          1,0xFA,   0xF1};//clear interrupt
1B35                
1B35 43 4C 49 00 01 I_CLI db 67,76,73,0,1,250,241
1B3C                
1B3C                ;-40 char I_STI[]=  {'S','T','I',0,          1,0xFB,   0xF1};//set interrupt
1B3C                
1B3C 53 54 49 00 01 I_STI db 83,84,73,0,1,251,241
1B43                
1B43                ;-41 char I_CLD[]=  {'C','L','D',0,          1,0xFC,   0xF1};//clear direction
1B43                
1B43 43 4C 44 00 01 I_CLD db 67,76,68,0,1,252,241
1B4A                
1B4A                ;-42 char I_STD[]=  {'S','T','D',0,          1,0xFD,   0xF1};//set direction
1B4A                
1B4A 53 54 44 00 01 I_STD db 83,84,68,0,1,253,241
1B51                
1B51                ;-43 // 2: mem reg 16 bit
1B51                
1B51                
1B51                ;-44 char I_INC[]=  {'I','N','C',0,          2,0xFE, 0,0x40,0xF1};
1B51                
1B51 49 4E 43 00 02 I_INC db 73,78,67,0,2,254,0,64,241
1B5A                
1B5A                ;-45 char I_DEC[]=  {'D','E','C',0,          2,0xFE, 1,0x48,0xF1};
1B5A                
1B5A 44 45 43 00 02 I_DEC db 68,69,67,0,2,254,1,72,241
1B63                
1B63                ;-46 char I_NOT[]=  {'N','O','T',0,          2,0xF6, 2,     0xF1};
1B63                
1B63 4E 4F 54 00 02 I_NOT db 78,79,84,0,2,246,2,241
1B6B                
1B6B                ;-47 char I_NEG[]=  {'N','E','G',0,          2,0xF6, 3,     0xF1};
1B6B                
1B6B 4E 45 47 00 02 I_NEG db 78,69,71,0,2,246,3,241
1B73                
1B73                ;-48 char I_MUL[]=  {'M','U','L',0,          2,0xF6, 4,     0xF1};
1B73                
1B73 4D 55 4C 00 02 I_MUL db 77,85,76,0,2,246,4,241
1B7B                
1B7B                ;-49 char I_IMUL[]= {'I','M','U','L',0,      2,0xF6, 5,     0xF1};//only acc
1B7B                
1B7B 49 4D 55 4C 00 I_IMUL db 73,77,85,76,0,2,246,5,241
1B84                
1B84                ;-50 char I_DIV[]=  {'D','I','V',0,          2,0xF6, 6,     0xF1};
1B84                
1B84 44 49 56 00 02 I_DIV db 68,73,86,0,2,246,6,241
1B8C                
1B8C                ;-51 char I_IDIV[]= {'I','D','I','V',0,      2,0xF6, 7,     0xF1};
1B8C                
1B8C 49 44 49 56 00 I_IDIV db 73,68,73,86,0,2,246,7,241
1B95                
1B95                ;-52 //  3: les, lda, lea, lss, lfs, lgs
1B95                
1B95                
1B95                ;-53 char I_LES[]=  {'L','E','S',0,          3,0xC4,     0xF1};
1B95                
1B95 4C 45 53 00 03 I_LES db 76,69,83,0,3,196,241
1B9C                
1B9C                ;-54 char I_LDS[]=  {'L','D','S',0,          3,0xC5,     0xF1};
1B9C                
1B9C 4C 44 53 00 03 I_LDS db 76,68,83,0,3,197,241
1BA3                
1BA3                ;-55 char I_LEA[]=  {'L','E','A',0,          3,0x8D,     0xF1};//r, m16
1BA3                
1BA3 4C 45 41 00 03 I_LEA db 76,69,65,0,3,141,241
1BAA                
1BAA                ;-56 char I_LSS[]=  {'L','S','S',0,          3,0x0F,0xB2,0xF1};
1BAA                
1BAA 4C 53 53 00 03 I_LSS db 76,83,83,0,3,15,178,241
1BB2                
1BB2                ;-57 char I_LFS[]=  {'L','F','S',0,          3,0x0F,0xB4,0xF1};
1BB2                
1BB2 4C 46 53 00 03 I_LFS db 76,70,83,0,3,15,180,241
1BBA                
1BBA                ;-58 char I_LGS[]=  {'L','G','S',0,          3,0x0F,0xB5,0xF1};
1BBA                
1BBA 4C 47 53 00 03 I_LGS db 76,71,83,0,3,15,181,241
1BC2                
1BC2                ;-59 //  4: acc,imm  reg,imm  index,reg
1BC2                
1BC2                
1BC2                ;-60 char I_ADD[]=  {'A','D','D',0,          4, 0,     0xF1};
1BC2                
1BC2 41 44 44 00 04 I_ADD db 65,68,68,0,4,0,241
1BC9                
1BC9                ;-61 char I_OR []=  {'O','R',0,              4, 1,     0xF1};
1BC9                
1BC9 4F 52 00 04 01 I_OR db 79,82,0,4,1,241
1BCF                
1BCF                ;-62 char I_ADC[]=  {'A','D','C',0,          4, 2,     0xF1};
1BCF                
1BCF 41 44 43 00 04 I_ADC db 65,68,67,0,4,2,241
1BD6                
1BD6                ;-63 char I_SBB[]=  {'S','B','B',0,          4, 3,     0xF1};
1BD6                
1BD6 53 42 42 00 04 I_SBB db 83,66,66,0,4,3,241
1BDD                
1BDD                ;-64 char I_AND[]=  {'A','N','D',0,          4, 4,     0xF1};
1BDD                
1BDD 41 4E 44 00 04 I_AND db 65,78,68,0,4,4,241
1BE4                
1BE4                ;-65 char I_SUB[]=  {'S','U','B',0,          4, 5,     0xF1};
1BE4                
1BE4 53 55 42 00 04 I_SUB db 83,85,66,0,4,5,241
1BEB                
1BEB                ;-66 char I_XOR[]=  {'X','O','R',0,          4, 6,     0xF1};
1BEB                
1BEB 58 4F 52 00 04 I_XOR db 88,79,82,0,4,6,241
1BF2                
1BF2                ;-67 char I_CMP[]=  {'C','M','P',0,          4, 7,     0xF1};
1BF2                
1BF2 43 4D 50 00 04 I_CMP db 67,77,80,0,4,7,241
1BF9                
1BF9                ;-68 char I_TEST[]= {'T','E','S','T',0,     41,0xA8,0x84,0xF6,0,0xF1};
1BF9                
1BF9 54 45 53 54 00 I_TEST db 84,69,83,84,0,41,168,132,246,0,241
1C04                
1C04                ;-69 //  5: mov
1C04                
1C04                
1C04                ;-70 char I_MOV[]=  {'M','O','V',0,          5,        0xF1};
1C04                
1C04 4D 4F 56 00 05 I_MOV db 77,79,86,0,5,241
1C0A                
1C0A                ;-71 char I_MOVSX[]={'M','O','V','S','X',0, 51,0xBE,   0xF1};
1C0A                
1C0A 4D 4F 56 53 58 I_MOVSX db 77,79,86,83,88,0,51,190,241
1C13                
1C13                ;-72 char I_MOVZX[]={'M','O','V','Z','X',0, 51,0xB6,   0xF1};
1C13                
1C13 4D 4F 56 5A 58 I_MOVZX db 77,79,86,90,88,0,51,182,241
1C1C                
1C1C                ;-73 //  6: single byte relative jump
1C1C                
1C1C                
1C1C                ;-74 char I_JO []=  {'J','O',0,              6, 0,     0xF1};
1C1C                
1C1C 4A 4F 00 06 00 I_JO db 74,79,0,6,0,241
1C22                
1C22                ;-75 char I_JNO[]=  {'J','N','O',0,          6, 1,     0xF1};
1C22                
1C22 4A 4E 4F 00 06 I_JNO db 74,78,79,0,6,1,241
1C29                
1C29                ;-76 char I_JB []=  {'J','B',0,              6, 2,     0xF1};
1C29                
1C29 4A 42 00 06 02 I_JB db 74,66,0,6,2,241
1C2F                
1C2F                ;-77 char I_JC []=  {'J','C',0,              6, 2,     0xF1};
1C2F                
1C2F 4A 43 00 06 02 I_JC db 74,67,0,6,2,241
1C35                
1C35                ;-78 char I_JNB[]=  {'J','N','B',0,          6, 3,     0xF1};
1C35                
1C35 4A 4E 42 00 06 I_JNB db 74,78,66,0,6,3,241
1C3C                
1C3C                ;-79 char I_JAE[]=  {'J','A','E',0,          6, 3,     0xF1};
1C3C                
1C3C 4A 41 45 00 06 I_JAE db 74,65,69,0,6,3,241
1C43                
1C43                ;-80 char I_JNC[]=  {'J','N','C',0,          6, 3,     0xF1};
1C43                
1C43 4A 4E 43 00 06 I_JNC db 74,78,67,0,6,3,241
1C4A                
1C4A                ;-81 char I_JE []=  {'J','E',0,              6, 4,     0xF1};//  74 je i8rel
1C4A                
1C4A 4A 45 00 06 04 I_JE db 74,69,0,6,4,241
1C50                
1C50                ;-82 char I_JZ []=  {'J','Z',0,              6, 4,     0xF1};//0F84 je i16r
1C50                
1C50 4A 5A 00 06 04 I_JZ db 74,90,0,6,4,241
1C56                
1C56                ;-83 char I_JNE[]=  {'J','N','E',0,          6, 5,     0xF1};
1C56                
1C56 4A 4E 45 00 06 I_JNE db 74,78,69,0,6,5,241
1C5D                
1C5D                ;-84 char I_JNZ[]=  {'J','N','Z',0,          6, 5,     0xF1};
1C5D                
1C5D 4A 4E 5A 00 06 I_JNZ db 74,78,90,0,6,5,241
1C64                
1C64                ;-85 char I_JBE[]=  {'J','B','E',0,          6, 6,     0xF1};
1C64                
1C64 4A 42 45 00 06 I_JBE db 74,66,69,0,6,6,241
1C6B                
1C6B                ;-86 char I_JNA[]=  {'J','N','A',0,          6, 6,     0xF1};
1C6B                
1C6B 4A 4E 41 00 06 I_JNA db 74,78,65,0,6,6,241
1C72                
1C72                ;-87 char I_JA []=  {'J','A',0,              6, 7,     0xF1};
1C72                
1C72 4A 41 00 06 07 I_JA db 74,65,0,6,7,241
1C78                
1C78                ;-88 char I_JS []=  {'J','S',0,              6, 8,     0xF1};
1C78                
1C78 4A 53 00 06 08 I_JS db 74,83,0,6,8,241
1C7E                
1C7E                ;-89 char I_JNS[]=  {'J','N','S',0,          6, 9,     0xF1};
1C7E                
1C7E 4A 4E 53 00 06 I_JNS db 74,78,83,0,6,9,241
1C85                
1C85                ;-90 char I_JP []=  {'J','P',0,              6,10,     0xF1};
1C85                
1C85 4A 50 00 06 0A I_JP db 74,80,0,6,10,241
1C8B                
1C8B                ;-91 char I_JPE[]=  {'J','P','E',0,          6,10,     0xF1};
1C8B                
1C8B 4A 50 45 00 06 I_JPE db 74,80,69,0,6,10,241
1C92                
1C92                ;-92 char I_JNP[]=  {'J','N','P',0,          6,11,     0xF1};
1C92                
1C92 4A 4E 50 00 06 I_JNP db 74,78,80,0,6,11,241
1C99                
1C99                ;-93 char I_JPO[]=  {'J','P','O',0,          6,11,     0xF1};
1C99                
1C99 4A 50 4F 00 06 I_JPO db 74,80,79,0,6,11,241
1CA0                
1CA0                ;-94 char I_JL []=  {'J','L',0,              6,12,     0xF1};
1CA0                
1CA0 4A 4C 00 06 0C I_JL db 74,76,0,6,12,241
1CA6                
1CA6                ;-95 char I_JNL[]=  {'J','N','L',0,          6,13,     0xF1};
1CA6                
1CA6 4A 4E 4C 00 06 I_JNL db 74,78,76,0,6,13,241
1CAD                
1CAD                ;-96 char I_JGE[]=  {'J','G','E',0,          6,13,     0xF1};
1CAD                
1CAD 4A 47 45 00 06 I_JGE db 74,71,69,0,6,13,241
1CB4                
1CB4                ;-97 char I_JLE[]=  {'J','L','E',0,          6,14,     0xF1};
1CB4                
1CB4 4A 4C 45 00 06 I_JLE db 74,76,69,0,6,14,241
1CBB                
1CBB                ;-98 char I_JNG[]=  {'J','N','G',0,          6,14,     0xF1};
1CBB                
1CBB 4A 4E 47 00 06 I_JNG db 74,78,71,0,6,14,241
1CC2                
1CC2                ;-99 char I_JG []=  {'J','G',0,              6,15,     0xF1};
1CC2                
1CC2 4A 47 00 06 0F I_JG db 74,71,0,6,15,241
1CC8                
1CC8                ;-100 //  7: jmp, call
1CC8                
1CC8                
1CC8                ;-101 char I_JMP[]=  {'J','M','P',0,          7,0xE9, 4,0xF1};
1CC8                
1CC8 4A 4D 50 00 07 I_JMP db 74,77,80,0,7,233,4,241
1CD0                
1CD0                ;-102 char I_CALL[]= {'C','A','L','L',0,      7,0xE8, 2,0xF1};
1CD0                
1CD0 43 41 4C 4C 00 I_CALL db 67,65,76,76,0,7,232,2,241
1CD9                
1CD9                ;-103 //  8: ret
1CD9                
1CD9                
1CD9                ;-104 char I_RET[]=  {'R','E','T',0,          8,0xC3,0xC2,0xF1};
1CD9                
1CD9 52 45 54 00 08 I_RET db 82,69,84,0,8,195,194,241
1CE1                
1CE1                ;-105 char I_RETF[]= {'R','E','T','F',0,      8,0xCB,0xCA,0xF1};
1CE1                
1CE1 52 45 54 46 00 I_RETF db 82,69,84,70,0,8,203,202,241
1CEA                
1CEA                ;-106 //  9: seg, r/m
1CEA                
1CEA                
1CEA                ;-107 char I_PUSH[]= {'P','U','S','H',0,      9,0x50,0xFF,6,6,0xF1};//r16
1CEA                
1CEA 50 55 53 48 00 I_PUSH db 80,85,83,72,0,9,80,255,6,6,241
1CF5                
1CF5                ;-108 char I_POP[]=  {'P','O','P',0,          9,0x58,0x8F,0,7,0xF1};//r16
1CF5                
1CF5 50 4F 50 00 09 I_POP db 80,79,80,0,9,88,143,0,7,241
1CFF                
1CFF                ;-109 //  11: shift, rotates
1CFF                
1CFF                
1CFF                ;-110 char I_ROL[]=  {'R','O','L',0,          11, 0,    0xF1};
1CFF                
1CFF 52 4F 4C 00 0B I_ROL db 82,79,76,0,11,0,241
1D06                
1D06                ;-111 char I_ROR[]=  {'R','O','R',0,          11, 1,    0xF1};
1D06                
1D06 52 4F 52 00 0B I_ROR db 82,79,82,0,11,1,241
1D0D                
1D0D                ;-112 char I_RCL[]=  {'R','C','L',0,          11, 2,    0xF1};
1D0D                
1D0D 52 43 4C 00 0B I_RCL db 82,67,76,0,11,2,241
1D14                
1D14                ;-113 char I_RCR[]=  {'R','C','R',0,          11, 3,    0xF1};
1D14                
1D14 52 43 52 00 0B I_RCR db 82,67,82,0,11,3,241
1D1B                
1D1B                ;-114 char I_SHL[]=  {'S','H','L',0,          11, 4,    0xF1};
1D1B                
1D1B 53 48 4C 00 0B I_SHL db 83,72,76,0,11,4,241
1D22                
1D22                ;-115 char I_SAL[]=  {'S','A','L',0,          11, 5,    0xF1};
1D22                
1D22 53 41 4C 00 0B I_SAL db 83,65,76,0,11,5,241
1D29                
1D29                ;-116 char I_SHR[]=  {'S','H','R',0,          11, 6,    0xF1};
1D29                
1D29 53 48 52 00 0B I_SHR db 83,72,82,0,11,6,241
1D30                
1D30                ;-117 char I_SAR[]=  {'S','A','R',0,          11, 7,    0xF1};
1D30                
1D30 53 41 52 00 0B I_SAR db 83,65,82,0,11,7,241
1D37                
1D37                ;-118 //  12: int
1D37                
1D37                
1D37                ;-119 char I_INT[]=  {'I','N','T',0,          12,0xCD,0xCC,0xF1};
1D37                
1D37 49 4E 54 00 0C I_INT db 73,78,84,0,12,205,204,241
1D3F                
1D3F                ;-120 //  14: in/out
1D3F                
1D3F                
1D3F                ;-121 /*char I_IN[]=   {'I','N',0,              14,0xE4,0xEC,0xF1};
1D3F                
1D3F                
1D3F                ;-122 char I_INSB[]= {'I','N','S','B',0,      14,0x6C,   0xF1};
1D3F                
1D3F                
1D3F                ;-123 char I_INSW[]= {'I','N','S','W',0,      14,0x6D,   0xF1};
1D3F                
1D3F                
1D3F                ;-124 char I_INSD[]= {'I','N','S','D',0,      14,0x6D,   0xF1};
1D3F                
1D3F                
1D3F                ;-125 char I_OUT[]=  {'O','U','T',0,          14,0xE6,0xEE,0xF1};
1D3F                
1D3F                
1D3F                ;-126 char I_OUTSB[]={'O','U','T','B',0,      14,0x6E,   0xF1};
1D3F                
1D3F                
1D3F                ;-127 char I_OUTSW[]={'O','U','T','W',0,      14,0x6F,   0xF1};
1D3F                
1D3F                
1D3F                ;-128 char I_OUTSD[]={'O','U','T','D',0,      14,0x6F,   0xF1};*/
1D3F                
1D3F                
1D3F                ;-129 //  15: xchg
1D3F                
1D3F                
1D3F                ;-130 char I_XCHG[]= {'X','C','H','G',0,      15,0x86,0x90,0xF1};
1D3F                
1D3F 58 43 48 47 00 I_XCHG db 88,67,72,71,0,15,134,144,241
1D48                
1D48                ;-131 //  16: loop, jcxz
1D48                
1D48                
1D48                ;-132 /*char I_LOOPNZ[]={'L','O','O','P','N','Z',0, 16,0xE0,0xF1};
1D48                
1D48                
1D48                ;-133 char I_LOOPNE[]={'L','O','O','P','N','E',0, 16,0xE0,0xF1};
1D48                
1D48                
1D48                ;-134 char I_LOOPZ[]={'L','O','O','P','Z',0,      16,0xE1,0xF1};
1D48                
1D48                
1D48                ;-135 char I_LOOPE[]={'L','O','O','P','E',0,      16,0xE1,0xF1};
1D48                
1D48                
1D48                ;-136 char I_LOOP[]= {'L','O','O','P',0,          16,0xE2,0xF1};
1D48                
1D48                
1D48                ;-137 char I_JCXZ[]= {'J','C','X','Z',0,          16,0xE3,0xF1};
1D48                
1D48                
1D48                ;-138 char I_JECXZ[]= {'J','E','C','X','Z',0,     16,0xE3,0xF1};*/
1D48                
1D48                
1D48                ;-139 //  30: enter
1D48                
1D48                
1D48                ;-140 char I_ENTER[]={'E','N','T','E','R',0,  30,       0xF1};
1D48                
1D48 45 4E 54 45 52 I_ENTER db 69,78,84,69,82,0,30,241
1D50                
1D50                ;-141 // 100: directives
1D50                
1D50                
1D50                ;-142 char I_ORG[]=  {'O','R','G',0,        101,        0xF1};
1D50                
1D50 4F 52 47 00 65 I_ORG db 79,82,71,0,101,241
1D56                
1D56                ;-143 // section, segment .TEXT .DATA .BSS
1D56                
1D56                
1D56                ;-144 /*char I_SECTION[]={'S','E','C','T','I','O','N',0,      102, 0xF1};
1D56                
1D56                
1D56                ;-145 char I_SEGMENT[]={'S','E','G','M','E','N','T',0,      102, 0xF1};
1D56                
1D56                
1D56                ;-146 char I_ABSOLUTE[]={'A','B','S','O','L','U','T','E',0, 110, 0xF1};*/
1D56                
1D56                
1D56                ;-147 char I_DB[]=   {'D','B',0,            200,        0xF1};
1D56                
1D56 44 42 00 C8 F1 I_DB db 68,66,0,200,241
1D5B                
1D5B                ;-148 char I_DW[]=   {'D','W',0,            201,        0xF1};
1D5B                
1D5B 44 57 00 C9 F1 I_DW db 68,87,0,201,241
1D60                
1D60                ;-149 char I_DD[]=   {'D','D',0,            202,        0xF1};
1D60                
1D60 44 44 00 CA F1 I_DD db 68,68,0,202,241
1D65                
1D65                ;-150 char I_RESB[]= {'R','E','S','B',0,    203,        0xF1};
1D65                
1D65 52 45 53 42 00 I_RESB db 82,69,83,66,0,203,241
1D6C                
1D6C                ;-151 char I_RESW[]= {'R','E','S','W',0,    204,        0xF1};
1D6C                
1D6C 52 45 53 57 00 I_RESW db 82,69,83,87,0,204,241
1D73                
1D73                ;-152 char I_RESD[]= {'R','E','S','D',0,    205,        0xF1};
1D73                
1D73 52 45 53 44 00 I_RESD db 82,69,83,68,0,205,241
1D7A                
1D7A                ;-153 char I_END=0;// end of table char
1D7A                
1D7A 00             I_END db 0
1D7B                ;Back to main program: AS.C
1D7B                
1D7B                ;-4 #include "OPS.C"
1D7B                
1D7B                ;Use include file: OPS.C
1D7B                
1D7B                ;-1 int ChangeDirection() {
1D7B                
1D7B                
1D7B                ChangeDirection:  ; *** PROC ***
1D7B                
1D7B                ;-2     char c;
1D7B                
1D7B                
1D7B                ;-3     c=Op;     Op    =Op2;    Op2   =c;
1D7B                
1D7B                ;Function : ChangeDirection, Number of local variables: 1
1D7B                ;   # type sign width line used address name   list of local variables
1D7B                ;  200 var sign byte     2 NULL bp-2    c;
1D7B C8 02 00 00     ENTER  2,0
1D7F A0 AE 02        mov al, [Op]
1D82 88 46 FE        mov byte [bp-2], al
1D85 A0 AF 02        mov al, [Op2]
1D88 A2 AE 02        mov byte [Op], al
1D8B 8A 46 FE        mov al, [bp-2]
1D8E A2 AF 02        mov byte [Op2], al
1D91                
1D91                ;-4     c=R1Type; R1Type=R2Type; R2Type=c;
1D91                
1D91 A0 B7 02        mov al, [R1Type]
1D94 88 46 FE        mov byte [bp-2], al
1D97 A0 B6 02        mov al, [R2Type]
1D9A A2 B7 02        mov byte [R1Type], al
1D9D 8A 46 FE        mov al, [bp-2]
1DA0 A2 B6 02        mov byte [R2Type], al
1DA3                
1DA3                ;-5     c=R1No;   R1No  =R2No;   R2No  =c;
1DA3                
1DA3 A0 B5 02        mov al, [R1No]
1DA6 88 46 FE        mov byte [bp-2], al
1DA9 A0 B4 02        mov al, [R2No]
1DAC A2 B5 02        mov byte [R1No], al
1DAF 8A 46 FE        mov al, [bp-2]
1DB2 A2 B4 02        mov byte [R2No], al
1DB5                
1DB5                ;-6     dflag=2;     
1DB5                
1DB5 66 B8 02 00     mov eax, 2
1DB9 A2 BA 02        mov byte [dflag], al
1DBC                
1DBC                ;-7 }
1DBC                
1DBC                
1DBC                ;-8      
1DBC                
1DBC                
1DBC                ;-9 int checkOpL() {
1DBC C9              LEAVE
1DBD C3              ret
1DBE                ; ENDP
1DBE                
1DBE                checkOpL:  ; *** PROC ***
1DBE                
1DBE                ;-10     if (Op == ADR) implerror();
1DBE                
1DBE A0 AE 02        mov al, [Op]
1DC1 3C 03           cmp al, 3
1DC3 0F 85 00 00   * jne @@checkOpL1
1DC7 E8 00 00      * call implerror
1DCA                
1DCA                ;-11     if (R1Type==SEGREG) {segregerror();return;}//only move,push,pop
1DCA                
1DCA                @@checkOpL1:
1DCA A0 B7 02        mov al, [R1Type]
1DCD 3C 04           cmp al, 4
1DCF 0F 85 00 00   * jne @@checkOpL2
1DD3 E8 00 00      * call segregerror
1DD6 E9 00 00      * jmp @@retn
1DD9                
1DD9                ;-12     setwflag();
1DD9                
1DD9                @@checkOpL2:
1DD9 E8 00 00      * call setwflag
1DDC                
1DDC                ;-13     if (OpSize == 0) error1("no op size declared");
1DDC                
1DDC A0 B8 02        mov al, [OpSize]
1DDF 3C 00           cmp al, 0
1DE1 0F 85 00 00   * jne @@checkOpL3
;***** next line ERROR: variable not found, Symbol: checkOpL_0
;***** next line ERROR: invalid or no operands, Symbol: checkOpL_0
;***** next line ERROR: no op size declared, Symbol: checkOpL_0
;***** next line ERROR: syntax, Symbol: checkOpL_0
1DE5                 push checkOpL_0
1DE5 E8 00 00      * call error1
1DE8 83 C4 02        add  sp, 2
1DEB                
1DEB                ;-14     if (OpSize == R1Type) return;
1DEB                
1DEB                @@checkOpL3:
1DEB A0 B8 02        mov al, [OpSize]
1DEE 3A 06 B7 02     cmp al, [R1Type]
1DF2 0F 85 00 00   * jne @@checkOpL4
1DF6 E9 00 00      * jmp @@retn
1DF9                
1DF9                ;-15     if (Op == REG) if (R1Type==0) error1("no register defined");
1DF9                
1DF9                @@checkOpL4:
1DF9 A0 AE 02        mov al, [Op]
1DFC 3C 02           cmp al, 2
1DFE 0F 85 00 00   * jne @@checkOpL5
1E02 A0 B7 02        mov al, [R1Type]
1E05 3C 00           cmp al, 0
1E07 0F 85 00 00   * jne @@checkOpL6
;***** next line ERROR: variable not found, Symbol: checkOpL_1
;***** next line ERROR: invalid or no operands, Symbol: checkOpL_1
;***** next line ERROR: no op size declared, Symbol: checkOpL_1
;***** next line ERROR: syntax, Symbol: checkOpL_1
1E0B                 push checkOpL_1
1E0B E8 00 00      * call error1
1E0E 83 C4 02        add  sp, 2
1E11                
1E11                ;-16 }
1E11                
1E11                @@checkOpL6:
1E11                @@checkOpL5:
1E11                
1E11                ;-17     
1E11                
1E11                
1E11                ;-18 int check2Ops() {
1E11                
1E11                @@retn:
1E11 C3              ret
1E12                ; ENDP
1E12 6E 6F 20 6F 70 checkOpL_0 db "no op size declared",0
1E26 6E 6F 20 72 65 checkOpL_1 db "no register defined",0
1E3A                
1E3A                check2Ops:  ; *** PROC ***
1E3A                
1E3A                ;-19     get2Ops();
1E3A                
1E3A E8 00 00      * call get2Ops
1E3D                
1E3D                ;-20     if (Op ==   0) addrerror();
1E3D                
1E3D A0 AE 02        mov al, [Op]
1E40 3C 00           cmp al, 0
1E42 0F 85 00 00   * jne @@check2Ops7
1E46 E8 00 00      * call addrerror
1E49                
1E49                ;-21     if (Op == ADR) invaloperror(); 
1E49                
1E49                @@check2Ops7:
1E49 A0 AE 02        mov al, [Op]
1E4C 3C 03           cmp al, 3
1E4E 0F 85 00 00   * jne @@check2Ops8
1E52 E8 00 00      * call invaloperror
1E55                
1E55                ;-22     if (Op == IMM) immeerror();   
1E55                
1E55                @@check2Ops8:
1E55 A0 AE 02        mov al, [Op]
1E58 3C 01           cmp al, 1
1E5A 0F 85 00 00   * jne @@check2Ops9
1E5E E8 00 00      * call immeerror
1E61                
1E61                ;-23     if (Op2==   0) addrerror();
1E61                
1E61                @@check2Ops9:
1E61 A0 AF 02        mov al, [Op2]
1E64 3C 00           cmp al, 0
1E66 0F 85 00 00   * jne @@check2Ops10
1E6A E8 00 00      * call addrerror
1E6D                
1E6D                ;-24     if (CodeType != 5) if (Op2==ADR) invaloperror();//allowed in mov           
1E6D                
1E6D                @@check2Ops10:
1E6D A0 B0 02        mov al, [CodeType]
1E70 3C 05           cmp al, 5
1E72 0F 84 00 00   * je  @@check2Ops11
1E76 A0 AF 02        mov al, [Op2]
1E79 3C 03           cmp al, 3
1E7B 0F 85 00 00   * jne @@check2Ops12
1E7F E8 00 00      * call invaloperror
1E82                
1E82                ;-25     setwflag();       
1E82                
1E82                @@check2Ops12:
1E82                @@check2Ops11:
1E82 E8 00 00      * call setwflag
1E85                
1E85                ;-26 }    
1E85                
1E85                
1E85                ;-27 int get2Ops() {
1E85                
1E85 C3              ret
1E86                ; ENDP
1E86                
1E86                get2Ops:  ; *** PROC ***
1E86                
1E86                ;-28     getOpL();
1E86                
1E86 E8 00 00      * call getOpL
1E89                
1E89                ;-29     need(',');    
1E89                
1E89 6A 2C           push 44
1E8B E8 00 00      * call need
1E8E 83 C4 02        add  sp, 2
1E91                
1E91                ;-30     getOpR();         
1E91                
1E91 E8 00 00      * call getOpR
1E94                
1E94                ;-31 } 
1E94                
1E94                
1E94                ;-32         
1E94                
1E94                
1E94                ;-33 int getOpL() {
1E94                
1E94 C3              ret
1E95                ; ENDP
1E95                
1E95                getOpL:  ; *** PROC ***
1E95                
1E95                ;-34 //set: op=0,IMM,REG,ADR,MEM
1E95                
1E95                
1E95                ;-35     getOpR();
1E95                
1E95 E8 00 00      * call getOpR
1E98                
1E98                ;-36     Op=Op2;         Op2=0;
1E98                
1E98 A0 AF 02        mov al, [Op2]
1E9B A2 AE 02        mov byte [Op], al
1E9E 66 B8 00 00     mov eax, 0
1EA2 A2 AF 02        mov byte [Op2], al
1EA5                
1EA5                ;-37     R1No=R2No;      R2No=0;
1EA5                
1EA5 A0 B4 02        mov al, [R2No]
1EA8 A2 B5 02        mov byte [R1No], al
1EAB 66 B8 00 00     mov eax, 0
1EAF A2 B4 02        mov byte [R2No], al
1EB2                
1EB2                ;-38     R1Type=R2Type; R2Type=0; 
1EB2                
1EB2 A0 B6 02        mov al, [R2Type]
1EB5 A2 B7 02        mov byte [R1Type], al
1EB8 66 B8 00 00     mov eax, 0
1EBC A2 B6 02        mov byte [R2Type], al
1EBF                
1EBF                ;-39 }  
1EBF                
1EBF                
1EBF                ;-40 
1EBF                
1EBF                
1EBF                ;-41 int getOpR() {
1EBF                
1EBF C3              ret
1EC0                ; ENDP
1EC0                
1EC0                getOpR:  ; *** PROC ***
1EC0                
1EC0                ;-42     Op2=getOp1();
1EC0                
1EC0 E8 00 00      * call getOp1
1EC3 A2 AF 02        mov byte [Op2], al
1EC6                
1EC6                ;-43     if (isToken('[')) {Op2 = MEM; getMEM();    return;}
1EC6                
1EC6 6A 5B           push 91
1EC8 E8 00 00      * call isToken
1ECB 83 C4 02        add  sp, 2
1ECE 08 C0           or  al, al
1ED0 0F 84 00 00   * je @@getOpR13
1ED4 66 B8 04 00     mov eax, 4
1ED8 A2 AF 02        mov byte [Op2], al
1EDB E8 00 00      * call getMEM
1EDE E9 30 FF        jmp @@retn
1EE1                
1EE1                ;-44     if (Op2 == 0)     {invaloperror();         return;}
1EE1                
1EE1                @@getOpR13:
1EE1 A0 AF 02        mov al, [Op2]
1EE4 3C 00           cmp al, 0
1EE6 0F 85 00 00   * jne @@getOpR14
1EEA E8 00 00      * call invaloperror
1EED E9 21 FF        jmp @@retn
1EF0                
1EF0                ;-45     if (Op2 == IMM)   {imme=SymbolInt;         return;}
1EF0                
1EF0                @@getOpR14:
1EF0 A0 AF 02        mov al, [Op2]
1EF3 3C 01           cmp al, 1
1EF5 0F 85 00 00   * jne @@getOpR15
1EF9 A1 4D 01        mov ax, [SymbolInt]
1EFC A3 C0 02        mov word [imme], ax
1EFF E9 0F FF        jmp @@retn
1F02                
1F02                ;-46     if (Op2 == REG)                            return;
1F02                
1F02                @@getOpR15:
1F02 A0 AF 02        mov al, [Op2]
1F05 3C 02           cmp al, 2
1F07 0F 85 00 00   * jne @@getOpR16
1F0B E9 03 FF        jmp @@retn
1F0E                
1F0E                ;-47     if (Op2 == ADR)   {disp=LabelAddr[LabelIx];return;}
1F0E                
1F0E                @@getOpR16:
1F0E A0 AF 02        mov al, [Op2]
1F11 3C 03           cmp al, 3
1F13 0F 85 00 00   * jne @@getOpR17
1F17 8B 1E 80 07     mov bx, [LabelIx]
;***** next line ERROR: Command not implemented or syntax error, Symbol: bx
;***** next line ERROR: extra char ignored, Symbol: bx
1F1B                 shl bx, 1
1F1B 8B 87 B6 06     mov ax, [LabelAddr + bx]
1F1F A3 BE 02        mov word [disp], ax
1F22 E9 EC FE        jmp @@retn
1F25                
1F25                ;-48     error1("Name of operand expected");
1F25                
1F25                @@getOpR17:
;***** next line ERROR: variable not found, Symbol: getOpR_0
;***** next line ERROR: invalid or no operands, Symbol: getOpR_0
;***** next line ERROR: no op size declared, Symbol: getOpR_0
;***** next line ERROR: syntax, Symbol: getOpR_0
1F25                 push getOpR_0
1F25 E8 00 00      * call error1
1F28 83 C4 02        add  sp, 2
1F2B                
1F2B                ;-49 }
1F2B                
1F2B                
1F2B                ;-50 
1F2B                
1F2B                
1F2B                ;-51 int getOp1() {//scan for a single operand
1F2B                
;***** next line ERROR: duplicate label, Symbol: @@retn
1F2B                @@retn:
1F2B C3              ret
1F2C                ; ENDP
1F2C 4E 61 6D 65 20 getOpR_0 db "Name of operand expected",0
1F45                
1F45                getOp1:  ; *** PROC ***
1F45                
1F45                ;-52 //return:0, IMM, REG, ADR (not MEM)
1F45                
1F45                
1F45                ;-53 //set   :R2Type, R2No by testReg
1F45                
1F45                
1F45                ;-54 //set   :LabelIx by searchLabel
1F45                
1F45                
1F45                ;-55     if (TokeType == 0)      return 0;
1F45                
1F45 A0 AD 02        mov al, [TokeType]
1F48 3C 00           cmp al, 0
1F4A 0F 85 00 00   * jne @@getOp118
1F4E 66 B8 00 00     mov eax, 0
1F52 E9 BC FE        jmp @@retn
1F55                
1F55                ;-56     if (TokeType == DIGIT)  return IMM;
1F55                
1F55                @@getOp118:
1F55 A0 AD 02        mov al, [TokeType]
1F58 3C 01           cmp al, 1
1F5A 0F 85 00 00   * jne @@getOp119
1F5E 66 B8 01 00     mov eax, 1
1F62 E9 AC FE        jmp @@retn
1F65                
1F65                ;-57     if (TokeType == ALNUME) {
1F65                
1F65                @@getOp119:
1F65 A0 AD 02        mov al, [TokeType]
1F68 3C 03           cmp al, 3
1F6A 0F 85 00 00   * jne @@getOp120
1F6E                
1F6E                ;-58         R2No=testReg();
1F6E                
1F6E E8 00 00      * call testReg
1F71 A2 B4 02        mov byte [R2No], al
1F74                
1F74                ;-59         if (R2Type)        return REG;
1F74                
1F74 A0 B6 02        mov al, [R2Type]
1F77 08 C0           or  al, al
1F79 0F 84 00 00   * je @@getOp121
1F7D 66 B8 02 00     mov eax, 2
1F81 E9 8D FE        jmp @@retn
1F84                
1F84                ;-60         LabelIx=searchLabel();
1F84                
1F84                @@getOp121:
1F84 E8 00 00      * call searchLabel
1F87 A3 80 07        mov word [LabelIx], ax
1F8A                
1F8A                ;-61         if (LabelIx)        return ADR;
1F8A                
1F8A A1 80 07        mov ax, [LabelIx]
1F8D 08 C0           or  al, al
1F8F 0F 84 00 00   * je @@getOp122
1F93 66 B8 03 00     mov eax, 3
1F97 E9 77 FE        jmp @@retn
1F9A                
1F9A                ;-62         else error1("variable not found"); 
1F9A                
1F9A E9 00 00      * jmp @@getOp123
1F9D                @@getOp122:
;***** next line ERROR: variable not found, Symbol: getOp1_0
;***** next line ERROR: invalid or no operands, Symbol: getOp1_0
;***** next line ERROR: no op size declared, Symbol: getOp1_0
;***** next line ERROR: syntax, Symbol: getOp1_0
1F9D                 push getOp1_0
1F9D E8 00 00      * call error1
1FA0 83 C4 02        add  sp, 2
1FA3                
1FA3                ;-63     }
1FA3                
1FA3                @@getOp123:
1FA3                
1FA3                ;-64     return 0;
1FA3                
1FA3                @@getOp120:
1FA3 66 B8 00 00     mov eax, 0
1FA7 E9 67 FE        jmp @@retn
1FAA                
1FAA                ;-65 }
1FAA                
1FAA                
1FAA                ;-66 
1FAA                
1FAA                
1FAA                ;-67 int getMEM() {// e.g. [array+bp+si-4]
1FAA                
;***** next line ERROR: duplicate label, Symbol: @@retn
1FAA                @@retn:
1FAA C3              ret
1FAB                ; ENDP
1FAB 76 61 72 69 61 getOp1_0 db "variable not found",0
1FBE                
1FBE                getMEM:  ; *** PROC ***
1FBE                
1FBE                ;-68 //set: disp, rm, R2Type
1FBE                
1FBE                
1FBE                ;-69     char c;
1FBE                
1FBE                
1FBE                ;-70     disp=0; rm=0;
1FBE                
1FBE                ;Function : getMEM, Number of local variables: 1
1FBE                ;   # type sign width line used address name   list of local variables
1FBE                ;  200 var sign byte    69 NULL bp-2    c;
1FBE C8 02 00 00     ENTER  2,0
1FC2 66 B8 00 00     mov eax, 0
1FC6 A3 BE 02        mov word [disp], ax
1FC9 66 B8 00 00     mov eax, 0
1FCD A2 BC 02        mov byte [rm], al
1FD0                
1FD0                ;-71     do {
1FD0                
1FD0                @@getMEM24:
1FD0                
1FD0                ;-72         getTokeType();
1FD0                
1FD0 E8 00 00      * call getTokeType
1FD3                
1FD3                ;-73         c=getOp1();
1FD3                
1FD3 E8 6F FF        call getOp1
1FD6 88 46 FE        mov byte [bp-2], al
1FD9                
1FD9                ;-74         if (c ==   0) syntaxerror();
1FD9                
1FD9 8A 46 FE        mov al, [bp-2]
1FDC 3C 00           cmp al, 0
1FDE 0F 85 00 00   * jne @@getMEM25
1FE2 E8 00 00      * call syntaxerror
1FE5                
1FE5                ;-75         if (c == REG) {
1FE5                
1FE5                @@getMEM25:
1FE5 8A 46 FE        mov al, [bp-2]
1FE8 3C 02           cmp al, 2
1FEA 0F 85 00 00   * jne @@getMEM26
1FEE                
1FEE                ;-76             isDirect=0;
1FEE                
1FEE 66 B8 00 00     mov eax, 0
1FF2 A2 BD 02        mov byte [isDirect], al
1FF5                
1FF5                ;-77             if (rm) rm=getIndReg2();
1FF5                
1FF5 A0 BC 02        mov al, [rm]
1FF8 08 C0           or  al, al
1FFA 0F 84 00 00   * je @@getMEM27
1FFE E8 00 00      * call getIndReg2
2001 A2 BC 02        mov byte [rm], al
2004                
2004                ;-78             else getIndReg1();
2004                
2004 E9 00 00      * jmp @@getMEM28
2007                @@getMEM27:
2007 E8 00 00      * call getIndReg1
200A                
200A                ;-79         }
200A                
200A                @@getMEM28:
200A                
200A                ;-80         if (c == ADR) disp=disp+LabelAddr[LabelIx];
200A                
200A                @@getMEM26:
200A 8A 46 FE        mov al, [bp-2]
200D 3C 03           cmp al, 3
200F 0F 85 00 00   * jne @@getMEM29
2013 A1 BE 02        mov ax, [disp]
2016 8B 1E 80 07     mov bx, [LabelIx]
;***** next line ERROR: Command not implemented or syntax error, Symbol: bx
;***** next line ERROR: extra char ignored, Symbol: bx
201A                 shl bx, 1
201A 03 87 B6 06     add ax, [LabelAddr + bx]
201E A3 BE 02        mov word [disp], ax
2021                
2021                ;-81         if (c == IMM) disp=disp+SymbolInt;
2021                
2021                @@getMEM29:
2021 8A 46 FE        mov al, [bp-2]
2024 3C 01           cmp al, 1
2026 0F 85 00 00   * jne @@getMEM30
202A A1 BE 02        mov ax, [disp]
202D 03 06 4D 01     add ax, [SymbolInt]
2031 A3 BE 02        mov word [disp], ax
2034                
2034                ;-82         if (isToken('-')) {
2034                
2034                @@getMEM30:
2034 6A 2D           push 45
2036 E8 00 00      * call isToken
2039 83 C4 02        add  sp, 2
203C 08 C0           or  al, al
203E 0F 84 00 00   * je @@getMEM31
2042                
2042                ;-83             getTokeType();
2042                
2042 E8 00 00      * call getTokeType
2045                
2045                ;-84             if (TokeType != DIGIT) numbererror();
2045                
2045 A0 AD 02        mov al, [TokeType]
2048 3C 01           cmp al, 1
204A 0F 84 00 00   * je  @@getMEM32
204E E8 00 00      * call numbererror
2051                
2051                ;-85             disp = disp - SymbolInt;
2051                
2051                @@getMEM32:
2051 A1 BE 02        mov ax, [disp]
2054 2B 06 4D 01     sub ax, [SymbolInt]
2058 A3 BE 02        mov word [disp], ax
205B                
205B                ;-86         }
205B                
205B                
205B                ;-87     } while (isToken('+'));
205B                
205B                @@getMEM31:
205B 6A 2B           push 43
205D E8 00 00      * call isToken
2060 83 C4 02        add  sp, 2
2063 08 C0           or  al, al
2065 0F 84 00 00   * je @@getMEM33
2069 E9 64 FF        jmp @@getMEM24
206C                @@getMEM33:
206C                
206C                ;-88     if (isToken(']') == 0) errorexit("] expected");
206C                
206C 6A 5D           push 93
206E E8 00 00      * call isToken
2071 83 C4 02        add  sp, 2
2074 83 F8 00        cmp ax, 0
2077 0F 85 00 00   * jne @@getMEM34
;***** next line ERROR: variable not found, Symbol: getMEM_0
;***** next line ERROR: invalid or no operands, Symbol: getMEM_0
;***** next line ERROR: no op size declared, Symbol: getMEM_0
;***** next line ERROR: syntax, Symbol: getMEM_0
207B                 push getMEM_0
207B E8 00 00      * call errorexit
207E 83 C4 02        add  sp, 2
2081                
2081                ;-89 }
2081                
2081                @@getMEM34:
2081                
2081                ;-90 int getIndReg1() {
2081 C9              LEAVE
2082 C3              ret
2083                ; ENDP
2083 5D 20 65 78 70 getMEM_0 db "] expected",0
208E                
208E                getIndReg1:  ; *** PROC ***
208E                
208E                ;-91     if (R2Type !=WORD) indexerror();
208E                
208E A0 B6 02        mov al, [R2Type]
2091 3C 02           cmp al, 2
2093 0F 84 00 00   * je  @@getIndReg135
2097 E8 00 00      * call indexerror
209A                
209A                ;-92     if (R2No==3) rm=7;//BX
209A                
209A                @@getIndReg135:
209A A0 B4 02        mov al, [R2No]
209D 3C 03           cmp al, 3
209F 0F 85 00 00   * jne @@getIndReg136
20A3 66 B8 07 00     mov eax, 7
20A7 A2 BC 02        mov byte [rm], al
20AA                
20AA                ;-93     if (R2No==5) rm=6;//BP, change to BP+0
20AA                
20AA                @@getIndReg136:
20AA A0 B4 02        mov al, [R2No]
20AD 3C 05           cmp al, 5
20AF 0F 85 00 00   * jne @@getIndReg137
20B3 66 B8 06 00     mov eax, 6
20B7 A2 BC 02        mov byte [rm], al
20BA                
20BA                ;-94     if (R2No==7) rm=5;//DI
20BA                
20BA                @@getIndReg137:
20BA A0 B4 02        mov al, [R2No]
20BD 3C 07           cmp al, 7
20BF 0F 85 00 00   * jne @@getIndReg138
20C3 66 B8 05 00     mov eax, 5
20C7 A2 BC 02        mov byte [rm], al
20CA                
20CA                ;-95     if (R2No==6) rm=4;//SI
20CA                
20CA                @@getIndReg138:
20CA A0 B4 02        mov al, [R2No]
20CD 3C 06           cmp al, 6
20CF 0F 85 00 00   * jne @@getIndReg139
20D3 66 B8 04 00     mov eax, 4
20D7 A2 BC 02        mov byte [rm], al
20DA                
20DA                ;-96     if (rm==0) indexerror();
20DA                
20DA                @@getIndReg139:
20DA A0 BC 02        mov al, [rm]
20DD 3C 00           cmp al, 0
20DF 0F 85 00 00   * jne @@getIndReg140
20E3 E8 00 00      * call indexerror
20E6                
20E6                ;-97 }
20E6                
20E6                @@getIndReg140:
20E6                
20E6                ;-98 int getIndReg2() {char m; m=4;//because m=0 is BX+DI
20E6                
20E6 C3              ret
20E7                ; ENDP
20E7                
20E7                getIndReg2:  ; *** PROC ***
20E7                ;Function : getIndReg2, Number of local variables: 1
20E7                ;   # type sign width line used address name   list of local variables
20E7                ;  200 var sign byte    98 NULL bp-2    m;
20E7 C8 02 00 00     ENTER  2,0
20EB 66 B8 04 00     mov eax, 4
20EF 88 46 FE        mov byte [bp-2], al
20F2                
20F2                ;-99     if (R2Type !=WORD) indexerror();
20F2                
20F2 A0 B6 02        mov al, [R2Type]
20F5 3C 02           cmp al, 2
20F7 0F 84 00 00   * je  @@getIndReg241
20FB E8 00 00      * call indexerror
20FE                
20FE                ;-100     if (R2No==7) if (rm==6) m=3;//BP+DI
20FE                
20FE                @@getIndReg241:
20FE A0 B4 02        mov al, [R2No]
2101 3C 07           cmp al, 7
2103 0F 85 00 00   * jne @@getIndReg242
2107 A0 BC 02        mov al, [rm]
210A 3C 06           cmp al, 6
210C 0F 85 00 00   * jne @@getIndReg243
2110 66 B8 03 00     mov eax, 3
2114 88 46 FE        mov byte [bp-2], al
2117                
2117                ;-101              else if (rm==7) m=1;//BX+DI
2117                
2117 E9 00 00      * jmp @@getIndReg244
211A                @@getIndReg243:
211A A0 BC 02        mov al, [rm]
211D 3C 07           cmp al, 7
211F 0F 85 00 00   * jne @@getIndReg245
2123 66 B8 01 00     mov eax, 1
2127 88 46 FE        mov byte [bp-2], al
212A                
212A                ;-102     if (R2No==6) if (rm==6) m=2;//BP+SI
212A                
212A                @@getIndReg245:
212A                @@getIndReg244:
212A                @@getIndReg242:
212A A0 B4 02        mov al, [R2No]
212D 3C 06           cmp al, 6
212F 0F 85 00 00   * jne @@getIndReg246
2133 A0 BC 02        mov al, [rm]
2136 3C 06           cmp al, 6
2138 0F 85 00 00   * jne @@getIndReg247
213C 66 B8 02 00     mov eax, 2
2140 88 46 FE        mov byte [bp-2], al
2143                
2143                ;-103              else if (rm==7) m=0;//BX+SI
2143                
2143 E9 00 00      * jmp @@getIndReg248
2146                @@getIndReg247:
2146 A0 BC 02        mov al, [rm]
2149 3C 07           cmp al, 7
214B 0F 85 00 00   * jne @@getIndReg249
214F 66 B8 00 00     mov eax, 0
2153 88 46 FE        mov byte [bp-2], al
2156                
2156                ;-104     if (m > 3) indexerror();
2156                
2156                @@getIndReg249:
2156                @@getIndReg248:
2156                @@getIndReg246:
2156 8A 46 FE        mov al, [bp-2]
2159 3C 03           cmp al, 3
215B 0F 8E 00 00   * jle @@getIndReg250
215F E8 00 00      * call indexerror
2162                
2162                ;-105     return m;
2162                
2162                @@getIndReg250:
2162 8A 46 FE        mov al, [bp-2]
2165 E9 A9 FC        jmp @@retn
2168                
2168                ;-106 }
2168                
2168                
2168                ;-107                   
2168                
2168                
2168                ;-108 int setwflag() {//word size, bit 0
2168                
;***** next line ERROR: duplicate label, Symbol: @@retn
2168 C9             @@retn: LEAVE
2169 C3              ret
216A                ; ENDP
216A                
216A                setwflag:  ; *** PROC ***
216A                
216A                ;-109     wflag=0;
216A                
216A 66 B8 00 00     mov eax, 0
216E A2 B9 02        mov byte [wflag], al
2171                
2171                ;-110     if (OpSize == 0) {//do not override OpSize
2171                
2171 A0 B8 02        mov al, [OpSize]
2174 3C 00           cmp al, 0
2176 0F 85 00 00   * jne @@setwflag51
217A                
217A                ;-111         if (Op == REG) OpSize=R1Type;
217A                
217A A0 AE 02        mov al, [Op]
217D 3C 02           cmp al, 2
217F 0F 85 00 00   * jne @@setwflag52
2183 A0 B7 02        mov al, [R1Type]
2186 A2 B8 02        mov byte [OpSize], al
2189                
2189                ;-112         if (Op2== REG) OpSize=R2Type;        
2189                
2189                @@setwflag52:
2189 A0 AF 02        mov al, [Op2]
218C 3C 02           cmp al, 2
218E 0F 85 00 00   * jne @@setwflag53
2192 A0 B6 02        mov al, [R2Type]
2195 A2 B8 02        mov byte [OpSize], al
2198                
2198                ;-113         if (R2Type== SEGREG) OpSize=WORD;
2198                
2198                @@setwflag53:
2198 A0 B6 02        mov al, [R2Type]
219B 3C 04           cmp al, 4
219D 0F 85 00 00   * jne @@setwflag54
21A1 66 B8 02 00     mov eax, 2
21A5 A2 B8 02        mov byte [OpSize], al
21A8                
21A8                ;-114         if (R1Type == SEGREG) OpSize=WORD;        
21A8                
21A8                @@setwflag54:
21A8 A0 B7 02        mov al, [R1Type]
21AB 3C 04           cmp al, 4
21AD 0F 85 00 00   * jne @@setwflag55
21B1 66 B8 02 00     mov eax, 2
21B5 A2 B8 02        mov byte [OpSize], al
21B8                
21B8                ;-115     }
21B8                
21B8                @@setwflag55:
21B8                
21B8                ;-116     if (OpSize  == DWORD) {gen66h(); wflag=1;}
21B8                
21B8                @@setwflag51:
21B8 A0 B8 02        mov al, [OpSize]
21BB 3C 03           cmp al, 3
21BD 0F 85 00 00   * jne @@setwflag56
21C1 E8 00 00      * call gen66h
21C4 66 B8 01 00     mov eax, 1
21C8 A2 B9 02        mov byte [wflag], al
21CB                
21CB                ;-117     if (OpSize  ==  WORD) wflag=1;
21CB                
21CB                @@setwflag56:
21CB A0 B8 02        mov al, [OpSize]
21CE 3C 02           cmp al, 2
21D0 0F 85 00 00   * jne @@setwflag57
21D4 66 B8 01 00     mov eax, 1
21D8 A2 B9 02        mov byte [wflag], al
21DB                
21DB                ;-118 }
21DB                
21DB                @@setwflag57:
21DB                
21DB                ;-119 int setsflag() {//sign-extend, bit 1, only PUSH, ALU, IMUL3 
21DB                
21DB C3              ret
21DC                ; ENDP
21DC                
21DC                setsflag:  ; *** PROC ***
21DC                
21DC                ;-120     unsigned int ui;    
21DC                
21DC                
21DC                ;-121     sflag=2;   
21DC                
21DC                ;Function : setsflag, Number of local variables: 1
21DC                ;   # type sign width line used address name   list of local variables
21DC                ;  200 var unsg word   120 NULL bp-2    ui;
21DC C8 02 00 00     ENTER  2,0
21E0 66 B8 02 00     mov eax, 2
21E4 A2 BB 02        mov byte [sflag], al
21E7                
21E7                ;-122     ui = imme & 0xFF80;//is greater than signed 127? 
21E7                
21E7 A1 C0 02        mov ax, [imme]
21EA 25 80 FF        and ax, 65408
21ED 89 46 FE        mov word [bp-2], ax
21F0                
21F0                ;-123     if(ui != 0) sflag = 0;
21F0                
21F0 8B 46 FE        mov ax, [bp-2]
21F3 83 F8 00        cmp ax, 0
21F6 0F 84 00 00   * je  @@setsflag58
21FA 66 B8 00 00     mov eax, 0
21FE A2 BB 02        mov byte [sflag], al
2201                
2201                ;-124     if (OpSize == BYTE) {
2201                
2201                @@setsflag58:
2201 A0 B8 02        mov al, [OpSize]
2204 3C 01           cmp al, 1
2206 0F 85 00 00   * jne @@setsflag59
220A                
220A                ;-125         if (imme > 255) error1("too big for byte r/m");
220A                
220A A1 C0 02        mov ax, [imme]
220D 3D FF 00        cmp ax, 255
2210 0F 8E 00 00   * jle @@setsflag60
;***** next line ERROR: variable not found, Symbol: setsflag_0
;***** next line ERROR: invalid or no operands, Symbol: setsflag_0
;***** next line ERROR: no op size declared, Symbol: setsflag_0
;***** next line ERROR: syntax, Symbol: setsflag_0
2214                 push setsflag_0
2214 E8 00 00      * call error1
2217 83 C4 02        add  sp, 2
221A                
221A                ;-126         sflag=0;//byte reg does not need sign extended   
221A                
221A                @@setsflag60:
221A 66 B8 00 00     mov eax, 0
221E A2 BB 02        mov byte [sflag], al
2221                
2221                ;-127     }
2221                
2221                
2221                ;-128 }
2221                
2221                @@setsflag59:
2221                
2221                ;-129 int checkConstSize(unsigned int ui) {    
2221 C9              LEAVE
2222 C3              ret
2223                ; ENDP
2223 74 6F 6F 20 62 setsflag_0 db "too big for byte r/m",0
2238                
2238                checkConstSize:  ; *** PROC ***
2238                
2238                ;-130     if (ui > 127   ) return 0;//is near; return sflag
2238                
2238                ;Function : checkConstSize, Number of local variables: 1
2238                ;   # type sign width line used address name   list of local variables
2238                ;  200 var unsg word   129 NULL bp+4    ui;
2238 C8 00 00 00     ENTER  0,0
223C 8B 46 04        mov ax, [bp+4]
223F 83 F8 7F        cmp ax, 127
2242 0F 8E 00 00   * jle @@checkConstSize61
2246 66 B8 00 00     mov eax, 0
224A E9 C4 FB        jmp @@retn
224D                
224D                ;-131     if (ui < 0xFF80) return 0;//-128dez    
224D                
224D                @@checkConstSize61:
224D 8B 46 04        mov ax, [bp+4]
2250 3D 80 FF        cmp ax, 65408
2253 0F 8D 00 00   * jge @@checkConstSize62
2257 66 B8 00 00     mov eax, 0
225B E9 B3 FB        jmp @@retn
225E                
225E                ;-132     return 2;// is short        
225E                
225E                @@checkConstSize62:
225E 66 B8 02 00     mov eax, 2
2262 E9 AC FB        jmp @@retn
2265                
2265                ;-133 }
2265                
;***** next line ERROR: duplicate label, Symbol: @@retn
2265 C9             @@retn: LEAVE
2266 C3              ret
2267                ; ENDP
2267                ;Back to main program: AS.C
2267                
;END open jmp/call: 104
;***** next line ERROR: Label not found, Symbol: main
;***** next line ERROR: Label not found, Symbol: implerror
;***** next line ERROR: Label not found, Symbol: segregerror
;***** next line ERROR: Label not found, Symbol: error1
;***** next line ERROR: Label not found, Symbol: error1
;***** next line ERROR: Label not found, Symbol: addrerror
;***** next line ERROR: Label not found, Symbol: invaloperror
;***** next line ERROR: Label not found, Symbol: immeerror
;***** next line ERROR: Label not found, Symbol: addrerror
;***** next line ERROR: Label not found, Symbol: invaloperror
;***** next line ERROR: Label not found, Symbol: need
;***** next line ERROR: Label not found, Symbol: isToken
;***** next line ERROR: Label not found, Symbol: invaloperror
;***** next line ERROR: Label not found, Symbol: error1
;***** next line ERROR: Label not found, Symbol: testReg
;***** next line ERROR: Label not found, Symbol: searchLabel
;***** next line ERROR: Label not found, Symbol: error1
;***** next line ERROR: Label not found, Symbol: getTokeType
;***** next line ERROR: Label not found, Symbol: syntaxerror
;***** next line ERROR: Label not found, Symbol: isToken
;***** next line ERROR: Label not found, Symbol: getTokeType
;***** next line ERROR: Label not found, Symbol: numbererror
;***** next line ERROR: Label not found, Symbol: isToken
;***** next line ERROR: Label not found, Symbol: isToken
;***** next line ERROR: Label not found, Symbol: errorexit
;***** next line ERROR: Label not found, Symbol: indexerror
;***** next line ERROR: Label not found, Symbol: indexerror
;***** next line ERROR: Label not found, Symbol: indexerror
;***** next line ERROR: Label not found, Symbol: indexerror
;***** next line ERROR: Label not found, Symbol: gen66h
;***** next line ERROR: Label not found, Symbol: error1. Errors: 63 ***ERROR*** , Out: N1.LST, N1.COM= 8807 bytes. Labels: 260. 