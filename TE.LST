;AS.C V0.2, Source: TE.S, Output: TE.LST, TE.COM

0000                
0000                ; A.COM V0.9, Source: AS.C, Output asm: AS.S
0000                org  256 
0000 E9 00 00      Rjmp main
0003                
0003                ;-1 char Version1[]="AS.C V0.2";//BAS.BAT, AS TE, NAS.BAT
0003                
0003 41 53 2E 43 20 Version1 db "AS.C V0.2",0
000D                
000D                ;-2 //#include "DECL.C"
000D                
000D                
000D                ;-3 #define SYMBOLMAX    31
000D                
000D                
000D                ;-4 char Symbol[SYMBOLMAX]; //next symbol to decode
000D                
000D                section .bss
000D                absolute 30000
000D                Symbol resb 31
000D                section .text
000D                
000D                ;-5 char SymbolUpper[SYMBOLMAX];//set toupper in getName
000D                
000D                section .bss
000D                absolute 30031
000D                SymbolUpper resb 31
000D                section .text
000D                
000D                ;-6 char ProcName[SYMBOLMAX];//name of actual proc
000D                
000D                section .bss
000D                absolute 30062
000D                ProcName resb 31
000D                section .text
000D                
000D                ;-7 char isInProc=0;        //is inside a procedure
000D                
000D 00             isInProc db 0
000E                
000E                ;-8 unsigned int SymbolInt; //integer value set in getDigit
000E                
000E 00 00          SymbolInt dw 0
0010                
0010                ;-9 unsigned long SymbolLong;//integer value set in getDigit
0010                
0010 00 00 00 00    SymbolLong dd 0
0014                
0014                ;-10 #define INPUTBUFMAX 255
0014                
0014                
0014                ;-11 char InputBuf[INPUTBUFMAX];//filled in getLine, no overflow test
0014                
0014                section .bss
0014                absolute 30093
0014                InputBuf resb 255
0014                section .text
0014                
0014                ;-12 unsigned char *InputPtr;//position in InputBuf
0014                
0014 00 00          InputPtr dw 0
0016                
0016                ;-13 char namein [67];       //input file name  .S
0016                
0016                section .bss
0016                absolute 30348
0016                namein resb 67
0016                section .text
0016                
0016                ;-14 char namelst[67];       //list file name   .LST
0016                
0016                section .bss
0016                absolute 30415
0016                namelst resb 67
0016                section .text
0016                
0016                ;-15 char namebin[67];       //output file name .COM
0016                
0016                section .bss
0016                absolute 30482
0016                namebin resb 67
0016                section .text
0016                
0016                ;-16 int  asm_fd;            //input file descriptor
0016                
0016 00 00          asm_fd dw 0
0018                
0018                ;-17 int lst_fd;             //list file descriptor
0018                
0018 00 00          lst_fd dw 0
001A                
001A                ;-18 int bin_fd;             //output file descriptor
001A                
001A 00 00          bin_fd dw 0
001C                
001C                ;-19 int DOS_ERR=0;          //global var
001C                
001C 00 00          DOS_ERR dw 0
001E                
001E                ;-20 int ErrorCount=0;       //number of errors
001E                
001E 00 00          ErrorCount dw 0
0020                
0020                ;-21 int DOS_NoBytes;        //number of bytes read (0 or 1)
0020                
0020 00 00          DOS_NoBytes dw 0
0022                
0022                ;-22 char DOS_ByteRead;      //the byte just read by DOS
0022                
0022 00             DOS_ByteRead db 0
0023                
0023                ;-23 
0023                
0023                
0023                ;-24 unsigned int PC=0;      //program counter
0023                
0023 00 00          PC dw 0
0025                
0025                ;-25 unsigned int Origin=0;  //ORG nn
0025                
0025 00 00          Origin dw 0
0027                
0027                ;-26 unsigned int AbsoluteLab=0;//uninitialised data
0027                
0027 00 00          AbsoluteLab dw 0
0029                
0029                ;-27 unsigned int PCStart;   //PC at start of line by PrintLine()
0029                
0029 00 00          PCStart dw 0
002B                
002B                ;-28 char isLabel;           //by getName()
002B                
002B 00             isLabel db 0
002C                
002C                ;-29 #define DIGIT    1      //0-9
002C                
002C                
002C                ;-30 #define LETTERE  2      //a-z A-Z @ . _
002C                
002C                
002C                ;-31 #define ALNUME   3      //a-z A-Z @ . _  0-9
002C                
002C                
002C                ;-32 #define NOALNUME 4      //other char
002C                
002C                
002C                ;-33 char TokeType;          //0, DIGIT, LETTERE, ALNUME, NOALNUME
002C                
002C 00             TokeType db 0
002D                
002D                ;-34 #define BYTE     1
002D                
002D                
002D                ;-35 #define WORD     2
002D                
002D                
002D                ;-36 #define DWORD    3
002D                
002D                
002D                ;-37 #define SEGREG   4
002D                
002D                
002D                ;-38 #define IMM      1      //const  ,123
002D                
002D                
002D                ;-39 #define REG      2      //       ,BX    mode=11
002D                
002D                
002D                ;-40 #define ADR      3      //DIRECT: VALUE  ,var1  mod=00, r/m=110
002D                
002D                
002D                ;-41 #define MEM      4      //[var1],[BX+SI],[table+BX],[bp-4] disp0,8,16
002D                
002D                
002D                ;-42 char Op;                //1. operand: 0, IMM, REG, ADR, MEM
002D                
002D 00             Op db 0
002E                
002E                ;-43 char Op2;               //2. operand
002E                
002E 00             Op2 db 0
002F                
002F                ;-44 char CodeType;          //1-207 by searchSymbol(), must be byte size
002F                
002F 00             CodeType db 0
0030                
0030                ;-45 char Code1;             //1. Opcode
0030                
0030 00             Code1 db 0
0031                
0031                ;-46 char Code2;             //2. Opcode
0031                
0031 00             Code2 db 0
0032                
0032                ;-47 char Code3;             //3. Opcode
0032                
0032 00             Code3 db 0
0033                
0033                ;-48 char R2No;              //0 - 7 AL, CL, ...  set in testReg()
0033                
0033 00             R2No db 0
0034                
0034                ;-49 char R1No;              //temp for 1. register
0034                
0034 00             R1No db 0
0035                
0035                ;-50 char R2Type;            //0=no reg, BYTE, WORD, DWORD, SEGREG
0035                
0035 00             R2Type db 0
0036                
0036                ;-51 char R1Type;            //temp for 1. register
0036                
0036 00             R1Type db 0
0037                
0037                ;-52 char OpSize;            //0, BYTE, WORD, DWORD by getCodeSize()
0037                
0037 00             OpSize db 0
0038                
0038                ;-53 char wflag;             //wordflag: 0=byte, 1=word/dword
0038                
0038 00             wflag db 0
0039                
0039                ;-54 char dflag;             //directionflag: 1=to reg MOV,ALU
0039                
0039 00             dflag db 0
003A                
003A                ;-55 char sflag;             //sign extended, imm8 to word PUSH,ALU,IMUL3
003A                
003A 00             sflag db 0
003B                
003B                ;-56 char rm;                //combination of index and base reg
003B                
003B 00             rm db 0
003C                
003C                ;-57 char isDirect;          //set in process and getMeM, need in WriteEA
003C                
003C 00             isDirect db 0
003D                
003D                ;-58 int disp;               //displacement      0-8 bytes
003D                
003D 00 00          disp dw 0
003F                
003F                ;-59 unsigned int imme;      //immediate         0-8 bytes
003F                
003F 00 00          imme dw 0
0041                
0041                ;-60 
0041                
0041                
0041                ;-61 #define OPMAXLEN 5
0041                
0041                
0041                ;-62 char OpPos[OPMAXLEN];   //array for one opcode to list
0041                
0041                section .bss
0041                absolute 30549
0041                OpPos resb 5
0041                section .text
0041                
0041                ;-63 int OpPrintIndex;       //0-OPMAXLEN, pos to print opcode, by genCode8
0041                
0041 00 00          OpPrintIndex dw 0
0043                
0043                ;-64 char *OpCodePtr;        //position in OpCodeTable by searchSymbol
0043                
0043 00 00          OpCodePtr dw 0
0045                
0045                ;-65 char PrintRA;           //print * for forward relocative jmp
0045                
0045 00             PrintRA db 0
0046                
0046                ;-66 
0046                
0046                
0046                ;-67 #define LABELNAMESMAX 5969//next number - SYMBOLMAX
0046                
0046                
0046                ;-68 char LabelNames[6000];  //space for names of all labels
0046                
0046                section .bss
0046                absolute 30554
0046                LabelNames resb 6000
0046                section .text
0046                
0046                ;-69 char *LabelNamePtr;     //first free position
0046                
0046 00 00          LabelNamePtr dw 0
0048                
0048                ;-70 char *tmpLabelNamePtr;  //set after PROC to LabelNamePtr
0048                
0048 00 00          tmpLabelNamePtr dw 0
004A                
004A                ;-71 
004A                
004A                
004A                ;-72 #define LABELADRMAX 600
004A                
004A                
004A                ;-73 unsigned int LabelAddr[LABELADRMAX];//addr of each label
004A                
004A                section .bss
004A                absolute 36554
004A                LabelAddr resw 600
004A                section .text
004A                
004A                ;-74 int LabelMaxIx=0;       //actual # of stored labels. 1 to LABELADRMAX-1
004A                
004A 00 00          LabelMaxIx dw 0
004C                
004C                ;-75 int tmpLabelMaxIx;      //set after PROC to LabelMaxIx
004C                
004C 00 00          tmpLabelMaxIx dw 0
004E                
004E                ;-76 int LabelIx;            //actual # of just searched label
004E                
004E 00 00          LabelIx dw 0
0050                
0050                ;-77 
0050                
0050                
0050                ;-78 #define JMPNAMESMAX 3969//next number - SYMBOLMAX
0050                
0050                
0050                ;-79 char JmpNames[4000];    //space for names of jmp, call
0050                
0050                section .bss
0050                absolute 37754
0050                JmpNames resb 4000
0050                section .text
0050                
0050                ;-80 char *JmpNamePtr;       //first free position
0050                
0050 00 00          JmpNamePtr dw 0
0052                
0052                ;-81 char *tmpJmpNamePtr;    //set after PROC to JmpNamePtr
0052                
0052 00 00          tmpJmpNamePtr dw 0
0054                
0054                ;-82 
0054                
0054                
0054                ;-83 #define JMPMAX 200      //max. jmp and call
0054                
0054                
0054                ;-84 unsigned int JmpAddr[JMPMAX];//addr to be fixed
0054                
0054                section .bss
0054                absolute 41754
0054                JmpAddr resw 200
0054                section .text
0054                
0054                ;-85 int JmpMaxIx=0;         //actual # of jmp, call. 1 to JMPMAX-1
0054                
0054 00 00          JmpMaxIx dw 0
0056                
0056                ;-86 int tmpJmpMaxIx=0;      //set after PROC to JmpMaxIx
0056                
0056 00 00          tmpJmpMaxIx dw 0
0058                
0058                ;-87 
0058                
0058                
0058                ;-88 #define FILEBINMAX 17000
0058                
0058                
0058                ;-89 char FileBin  [FILEBINMAX];//output binary file
0058                
0058                section .bss
0058                absolute 42154
0058                FileBin resb 17000
0058                section .text
0058                
0058                ;-90 unsigned int BinLen=0;  //length of binary file
0058                
0058 00 00          BinLen dw 0
005A                
005A                ;-91 
005A                
005A                
005A                ;-92 char *arglen=0x80;      // for main only
005A                
005A 80 00          arglen dw 128
005C                
005C                ;-93 char *argv=0x82;        // for main only
005C                
005C 82 00          argv dw 130
005E                
005E                ;-94 
005E                
005E                
005E                ;-95 
005E                
005E                
005E                ;-96 //#include "HELPER.C"
005E                
005E                
005E                ;-97 int writetty()     { ah=0x0E; bx=0; __emit__(0xCD,0x10); }
005E                
005E                
entering: writetty
005E                writetty: PROC
005E B4 0E           mov  ah, 14
0060 BB 00 00        mov  bx, 0
0063 CD 10           db 205,16
0065                
0065                ;-98 int putch(char c)  {if (_ c==10) {al=13; writetty();} al=c; writetty(); }
0065                
0065 C3              ret
leaving: writetty, loc labels: 0, loc jmp forward: 0
0066                ENDP
0066                
entering: putch
0066                putch: PROC
0066                ;Function : putch, Number of local variables: 1
0066                ;   # type sign width addr used name   list of local variables
0066                ;  200 var sign byte    98 NULL c = bp+4;
0066 C8 00 00 00     ENTER  0,0 ; constant expression
006A 80 7E 04 0A    cmp byte[bp+4], 10
006E 0F 85 00 00   r jne .putch1
0072 B0 0D           mov  al, 13
0074 E8 E7 FF        call writetty
0077                .putch1:
0077 8A 46 04        mov  al, [bp+4]
007A E8 E1 FF        call writetty
007D                
007D                ;-99 int cputs(char *s) {char c;  while(*s) { c=*s; putch(c); s++; } }
007D C9              LEAVE
007E C3              ret
leaving: putch, loc labels: 1, loc jmp forward: 1
007F                ENDP
007F                
entering: cputs
007F                cputs: PROC
007F                ;Function : cputs, Number of local variables: 2
007F                ;   # type sign width addr used name   list of local variables
007F                ;  200 ptr sign byte    99 NULL s = bp+4
007F                ;  201 var sign byte    99 NULL c = bp-2;
007F C8 02 00 00     ENTER  2,0
0083                .cputs2:
0083 8B 5E 04        mov bx, [bp+4]
0086 8A 07           mov al, [bx]
0088 B4 00           mov ah, 0
008A 08 C0           or  al, al
008C 0F 84 00 00   r je .cputs3
0090 8B 5E 04        mov bx, [bp+4]
0093 8A 07           mov al, [bx]
0095 B4 00           mov ah, 0
0097 88 46 FE        mov [bp-2], al
009A 8A 46 FE        mov al, byte [bp-2]
009D B4 00           mov ah, 0
009F 50              push ax
00A0 E8 C3 FF        call putch
00A3 83 C4 02        add  sp, 2
00A6 FF 46 04        inc  word[bp+4]
00A9 EB D8           jmp .cputs2
00AB                .cputs3:
00AB                
00AB                ;-100 
00AB                
00AB                
00AB                ;-101 int DosInt() {
00AB C9              LEAVE
00AC C3              ret
leaving: cputs, loc labels: 2, loc jmp forward: 1
00AD                ENDP
00AD                
entering: DosInt
00AD                DosInt: PROC
00AD                
00AD                ;-102     __emit__(0xCD,0x21);//inth 0x21;
00AD                
00AD CD 21           db 205,33
00AF                
00AF                ;-103     __emit__(0x73, 04); //ifcarry DOS_ERR++;
00AF                
00AF 73 04           db 115,4
00B1                
00B1                ;-104     DOS_ERR++;
00B1                
00B1 FF 06 1C 01     inc  word[DOS_ERR]
00B5                
00B5                ;-105 }
00B5                
00B5                
00B5                ;-106 int openR (char *s) { dx=s;       ax=0x3D02; DosInt(); }
00B5                
00B5 C3              ret
leaving: DosInt, loc labels: 0, loc jmp forward: 0
00B6                ENDP
00B6                
entering: openR
00B6                openR: PROC
00B6                ;Function : openR, Number of local variables: 1
00B6                ;   # type sign width addr used name   list of local variables
00B6                ;  200 ptr sign byte   106 NULL s = bp+4;
00B6 C8 00 00 00     ENTER  0,0
00BA 8B 56 04        mov  dx, [bp+4]
00BD B8 02 3D        mov  ax, 15618
00C0 E8 EA FF        call DosInt
00C3                
00C3                ;-107 int creatR(char *s) { dx=s; cx=0; ax=0x3C00; DosInt(); }
00C3 C9              LEAVE
00C4 C3              ret
leaving: openR, loc labels: 0, loc jmp forward: 0
00C5                ENDP
00C5                
entering: creatR
00C5                creatR: PROC
00C5                ;Function : creatR, Number of local variables: 1
00C5                ;   # type sign width addr used name   list of local variables
00C5                ;  200 ptr sign byte   107 NULL s = bp+4;
00C5 C8 00 00 00     ENTER  0,0
00C9 8B 56 04        mov  dx, [bp+4]
00CC B9 00 00        mov  cx, 0
00CF B8 00 3C        mov  ax, 15360
00D2 E8 D8 FF        call DosInt
00D5                
00D5                ;-108 int fcloseR(int fd) {bx=fd;       ax=0x3E00; DosInt(); }
00D5 C9              LEAVE
00D6 C3              ret
leaving: creatR, loc labels: 0, loc jmp forward: 0
00D7                ENDP
00D7                
entering: fcloseR
00D7                fcloseR: PROC
00D7                ;Function : fcloseR, Number of local variables: 1
00D7                ;   # type sign width addr used name   list of local variables
00D7                ;  200 var sign word   108 NULL fd = bp+4;
00D7 C8 00 00 00     ENTER  0,0
00DB 8B 5E 04        mov  bx, [bp+4]
00DE B8 00 3E        mov  ax, 15872
00E1 E8 C9 FF        call DosInt
00E4                
00E4                ;-109 int exitR  (char c) {ah=0x4C; al=c;          DosInt(); }
00E4 C9              LEAVE
00E5 C3              ret
leaving: fcloseR, loc labels: 0, loc jmp forward: 0
00E6                ENDP
00E6                
entering: exitR
00E6                exitR: PROC
00E6                ;Function : exitR, Number of local variables: 1
00E6                ;   # type sign width addr used name   list of local variables
00E6                ;  200 var sign byte   109 NULL c = bp+4;
00E6 C8 00 00 00     ENTER  0,0
00EA B4 4C           mov  ah, 76
00EC 8A 46 04        mov  al, [bp+4]
00EF E8 BB FF        call DosInt
00F2                
00F2                ;-110 int readRL(char *s, int fd, int len){
00F2 C9              LEAVE
00F3 C3              ret
leaving: exitR, loc labels: 0, loc jmp forward: 0
00F4                ENDP
00F4                
entering: readRL
00F4                readRL: PROC
00F4                
00F4                ;-111     dx=s; cx=len; bx=fd; ax=0x3F00; DosInt();}
00F4                
00F4                ;Function : readRL, Number of local variables: 3
00F4                ;   # type sign width addr used name   list of local variables
00F4                ;  200 ptr sign byte   110 NULL s = bp+4
00F4                ;  201 var sign word   110 NULL fd = bp+6
00F4                ;  202 var sign word   110 NULL len = bp+8;
00F4 C8 00 00 00     ENTER  0,0
00F8 8B 56 04        mov  dx, [bp+4]
00FB 8B 4E 08        mov  cx, [bp+8]
00FE 8B 5E 06        mov  bx, [bp+6]
0101 B8 00 3F        mov  ax, 16128
0104 E8 A6 FF        call DosInt
0107                
0107                ;-112 int fputcR(char *n, int fd) { __asm{lea dx, [bp+4]}; /* = *n */
0107 C9              LEAVE
0108 C3              ret
leaving: readRL, loc labels: 0, loc jmp forward: 0
0109                ENDP
0109                
entering: fputcR
0109                fputcR: PROC
0109                ;Function : fputcR, Number of local variables: 2
0109                ;   # type sign width addr used name   list of local variables
0109                ;  200 ptr sign byte   112 NULL n = bp+4
0109                ;  201 var sign word   112 NULL fd = bp+6;
0109 C8 00 00 00     ENTER  0,0
010D 8D 56 04       lea dx, [bp+4]
0110                
0110                ;-113   cx=1; bx=fd; ax=0x4000; DosInt(); }
0110                
0110 B9 01 00        mov  cx, 1
0113 8B 5E 06        mov  bx, [bp+6]
0116 B8 00 40        mov  ax, 16384
0119 E8 91 FF        call DosInt
011C                
011C                ;-114 
011C                
011C                
011C                ;-115 int letterE(char c) {
011C C9              LEAVE
011D C3              ret
leaving: fputcR, loc labels: 0, loc jmp forward: 0
011E                ENDP
011E                
entering: letterE
011E                letterE: PROC
011E                
011E                ;-116   if (c=='_') return 1;
011E                
011E                ;Function : letterE, Number of local variables: 1
011E                ;   # type sign width addr used name   list of local variables
011E                ;  200 var sign byte   115 NULL c = bp+4;
011E C8 00 00 00     ENTER  0,0
0122 8A 46 04        mov al, [bp+4]
0125 3C 5F           cmp al, 95
0127 0F 85 00 00   r jne .letterE4
012B B8 01 00        mov ax, 1
012E E9 00 00      R jmp .retnletterE
0131                
0131                ;-117   if (c=='.') return 1;
0131                
0131                .letterE4:
0131 8A 46 04        mov al, [bp+4]
0134 3C 2E           cmp al, 46
0136 0F 85 00 00   r jne .letterE5
013A B8 01 00        mov ax, 1
013D E9 00 00      R jmp .retnletterE
0140                
0140                ;-118   if (c=='?') return 1;
0140                
0140                .letterE5:
0140 8A 46 04        mov al, [bp+4]
0143 3C 3F           cmp al, 63
0145 0F 85 00 00   r jne .letterE6
0149 B8 01 00        mov ax, 1
014C E9 00 00      R jmp .retnletterE
014F                
014F                ;-119   if (c=='$') return 1;
014F                
014F                .letterE6:
014F 8A 46 04        mov al, [bp+4]
0152 3C 24           cmp al, 36
0154 0F 85 00 00   r jne .letterE7
0158 B8 01 00        mov ax, 1
015B E9 00 00      R jmp .retnletterE
015E                
015E                ;-120   if (c> 'z') return 0;
015E                
015E                .letterE7:
015E 8A 46 04        mov al, [bp+4]
0161 3C 7A           cmp al, 122
0163 0F 8E 00 00   r jle .letterE8
0167 B8 00 00        mov ax, 0
016A E9 00 00      R jmp .retnletterE
016D                
016D                ;-121   if (c< '@') return 0; // at included
016D                
016D                .letterE8:
016D 8A 46 04        mov al, [bp+4]
0170 3C 40           cmp al, 64
0172 0F 8D 00 00   r jge .letterE9
0176 B8 00 00        mov ax, 0
0179 E9 00 00      R jmp .retnletterE
017C                
017C                ;-122   if (c> 'Z') { if (c< 'a') return 0; }
017C                
017C                .letterE9:
017C 8A 46 04        mov al, [bp+4]
017F 3C 5A           cmp al, 90
0181 0F 8E 00 00   r jle .letterE10
0185 8A 46 04        mov al, [bp+4]
0188 3C 61           cmp al, 97
018A 0F 8D 00 00   r jge .letterE11
018E B8 00 00        mov ax, 0
0191 E9 00 00      R jmp .retnletterE
0194                .letterE11:
0194                
0194                ;-123   return 1;
0194                
0194                .letterE10:
0194 B8 01 00        mov ax, 1
0197 E9 00 00      R jmp .retnletterE
019A                
019A                ;-124 }
019A                
019A                
019A                ;-125 int digit(char c){
019A                
019A C9              .retnletterE: LEAVE
019B C3              ret
leaving: letterE, loc labels: 9, loc jmp forward: 16
019C                ENDP
019C                
entering: digit
019C                digit: PROC
019C                
019C                ;-126     if(c<'0') return 0;
019C                
019C                ;Function : digit, Number of local variables: 1
019C                ;   # type sign width addr used name   list of local variables
019C                ;  200 var sign byte   125 NULL c = bp+4;
019C C8 00 00 00     ENTER  0,0
01A0 8A 46 04        mov al, [bp+4]
01A3 3C 30           cmp al, 48
01A5 0F 8D 00 00   r jge .digit12
01A9 B8 00 00        mov ax, 0
01AC E9 00 00      R jmp .retndigit
01AF                
01AF                ;-127     if(c>'9') return 0;
01AF                
01AF                .digit12:
01AF 8A 46 04        mov al, [bp+4]
01B2 3C 39           cmp al, 57
01B4 0F 8E 00 00   r jle .digit13
01B8 B8 00 00        mov ax, 0
01BB E9 00 00      R jmp .retndigit
01BE                
01BE                ;-128     return 1;
01BE                
01BE                .digit13:
01BE B8 01 00        mov ax, 1
01C1 E9 00 00      R jmp .retndigit
01C4                
01C4                ;-129 }
01C4                
01C4                
01C4                ;-130 int alnumE(char c) {
01C4                
01C4 C9              .retndigit: LEAVE
01C5 C3              ret
leaving: digit, loc labels: 3, loc jmp forward: 5
01C6                ENDP
01C6                
entering: alnumE
01C6                alnumE: PROC
01C6                
01C6                ;-131   if (digit(c)) return 1;
01C6                
01C6                ;Function : alnumE, Number of local variables: 1
01C6                ;   # type sign width addr used name   list of local variables
01C6                ;  200 var sign byte   130 NULL c = bp+4;
01C6 C8 00 00 00     ENTER  0,0
01CA 8A 46 04        mov al, byte [bp+4]
01CD B4 00           mov ah, 0
01CF 50              push ax
01D0 E8 C9 FF        call digit
01D3 83 C4 02        add  sp, 2
01D6 08 C0           or  al, al
01D8 0F 84 00 00   r je .alnumE14
01DC B8 01 00        mov ax, 1
01DF E9 00 00      R jmp .retnalnumE
01E2                
01E2                ;-132   if (letterE(c)) return 1;
01E2                
01E2                .alnumE14:
01E2 8A 46 04        mov al, byte [bp+4]
01E5 B4 00           mov ah, 0
01E7 50              push ax
01E8 E8 33 FF        call letterE
01EB 83 C4 02        add  sp, 2
01EE 08 C0           or  al, al
01F0 0F 84 00 00   r je .alnumE15
01F4 B8 01 00        mov ax, 1
01F7 E9 00 00      R jmp .retnalnumE
01FA                
01FA                ;-133   return 0;
01FA                
01FA                .alnumE15:
01FA B8 00 00        mov ax, 0
01FD E9 00 00      R jmp .retnalnumE
0200                
0200                ;-134 }
0200                
0200                
0200                ;-135 int strlen(char *s) { int c;
0200                
0200 C9              .retnalnumE: LEAVE
0201 C3              ret
leaving: alnumE, loc labels: 3, loc jmp forward: 5
0202                ENDP
0202                
entering: strlen
0202                strlen: PROC
0202                
0202                ;-136     c=0;
0202                
0202                ;Function : strlen, Number of local variables: 2
0202                ;   # type sign width addr used name   list of local variables
0202                ;  200 ptr sign byte   135 NULL s = bp+4
0202                ;  201 var sign word   135 NULL c = bp-2;
0202 C8 02 00 00     ENTER  2,0
0206 B8 00 00        mov ax, 0
0209 89 46 FE        mov [bp-2], ax
020C                
020C                ;-137     while (*s!=0) {s++; c++;}
020C                
020C                .strlen16:
020C 8B 5E 04        mov bx, [bp+4]
020F 8A 07           mov al, [bx]
0211 B4 00           mov ah, 0
0213 83 F8 00        cmp ax, 0
0216 0F 84 00 00   r je  .strlen17
021A FF 46 04        inc  word[bp+4]
021D FF 46 FE        inc  word[bp-2]
0220                
0220                ;-138     return c;
0220                
0220 EB EA           jmp .strlen16
0222                .strlen17:
0222 8B 46 FE        mov ax, [bp-2]
0225 E9 00 00      R jmp .retnstrlen
0228                
0228                ;-139     }
0228                
0228                
0228                ;-140 int strcpy(char *s, char *t) {
0228                
0228 C9              .retnstrlen: LEAVE
0229 C3              ret
leaving: strlen, loc labels: 3, loc jmp forward: 2
022A                ENDP
022A                
entering: strcpy
022A                strcpy: PROC
022A                
022A                ;-141     do { *s=*t; s++; t++; }
022A                
022A                ;Function : strcpy, Number of local variables: 2
022A                ;   # type sign width addr used name   list of local variables
022A                ;  200 ptr sign byte   140 NULL s = bp+4
022A                ;  201 ptr sign byte   140 NULL t = bp+6;
022A C8 00 00 00     ENTER  0,0
022E                .strcpy18:
022E 8B 5E 06        mov bx, [bp+6]
0231 8A 07           mov al, [bx]
0233 B4 00           mov ah, 0
0235 8B 5E 04        mov  bx, [bp+4]
0238 88 07           mov  [bx], al
023A FF 46 04        inc  word[bp+4]
023D FF 46 06        inc  word[bp+6]
0240                
0240                ;-142     while (*t!=0);
0240                
0240 8B 5E 06        mov bx, [bp+6]
0243 8A 07           mov al, [bx]
0245 B4 00           mov ah, 0
0247 83 F8 00        cmp ax, 0
024A 0F 84 00 00   r je  .strcpy19
024E EB DE           jmp .strcpy18
0250                .strcpy19:
0250                
0250                ;-143     *s=0;
0250                
0250 B8 00 00        mov ax, 0
0253 8B 5E 04        mov  bx, [bp+4]
0256 88 07           mov  [bx], al
0258                
0258                ;-144     return s;
0258                
0258 8B 46 04        mov ax, [bp+4]
025B E9 00 00      R jmp .retnstrcpy
025E                
025E                ;-145     }
025E                
025E                
025E                ;-146 int eqstr(char *p, char *q) {
025E                
025E C9              .retnstrcpy: LEAVE
025F C3              ret
leaving: strcpy, loc labels: 3, loc jmp forward: 2
0260                ENDP
0260                
entering: eqstr
0260                eqstr: PROC
0260                
0260                ;-147     while(*p) {
0260                
0260                ;Function : eqstr, Number of local variables: 2
0260                ;   # type sign width addr used name   list of local variables
0260                ;  200 ptr sign byte   146 NULL p = bp+4
0260                ;  201 ptr sign byte   146 NULL q = bp+6;
0260 C8 00 00 00     ENTER  0,0
0264                .eqstr20:
0264 8B 5E 04        mov bx, [bp+4]
0267 8A 07           mov al, [bx]
0269 B4 00           mov ah, 0
026B 08 C0           or  al, al
026D 0F 84 00 00   r je .eqstr21
0271                
0271                ;-148         if (*p != *q) return 0;
0271                
0271 8B 5E 04        mov bx, [bp+4]
0274 8A 07           mov al, [bx]
0276 B4 00           mov ah, 0
0278 8B 5E 06        mov bx, [bp+6]
027B 3A 07           cmp al, [bx]
027D B4 00           mov ah, 0
027F 0F 84 00 00   r je  .eqstr22
0283 B8 00 00        mov ax, 0
0286 E9 00 00      R jmp .retneqstr
0289                
0289                ;-149             p++;
0289                
0289                .eqstr22:
0289 FF 46 04        inc  word[bp+4]
028C                
028C                ;-150             q++;
028C                
028C FF 46 06        inc  word[bp+6]
028F                
028F                ;-151             }
028F                
028F                
028F                ;-152     if(*q) return 0;
028F                
028F EB D3           jmp .eqstr20
0291                .eqstr21:
0291 8B 5E 06        mov bx, [bp+6]
0294 8A 07           mov al, [bx]
0296 B4 00           mov ah, 0
0298 08 C0           or  al, al
029A 0F 84 00 00   r je .eqstr23
029E B8 00 00        mov ax, 0
02A1 E9 00 00      R jmp .retneqstr
02A4                
02A4                ;-153     return 1;
02A4                
02A4                .eqstr23:
02A4 B8 01 00        mov ax, 1
02A7 E9 00 00      R jmp .retneqstr
02AA                
02AA                ;-154     }
02AA                
02AA                
02AA                ;-155 int strcat1(char *s, char *t) {
02AA                
02AA C9              .retneqstr: LEAVE
02AB C3              ret
leaving: eqstr, loc labels: 5, loc jmp forward: 6
02AC                ENDP
02AC                
entering: strcat1
02AC                strcat1: PROC
02AC                
02AC                ;-156     while (*s != 0) s++;
02AC                
02AC                ;Function : strcat1, Number of local variables: 2
02AC                ;   # type sign width addr used name   list of local variables
02AC                ;  200 ptr sign byte   155 NULL s = bp+4
02AC                ;  201 ptr sign byte   155 NULL t = bp+6;
02AC C8 00 00 00     ENTER  0,0
02B0                .strcat124:
02B0 8B 5E 04        mov bx, [bp+4]
02B3 8A 07           mov al, [bx]
02B5 B4 00           mov ah, 0
02B7 83 F8 00        cmp ax, 0
02BA 0F 84 00 00   r je  .strcat125
02BE FF 46 04        inc  word[bp+4]
02C1                
02C1                ;-157     strcpy(s, t);
02C1                
02C1 EB ED           jmp .strcat124
02C3                .strcat125:
02C3 55              push word [bp+6]
02C4 55              push word [bp+4]
02C5 E8 62 FF        call strcpy
02C8 83 C4 04        add  sp, 4
02CB                
02CB                ;-158     }
02CB                
02CB                
02CB                ;-159 int toupper(char *s) {
02CB C9              LEAVE
02CC C3              ret
leaving: strcat1, loc labels: 2, loc jmp forward: 1
02CD                ENDP
02CD                
entering: toupper
02CD                toupper: PROC
02CD                
02CD                ;-160     while(*s) {
02CD                
02CD                ;Function : toupper, Number of local variables: 1
02CD                ;   # type sign width addr used name   list of local variables
02CD                ;  200 ptr sign byte   159 NULL s = bp+4;
02CD C8 00 00 00     ENTER  0,0
02D1                .toupper26:
02D1 8B 5E 04        mov bx, [bp+4]
02D4 8A 07           mov al, [bx]
02D6 B4 00           mov ah, 0
02D8 08 C0           or  al, al
02DA 0F 84 00 00   r je .toupper27
02DE                
02DE                ;-161         if (*s >= 'a') if (*s <= 'z') *s=*s-32;
02DE                
02DE 8B 5E 04        mov bx, [bp+4]
02E1 8A 07           mov al, [bx]
02E3 B4 00           mov ah, 0
02E5 83 F8 61        cmp ax, 97 ;unsigned : 1
02E8 0F 8C 00 00   r jl  .toupper28
02EC 8B 5E 04        mov bx, [bp+4]
02EF 8A 07           mov al, [bx]
02F1 B4 00           mov ah, 0
02F3 83 F8 7A        cmp ax, 122
02F6 0F 8F 00 00   r jg  .toupper29
02FA 8B 5E 04        mov bx, [bp+4]
02FD 8A 07           mov al, [bx]
02FF B4 00           mov ah, 0
0301 83 E8 20        sub ax, 32
0304 8B 5E 04        mov  bx, [bp+4]
0307 88 07           mov  [bx], al
0309                
0309                ;-162             s++;
0309                
0309                .toupper29:
0309                .toupper28:
0309 FF 46 04        inc  word[bp+4]
030C                
030C                ;-163               }
030C                
030C                
030C                ;-164     }
030C                
030C EB C3           jmp .toupper26
030E                .toupper27:
030E                
030E                ;-165 
030E                
030E                
030E                ;-166 int testReg() {
030E C9              LEAVE
030F C3              ret
leaving: toupper, loc labels: 4, loc jmp forward: 3
0310                ENDP
0310                
entering: testReg
0310                testReg: PROC
0310                
0310                ;-167 //ret:RegNo: 0 - 7 AL, CL  set:R2Type: 0=no reg,BYTE,WORD,SEGREG,DWORD
0310                
0310                
0310                ;-168   R2Type=0;
0310                
0310 B8 00 00        mov ax, 0
0313 A2 35 01        mov byte [R2Type], al
0316                
0316                ;-169   if (strlen(Symbol) < 2) return 0;
0316                
0316 8D 06 30 75     lea  ax, [Symbol]
031A 50              push ax
031B E8 E4 FE        call strlen
031E 83 C4 02        add  sp, 2
0321 3C 02           cmp al, 2
0323 0F 8D 00 00   r jge .testReg30
0327 B8 00 00        mov ax, 0
032A E9 00 00      R jmp .retntestReg
032D                
032D                ;-170   if (strlen(Symbol) > 3) return 0;
032D                
032D                .testReg30:
032D 8D 06 30 75     lea  ax, [Symbol]
0331 50              push ax
0332 E8 CD FE        call strlen
0335 83 C4 02        add  sp, 2
0338 3C 03           cmp al, 3
033A 0F 8E 00 00   r jle .testReg31
033E B8 00 00        mov ax, 0
0341 E9 00 00      R jmp .retntestReg
0344                
0344                ;-171   R2Type=BYTE;
0344                
0344                .testReg31:
0344 B8 01 00        mov ax, 1
0347 A2 35 01        mov byte [R2Type], al
034A                
034A                ;-172   if (eqstr(SymbolUpper, "AL")) return 0;
034A                
034A 68 AA AA      A push testReg_0
034D 8D 06 4F 75     lea  ax, [SymbolUpper]
0351 50              push ax
0352 E8 0B FF        call eqstr
0355 83 C4 04        add  sp, 4
0358 08 C0           or  al, al
035A 0F 84 00 00   r je .testReg32
035E B8 00 00        mov ax, 0
0361 E9 00 00      R jmp .retntestReg
0364                
0364                ;-173   if (eqstr(SymbolUpper, "CL")) return 1;
0364                
0364                .testReg32:
0364 68 AA AA      A push testReg_1
0367 8D 06 4F 75     lea  ax, [SymbolUpper]
036B 50              push ax
036C E8 F1 FE        call eqstr
036F 83 C4 04        add  sp, 4
0372 08 C0           or  al, al
0374 0F 84 00 00   r je .testReg33
0378 B8 01 00        mov ax, 1
037B E9 00 00      R jmp .retntestReg
037E                
037E                ;-174   if (eqstr(SymbolUpper, "DL")) return 2;
037E                
037E                .testReg33:
037E 68 AA AA      A push testReg_2
0381 8D 06 4F 75     lea  ax, [SymbolUpper]
0385 50              push ax
0386 E8 D7 FE        call eqstr
0389 83 C4 04        add  sp, 4
038C 08 C0           or  al, al
038E 0F 84 00 00   r je .testReg34
0392 B8 02 00        mov ax, 2
0395 E9 00 00      R jmp .retntestReg
0398                
0398                ;-175   if (eqstr(SymbolUpper, "BL")) return 3;
0398                
0398                .testReg34:
0398 68 AA AA      A push testReg_3
039B 8D 06 4F 75     lea  ax, [SymbolUpper]
039F 50              push ax
03A0 E8 BD FE        call eqstr
03A3 83 C4 04        add  sp, 4
03A6 08 C0           or  al, al
03A8 0F 84 00 00   r je .testReg35
03AC B8 03 00        mov ax, 3
03AF E9 00 00      R jmp .retntestReg
03B2                
03B2                ;-176   if (eqstr(SymbolUpper, "AH")) return 4;
03B2                
03B2                .testReg35:
03B2 68 AA AA      A push testReg_4
03B5 8D 06 4F 75     lea  ax, [SymbolUpper]
03B9 50              push ax
03BA E8 A3 FE        call eqstr
03BD 83 C4 04        add  sp, 4
03C0 08 C0           or  al, al
03C2 0F 84 00 00   r je .testReg36
03C6 B8 04 00        mov ax, 4
03C9 E9 00 00      R jmp .retntestReg
03CC                
03CC                ;-177   if (eqstr(SymbolUpper, "CH")) return 5;
03CC                
03CC                .testReg36:
03CC 68 AA AA      A push testReg_5
03CF 8D 06 4F 75     lea  ax, [SymbolUpper]
03D3 50              push ax
03D4 E8 89 FE        call eqstr
03D7 83 C4 04        add  sp, 4
03DA 08 C0           or  al, al
03DC 0F 84 00 00   r je .testReg37
03E0 B8 05 00        mov ax, 5
03E3 E9 00 00      R jmp .retntestReg
03E6                
03E6                ;-178   if (eqstr(SymbolUpper, "DH")) return 6;
03E6                
03E6                .testReg37:
03E6 68 AA AA      A push testReg_6
03E9 8D 06 4F 75     lea  ax, [SymbolUpper]
03ED 50              push ax
03EE E8 6F FE        call eqstr
03F1 83 C4 04        add  sp, 4
03F4 08 C0           or  al, al
03F6 0F 84 00 00   r je .testReg38
03FA B8 06 00        mov ax, 6
03FD E9 00 00      R jmp .retntestReg
0400                
0400                ;-179   if (eqstr(SymbolUpper, "BH")) return 7;
0400                
0400                .testReg38:
0400 68 AA AA      A push testReg_7
0403 8D 06 4F 75     lea  ax, [SymbolUpper]
0407 50              push ax
0408 E8 55 FE        call eqstr
040B 83 C4 04        add  sp, 4
040E 08 C0           or  al, al
0410 0F 84 00 00   r je .testReg39
0414 B8 07 00        mov ax, 7
0417 E9 00 00      R jmp .retntestReg
041A                
041A                ;-180   R2Type=WORD;
041A                
041A                .testReg39:
041A B8 02 00        mov ax, 2
041D A2 35 01        mov byte [R2Type], al
0420                
0420                ;-181   if (eqstr(SymbolUpper, "AX")) return 0;
0420                
0420 68 AA AA      A push testReg_8
0423 8D 06 4F 75     lea  ax, [SymbolUpper]
0427 50              push ax
0428 E8 35 FE        call eqstr
042B 83 C4 04        add  sp, 4
042E 08 C0           or  al, al
0430 0F 84 00 00   r je .testReg40
0434 B8 00 00        mov ax, 0
0437 E9 00 00      R jmp .retntestReg
043A                
043A                ;-182   if (eqstr(SymbolUpper, "CX")) return 1;
043A                
043A                .testReg40:
043A 68 AA AA      A push testReg_9
043D 8D 06 4F 75     lea  ax, [SymbolUpper]
0441 50              push ax
0442 E8 1B FE        call eqstr
0445 83 C4 04        add  sp, 4
0448 08 C0           or  al, al
044A 0F 84 00 00   r je .testReg41
044E B8 01 00        mov ax, 1
0451 E9 00 00      R jmp .retntestReg
0454                
0454                ;-183   if (eqstr(SymbolUpper, "DX")) return 2;
0454                
0454                .testReg41:
0454 68 AA AA      A push testReg_10
0457 8D 06 4F 75     lea  ax, [SymbolUpper]
045B 50              push ax
045C E8 01 FE        call eqstr
045F 83 C4 04        add  sp, 4
0462 08 C0           or  al, al
0464 0F 84 00 00   r je .testReg42
0468 B8 02 00        mov ax, 2
046B E9 00 00      R jmp .retntestReg
046E                
046E                ;-184   if (eqstr(SymbolUpper, "BX")) return 3;
046E                
046E                .testReg42:
046E 68 AA AA      A push testReg_11
0471 8D 06 4F 75     lea  ax, [SymbolUpper]
0475 50              push ax
0476 E8 E7 FD        call eqstr
0479 83 C4 04        add  sp, 4
047C 08 C0           or  al, al
047E 0F 84 00 00   r je .testReg43
0482 B8 03 00        mov ax, 3
0485 E9 00 00      R jmp .retntestReg
0488                
0488                ;-185   if (eqstr(SymbolUpper, "SP")) return 4;
0488                
0488                .testReg43:
0488 68 AA AA      A push testReg_12
048B 8D 06 4F 75     lea  ax, [SymbolUpper]
048F 50              push ax
0490 E8 CD FD        call eqstr
0493 83 C4 04        add  sp, 4
0496 08 C0           or  al, al
0498 0F 84 00 00   r je .testReg44
049C B8 04 00        mov ax, 4
049F E9 00 00      R jmp .retntestReg
04A2                
04A2                ;-186   if (eqstr(SymbolUpper, "BP")) return 5;
04A2                
04A2                .testReg44:
04A2 68 AA AA      A push testReg_13
04A5 8D 06 4F 75     lea  ax, [SymbolUpper]
04A9 50              push ax
04AA E8 B3 FD        call eqstr
04AD 83 C4 04        add  sp, 4
04B0 08 C0           or  al, al
04B2 0F 84 00 00   r je .testReg45
04B6 B8 05 00        mov ax, 5
04B9 E9 00 00      R jmp .retntestReg
04BC                
04BC                ;-187   if (eqstr(SymbolUpper, "SI")) return 6;
04BC                
04BC                .testReg45:
04BC 68 AA AA      A push testReg_14
04BF 8D 06 4F 75     lea  ax, [SymbolUpper]
04C3 50              push ax
04C4 E8 99 FD        call eqstr
04C7 83 C4 04        add  sp, 4
04CA 08 C0           or  al, al
04CC 0F 84 00 00   r je .testReg46
04D0 B8 06 00        mov ax, 6
04D3 E9 00 00      R jmp .retntestReg
04D6                
04D6                ;-188   if (eqstr(SymbolUpper, "DI")) return 7;
04D6                
04D6                .testReg46:
04D6 68 AA AA      A push testReg_15
04D9 8D 06 4F 75     lea  ax, [SymbolUpper]
04DD 50              push ax
04DE E8 7F FD        call eqstr
04E1 83 C4 04        add  sp, 4
04E4 08 C0           or  al, al
04E6 0F 84 00 00   r je .testReg47
04EA B8 07 00        mov ax, 7
04ED E9 00 00      R jmp .retntestReg
04F0                
04F0                ;-189   R2Type=SEGREG;
04F0                
04F0                .testReg47:
04F0 B8 04 00        mov ax, 4
04F3 A2 35 01        mov byte [R2Type], al
04F6                
04F6                ;-190   if (eqstr(SymbolUpper, "ES")) return 0;
04F6                
04F6 68 AA AA      A push testReg_16
04F9 8D 06 4F 75     lea  ax, [SymbolUpper]
04FD 50              push ax
04FE E8 5F FD        call eqstr
0501 83 C4 04        add  sp, 4
0504 08 C0           or  al, al
0506 0F 84 00 00   r je .testReg48
050A B8 00 00        mov ax, 0
050D E9 00 00      R jmp .retntestReg
0510                
0510                ;-191   if (eqstr(SymbolUpper, "CS")) return 1;
0510                
0510                .testReg48:
0510 68 AA AA      A push testReg_17
0513 8D 06 4F 75     lea  ax, [SymbolUpper]
0517 50              push ax
0518 E8 45 FD        call eqstr
051B 83 C4 04        add  sp, 4
051E 08 C0           or  al, al
0520 0F 84 00 00   r je .testReg49
0524 B8 01 00        mov ax, 1
0527 E9 00 00      R jmp .retntestReg
052A                
052A                ;-192   if (eqstr(SymbolUpper, "SS")) return 2;
052A                
052A                .testReg49:
052A 68 AA AA      A push testReg_18
052D 8D 06 4F 75     lea  ax, [SymbolUpper]
0531 50              push ax
0532 E8 2B FD        call eqstr
0535 83 C4 04        add  sp, 4
0538 08 C0           or  al, al
053A 0F 84 00 00   r je .testReg50
053E B8 02 00        mov ax, 2
0541 E9 00 00      R jmp .retntestReg
0544                
0544                ;-193   if (eqstr(SymbolUpper, "DS")) return 3;
0544                
0544                .testReg50:
0544 68 AA AA      A push testReg_19
0547 8D 06 4F 75     lea  ax, [SymbolUpper]
054B 50              push ax
054C E8 11 FD        call eqstr
054F 83 C4 04        add  sp, 4
0552 08 C0           or  al, al
0554 0F 84 00 00   r je .testReg51
0558 B8 03 00        mov ax, 3
055B E9 00 00      R jmp .retntestReg
055E                
055E                ;-194   if (eqstr(SymbolUpper, "FS")) return 4;
055E                
055E                .testReg51:
055E 68 AA AA      A push testReg_20
0561 8D 06 4F 75     lea  ax, [SymbolUpper]
0565 50              push ax
0566 E8 F7 FC        call eqstr
0569 83 C4 04        add  sp, 4
056C 08 C0           or  al, al
056E 0F 84 00 00   r je .testReg52
0572 B8 04 00        mov ax, 4
0575 E9 00 00      R jmp .retntestReg
0578                
0578                ;-195   if (eqstr(SymbolUpper, "GS")) return 5;
0578                
0578                .testReg52:
0578 68 AA AA      A push testReg_21
057B 8D 06 4F 75     lea  ax, [SymbolUpper]
057F 50              push ax
0580 E8 DD FC        call eqstr
0583 83 C4 04        add  sp, 4
0586 08 C0           or  al, al
0588 0F 84 00 00   r je .testReg53
058C B8 05 00        mov ax, 5
058F E9 00 00      R jmp .retntestReg
0592                
0592                ;-196   R2Type=DWORD;
0592                
0592                .testReg53:
0592 B8 03 00        mov ax, 3
0595 A2 35 01        mov byte [R2Type], al
0598                
0598                ;-197   if (eqstr(SymbolUpper, "EAX"))return 0;
0598                
0598 68 AA AA      A push testReg_22
059B 8D 06 4F 75     lea  ax, [SymbolUpper]
059F 50              push ax
05A0 E8 BD FC        call eqstr
05A3 83 C4 04        add  sp, 4
05A6 08 C0           or  al, al
05A8 0F 84 00 00   r je .testReg54
05AC B8 00 00        mov ax, 0
05AF E9 00 00      R jmp .retntestReg
05B2                
05B2                ;-198   if (eqstr(SymbolUpper, "ECX"))return 1;
05B2                
05B2                .testReg54:
05B2 68 AA AA      A push testReg_23
05B5 8D 06 4F 75     lea  ax, [SymbolUpper]
05B9 50              push ax
05BA E8 A3 FC        call eqstr
05BD 83 C4 04        add  sp, 4
05C0 08 C0           or  al, al
05C2 0F 84 00 00   r je .testReg55
05C6 B8 01 00        mov ax, 1
05C9 E9 00 00      R jmp .retntestReg
05CC                
05CC                ;-199   if (eqstr(SymbolUpper, "EDX"))return 2;
05CC                
05CC                .testReg55:
05CC 68 AA AA      A push testReg_24
05CF 8D 06 4F 75     lea  ax, [SymbolUpper]
05D3 50              push ax
05D4 E8 89 FC        call eqstr
05D7 83 C4 04        add  sp, 4
05DA 08 C0           or  al, al
05DC 0F 84 00 00   r je .testReg56
05E0 B8 02 00        mov ax, 2
05E3 E9 00 00      R jmp .retntestReg
05E6                
05E6                ;-200   if (eqstr(SymbolUpper, "EBX"))return 3;
05E6                
05E6                .testReg56:
05E6 68 AA AA      A push testReg_25
05E9 8D 06 4F 75     lea  ax, [SymbolUpper]
05ED 50              push ax
05EE E8 6F FC        call eqstr
05F1 83 C4 04        add  sp, 4
05F4 08 C0           or  al, al
05F6 0F 84 00 00   r je .testReg57
05FA B8 03 00        mov ax, 3
05FD E9 00 00      R jmp .retntestReg
0600                
0600                ;-201   if (eqstr(SymbolUpper, "ESP"))return 4;
0600                
0600                .testReg57:
0600 68 AA AA      A push testReg_26
0603 8D 06 4F 75     lea  ax, [SymbolUpper]
0607 50              push ax
0608 E8 55 FC        call eqstr
060B 83 C4 04        add  sp, 4
060E 08 C0           or  al, al
0610 0F 84 00 00   r je .testReg58
0614 B8 04 00        mov ax, 4
0617 E9 00 00      R jmp .retntestReg
061A                
061A                ;-202   if (eqstr(SymbolUpper, "EBP"))return 5;
061A                
061A                .testReg58:
061A 68 AA AA      A push testReg_27
061D 8D 06 4F 75     lea  ax, [SymbolUpper]
0621 50              push ax
0622 E8 3B FC        call eqstr
0625 83 C4 04        add  sp, 4
0628 08 C0           or  al, al
062A 0F 84 00 00   r je .testReg59
062E B8 05 00        mov ax, 5
0631 E9 00 00      R jmp .retntestReg
0634                
0634                ;-203   if (eqstr(SymbolUpper, "ESI"))return 6;
0634                
0634                .testReg59:
0634 68 AA AA      A push testReg_28
0637 8D 06 4F 75     lea  ax, [SymbolUpper]
063B 50              push ax
063C E8 21 FC        call eqstr
063F 83 C4 04        add  sp, 4
0642 08 C0           or  al, al
0644 0F 84 00 00   r je .testReg60
0648 B8 06 00        mov ax, 6
064B E9 00 00      R jmp .retntestReg
064E                
064E                ;-204   if (eqstr(SymbolUpper, "EDI"))return 7;
064E                
064E                .testReg60:
064E 68 AA AA      A push testReg_29
0651 8D 06 4F 75     lea  ax, [SymbolUpper]
0655 50              push ax
0656 E8 07 FC        call eqstr
0659 83 C4 04        add  sp, 4
065C 08 C0           or  al, al
065E 0F 84 00 00   r je .testReg61
0662 B8 07 00        mov ax, 7
0665 E9 00 00      R jmp .retntestReg
0668                
0668                ;-205   R2Type=0; return 0;
0668                
0668                .testReg61:
0668 B8 00 00        mov ax, 0
066B A2 35 01        mov byte [R2Type], al
066E B8 00 00        mov ax, 0
0671 E9 00 00      R jmp .retntestReg
0674                
0674                ;-206 }
0674                
0674                
0674                ;-207 
0674                
0674                
0674                ;-208 
0674                
0674                
0674                ;-209 int prc(unsigned char c) {//print char
0674                
0674                 .retntestReg:
0674 C3              ret
0675 41 4C 00       testReg_0 db "AL",0
0678 43 4C 00       testReg_1 db "CL",0
067B 44 4C 00       testReg_2 db "DL",0
067E 42 4C 00       testReg_3 db "BL",0
0681 41 48 00       testReg_4 db "AH",0
0684 43 48 00       testReg_5 db "CH",0
0687 44 48 00       testReg_6 db "DH",0
068A 42 48 00       testReg_7 db "BH",0
068D 41 58 00       testReg_8 db "AX",0
0690 43 58 00       testReg_9 db "CX",0
0693 44 58 00       testReg_10 db "DX",0
0696 42 58 00       testReg_11 db "BX",0
0699 53 50 00       testReg_12 db "SP",0
069C 42 50 00       testReg_13 db "BP",0
069F 53 49 00       testReg_14 db "SI",0
06A2 44 49 00       testReg_15 db "DI",0
06A5 45 53 00       testReg_16 db "ES",0
06A8 43 53 00       testReg_17 db "CS",0
06AB 53 53 00       testReg_18 db "SS",0
06AE 44 53 00       testReg_19 db "DS",0
06B1 46 53 00       testReg_20 db "FS",0
06B4 47 53 00       testReg_21 db "GS",0
06B7 45 41 58 00    testReg_22 db "EAX",0
06BB 45 43 58 00    testReg_23 db "ECX",0
06BF 45 44 58 00    testReg_24 db "EDX",0
06C3 45 42 58 00    testReg_25 db "EBX",0
06C7 45 53 50 00    testReg_26 db "ESP",0
06CB 45 42 50 00    testReg_27 db "EBP",0
06CF 45 53 49 00    testReg_28 db "ESI",0
06D3 45 44 49 00    testReg_29 db "EDI",0
leaving: testReg, loc labels: 63, loc jmp forward: 95
06D7                ENDP
06D7                
entering: prc
06D7                prc: PROC
06D7                
06D7                ;-210         if ( _ c==10) {
06D7                
06D7                ;Function : prc, Number of local variables: 1
06D7                ;   # type sign width addr used name   list of local variables
06D7                ;  200 var unsg byte   209 NULL c = bp+4;
06D7 C8 00 00 00     ENTER  0,0 ; constant expression
06DB 80 7E 04 0A    cmp byte[bp+4], 10
06DF 0F 85 00 00   r jne .prc62
06E3                
06E3                ;-211             ax=13;
06E3                
06E3 B8 0D 00        mov  ax, 13
06E6                
06E6                ;-212             writetty();
06E6                
06E6 E8 75 F9        call writetty
06E9                
06E9                ;-213             }
06E9                
06E9                
06E9                ;-214         al=c;
06E9                
06E9                .prc62:
06E9 8A 46 04        mov  al, [bp+4]
06EC                
06EC                ;-215         writetty();
06EC                
06EC E8 6F F9        call writetty
06EF                
06EF                ;-216     fputcR(c,lst_fd);
06EF                
06EF FF 36 18 01     push word [lst_fd]
06F3 8A 46 04        mov al, byte [bp+4]
06F6 B4 00           mov ah, 0
06F8 50              push ax
06F9 E8 0D FA        call fputcR
06FC 83 C4 04        add  sp, 4
06FF                
06FF                ;-217 }
06FF                
06FF                
06FF                ;-218 
06FF                
06FF                
06FF                ;-219 int prscomment(unsigned char *s) {
06FF C9              LEAVE
0700 C3              ret
leaving: prc, loc labels: 1, loc jmp forward: 1
0701                ENDP
0701                
entering: prscomment
0701                prscomment: PROC
0701                
0701                ;-220     unsigned char c;
0701                
0701                
0701                ;-221     while (*s){
0701                
0701                ;Function : prscomment, Number of local variables: 2
0701                ;   # type sign width addr used name   list of local variables
0701                ;  200 ptr unsg byte   219 NULL s = bp+4
0701                ;  201 var unsg byte   220 NULL c = bp-2;
0701 C8 02 00 00     ENTER  2,0
0705                .prscomment63:
0705 8B 5E 04        mov bx, [bp+4]
0708 8A 07           mov al, [bx]
070A B4 00           mov ah, 0
070C 08 C0           or  al, al
070E 0F 84 00 00   r je .prscomment64
0712                
0712                ;-222         c=*s;
0712                
0712 8B 5E 04        mov bx, [bp+4]
0715 8A 07           mov al, [bx]
0717 B4 00           mov ah, 0
0719 88 46 FE        mov [bp-2], al
071C                
071C                ;-223         prc(c);
071C                
071C 8A 46 FE        mov al, byte [bp-2]
071F B4 00           mov ah, 0
0721 50              push ax
0722 E8 B2 FF        call prc
0725 83 C4 02        add  sp, 2
0728                
0728                ;-224         s++;
0728                
0728 FF 46 04        inc  word[bp+4]
072B                
072B                ;-225     }
072B                
072B                
072B                ;-226 }
072B                
072B EB D8           jmp .prscomment63
072D                .prscomment64:
072D                
072D                ;-227 int prs(unsigned char *s) {
072D C9              LEAVE
072E C3              ret
leaving: prscomment, loc labels: 2, loc jmp forward: 1
072F                ENDP
072F                
entering: prs
072F                prs: PROC
072F                
072F                ;-228     unsigned char c;
072F                
072F                
072F                ;-229     int com;
072F                
072F                
072F                ;-230     com=0;
072F                
072F                ;Function : prs, Number of local variables: 3
072F                ;   # type sign width addr used name   list of local variables
072F                ;  200 ptr unsg byte   227 NULL s = bp+4
072F                ;  201 var unsg byte   228 NULL c = bp-2
072F                ;  202 var sign word   229 NULL com = bp-4;
072F C8 04 00 00     ENTER  4,0
0733 B8 00 00        mov ax, 0
0736 89 46 FC        mov [bp-4], ax
0739                
0739                ;-231     while (*s) {
0739                
0739                .prs65:
0739 8B 5E 04        mov bx, [bp+4]
073C 8A 07           mov al, [bx]
073E B4 00           mov ah, 0
0740 08 C0           or  al, al
0742 0F 84 00 00   r je .prs66
0746                
0746                ;-232         c=*s;
0746                
0746 8B 5E 04        mov bx, [bp+4]
0749 8A 07           mov al, [bx]
074B B4 00           mov ah, 0
074D 88 46 FE        mov [bp-2], al
0750                
0750                ;-233         if (c==34) {
0750                
0750 8A 46 FE        mov al, [bp-2]
0753 3C 22           cmp al, 34
0755 0F 85 00 00   r jne .prs67
0759                
0759                ;-234             if (com) com=0;
0759                
0759 8B 46 FC        mov ax, [bp-4]
075C 08 C0           or  al, al
075E 0F 84 00 00   r je .prs68
0762 B8 00 00        mov ax, 0
0765 89 46 FC        mov [bp-4], ax
0768                
0768                ;-235                 else com=1;
0768                
0768 E9 00 00      R jmp .prs69
076B                .prs68:
076B B8 01 00        mov ax, 1
076E 89 46 FC        mov [bp-4], ax
0771                
0771                ;-236         }
0771                
0771                .prs69:
0771                
0771                ;-237         if (c==92) {
0771                
0771                .prs67:
0771 8A 46 FE        mov al, [bp-2]
0774 3C 5C           cmp al, 92
0776 0F 85 00 00   r jne .prs70
077A                
077A                ;-238             if (com==0) {
077A                
077A 8B 46 FC        mov ax, [bp-4]
077D 83 F8 00        cmp ax, 0
0780 0F 85 00 00   r jne .prs71
0784                
0784                ;-239                 s++;
0784                
0784 FF 46 04        inc  word[bp+4]
0787                
0787                ;-240                 c=*s;
0787                
0787 8B 5E 04        mov bx, [bp+4]
078A 8A 07           mov al, [bx]
078C B4 00           mov ah, 0
078E 88 46 FE        mov [bp-2], al
0791                
0791                ;-241                 if (c=='n') c=10;
0791                
0791 8A 46 FE        mov al, [bp-2]
0794 3C 6E           cmp al, 110
0796 0F 85 00 00   r jne .prs72
079A B8 0A 00        mov ax, 10
079D 88 46 FE        mov [bp-2], al
07A0                
07A0                ;-242                 if (c=='t') c= 9;
07A0                
07A0                .prs72:
07A0 8A 46 FE        mov al, [bp-2]
07A3 3C 74           cmp al, 116
07A5 0F 85 00 00   r jne .prs73
07A9 B8 09 00        mov ax, 9
07AC 88 46 FE        mov [bp-2], al
07AF                
07AF                ;-243             }
07AF                
07AF                .prs73:
07AF                
07AF                ;-244         }
07AF                
07AF                .prs71:
07AF                
07AF                ;-245         prc(c);
07AF                
07AF                .prs70:
07AF 8A 46 FE        mov al, byte [bp-2]
07B2 B4 00           mov ah, 0
07B4 50              push ax
07B5 E8 1F FF        call prc
07B8 83 C4 02        add  sp, 2
07BB                
07BB                ;-246         s++;
07BB                
07BB FF 46 04        inc  word[bp+4]
07BE                
07BE                ;-247     }
07BE                
07BE                
07BE                ;-248 }
07BE                
07BE E9 78 FF        jmp .prs65
07C1                .prs66:
07C1                
07C1                ;-249 int printhex4(unsigned char c) {
07C1 C9              LEAVE
07C2 C3              ret
leaving: prs, loc labels: 9, loc jmp forward: 8
07C3                ENDP
07C3                
entering: printhex4
07C3                printhex4: PROC
07C3                
07C3                ;-250     c += 48;
07C3                
07C3                ;Function : printhex4, Number of local variables: 1
07C3                ;   # type sign width addr used name   list of local variables
07C3                ;  200 var unsg byte   249 NULL c = bp+4;
07C3 C8 00 00 00     ENTER  0,0
07C7 80 46 04 30     add  byte[bp+4], 48
07CB                
07CB                ;-251     if (c > 57) c += 7;
07CB                
07CB 8A 46 04        mov al, [bp+4]
07CE 3C 39           cmp al, 57
07D0 0F 8E 00 00   r jle .printhex474
07D4 80 46 04 07     add  byte[bp+4], 7
07D8                
07D8                ;-252     prc(c);
07D8                
07D8                .printhex474:
07D8 8A 46 04        mov al, byte [bp+4]
07DB B4 00           mov ah, 0
07DD 50              push ax
07DE E8 F6 FE        call prc
07E1 83 C4 02        add  sp, 2
07E4                
07E4                ;-253 }
07E4                
07E4                
07E4                ;-254 int printhex8a(unsigned char c) {
07E4 C9              LEAVE
07E5 C3              ret
leaving: printhex4, loc labels: 1, loc jmp forward: 1
07E6                ENDP
07E6                
entering: printhex8a
07E6                printhex8a: PROC
07E6                
07E6                ;-255     unsigned char nib;
07E6                
07E6                
07E6                ;-256     nib = c >> 4; printhex4(nib);
07E6                
07E6                ;Function : printhex8a, Number of local variables: 2
07E6                ;   # type sign width addr used name   list of local variables
07E6                ;  200 var unsg byte   254 NULL c = bp+4
07E6                ;  201 var unsg byte   255 NULL nib = bp-2;
07E6 C8 02 00 00     ENTER  2,0
07EA 8A 46 04        mov al, [bp+4]
07ED C0 E8 04        shr al, 4
07F0 88 46 FE        mov [bp-2], al
07F3 8A 46 FE        mov al, byte [bp-2]
07F6 B4 00           mov ah, 0
07F8 50              push ax
07F9 E8 C7 FF        call printhex4
07FC 83 C4 02        add  sp, 2
07FF                
07FF                ;-257     nib = c & 15; printhex4(nib);
07FF                
07FF 8A 46 04        mov al, [bp+4]
0802 24 0F           and al, 15
0804 88 46 FE        mov [bp-2], al
0807 8A 46 FE        mov al, byte [bp-2]
080A B4 00           mov ah, 0
080C 50              push ax
080D E8 B3 FF        call printhex4
0810 83 C4 02        add  sp, 2
0813                
0813                ;-258 }
0813                
0813                
0813                ;-259 int printhex16(unsigned int i) {
0813 C9              LEAVE
0814 C3              ret
leaving: printhex8a, loc labels: 0, loc jmp forward: 0
0815                ENDP
0815                
entering: printhex16
0815                printhex16: PROC
0815                
0815                ;-260     unsigned int half;
0815                
0815                
0815                ;-261     half = i >>  8; printhex8a(half);
0815                
0815                ;Function : printhex16, Number of local variables: 2
0815                ;   # type sign width addr used name   list of local variables
0815                ;  200 var unsg word   259 NULL i = bp+4
0815                ;  201 var unsg word   260 NULL half = bp-2;
0815 C8 02 00 00     ENTER  2,0
0819 8B 46 04        mov ax, [bp+4]
081C C1 E8 08        shr ax, 8
081F 89 46 FE        mov [bp-2], ax
0822 55              push word [bp-2]
0823 E8 C0 FF        call printhex8a
0826 83 C4 02        add  sp, 2
0829                
0829                ;-262     half = i & 255; printhex8a(half);
0829                
0829 8B 46 04        mov ax, [bp+4]
082C 25 FF 00        and ax, 255
082F 89 46 FE        mov [bp-2], ax
0832 55              push word [bp-2]
0833 E8 B0 FF        call printhex8a
0836 83 C4 02        add  sp, 2
0839                
0839                ;-263 }
0839                
0839                
0839                ;-264 int printIntU(unsigned int n) {
0839 C9              LEAVE
083A C3              ret
leaving: printhex16, loc labels: 0, loc jmp forward: 0
083B                ENDP
083B                
entering: printIntU
083B                printIntU: PROC
083B                
083B                ;-265     unsigned int e;
083B                
083B                
083B                ;-266     if ( _ n >= 10) {
083B                
083B                ;Function : printIntU, Number of local variables: 2
083B                ;   # type sign width addr used name   list of local variables
083B                ;  200 var unsg word   264 NULL n = bp+4
083B                ;  201 var unsg word   265 NULL e = bp-2;
083B C8 02 00 00     ENTER  2,0 ; constant expression
083F 83 7E 04 0A    cmp word[bp+4], 10 ;unsigned : 0
0843 0F 82 00 00   r jb  .printIntU75
0847                
0847                ;-267         e=n/10; //DIV
0847                
0847 8B 46 04        mov ax, [bp+4]
084A BB 0A 00        mov bx, 10
084D BA 00 00        mov dx, 0
0850 F7 F3           div bx
0852 89 46 FE        mov [bp-2], ax
0855                
0855                ;-268         printIntU(e);
0855                
0855 55              push word [bp-2]
0856 E8 E2 FF        call printIntU
0859 83 C4 02        add  sp, 2
085C                
085C                ;-269     }
085C                
085C                
085C                ;-270     n = n % 10; //unsigned mod
085C                
085C                .printIntU75:
085C 8B 46 04        mov ax, [bp+4]
085F BB 0A 00        mov bx, 10
0862 BA 00 00        mov dx, 0
0865 F7 F3           div bx
0867 89 D0           mov ax, dx
0869 89 46 04        mov [bp+4], ax
086C                
086C                ;-271     n += '0';
086C                
086C 83 46 04 30     add  word[bp+4], 48
0870                
0870                ;-272     prc(n);
0870                
0870 55              push word [bp+4]
0871 E8 63 FE        call prc
0874 83 C4 02        add  sp, 2
0877                
0877                ;-273 }
0877                
0877                
0877                ;-274 int printLine() {
0877 C9              LEAVE
0878 C3              ret
leaving: printIntU, loc labels: 1, loc jmp forward: 1
0879                ENDP
0879                
entering: printLine
0879                printLine: PROC
0879                
0879                ;-275     int i; char c;
0879                
0879                
0879                ;-276     prs("\n");
0879                
0879                ;Function : printLine, Number of local variables: 2
0879                ;   # type sign width addr used name   list of local variables
0879                ;  200 var sign word   275 NULL i = bp-2
0879                ;  201 var sign byte   275 NULL c = bp-4;
0879 C8 04 00 00     ENTER  4,0
087D 68 AA AA      A push printLine_0
0880 E8 AC FE        call prs
0883 83 C4 02        add  sp, 2
0886                
0886                ;-277     printhex16(PCStart);
0886                
0886 FF 36 29 01     push word [PCStart]
088A E8 88 FF        call printhex16
088D 83 C4 02        add  sp, 2
0890                
0890                ;-278     if (OpPrintIndex == 0) prs("               ");
0890                
0890 A1 41 01        mov ax, [OpPrintIndex]
0893 83 F8 00        cmp ax, 0
0896 0F 85 00 00   r jne .printLine76
089A 68 AA AA      A push printLine_1
089D E8 8F FE        call prs
08A0 83 C4 02        add  sp, 2
08A3                
08A3                ;-279     else {
08A3                
08A3 E9 00 00      R jmp .printLine77
08A6                .printLine76:
08A6                
08A6                ;-280 //        prc(' ');
08A6                
08A6                
08A6                ;-281         i=0;
08A6                
08A6 B8 00 00        mov ax, 0
08A9 89 46 FE        mov [bp-2], ax
08AC                
08AC                ;-282         do {
08AC                
08AC                .printLine78:
08AC                
08AC                ;-283             c=OpPos[i];
08AC                
08AC 8B 5E FE        mov bx, [bp-2]
08AF 8A 87 55 77     mov al, [OpPos + bx]
08B3 88 46 FC        mov [bp-4], al
08B6                
08B6                ;-284             prc(' ');
08B6                
08B6 6A 20           push 32
08B8 E8 1C FE        call prc
08BB 83 C4 02        add  sp, 2
08BE                
08BE                ;-285             printhex8a(c);
08BE                
08BE 8A 46 FC        mov al, byte [bp-4]
08C1 B4 00           mov ah, 0
08C3 50              push ax
08C4 E8 1F FF        call printhex8a
08C7 83 C4 02        add  sp, 2
08CA                
08CA                ;-286             i++;
08CA                
08CA FF 46 FE        inc  word[bp-2]
08CD                
08CD                ;-287         } while (i < OpPrintIndex);
08CD                
08CD 8B 46 FE        mov ax, [bp-2]
08D0 3B 06 41 01     cmp ax, [OpPrintIndex]
08D4 0F 8D 00 00   r jge .printLine79
08D8 EB D2           jmp .printLine78
08DA                .printLine79:
08DA                
08DA                ;-288         while (i < OPMAXLEN) {// fill rest with blank
08DA                
08DA                .printLine80:
08DA 8B 46 FE        mov ax, [bp-2]
08DD 83 F8 05        cmp ax, 5
08E0 0F 8D 00 00   r jge .printLine81
08E4                
08E4                ;-289             prs("   ");
08E4                
08E4 68 AA AA      A push printLine_2
08E7 E8 45 FE        call prs
08EA 83 C4 02        add  sp, 2
08ED                
08ED                ;-290             i++;
08ED                
08ED FF 46 FE        inc  word[bp-2]
08F0                
08F0                ;-291         }
08F0                
08F0                
08F0                ;-292     }
08F0                
08F0 EB E8           jmp .printLine80
08F2                .printLine81:
08F2                
08F2                ;-293     prc(PrintRA);
08F2                
08F2                .printLine77:
08F2 A0 45 01        mov al, byte [PrintRA]
08F5 B4 00           mov ah, 0
08F7 50              push ax
08F8 E8 DC FD        call prc
08FB 83 C4 02        add  sp, 2
08FE                
08FE                ;-294     prscomment(InputBuf);
08FE                
08FE 8D 06 8D 75     lea  ax, [InputBuf]
0902 50              push ax
0903 E8 FB FD        call prscomment
0906 83 C4 02        add  sp, 2
0909                
0909                ;-295 }
0909                
0909                
0909                ;-296 
0909                
0909                
0909                ;-297 int epilog() {
0909 C9              LEAVE
090A C3              ret
090B 5C 6E 00       printLine_0 db "\n",0
090E 20 20 20 20 20 printLine_1 db "               ",0
091E 20 20 20 00    printLine_2 db "   ",0
leaving: printLine, loc labels: 9, loc jmp forward: 7
0922                ENDP
0922                
entering: epilog
0922                epilog: PROC
0922                
0922                ;-298     unsigned int i; char c;     int j;
0922                
0922                
0922                ;-299     prs("\n Errors: ");
0922                
0922                ;Function : epilog, Number of local variables: 3
0922                ;   # type sign width addr used name   list of local variables
0922                ;  200 var unsg word   298 NULL i = bp-2
0922                ;  201 var sign byte   298 NULL c = bp-4
0922                ;  202 var sign word   298 NULL j = bp-6;
0922 C8 06 00 00     ENTER  6,0
0926 68 AA AA      A push epilog_0
0929 E8 03 FE        call prs
092C 83 C4 02        add  sp, 2
092F                
092F                ;-300     printIntU(ErrorCount);
092F                
092F FF 36 1E 01     push word [ErrorCount]
0933 E8 05 FF        call printIntU
0936 83 C4 02        add  sp, 2
0939                
0939                ;-301     if (ErrorCount) prs(" *** ERRORS *** ");
0939                
0939 A1 1E 01        mov ax, [ErrorCount]
093C 08 C0           or  al, al
093E 0F 84 00 00   r je .epilog82
0942 68 AA AA      A push epilog_1
0945 E8 E7 FD        call prs
0948 83 C4 02        add  sp, 2
094B                
094B                ;-302     prs(", Out: ");
094B                
094B                .epilog82:
094B 68 AA AA      A push epilog_2
094E E8 DE FD        call prs
0951 83 C4 02        add  sp, 2
0954                
0954                ;-303     prs(namelst);
0954                
0954 8D 06 CF 76     lea  ax, [namelst]
0958 50              push ax
0959 E8 D3 FD        call prs
095C 83 C4 02        add  sp, 2
095F                
095F                ;-304     prs(", ");
095F                
095F 68 AA AA      A push epilog_3
0962 E8 CA FD        call prs
0965 83 C4 02        add  sp, 2
0968                
0968                ;-305     prs(namebin);
0968                
0968 8D 06 12 77     lea  ax, [namebin]
096C 50              push ax
096D E8 BF FD        call prs
0970 83 C4 02        add  sp, 2
0973                
0973                ;-306     prs("= ");
0973                
0973 68 AA AA      A push epilog_4
0976 E8 B6 FD        call prs
0979 83 C4 02        add  sp, 2
097C                
097C                ;-307     printIntU(BinLen);
097C                
097C FF 36 58 01     push word [BinLen]
0980 E8 B8 FE        call printIntU
0983 83 C4 02        add  sp, 2
0986                
0986                ;-308     prs(" bytes.");
0986                
0986 68 AA AA      A push epilog_5
0989 E8 A3 FD        call prs
098C 83 C4 02        add  sp, 2
098F                
098F                ;-309     prs(" Labels: ");
098F                
098F 68 AA AA      A push epilog_6
0992 E8 9A FD        call prs
0995 83 C4 02        add  sp, 2
0998                
0998                ;-310     printIntU(LabelMaxIx);
0998                
0998 FF 36 4A 01     push word [LabelMaxIx]
099C E8 9C FE        call printIntU
099F 83 C4 02        add  sp, 2
09A2                
09A2                ;-311 // prs(", code:\n ");//debug
09A2                
09A2                
09A2                ;-312 
09A2                
09A2                
09A2                ;-313     i=0;
09A2                
09A2 B8 00 00        mov ax, 0
09A5 89 46 FE        mov [bp-2], ax
09A8                
09A8                ;-314     do {
09A8                
09A8                .epilog83:
09A8                
09A8                ;-315         c = FileBin[i];
09A8                
09A8 8B 5E FE        mov bx, [bp-2]
09AB 8A 47 AA        mov al, [FileBin + bx]
09AE 88 46 FC        mov [bp-4], al
09B1                
09B1                ;-316         fputcR(c, bin_fd);
09B1                
09B1 FF 36 1A 01     push word [bin_fd]
09B5 8A 46 FC        mov al, byte [bp-4]
09B8 B4 00           mov ah, 0
09BA 50              push ax
09BB E8 4B F7        call fputcR
09BE 83 C4 04        add  sp, 4
09C1                
09C1                ;-317 // printhex8a(c); prc(' ');//debug
09C1                
09C1                
09C1                ;-318         i++;
09C1                
09C1 FF 46 FE        inc  word[bp-2]
09C4                
09C4                ;-319     } while (i < BinLen);
09C4                
09C4 8B 46 FE        mov ax, [bp-2]
09C7 3B 06 58 01     cmp ax, [BinLen]
09CB 0F 8D 00 00   r jge .epilog84
09CF EB D7           jmp .epilog83
09D1                .epilog84:
09D1                
09D1                ;-320 
09D1                
09D1                
09D1                ;-321 /* 
09D1                
09D1                
09D1                ;-322   prs("\n\n LabelNamePtr:"); printIntU(LabelNamePtr);
09D1                
09D1                
09D1                ;-323   i= &LabelNames;
09D1                
09D1                
09D1                ;-324   prs(" &LabelNames:"); printIntU(i);
09D1                
09D1                
09D1                ;-325   i=LabelNamePtr-i;
09D1                
09D1                
09D1                ;-326   prs(", size: ");
09D1                
09D1                
09D1                ;-327   printIntU(i);
09D1                
09D1                
09D1                ;-328   prs(".\n >>");
09D1                
09D1                
09D1                ;-329   i= &LabelNames;
09D1                
09D1                
09D1                ;-330   do { c=*i; if (c==0) c=' '; prc(c); i++;
09D1                
09D1                
09D1                ;-331   } while (i < LabelNamePtr); prs("<< \n");
09D1                
09D1                
09D1                ;-332    i = 1;
09D1                
09D1                
09D1                ;-333     LabelNamePtr= &LabelNames;
09D1                
09D1                
09D1                ;-334     do {
09D1                
09D1                
09D1                ;-335       prs(LabelNamePtr); prc(' ');
09D1                
09D1                
09D1                ;-336       j=LabelAddr[i]; printhex16(j); prs(", ");
09D1                
09D1                
09D1                ;-337       j=strlen(LabelNamePtr);//get end of actual name
09D1                
09D1                
09D1                ;-338       LabelNamePtr=LabelNamePtr+j;
09D1                
09D1                
09D1                ;-339       LabelNamePtr++;
09D1                
09D1                
09D1                ;-340       i++;
09D1                
09D1                
09D1                ;-341     } while (i <= LabelMaxIx);
09D1                
09D1                
09D1                ;-342 */
09D1                
09D1                
09D1                ;-343 }
09D1                
09D1                
09D1                ;-344 
09D1                
09D1                
09D1                ;-345 int end1(int n) {
09D1 C9              LEAVE
09D2 C3              ret
09D3 5C 6E 20 45 72 epilog_0 db "\n Errors: ",0
09DF 20 2A 2A 2A 20 epilog_1 db " *** ERRORS *** ",0
09F0 2C 20 4F 75 74 epilog_2 db ", Out: ",0
09F8 2C 20 00       epilog_3 db ", ",0
09FB 3D 20 00       epilog_4 db "= ",0
09FE 20 62 79 74 65 epilog_5 db " bytes.",0
0A06 20 4C 61 62 65 epilog_6 db " Labels: ",0
leaving: epilog, loc labels: 10, loc jmp forward: 9
0A10                ENDP
0A10                
entering: end1
0A10                end1: PROC
0A10                
0A10                ;-346     fcloseR(asm_fd);
0A10                
0A10                ;Function : end1, Number of local variables: 1
0A10                ;   # type sign width addr used name   list of local variables
0A10                ;  200 var sign word   345 NULL n = bp+4;
0A10 C8 00 00 00     ENTER  0,0
0A14 FF 36 16 01     push word [asm_fd]
0A18 E8 BC F6        call fcloseR
0A1B 83 C4 02        add  sp, 2
0A1E                
0A1E                ;-347     fcloseR(lst_fd);
0A1E                
0A1E FF 36 18 01     push word [lst_fd]
0A22 E8 B2 F6        call fcloseR
0A25 83 C4 02        add  sp, 2
0A28                
0A28                ;-348     fcloseR(bin_fd);
0A28                
0A28 FF 36 1A 01     push word [bin_fd]
0A2C E8 A8 F6        call fcloseR
0A2F 83 C4 02        add  sp, 2
0A32                
0A32                ;-349     exitR(n);
0A32                
0A32 55              push word [bp+4]
0A33 E8 B0 F6        call exitR
0A36 83 C4 02        add  sp, 2
0A39                
0A39                ;-350 }
0A39                
0A39                
0A39                ;-351 
0A39                
0A39                
0A39                ;-352 
0A39                
0A39                
0A39                ;-353 int error1(char *s) {
0A39 C9              LEAVE
0A3A C3              ret
leaving: end1, loc labels: 0, loc jmp forward: 0
0A3B                ENDP
0A3B                
entering: error1
0A3B                error1: PROC
0A3B                
0A3B                ;-354     ErrorCount++;
0A3B                
0A3B                ;Function : error1, Number of local variables: 1
0A3B                ;   # type sign width addr used name   list of local variables
0A3B                ;  200 ptr sign byte   353 NULL s = bp+4;
0A3B C8 00 00 00     ENTER  0,0
0A3F FF 06 1E 01     inc  word[ErrorCount]
0A43                
0A43                ;-355     prs("\n******* next line ERROR: ");
0A43                
0A43 68 AA AA      A push error1_0
0A46 E8 E6 FC        call prs
0A49 83 C4 02        add  sp, 2
0A4C                
0A4C                ;-356     prs(s);
0A4C                
0A4C 55              push word [bp+4]
0A4D E8 DF FC        call prs
0A50 83 C4 02        add  sp, 2
0A53                
0A53                ;-357     prs(", Symbol: ");
0A53                
0A53 68 AA AA      A push error1_1
0A56 E8 D6 FC        call prs
0A59 83 C4 02        add  sp, 2
0A5C                
0A5C                ;-358     prs(Symbol);
0A5C                
0A5C 8D 06 30 75     lea  ax, [Symbol]
0A60 50              push ax
0A61 E8 CB FC        call prs
0A64 83 C4 02        add  sp, 2
0A67                
0A67                ;-359 }
0A67                
0A67                
0A67                ;-360 int errorexit(char *s) {
0A67 C9              LEAVE
0A68 C3              ret
0A69 5C 6E 2A 2A 2A error1_0 db "\n******* next line ERROR: ",0
0A85 2C 20 53 79 6D error1_1 db ", Symbol: ",0
leaving: error1, loc labels: 2, loc jmp forward: 2
0A90                ENDP
0A90                
entering: errorexit
0A90                errorexit: PROC
0A90                
0A90                ;-361     error1(s);
0A90                
0A90                ;Function : errorexit, Number of local variables: 1
0A90                ;   # type sign width addr used name   list of local variables
0A90                ;  200 ptr sign byte   360 NULL s = bp+4;
0A90 C8 00 00 00     ENTER  0,0
0A94 55              push word [bp+4]
0A95 E8 A3 FF        call error1
0A98 83 C4 02        add  sp, 2
0A9B                
0A9B                ;-362     epilog();
0A9B                
0A9B E8 84 FE        call epilog
0A9E                
0A9E                ;-363     end1(1);
0A9E                
0A9E 6A 01           push 1
0AA0 E8 6D FF        call end1
0AA3 83 C4 02        add  sp, 2
0AA6                
0AA6                ;-364 }
0AA6                
0AA6                
0AA6                ;-365 int notfounderror(){
0AA6 C9              LEAVE
0AA7 C3              ret
leaving: errorexit, loc labels: 0, loc jmp forward: 0
0AA8                ENDP
0AA8                
entering: notfounderror
0AA8                notfounderror: PROC
0AA8                
0AA8                ;-366     ErrorCount++;
0AA8                
0AA8 FF 06 1E 01     inc  word[ErrorCount]
0AAC                
0AAC                ;-367     prs("\n******* ERROR: label not found: ");
0AAC                
0AAC 68 AA AA      A push notfounderror_0
0AAF E8 7D FC        call prs
0AB2 83 C4 02        add  sp, 2
0AB5                
0AB5                ;-368     prs(Symbol);
0AB5                
0AB5 8D 06 30 75     lea  ax, [Symbol]
0AB9 50              push ax
0ABA E8 72 FC        call prs
0ABD 83 C4 02        add  sp, 2
0AC0                
0AC0                ;-369     prs(" ");
0AC0                
0AC0 68 AA AA      A push notfounderror_1
0AC3 E8 69 FC        call prs
0AC6 83 C4 02        add  sp, 2
0AC9                
0AC9                ;-370 }
0AC9                
0AC9                
0AC9                ;-371 int allowederror() {error1("not allowed here"); }
0AC9                
0AC9 C3              ret
0ACA 5C 6E 2A 2A 2A notfounderror_0 db "\n******* ERROR: label not found: ",0
0AED 20 00          notfounderror_1 db " ",0
leaving: notfounderror, loc labels: 2, loc jmp forward: 2
0AEF                ENDP
0AEF                
entering: allowederror
0AEF                allowederror: PROC
0AEF 68 AA AA      A push allowederror_0
0AF2 E8 46 FF        call error1
0AF5 83 C4 02        add  sp, 2
0AF8                
0AF8                ;-372 int addrerror()    {error1("address missing");}
0AF8                
0AF8 C3              ret
0AF9 6E 6F 74 20 61 allowederror_0 db "not allowed here",0
leaving: allowederror, loc labels: 1, loc jmp forward: 1
0B0A                ENDP
0B0A                
entering: addrerror
0B0A                addrerror: PROC
0B0A 68 AA AA      A push addrerror_0
0B0D E8 2B FF        call error1
0B10 83 C4 02        add  sp, 2
0B13                
0B13                ;-373 int immeerror()    {error1("immediate not allowed here");}
0B13                
0B13 C3              ret
0B14 61 64 64 72 65 addrerror_0 db "address missing",0
leaving: addrerror, loc labels: 1, loc jmp forward: 1
0B24                ENDP
0B24                
entering: immeerror
0B24                immeerror: PROC
0B24 68 AA AA      A push immeerror_0
0B27 E8 11 FF        call error1
0B2A 83 C4 02        add  sp, 2
0B2D                
0B2D                ;-374 int implerror()    {error1("not implemented");}
0B2D                
0B2D C3              ret
0B2E 69 6D 6D 65 64 immeerror_0 db "immediate not allowed here",0
leaving: immeerror, loc labels: 1, loc jmp forward: 1
0B49                ENDP
0B49                
entering: implerror
0B49                implerror: PROC
0B49 68 AA AA      A push implerror_0
0B4C E8 EC FE        call error1
0B4F 83 C4 02        add  sp, 2
0B52                
0B52                ;-375 int indexerror()   {error1("invalid index register");}
0B52                
0B52 C3              ret
0B53 6E 6F 74 20 69 implerror_0 db "not implemented",0
leaving: implerror, loc labels: 1, loc jmp forward: 1
0B63                ENDP
0B63                
entering: indexerror
0B63                indexerror: PROC
0B63 68 AA AA      A push indexerror_0
0B66 E8 D2 FE        call error1
0B69 83 C4 02        add  sp, 2
0B6C                
0B6C                ;-376 int invaloperror() {error1("invalid or no operands");}
0B6C                
0B6C C3              ret
0B6D 69 6E 76 61 6C indexerror_0 db "invalid index register",0
leaving: indexerror, loc labels: 1, loc jmp forward: 1
0B84                ENDP
0B84                
entering: invaloperror
0B84                invaloperror: PROC
0B84 68 AA AA      A push invaloperror_0
0B87 E8 B1 FE        call error1
0B8A 83 C4 02        add  sp, 2
0B8D                
0B8D                ;-377 int numbererror()  {error1("number expected");}
0B8D                
0B8D C3              ret
0B8E 69 6E 76 61 6C invaloperror_0 db "invalid or no operands",0
leaving: invaloperror, loc labels: 1, loc jmp forward: 1
0BA5                ENDP
0BA5                
entering: numbererror
0BA5                numbererror: PROC
0BA5 68 AA AA      A push numbererror_0
0BA8 E8 90 FE        call error1
0BAB 83 C4 02        add  sp, 2
0BAE                
0BAE                ;-378 int regmemerror()  {error1("only register or memory allowed");}
0BAE                
0BAE C3              ret
0BAF 6E 75 6D 62 65 numbererror_0 db "number expected",0
leaving: numbererror, loc labels: 1, loc jmp forward: 1
0BBF                ENDP
0BBF                
entering: regmemerror
0BBF                regmemerror: PROC
0BBF 68 AA AA      A push regmemerror_0
0BC2 E8 76 FE        call error1
0BC5 83 C4 02        add  sp, 2
0BC8                
0BC8                ;-379 int reg16error()   {error1("only reg16, no segreg allowed");}
0BC8                
0BC8 C3              ret
0BC9 6F 6E 6C 79 20 regmemerror_0 db "only register or memory allowed",0
leaving: regmemerror, loc labels: 1, loc jmp forward: 1
0BE9                ENDP
0BE9                
entering: reg16error
0BE9                reg16error: PROC
0BE9 68 AA AA      A push reg16error_0
0BEC E8 4C FE        call error1
0BEF 83 C4 02        add  sp, 2
0BF2                
0BF2                ;-380 int segregerror()  {error1("segment register not allowed");}
0BF2                
0BF2 C3              ret
0BF3 6F 6E 6C 79 20 reg16error_0 db "only reg16, no segreg allowed",0
leaving: reg16error, loc labels: 1, loc jmp forward: 1
0C11                ENDP
0C11                
entering: segregerror
0C11                segregerror: PROC
0C11 68 AA AA      A push segregerror_0
0C14 E8 24 FE        call error1
0C17 83 C4 02        add  sp, 2
0C1A                
0C1A                ;-381 int syntaxerror()  {error1("syntax");}
0C1A                
0C1A C3              ret
0C1B 73 65 67 6D 65 segregerror_0 db "segment register not allowed",0
leaving: segregerror, loc labels: 1, loc jmp forward: 1
0C38                ENDP
0C38                
entering: syntaxerror
0C38                syntaxerror: PROC
0C38 68 AA AA      A push syntaxerror_0
0C3B E8 FD FD        call error1
0C3E 83 C4 02        add  sp, 2
0C41                
0C41                ;-382 
0C41                
0C41                
0C41                ;-383 int addrexit()     {errorexit("illegal address");}
0C41                
0C41 C3              ret
0C42 73 79 6E 74 61 syntaxerror_0 db "syntax",0
leaving: syntaxerror, loc labels: 1, loc jmp forward: 1
0C49                ENDP
0C49                
entering: addrexit
0C49                addrexit: PROC
0C49 68 AA AA      A push addrexit_0
0C4C E8 41 FE        call errorexit
0C4F 83 C4 02        add  sp, 2
0C52                
0C52                ;-384 int dataexit()     {errorexit("DB,DW,DD or RESB,W,D expected");}
0C52                
0C52 C3              ret
0C53 69 6C 6C 65 67 addrexit_0 db "illegal address",0
leaving: addrexit, loc labels: 1, loc jmp forward: 1
0C63                ENDP
0C63                
entering: dataexit
0C63                dataexit: PROC
0C63 68 AA AA      A push dataexit_0
0C66 E8 27 FE        call errorexit
0C69 83 C4 02        add  sp, 2
0C6C                
0C6C                ;-385 int internexit()   {errorexit("intern compiler error");}
0C6C                
0C6C C3              ret
0C6D 44 42 2C 44 57 dataexit_0 db "DB,DW,DD or RESB,W,D expected",0
leaving: dataexit, loc labels: 1, loc jmp forward: 1
0C8B                ENDP
0C8B                
entering: internexit
0C8B                internexit: PROC
0C8B 68 AA AA      A push internexit_0
0C8E E8 FF FD        call errorexit
0C91 83 C4 02        add  sp, 2
0C94                
0C94                ;-386 
0C94                
0C94                
0C94                ;-387 int ifEOL(char c) {//unix LF, win CRLF= 13/10, mac CR
0C94                
0C94 C3              ret
0C95 69 6E 74 65 72 internexit_0 db "intern compiler error",0
leaving: internexit, loc labels: 1, loc jmp forward: 1
0CAB                ENDP
0CAB                
entering: ifEOL
0CAB                ifEOL: PROC
0CAB                
0CAB                ;-388   if (c == 10) return 1;//LF
0CAB                
0CAB                ;Function : ifEOL, Number of local variables: 1
0CAB                ;   # type sign width addr used name   list of local variables
0CAB                ;  200 var sign byte   387 NULL c = bp+4;
0CAB C8 00 00 00     ENTER  0,0
0CAF 8A 46 04        mov al, [bp+4]
0CB2 3C 0A           cmp al, 10
0CB4 0F 85 00 00   r jne .ifEOL85
0CB8 B8 01 00        mov ax, 1
0CBB E9 00 00      R jmp .retnifEOL
0CBE                
0CBE                ;-389   if (c == 13) {//CR
0CBE                
0CBE                .ifEOL85:
0CBE 8A 46 04        mov al, [bp+4]
0CC1 3C 0D           cmp al, 13
0CC3 0F 85 00 00   r jne .ifEOL86
0CC7                
0CC7                ;-390     DOS_NoBytes=readRL(&DOS_ByteRead, asm_fd, 1);
0CC7                
0CC7 6A 01           push 1
0CC9 FF 36 16 01     push word [asm_fd]
0CCD 8D 06 22 01     lea  ax, [DOS_ByteRead]
0CD1 50              push ax
0CD2 E8 1F F4        call readRL
0CD5 83 C4 06        add  sp, 6
0CD8 A3 20 01        mov word [DOS_NoBytes], ax
0CDB                
0CDB                ;-391     if (DOS_ByteRead != 10) errorexit("missing LF(10) after CR(13)");
0CDB                
0CDB A0 22 01        mov al, [DOS_ByteRead]
0CDE 3C 0A           cmp al, 10
0CE0 0F 84 00 00   r je  .ifEOL87
0CE4 68 AA AA      A push ifEOL_0
0CE7 E8 A6 FD        call errorexit
0CEA 83 C4 02        add  sp, 2
0CED                
0CED                ;-392     return 1;
0CED                
0CED                .ifEOL87:
0CED B8 01 00        mov ax, 1
0CF0 E9 00 00      R jmp .retnifEOL
0CF3                
0CF3                ;-393   }
0CF3                
0CF3                
0CF3                ;-394   return 0;
0CF3                
0CF3                .ifEOL86:
0CF3 B8 00 00        mov ax, 0
0CF6 E9 00 00      R jmp .retnifEOL
0CF9                
0CF9                ;-395 }
0CF9                
0CF9                
0CF9                ;-396 int getLine() {// make ASCIIZ, skip LF=10 and CR=13
0CF9                
0CF9 C9              .retnifEOL: LEAVE
0CFA C3              ret
0CFB 6D 69 73 73 69 ifEOL_0 db "missing LF(10) after CR(13)",0
leaving: ifEOL, loc labels: 5, loc jmp forward: 7
0D17                ENDP
0D17                
entering: getLine
0D17                getLine: PROC
0D17                
0D17                ;-397   unsigned int i;
0D17                
0D17                
0D17                ;-398   InputPtr= &InputBuf;
0D17                
0D17                ;Function : getLine, Number of local variables: 1
0D17                ;   # type sign width addr used name   list of local variables
0D17                ;  200 var unsg word   397 NULL i = bp-2;
0D17 C8 02 00 00     ENTER  2,0
0D1B B8 8D 75        mov ax, InputBuf
0D1E A3 14 01        mov word [InputPtr], ax
0D21                
0D21                ;-399   *InputPtr=0;//if last line is empty
0D21                
0D21 B8 00 00        mov ax, 0
0D24 8B 1E 14 01     mov  bx, [InputPtr]
0D28 88 07           mov  [bx], al
0D2A                
0D2A                ;-400   do {
0D2A                
0D2A                .getLine88:
0D2A                
0D2A                ;-401     DOS_NoBytes=readRL(&DOS_ByteRead, asm_fd, 1);
0D2A                
0D2A 6A 01           push 1
0D2C FF 36 16 01     push word [asm_fd]
0D30 8D 06 22 01     lea  ax, [DOS_ByteRead]
0D34 50              push ax
0D35 E8 BC F3        call readRL
0D38 83 C4 06        add  sp, 6
0D3B A3 20 01        mov word [DOS_NoBytes], ax
0D3E                
0D3E                ;-402     if (DOS_ERR) errorexit("Reading Source");
0D3E                
0D3E A1 1C 01        mov ax, [DOS_ERR]
0D41 08 C0           or  al, al
0D43 0F 84 00 00   r je .getLine89
0D47 68 AA AA      A push getLine_0
0D4A E8 43 FD        call errorexit
0D4D 83 C4 02        add  sp, 2
0D50                
0D50                ;-403     if (DOS_NoBytes == 0) return;
0D50                
0D50                .getLine89:
0D50 A1 20 01        mov ax, [DOS_NoBytes]
0D53 83 F8 00        cmp ax, 0
0D56 0F 85 00 00   r jne .getLine90
0D5A E9 00 00      R jmp .retngetLine
0D5D                
0D5D                ;-404     *InputPtr = DOS_ByteRead;
0D5D                
0D5D                .getLine90:
0D5D A0 22 01        mov al, [DOS_ByteRead]
0D60 8B 1E 14 01     mov  bx, [InputPtr]
0D64 88 07           mov  [bx], al
0D66                
0D66                ;-405     InputPtr++;
0D66                
0D66 FF 06 14 01     inc  word[InputPtr]
0D6A                
0D6A                ;-406     i = InputPtr - &InputBuf;
0D6A                
0D6A A1 14 01        mov ax, [InputPtr]
******* next line ERROR: invalid or no operands, Symbol: InputBuf
******* next line ERROR: syntax, Symbol: InputBuf
0D6D                 sub ax, InputBuf
0D6D 89 46 FE        mov [bp-2], ax
0D70                
0D70                ;-407     if (i >= INPUTBUFMAX) errorexit("input line too long");
0D70                
0D70 8B 46 FE        mov ax, [bp-2]
0D73 3D FF 00        cmp ax, 255 ;unsigned : 0
0D76 0F 82 00 00   r jb  .getLine91
0D7A 68 AA AA      A push getLine_1
0D7D E8 10 FD        call errorexit
0D80 83 C4 02        add  sp, 2
0D83                
0D83                ;-408   } while (ifEOL(DOS_ByteRead) == 0);
0D83                
0D83                .getLine91:
0D83 A0 22 01        mov al, byte [DOS_ByteRead]
0D86 B4 00           mov ah, 0
0D88 50              push ax
0D89 E8 1F FF        call ifEOL
0D8C 83 C4 02        add  sp, 2
0D8F 3C 00           cmp al, 0
0D91 0F 85 00 00   r jne .getLine92
0D95 EB 93           jmp .getLine88
0D97                .getLine92:
0D97                
0D97                ;-409   InputPtr--;
0D97                
0D97 FF 0E 14 01     dec  word[InputPtr]
0D9B                
0D9B                ;-410   *InputPtr=0;
0D9B                
0D9B B8 00 00        mov ax, 0
0D9E 8B 1E 14 01     mov  bx, [InputPtr]
0DA2 88 07           mov  [bx], al
0DA4                
0DA4                ;-411 }
0DA4                
0DA4                
0DA4                ;-412 int skipBlank() {
0DA4                
0DA4 C9              .retngetLine: LEAVE
0DA5 C3              ret
0DA6 52 65 61 64 69 getLine_0 db "Reading Source",0
0DB5 69 6E 70 75 74 getLine_1 db "input line too long",0
leaving: getLine, loc labels: 8, loc jmp forward: 7
0DC9                ENDP
0DC9                
entering: skipBlank
0DC9                skipBlank: PROC
0DC9                
0DC9                ;-413   skipblank1:
0DC9                
0DC9                .skipblank1:
0DC9                
0DC9                ;-414     if (*InputPtr == ' ') { InputPtr++; goto skipblank1; }
0DC9                
0DC9 8B 1E 14 01     mov bx, [InputPtr]
0DCD 8A 07           mov al, [bx]
0DCF B4 00           mov ah, 0
0DD1 83 F8 20        cmp ax, 32
0DD4 0F 85 00 00   r jne .skipBlank93
0DD8 FF 06 14 01     inc  word[InputPtr]
0DDC EB EB           jmp .skipblank1
0DDE                
0DDE                ;-415     if (*InputPtr == 9  ) { InputPtr++; goto skipblank1; }
0DDE                
0DDE                .skipBlank93:
0DDE 8B 1E 14 01     mov bx, [InputPtr]
0DE2 8A 07           mov al, [bx]
0DE4 B4 00           mov ah, 0
0DE6 83 F8 09        cmp ax, 9
0DE9 0F 85 00 00   r jne .skipBlank94
0DED FF 06 14 01     inc  word[InputPtr]
0DF1 EB D6           jmp .skipblank1
0DF3                
0DF3                ;-416 }
0DF3                
0DF3                .skipBlank94:
0DF3                
0DF3                ;-417 
0DF3                
0DF3                
0DF3                ;-418 int getDigit(unsigned char c) {//ret: SymbolInt
0DF3                
0DF3 C3              ret
leaving: skipBlank, loc labels: 3, loc jmp forward: 2
0DF4                ENDP
0DF4                
entering: getDigit
0DF4                getDigit: PROC
0DF4                
0DF4                ;-419   unsigned int CastInt;
0DF4                
0DF4                
0DF4                ;-420   SymbolInt=0;
0DF4                
0DF4                ;Function : getDigit, Number of local variables: 2
0DF4                ;   # type sign width addr used name   list of local variables
0DF4                ;  200 var unsg byte   418 NULL c = bp+4
0DF4                ;  201 var unsg word   419 NULL CastInt = bp-2;
0DF4 C8 02 00 00     ENTER  2,0
0DF8 B8 00 00        mov ax, 0
0DFB A3 0E 01        mov word [SymbolInt], ax
0DFE                
0DFE                ;-421   do {
0DFE                
0DFE                .getDigit95:
0DFE                
0DFE                ;-422     c-='0';
0DFE                
0DFE 80 6E 04 30     sub  byte[bp+4], 48
0E02                
0E02                ;-423     SymbolInt=SymbolInt*10;
0E02                
0E02 A1 0E 01        mov ax, [SymbolInt]
0E05 BB 0A 00        mov bx, 10
0E08 F7 E3           mul bx
0E0A A3 0E 01        mov word [SymbolInt], ax
0E0D                
0E0D                ;-424     ax=0; CastInt=c; //cast b2w
0E0D                
0E0D B8 00 00        mov  ax, 0
0E10 8A 46 04        mov al, [bp+4]
0E13 89 46 FE        mov [bp-2], ax
0E16                
0E16                ;-425     SymbolInt=SymbolInt+CastInt;
0E16                
0E16 A1 0E 01        mov ax, [SymbolInt]
0E19 03 46 FE        add ax, [bp-2]
0E1C A3 0E 01        mov word [SymbolInt], ax
0E1F                
0E1F                ;-426     InputPtr++;
0E1F                
0E1F FF 06 14 01     inc  word[InputPtr]
0E23                
0E23                ;-427     c = *InputPtr;
0E23                
0E23 8B 1E 14 01     mov bx, [InputPtr]
0E27 8A 07           mov al, [bx]
0E29 B4 00           mov ah, 0
0E2B 88 46 04        mov [bp+4], al
0E2E                
0E2E                ;-428   } while(digit(c));
0E2E                
0E2E 8A 46 04        mov al, byte [bp+4]
0E31 B4 00           mov ah, 0
0E33 50              push ax
0E34 E8 65 F3        call digit
0E37 83 C4 02        add  sp, 2
0E3A 08 C0           or  al, al
0E3C 0F 84 00 00   r je .getDigit96
0E40 EB BC           jmp .getDigit95
0E42                .getDigit96:
0E42                
0E42                ;-429 }
0E42                
0E42                
0E42                ;-430 int getName(unsigned char c) {//ret: Symbol, SymbolUpper, isLabel
0E42 C9              LEAVE
0E43 C3              ret
leaving: getDigit, loc labels: 2, loc jmp forward: 1
0E44                ENDP
0E44                
entering: getName
0E44                getName: PROC
0E44                
0E44                ;-431   char *p; unsigned int i;
0E44                
0E44                
0E44                ;-432   p = &Symbol;
0E44                
0E44                ;Function : getName, Number of local variables: 3
0E44                ;   # type sign width addr used name   list of local variables
0E44                ;  200 var unsg byte   430 NULL c = bp+4
0E44                ;  201 ptr sign byte   431 NULL p = bp-2
0E44                ;  202 var unsg word   431 NULL i = bp-4;
0E44 C8 04 00 00     ENTER  4,0
0E48 B8 30 75        mov ax, Symbol
0E4B 89 46 FE        mov [bp-2], ax
0E4E                
0E4E                ;-433   *p = c;
0E4E                
0E4E 8A 46 04        mov al, [bp+4]
0E51 8B 5E FE        mov  bx, [bp-2]
0E54 88 07           mov  [bx], al
0E56                
0E56                ;-434   p++;
0E56                
0E56 FF 46 FE        inc  word[bp-2]
0E59                
0E59                ;-435   while (alnumE(c)) {
0E59                
0E59                .getName97:
0E59 8A 46 04        mov al, byte [bp+4]
0E5C B4 00           mov ah, 0
0E5E 50              push ax
0E5F E8 64 F3        call alnumE
0E62 83 C4 02        add  sp, 2
0E65 08 C0           or  al, al
0E67 0F 84 00 00   r je .getName98
0E6B                
0E6B                ;-436     InputPtr++;
0E6B                
0E6B FF 06 14 01     inc  word[InputPtr]
0E6F                
0E6F                ;-437     c = *InputPtr;
0E6F                
0E6F 8B 1E 14 01     mov bx, [InputPtr]
0E73 8A 07           mov al, [bx]
0E75 B4 00           mov ah, 0
0E77 88 46 04        mov [bp+4], al
0E7A                
0E7A                ;-438     *p = c;
0E7A                
0E7A 8A 46 04        mov al, [bp+4]
0E7D 8B 5E FE        mov  bx, [bp-2]
0E80 88 07           mov  [bx], al
0E82                
0E82                ;-439     p++;
0E82                
0E82 FF 46 FE        inc  word[bp-2]
0E85                
0E85                ;-440     i = p - &Symbol;
0E85                
0E85 8B 46 FE        mov ax, [bp-2]
******* next line ERROR: invalid or no operands, Symbol: Symbol
******* next line ERROR: syntax, Symbol: Symbol
0E88                 sub ax, Symbol
0E88 89 46 FC        mov [bp-4], ax
0E8B                
0E8B                ;-441     if (i >= SYMBOLMAX) errorexit("symbol too long");
0E8B                
0E8B 8B 46 FC        mov ax, [bp-4]
0E8E 83 F8 1F        cmp ax, 31 ;unsigned : 0
0E91 0F 82 00 00   r jb  .getName99
0E95 68 AA AA      A push getName_0
0E98 E8 F5 FB        call errorexit
0E9B 83 C4 02        add  sp, 2
0E9E                
0E9E                ;-442   }
0E9E                
0E9E                .getName99:
0E9E                
0E9E                ;-443   if (c == ':') isLabel=1; else isLabel=0;
0E9E                
0E9E EB B9           jmp .getName97
0EA0                .getName98:
0EA0 8A 46 04        mov al, [bp+4]
0EA3 3C 3A           cmp al, 58
0EA5 0F 85 00 00   r jne .getName100
0EA9 B8 01 00        mov ax, 1
0EAC A2 2B 01        mov byte [isLabel], al
0EAF E9 00 00      R jmp .getName101
0EB2                .getName100:
0EB2 B8 00 00        mov ax, 0
0EB5 A2 2B 01        mov byte [isLabel], al
0EB8                
0EB8                ;-444   p--;
0EB8                
0EB8                .getName101:
0EB8 FF 4E FE        dec  word[bp-2]
0EBB                
0EBB                ;-445   *p = 0;
0EBB                
0EBB B8 00 00        mov ax, 0
0EBE 8B 5E FE        mov  bx, [bp-2]
0EC1 88 07           mov  [bx], al
0EC3                
0EC3                ;-446   strcpy(SymbolUpper, Symbol);
0EC3                
0EC3 8D 06 30 75     lea  ax, [Symbol]
0EC7 50              push ax
0EC8 8D 06 4F 75     lea  ax, [SymbolUpper]
0ECC 50              push ax
0ECD E8 5A F3        call strcpy
0ED0 83 C4 04        add  sp, 4
0ED3                
0ED3                ;-447   toupper(SymbolUpper);
0ED3                
0ED3 8D 06 4F 75     lea  ax, [SymbolUpper]
0ED7 50              push ax
0ED8 E8 F2 F3        call toupper
0EDB 83 C4 02        add  sp, 2
0EDE                
0EDE                ;-448 }
0EDE                
0EDE                
0EDE                ;-449 
0EDE                
0EDE                
0EDE                ;-450 //#include "OPTABL.C"
0EDE                
0EDE                
0EDE                ;-451 char I_START=0xF1;
0EDE C9              LEAVE
0EDF C3              ret
0EE0 73 79 6D 62 6F getName_0 db "symbol too long",0
leaving: getName, loc labels: 6, loc jmp forward: 5
0EF0                ENDP
0EF0 F1             I_START db 241
0EF1                
0EF1                ;-452 //OpName, 0, CodeType, OpCode1-n, F1h
0EF1                
0EF1                
0EF1                ;-453 //  1:   1 byte opcode
0EF1                
0EF1                
0EF1                ;-454 char I_PUSHA[]={'P','U','S','H','A',0,1,0x60,0xF1, 'P','O','P','A',0,    1,0x61,0xF1};
0EF1                
0EF1 50 55 53 48 41 I_PUSHA db 80,85,83,72,65,0,1,96,241,80,79,80,65,0,1,97,241
0F02                
0F02                ;-455 char I_NOP[]=  {'N','O','P',0,        1,0x90,0xF1, 'C','B','W',0,        1,0x98,0xF1};
0F02                
0F02 4E 4F 50 00 01 I_NOP db 78,79,80,0,1,144,241,67,66,87,0,1,152,241
0F10                
0F10                ;-456 char I_CWDE[]= {'C','W','D','E',0,    1,0x98,0xF1, 'C','W','D',0,        1,0x99,0xF1};
0F10                
0F10 43 57 44 45 00 I_CWDE db 67,87,68,69,0,1,152,241,67,87,68,0,1,153,241
0F1F                
0F1F                ;-457 char I_CDQ[]=  {'C','D','Q',0,        1,0x99,0xF1, 'W','A','I','T',0,    1,0x9B,0xF1};
0F1F                
0F1F 43 44 51 00 01 I_CDQ db 67,68,81,0,1,153,241,87,65,73,84,0,1,155,241
0F2E                
0F2E                ;-458 char I_PUSHF[]={'P','U','S','H','F',0,1,0x9C,0xF1, 'P','O','P','F',0,    1,0x9D,0xF1};
0F2E                
0F2E 50 55 53 48 46 I_PUSHF db 80,85,83,72,70,0,1,156,241,80,79,80,70,0,1,157,241
0F3F                
0F3F                ;-459 char I_SAHF[]= {'S','A','H','F',0,    1,0x9E,0xF1, 'L','A','H','F',0,    1,0x9F,0xF1};
0F3F                
0F3F 53 41 48 46 00 I_SAHF db 83,65,72,70,0,1,158,241,76,65,72,70,0,1,159,241
0F4F                
0F4F                ;-460 char I_MOVSB[]={'M','O','V','S','B',0,1,0xA4,0xF1, 'M','O','V','S','W',0,1,0xA5,0xF1};
0F4F                
0F4F 4D 4F 56 53 42 I_MOVSB db 77,79,86,83,66,0,1,164,241,77,79,86,83,87,0,1,165,241
0F61                
0F61                ;-461 char I_CMPSB[]={'C','M','P','S','B',0,1,0xA6,0xF1, 'C','M','P','S','W',0,1,0xA7,0xF1};
0F61                
0F61 43 4D 50 53 42 I_CMPSB db 67,77,80,83,66,0,1,166,241,67,77,80,83,87,0,1,167,241
0F73                
0F73                ;-462 char I_STOSB[]={'S','T','O','S','B',0,1,0xAA,0xF1, 'S','T','O','S','W',0,1,0xAB,0xF1};
0F73                
0F73 53 54 4F 53 42 I_STOSB db 83,84,79,83,66,0,1,170,241,83,84,79,83,87,0,1,171,241
0F85                
0F85                ;-463 char I_LODSB[]={'L','O','D','S','B',0,1,0xAC,0xF1, 'L','O','D','S','W',0,1,0xAD,0xF1};
0F85                
0F85 4C 4F 44 53 42 I_LODSB db 76,79,68,83,66,0,1,172,241,76,79,68,83,87,0,1,173,241
0F97                
0F97                ;-464 char I_SCASB[]={'S','C','A','S','B',0,1,0xAE,0xF1, 'S','C','A','S','W',0,1,0xAF,0xF1};
0F97                
0F97 53 43 41 53 42 I_SCASB db 83,67,65,83,66,0,1,174,241,83,67,65,83,87,0,1,175,241
0FA9                
0FA9                ;-465 char I_LEAVE[]={'L','E','A','V','E',0,1,0xC9,0xF1, 'I','N','T','3',0,    1,0xCC,0xF1};
0FA9                
0FA9 4C 45 41 56 45 I_LEAVE db 76,69,65,86,69,0,1,201,241,73,78,84,51,0,1,204,241
0FBA                
0FBA                ;-466 char I_INTO[]= {'I','N','T','O',0,    1,0xCE,0xF1, 'I','R','E','T',0,    1,0xCF,0xF1};
0FBA                
0FBA 49 4E 54 4F 00 I_INTO db 73,78,84,79,0,1,206,241,73,82,69,84,0,1,207,241
0FCA                
0FCA                ;-467 char I_XLAT[]= {'X','L','A','T',0,    1,0xD7,0xF1, 'L','O','C','K',0,    1,0xF0,0xF1};
0FCA                
0FCA 58 4C 41 54 00 I_XLAT db 88,76,65,84,0,1,215,241,76,79,67,75,0,1,240,241
0FDA                
0FDA                ;-468 char I_REPNE[]={'R','E','P','N','E',0,1,0xF2,0xF1, 'R','E','P','N','Z',0,1,0xF2,0xF1};
0FDA                
0FDA 52 45 50 4E 45 I_REPNE db 82,69,80,78,69,0,1,242,241,82,69,80,78,90,0,1,242,241
0FEC                
0FEC                ;-469 char I_REPE[]= {'R','E','P','E',0,    1,0xF3,0xF1, 'R','E','P','Z',0,    1,0xF3,0xF1};
0FEC                
0FEC 52 45 50 45 00 I_REPE db 82,69,80,69,0,1,243,241,82,69,80,90,0,1,243,241
0FFC                
0FFC                ;-470 char I_HLT[]=  {'H','L','T',0,        1,0xF4,0xF1, 'C','L','C',0,        1,0xF8,0xF1};
0FFC                
0FFC 48 4C 54 00 01 I_HLT db 72,76,84,0,1,244,241,67,76,67,0,1,248,241
100A                
100A                ;-471 char I_STC[]=  {'S','T','C',0,        1,0xF9,0xF1, 'C','L','I',0,        1,0xFA,0xF1};
100A                
100A 53 54 43 00 01 I_STC db 83,84,67,0,1,249,241,67,76,73,0,1,250,241
1018                
1018                ;-472 char I_STI[]=  {'S','T','I',0,        1,0xFB,0xF1, 'C','L','D',0,        1,0xFC,0xF1};
1018                
1018 53 54 49 00 01 I_STI db 83,84,73,0,1,251,241,67,76,68,0,1,252,241
1026                
1026                ;-473 char I_STD[]=  {'S','T','D',0,        1,0xFD,0xF1};
1026                
1026 53 54 44 00 01 I_STD db 83,84,68,0,1,253,241
102D                
102D                ;-474 // 2: mem reg 16 bit
102D                
102D                
102D                ;-475 char I_INC[]=  {'I','N','C',0,          2,0xFE, 0,0x40,0xF1};
102D                
102D 49 4E 43 00 02 I_INC db 73,78,67,0,2,254,0,64,241
1036                
1036                ;-476 char I_DEC[]=  {'D','E','C',0,          2,0xFE, 1,0x48,0xF1};
1036                
1036 44 45 43 00 02 I_DEC db 68,69,67,0,2,254,1,72,241
103F                
103F                ;-477 char I_NOT[]=  {'N','O','T',0,          2,0xF6, 2,     0xF1};
103F                
103F 4E 4F 54 00 02 I_NOT db 78,79,84,0,2,246,2,241
1047                
1047                ;-478 char I_NEG[]=  {'N','E','G',0,          2,0xF6, 3,     0xF1};
1047                
1047 4E 45 47 00 02 I_NEG db 78,69,71,0,2,246,3,241
104F                
104F                ;-479 char I_MUL[]=  {'M','U','L',0,          2,0xF6, 4,     0xF1};
104F                
104F 4D 55 4C 00 02 I_MUL db 77,85,76,0,2,246,4,241
1057                
1057                ;-480 char I_IMUL[]= {'I','M','U','L',0,      2,0xF6, 5,     0xF1};//only acc
1057                
1057 49 4D 55 4C 00 I_IMUL db 73,77,85,76,0,2,246,5,241
1060                
1060                ;-481 char I_DIV[]=  {'D','I','V',0,          2,0xF6, 6,     0xF1};
1060                
1060 44 49 56 00 02 I_DIV db 68,73,86,0,2,246,6,241
1068                
1068                ;-482 char I_IDIV[]= {'I','D','I','V',0,      2,0xF6, 7,     0xF1};
1068                
1068 49 44 49 56 00 I_IDIV db 73,68,73,86,0,2,246,7,241
1071                
1071                ;-483 //  3: les, lda, lea, lss, lfs, lgs
1071                
1071                
1071                ;-484 char I_LES[]=  {'L','E','S',0,          3,0xC4,     0xF1};
1071                
1071 4C 45 53 00 03 I_LES db 76,69,83,0,3,196,241
1078                
1078                ;-485 char I_LDS[]=  {'L','D','S',0,          3,0xC5,     0xF1};
1078                
1078 4C 44 53 00 03 I_LDS db 76,68,83,0,3,197,241
107F                
107F                ;-486 char I_LEA[]=  {'L','E','A',0,          3,0x8D,     0xF1};//r, m16
107F                
107F 4C 45 41 00 03 I_LEA db 76,69,65,0,3,141,241
1086                
1086                ;-487 char I_LSS[]=  {'L','S','S',0,          3,0x0F,0xB2,0xF1};
1086                
1086 4C 53 53 00 03 I_LSS db 76,83,83,0,3,15,178,241
108E                
108E                ;-488 char I_LFS[]=  {'L','F','S',0,          3,0x0F,0xB4,0xF1};
108E                
108E 4C 46 53 00 03 I_LFS db 76,70,83,0,3,15,180,241
1096                
1096                ;-489 char I_LGS[]=  {'L','G','S',0,          3,0x0F,0xB5,0xF1};
1096                
1096 4C 47 53 00 03 I_LGS db 76,71,83,0,3,15,181,241
109E                
109E                ;-490 //  4: acc,imm  reg,imm  index,reg
109E                
109E                
109E                ;-491 char I_ADD[]=  {'A','D','D',0,          4, 0,     0xF1};
109E                
109E 41 44 44 00 04 I_ADD db 65,68,68,0,4,0,241
10A5                
10A5                ;-492 char I_OR []=  {'O','R',0,              4, 1,     0xF1};
10A5                
10A5 4F 52 00 04 01 I_OR db 79,82,0,4,1,241
10AB                
10AB                ;-493 char I_ADC[]=  {'A','D','C',0,          4, 2,     0xF1};
10AB                
10AB 41 44 43 00 04 I_ADC db 65,68,67,0,4,2,241
10B2                
10B2                ;-494 char I_SBB[]=  {'S','B','B',0,          4, 3,     0xF1};
10B2                
10B2 53 42 42 00 04 I_SBB db 83,66,66,0,4,3,241
10B9                
10B9                ;-495 char I_AND[]=  {'A','N','D',0,          4, 4,     0xF1};
10B9                
10B9 41 4E 44 00 04 I_AND db 65,78,68,0,4,4,241
10C0                
10C0                ;-496 char I_SUB[]=  {'S','U','B',0,          4, 5,     0xF1};
10C0                
10C0 53 55 42 00 04 I_SUB db 83,85,66,0,4,5,241
10C7                
10C7                ;-497 char I_XOR[]=  {'X','O','R',0,          4, 6,     0xF1};
10C7                
10C7 58 4F 52 00 04 I_XOR db 88,79,82,0,4,6,241
10CE                
10CE                ;-498 char I_CMP[]=  {'C','M','P',0,          4, 7,     0xF1};
10CE                
10CE 43 4D 50 00 04 I_CMP db 67,77,80,0,4,7,241
10D5                
10D5                ;-499 char I_TEST[]= {'T','E','S','T',0,     41,0xA8,0x84,0xF6,0,0xF1};
10D5                
10D5 54 45 53 54 00 I_TEST db 84,69,83,84,0,41,168,132,246,0,241
10E0                
10E0                ;-500 //  5: mov
10E0                
10E0                
10E0                ;-501 char I_MOV[]=  {'M','O','V',0,          5,        0xF1};
10E0                
10E0 4D 4F 56 00 05 I_MOV db 77,79,86,0,5,241
10E6                
10E6                ;-502 char I_MOVSX[]={'M','O','V','S','X',0, 51,0xBE,   0xF1};
10E6                
10E6 4D 4F 56 53 58 I_MOVSX db 77,79,86,83,88,0,51,190,241
10EF                
10EF                ;-503 char I_MOVZX[]={'M','O','V','Z','X',0, 51,0xB6,   0xF1};
10EF                
10EF 4D 4F 56 5A 58 I_MOVZX db 77,79,86,90,88,0,51,182,241
10F8                
10F8                ;-504 //  6: single byte relative jump
10F8                
10F8                
10F8                ;-505 char I_JO []=  {'J','O',0,     6, 0,0xF1};
10F8                
10F8 4A 4F 00 06 00 I_JO db 74,79,0,6,0,241
10FE                
10FE                ;-506 char I_JNO[]=  {'J','N','O',0, 6, 1,0xF1};
10FE                
10FE 4A 4E 4F 00 06 I_JNO db 74,78,79,0,6,1,241
1105                
1105                ;-507 char I_JB []=  {'J','B',0,     6, 2,0xF1, 'J','C',0,     6, 2,0xF1};
1105                
1105 4A 42 00 06 02 I_JB db 74,66,0,6,2,241,74,67,0,6,2,241
1111                
1111                ;-508 char I_JNB[]=  {'J','N','B',0, 6, 3,0xF1};
1111                
1111 4A 4E 42 00 06 I_JNB db 74,78,66,0,6,3,241
1118                
1118                ;-509 char I_JAE[]=  {'J','A','E',0, 6, 3,0xF1, 'J','N','C',0, 6, 3,0xF1};
1118                
1118 4A 41 45 00 06 I_JAE db 74,65,69,0,6,3,241,74,78,67,0,6,3,241
1126                
1126                ;-510 char I_JE []=  {'J','E',0,     6, 4,0xF1, 'J','Z',0,     6, 4,0xF1};
1126                
1126 4A 45 00 06 04 I_JE db 74,69,0,6,4,241,74,90,0,6,4,241
1132                
1132                ;-511 char I_JNE[]=  {'J','N','E',0, 6, 5,0xF1, 'J','N','Z',0, 6, 5,0xF1};
1132                
1132 4A 4E 45 00 06 I_JNE db 74,78,69,0,6,5,241,74,78,90,0,6,5,241
1140                
1140                ;-512 char I_JBE[]=  {'J','B','E',0, 6, 6,0xF1, 'J','N','A',0, 6, 6,0xF1};
1140                
1140 4A 42 45 00 06 I_JBE db 74,66,69,0,6,6,241,74,78,65,0,6,6,241
114E                
114E                ;-513 char I_JA []=  {'J','A',0,     6, 7,0xF1};
114E                
114E 4A 41 00 06 07 I_JA db 74,65,0,6,7,241
1154                
1154                ;-514 char I_JS []=  {'J','S',0,     6, 8,0xF1};
1154                
1154 4A 53 00 06 08 I_JS db 74,83,0,6,8,241
115A                
115A                ;-515 char I_JNS[]=  {'J','N','S',0, 6, 9,0xF1};
115A                
115A 4A 4E 53 00 06 I_JNS db 74,78,83,0,6,9,241
1161                
1161                ;-516 char I_JP []=  {'J','P',0,     6,10,0xF1, 'J','P','E',0, 6,10,0xF1};
1161                
1161 4A 50 00 06 0A I_JP db 74,80,0,6,10,241,74,80,69,0,6,10,241
116E                
116E                ;-517 char I_JNP[]=  {'J','N','P',0, 6,11,0xF1, 'J','P','O',0, 6,11,0xF1};
116E                
116E 4A 4E 50 00 06 I_JNP db 74,78,80,0,6,11,241,74,80,79,0,6,11,241
117C                
117C                ;-518 char I_JL []=  {'J','L',0,     6,12,0xF1};
117C                
117C 4A 4C 00 06 0C I_JL db 74,76,0,6,12,241
1182                
1182                ;-519 char I_JNL[]=  {'J','N','L',0, 6,13,0xF1, 'J','G','E',0, 6,13,0xF1};
1182                
1182 4A 4E 4C 00 06 I_JNL db 74,78,76,0,6,13,241,74,71,69,0,6,13,241
1190                
1190                ;-520 char I_JLE[]=  {'J','L','E',0, 6,14,0xF1, 'J','N','G',0, 6,14,0xF1};
1190                
1190 4A 4C 45 00 06 I_JLE db 74,76,69,0,6,14,241,74,78,71,0,6,14,241
119E                
119E                ;-521 char I_JG []=  {'J','G',0,     6,15,0xF1};
119E                
119E 4A 47 00 06 0F I_JG db 74,71,0,6,15,241
11A4                
11A4                ;-522 //  7: jmp, call
11A4                
11A4                
11A4                ;-523 char I_JMP[]=  {'J','M','P',0,          7,0xE9, 4,0xF1};
11A4                
11A4 4A 4D 50 00 07 I_JMP db 74,77,80,0,7,233,4,241
11AC                
11AC                ;-524 char I_CALL[]= {'C','A','L','L',0,      7,0xE8, 2,0xF1};
11AC                
11AC 43 41 4C 4C 00 I_CALL db 67,65,76,76,0,7,232,2,241
11B5                
11B5                ;-525 //  8: ret
11B5                
11B5                
11B5                ;-526 char I_RET[]=  {'R','E','T',0,          8,0xC3,0xC2,0xF1};
11B5                
11B5 52 45 54 00 08 I_RET db 82,69,84,0,8,195,194,241
11BD                
11BD                ;-527 char I_RETF[]= {'R','E','T','F',0,      8,0xCB,0xCA,0xF1};
11BD                
11BD 52 45 54 46 00 I_RETF db 82,69,84,70,0,8,203,202,241
11C6                
11C6                ;-528 //  9: seg, r/m
11C6                
11C6                
11C6                ;-529 char I_PUSH[]= {'P','U','S','H',0,      9,0x50,0xFF,6,6,0xF1};//r16
11C6                
11C6 50 55 53 48 00 I_PUSH db 80,85,83,72,0,9,80,255,6,6,241
11D1                
11D1                ;-530 char I_POP[]=  {'P','O','P',0,          9,0x58,0x8F,0,7,0xF1};//r16
11D1                
11D1 50 4F 50 00 09 I_POP db 80,79,80,0,9,88,143,0,7,241
11DB                
11DB                ;-531 //  11: shift, rotates
11DB                
11DB                
11DB                ;-532 char I_ROL[]=  {'R','O','L',0, 11, 0,0xF1, 'R','O','R',0, 11, 1,0xF1};
11DB                
11DB 52 4F 4C 00 0B I_ROL db 82,79,76,0,11,0,241,82,79,82,0,11,1,241
11E9                
11E9                ;-533 char I_RCL[]=  {'R','C','L',0, 11, 2,0xF1, 'R','C','R',0, 11, 3,0xF1};
11E9                
11E9 52 43 4C 00 0B I_RCL db 82,67,76,0,11,2,241,82,67,82,0,11,3,241
11F7                
11F7                ;-534 char I_SHL[]=  {'S','H','L',0, 11, 4,0xF1, 'S','A','L',0, 11, 4,0xF1};
11F7                
11F7 53 48 4C 00 0B I_SHL db 83,72,76,0,11,4,241,83,65,76,0,11,4,241
1205                
1205                ;-535 char I_SHR[]=  {'S','H','R',0, 11, 5,0xF1, 'S','A','R',0, 11, 7,0xF1};
1205                
1205 53 48 52 00 0B I_SHR db 83,72,82,0,11,5,241,83,65,82,0,11,7,241
1213                
1213                ;-536 //  12: int
1213                
1213                
1213                ;-537 char I_INT[]=  {'I','N','T',0,          12,0xCD,0xCC,0xF1};
1213                
1213 49 4E 54 00 0C I_INT db 73,78,84,0,12,205,204,241
121B                
121B                ;-538 //  14: in/out
121B                
121B                
121B                ;-539 char I_IN[]=   {'I','N',0,              14,0xE4,0xEC,0xF1};
121B                
121B 49 4E 00 0E E4 I_IN db 73,78,0,14,228,236,241
1222                
1222                ;-540 char I_INSB[]= {'I','N','S','B',0,      14,0x6C,   0xF1};
1222                
1222 49 4E 53 42 00 I_INSB db 73,78,83,66,0,14,108,241
122A                
122A                ;-541 char I_INSW[]= {'I','N','S','W',0,      14,0x6D,   0xF1};
122A                
122A 49 4E 53 57 00 I_INSW db 73,78,83,87,0,14,109,241
1232                
1232                ;-542 char I_INSD[]= {'I','N','S','D',0,      14,0x6D,   0xF1};
1232                
1232 49 4E 53 44 00 I_INSD db 73,78,83,68,0,14,109,241
123A                
123A                ;-543 char I_OUT[]=  {'O','U','T',0,          14,0xE6,0xEE,0xF1};
123A                
123A 4F 55 54 00 0E I_OUT db 79,85,84,0,14,230,238,241
1242                
1242                ;-544 char I_OUTSB[]={'O','U','T','B',0,      14,0x6E,   0xF1};
1242                
1242 4F 55 54 42 00 I_OUTSB db 79,85,84,66,0,14,110,241
124A                
124A                ;-545 char I_OUTSW[]={'O','U','T','W',0,      14,0x6F,   0xF1};
124A                
124A 4F 55 54 57 00 I_OUTSW db 79,85,84,87,0,14,111,241
1252                
1252                ;-546 char I_OUTSD[]={'O','U','T','D',0,      14,0x6F,   0xF1};
1252                
1252 4F 55 54 44 00 I_OUTSD db 79,85,84,68,0,14,111,241
125A                
125A                ;-547 //  15: xchg
125A                
125A                
125A                ;-548 char I_XCHG[]= {'X','C','H','G',0,      15,0x86,0x90,0xF1};
125A                
125A 58 43 48 47 00 I_XCHG db 88,67,72,71,0,15,134,144,241
1263                
1263                ;-549 //  16: loop, jcxz
1263                
1263                
1263                ;-550 char I_LOOPNZ[]={'L','O','O','P','N','Z',0, 16,0xE0,0xF1};
1263                
1263 4C 4F 4F 50 4E I_LOOPNZ db 76,79,79,80,78,90,0,16,224,241
126D                
126D                ;-551 char I_LOOPNE[]={'L','O','O','P','N','E',0, 16,0xE0,0xF1};
126D                
126D 4C 4F 4F 50 4E I_LOOPNE db 76,79,79,80,78,69,0,16,224,241
1277                
1277                ;-552 char I_LOOPZ[]={'L','O','O','P','Z',0,      16,0xE1,0xF1};
1277                
1277 4C 4F 4F 50 5A I_LOOPZ db 76,79,79,80,90,0,16,225,241
1280                
1280                ;-553 char I_LOOPE[]={'L','O','O','P','E',0,      16,0xE1,0xF1};
1280                
1280 4C 4F 4F 50 45 I_LOOPE db 76,79,79,80,69,0,16,225,241
1289                
1289                ;-554 char I_LOOP[]= {'L','O','O','P',0,          16,0xE2,0xF1};
1289                
1289 4C 4F 4F 50 00 I_LOOP db 76,79,79,80,0,16,226,241
1291                
1291                ;-555 char I_JCXZ[]= {'J','C','X','Z',0,          16,0xE3,0xF1};
1291                
1291 4A 43 58 5A 00 I_JCXZ db 74,67,88,90,0,16,227,241
1299                
1299                ;-556 char I_JECXZ[]= {'J','E','C','X','Z',0,     16,0xE3,0xF1};
1299                
1299 4A 45 43 58 5A I_JECXZ db 74,69,67,88,90,0,16,227,241
12A2                
12A2                ;-557 //  30: enter
12A2                
12A2                
12A2                ;-558 char I_ENTER[]={'E','N','T','E','R',0, 30,        0xF1};
12A2                
12A2 45 4E 54 45 52 I_ENTER db 69,78,84,69,82,0,30,241
12AA                
12AA                ;-559 // 100: directives
12AA                
12AA                
12AA                ;-560 char I_ORG[]=  {'O','R','G',0,        101,        0xF1};
12AA                
12AA 4F 52 47 00 65 I_ORG db 79,82,71,0,101,241
12B0                
12B0                ;-561 // section, segment .TEXT .DATA .BSS
12B0                
12B0                
12B0                ;-562 char I_SECTION[]={'S','E','C','T','I','O','N',0,      102, 0xF1};
12B0                
12B0 53 45 43 54 49 I_SECTION db 83,69,67,84,73,79,78,0,102,241
12BA                
12BA                ;-563 char I_SEGMENT[]={'S','E','G','M','E','N','T',0,      102, 0xF1};
12BA                
12BA 53 45 47 4D 45 I_SEGMENT db 83,69,71,77,69,78,84,0,102,241
12C4                
12C4                ;-564 char I_ABSOLUTE[]={'A','B','S','O','L','U','T','E',0, 110, 0xF1};
12C4                
12C4 41 42 53 4F 4C I_ABSOLUTE db 65,66,83,79,76,85,84,69,0,110,241
12CF                
12CF                ;-565 char I_PROC[]= {'P','R','O','C',0,    111,        0xF1};
12CF                
12CF 50 52 4F 43 00 I_PROC db 80,82,79,67,0,111,241
12D6                
12D6                ;-566 char I_ENDP[]= {'E','N','D','P',0,    112,        0xF1};
12D6                
12D6 45 4E 44 50 00 I_ENDP db 69,78,68,80,0,112,241
12DD                
12DD                ;-567 char I_DB[]=   {'D','B',0,            200,        0xF1};
12DD                
12DD 44 42 00 C8 F1 I_DB db 68,66,0,200,241
12E2                
12E2                ;-568 char I_DW[]=   {'D','W',0,            201,        0xF1};
12E2                
12E2 44 57 00 C9 F1 I_DW db 68,87,0,201,241
12E7                
12E7                ;-569 char I_DD[]=   {'D','D',0,            202,        0xF1};
12E7                
12E7 44 44 00 CA F1 I_DD db 68,68,0,202,241
12EC                
12EC                ;-570 char I_RESB[]= {'R','E','S','B',0,    203,        0xF1};
12EC                
12EC 52 45 53 42 00 I_RESB db 82,69,83,66,0,203,241
12F3                
12F3                ;-571 char I_RESW[]= {'R','E','S','W',0,    204,        0xF1};
12F3                
12F3 52 45 53 57 00 I_RESW db 82,69,83,87,0,204,241
12FA                
12FA                ;-572 char I_RESD[]= {'R','E','S','D',0,    205,        0xF1};
12FA                
12FA 52 45 53 44 00 I_RESD db 82,69,83,68,0,205,241
1301                
1301                ;-573 char I_END=0;// end of table char
1301                
1301 00             I_END db 0
1302                
1302                ;-574 
1302                
1302                
1302                ;-575 int lookCode() {//ret: CodeType, *OpCodePtr
1302                
1302                
entering: lookCode
1302                lookCode: PROC
1302                
1302                ;-576     CodeType=0;
1302                
1302 B8 00 00        mov ax, 0
1305 A2 2F 01        mov byte [CodeType], al
1308                
1308                ;-577     OpCodePtr= &I_START;
1308                
1308 B8 F0 0F        mov ax, I_START
130B A3 43 01        mov word [OpCodePtr], ax
130E                
130E                ;-578     OpCodePtr++;
130E                
130E FF 06 43 01     inc  word[OpCodePtr]
1312                
1312                ;-579     do  {
1312                
1312                .lookCode102:
1312                
1312                ;-580         if (eqstr(SymbolUpper, OpCodePtr))  {
1312                
1312 FF 36 43 01     push word [OpCodePtr]
1316 8D 06 4F 75     lea  ax, [SymbolUpper]
131A 50              push ax
131B E8 42 EF        call eqstr
131E 83 C4 04        add  sp, 4
1321 08 C0           or  al, al
1323 0F 84 00 00   r je .lookCode103
1327                
1327                ;-581             while(*OpCodePtr!=0) OpCodePtr++;
1327                
1327                .lookCode104:
1327 8B 1E 43 01     mov bx, [OpCodePtr]
132B 8A 07           mov al, [bx]
132D B4 00           mov ah, 0
132F 83 F8 00        cmp ax, 0
1332 0F 84 00 00   r je  .lookCode105
1336 FF 06 43 01     inc  word[OpCodePtr]
133A                
133A                ;-582             OpCodePtr++;
133A                
133A EB EB           jmp .lookCode104
133C                .lookCode105:
133C FF 06 43 01     inc  word[OpCodePtr]
1340                
1340                ;-583             CodeType =*OpCodePtr;
1340                
1340 8B 1E 43 01     mov bx, [OpCodePtr]
1344 8A 07           mov al, [bx]
1346 B4 00           mov ah, 0
1348 A2 2F 01        mov byte [CodeType], al
134B                
134B                ;-584             return;
134B                
134B E9 00 00      R jmp .retnlookCode
134E                
134E                ;-585         }
134E                
134E                
134E                ;-586     while(*OpCodePtr!=0xF1) OpCodePtr++;
134E                
134E                .lookCode103:
134E                .lookCode106:
134E 8B 1E 43 01     mov bx, [OpCodePtr]
1352 8A 07           mov al, [bx]
1354 B4 00           mov ah, 0
1356 3D F1 00        cmp ax, 241
1359 0F 84 00 00   r je  .lookCode107
135D FF 06 43 01     inc  word[OpCodePtr]
1361                
1361                ;-587     OpCodePtr++;
1361                
1361 EB EB           jmp .lookCode106
1363                .lookCode107:
1363 FF 06 43 01     inc  word[OpCodePtr]
1367                
1367                ;-588     } while(*OpCodePtr!=0);
1367                
1367 8B 1E 43 01     mov bx, [OpCodePtr]
136B 8A 07           mov al, [bx]
136D B4 00           mov ah, 0
136F 83 F8 00        cmp ax, 0
1372 0F 84 00 00   r je  .lookCode108
1376 EB 9A           jmp .lookCode102
1378                .lookCode108:
1378                
1378                ;-589 }
1378                
1378                
1378                ;-590 
1378                
1378                
1378                ;-591 int genCode8(char c) {
1378                
1378                 .retnlookCode:
1378 C3              ret
leaving: lookCode, loc labels: 8, loc jmp forward: 5
1379                ENDP
1379                
entering: genCode8
1379                genCode8: PROC
1379                
1379                ;-592 //set: BinLen++, OpPrintIndex++
1379                
1379                
1379                ;-593     FileBin[BinLen]=c;
1379                
1379                ;Function : genCode8, Number of local variables: 1
1379                ;   # type sign width addr used name   list of local variables
1379                ;  200 var sign byte   591 NULL c = bp+4;
1379 C8 00 00 00     ENTER  0,0
137D 8A 46 04        mov al, [bp+4]
1380 8B 1E 58 01     mov bx, [BinLen]
1384 88 47 AA        mov [FileBin+bx], al
1387                
1387                ;-594     BinLen++;
1387                
1387 FF 06 58 01     inc  word[BinLen]
138B                
138B                ;-595     PC++;
138B                
138B FF 06 23 01     inc  word[PC]
138F                
138F                ;-596     if (BinLen >= FILEBINMAX) errorexit("COM file too long");
138F                
138F A1 58 01        mov ax, [BinLen]
1392 3D 68 42        cmp ax, 17000 ;unsigned : 0
1395 0F 82 00 00   r jb  .genCode8109
1399 68 AA AA      A push genCode8_0
139C E8 F1 F6        call errorexit
139F 83 C4 02        add  sp, 2
13A2                
13A2                ;-597     if (OpPrintIndex < OPMAXLEN) {
13A2                
13A2                .genCode8109:
13A2 A1 41 01        mov ax, [OpPrintIndex]
13A5 83 F8 05        cmp ax, 5
13A8 0F 8D 00 00   r jge .genCode8110
13AC                
13AC                ;-598         OpPos[OpPrintIndex]=c;
13AC                
13AC 8A 46 04        mov al, [bp+4]
13AF 8B 1E 41 01     mov bx, [OpPrintIndex]
13B3 88 87 55 77     mov [OpPos+bx], al
13B7                
13B7                ;-599         OpPrintIndex++;
13B7                
13B7 FF 06 41 01     inc  word[OpPrintIndex]
13BB                
13BB                ;-600     }
13BB                
13BB                
13BB                ;-601 }
13BB                
13BB                .genCode8110:
13BB                
13BB                ;-602 int gen66h() {genCode8(0x66);
13BB C9              LEAVE
13BC C3              ret
13BD 43 4F 4D 20 66 genCode8_0 db "COM file too long",0
leaving: genCode8, loc labels: 3, loc jmp forward: 3
13CF                ENDP
13CF                
entering: gen66h
13CF                gen66h: PROC
13CF 6A 66           push 102
13D1 E8 A5 FF        call genCode8
13D4 83 C4 02        add  sp, 2
13D7                
13D7                ;-603 }
13D7                
13D7                
13D7                ;-604 int genCode2(char c, char d) {
13D7                
13D7 C3              ret
leaving: gen66h, loc labels: 0, loc jmp forward: 0
13D8                ENDP
13D8                
entering: genCode2
13D8                genCode2: PROC
13D8                
13D8                ;-605     c = c + d;
13D8                
13D8                ;Function : genCode2, Number of local variables: 2
13D8                ;   # type sign width addr used name   list of local variables
13D8                ;  200 var sign byte   604 NULL c = bp+4
13D8                ;  201 var sign byte   604 NULL d = bp+6;
13D8 C8 00 00 00     ENTER  0,0
13DC 8A 46 04        mov al, [bp+4]
13DF 02 46 06        add al, [bp+6]
13E2 88 46 04        mov [bp+4], al
13E5                
13E5                ;-606     genCode8(c);
13E5                
13E5 8A 46 04        mov al, byte [bp+4]
13E8 B4 00           mov ah, 0
13EA 50              push ax
13EB E8 8B FF        call genCode8
13EE 83 C4 02        add  sp, 2
13F1                
13F1                ;-607 }
13F1                
13F1                
13F1                ;-608 int genCodeW(char c) {
13F1 C9              LEAVE
13F2 C3              ret
leaving: genCode2, loc labels: 0, loc jmp forward: 0
13F3                ENDP
13F3                
entering: genCodeW
13F3                genCodeW: PROC
13F3                
13F3                ;-609     c = c + wflag;
13F3                
13F3                ;Function : genCodeW, Number of local variables: 1
13F3                ;   # type sign width addr used name   list of local variables
13F3                ;  200 var sign byte   608 NULL c = bp+4;
13F3 C8 00 00 00     ENTER  0,0
13F7 8A 46 04        mov al, [bp+4]
13FA 02 06 38 01     add al, [wflag]
13FE 88 46 04        mov [bp+4], al
1401                
1401                ;-610     genCode8(c);
1401                
1401 8A 46 04        mov al, byte [bp+4]
1404 B4 00           mov ah, 0
1406 50              push ax
1407 E8 6F FF        call genCode8
140A 83 C4 02        add  sp, 2
140D                
140D                ;-611 }
140D                
140D                
140D                ;-612 int genCode16(unsigned int i) {
140D C9              LEAVE
140E C3              ret
leaving: genCodeW, loc labels: 0, loc jmp forward: 0
140F                ENDP
140F                
entering: genCode16
140F                genCode16: PROC
140F                
140F                ;-613     genCode8(i); i=i >> 8;
140F                
140F                ;Function : genCode16, Number of local variables: 1
140F                ;   # type sign width addr used name   list of local variables
140F                ;  200 var unsg word   612 NULL i = bp+4;
140F C8 00 00 00     ENTER  0,0
1413 55              push word [bp+4]
1414 E8 62 FF        call genCode8
1417 83 C4 02        add  sp, 2
141A 8B 46 04        mov ax, [bp+4]
141D C1 E8 08        shr ax, 8
1420 89 46 04        mov [bp+4], ax
1423                
1423                ;-614     genCode8(i);
1423                
1423 55              push word [bp+4]
1424 E8 52 FF        call genCode8
1427 83 C4 02        add  sp, 2
142A                
142A                ;-615 }
142A                
142A                
142A                ;-616 int genCode32(unsigned long L) {
142A C9              LEAVE
142B C3              ret
leaving: genCode16, loc labels: 0, loc jmp forward: 0
142C                ENDP
142C                
entering: genCode32
142C                genCode32: PROC
142C                
142C                ;-617     genCode16(L); L=L >>16;
142C                
142C                ;Function : genCode32, Number of local variables: 1
142C                ;   # type sign width addr used name   list of local variables
142C                ;  200 var unsg dwrd   616 NULL L = bp+4;
142C C8 00 00 00     ENTER  0,0
1430 8A 46 04        mov al, byte [bp+4]
1433 B4 00           mov ah, 0
1435 50              push ax
1436 E8 D6 FF        call genCode16
1439 83 C4 02        add  sp, 2
143C 66 8B 46 04     mov eax, [bp+4]
1440 66 C1 E8 10     shr eax, 16
1444 66 89 46 04     mov [bp+4], eax
1448                
1448                ;-618     genCode16(L);
1448                
1448 8A 46 04        mov al, byte [bp+4]
144B B4 00           mov ah, 0
144D 50              push ax
144E E8 BE FF        call genCode16
1451 83 C4 02        add  sp, 2
1454                
1454                ;-619 }
1454                
1454                
1454                ;-620 int writeEA(char xxx) {//value for reg/operand
1454 C9              LEAVE
1455 C3              ret
leaving: genCode32, loc labels: 0, loc jmp forward: 0
1456                ENDP
1456                
entering: writeEA
1456                writeEA: PROC
1456                
1456                ;-621 //need: Op, Op2, disp, R1No, R2No, rm, isDirect
1456                
1456                
1456                ;-622 //mod-bits: mode76, reg/opcode543, r/m210
1456                
1456                
1456                ;-623 //Op: 0, IMM, REG, ADR, MEM
1456                
1456                
1456                ;-624     char len;
1456                
1456                
1456                ;-625     len=0;
1456                
1456                ;Function : writeEA, Number of local variables: 2
1456                ;   # type sign width addr used name   list of local variables
1456                ;  200 var sign byte   620 NULL xxx = bp+4
1456                ;  201 var sign byte   624 NULL len = bp-2;
1456 C8 02 00 00     ENTER  2,0
145A B8 00 00        mov ax, 0
145D 88 46 FE        mov [bp-2], al
1460                
1460                ;-626     xxx = xxx << 3;//in reg/opcode field
1460                
1460 8A 46 04        mov al, [bp+4]
1463 C0 E0 03        shl al, 3
1466 88 46 04        mov [bp+4], al
1469                
1469                ;-627     if (Op == REG) {
1469                
1469 A0 2D 01        mov al, [Op]
146C 3C 02           cmp al, 2
146E 0F 85 00 00   r jne .writeEA111
1472                
1472                ;-628         xxx |= 0xC0;
1472                
1472 80 4E 04 C0     or  byte[bp+4], 192
1476                
1476                ;-629         if (Op2 <= IMM) xxx = xxx + R1No;//empty or IMM
1476                
1476 A0 2E 01        mov al, [Op2]
1479 3C 01           cmp al, 1
147B 0F 8F 00 00   r jg  .writeEA112
147F 8A 46 04        mov al, [bp+4]
1482 02 06 34 01     add al, [R1No]
1486 88 46 04        mov [bp+4], al
1489                
1489                ;-630             else {
1489                
1489 E9 00 00      R jmp .writeEA113
148C                .writeEA112:
148C                
148C                ;-631                 if (Op2 == REG) xxx = xxx + R1No;
148C                
148C A0 2E 01        mov al, [Op2]
148F 3C 02           cmp al, 2
1491 0F 85 00 00   r jne .writeEA114
1495 8A 46 04        mov al, [bp+4]
1498 02 06 34 01     add al, [R1No]
149C 88 46 04        mov [bp+4], al
149F                
149F                ;-632                 else            xxx = xxx + R2No;
149F                
149F E9 00 00      R jmp .writeEA115
14A2                .writeEA114:
14A2 8A 46 04        mov al, [bp+4]
14A5 02 06 33 01     add al, [R2No]
14A9 88 46 04        mov [bp+4], al
14AC                
14AC                ;-633             }
14AC                
14AC                .writeEA115:
14AC                
14AC                ;-634         }
14AC                
14AC                .writeEA113:
14AC                
14AC                ;-635     if (Op == MEM) {
14AC                
14AC                .writeEA111:
14AC A0 2D 01        mov al, [Op]
14AF 3C 04           cmp al, 4
14B1 0F 85 00 00   r jne .writeEA116
14B5                
14B5                ;-636         if (isDirect) {
14B5                
14B5 A0 3C 01        mov al, [isDirect]
14B8 08 C0           or  al, al
14BA 0F 84 00 00   r je .writeEA117
14BE                
14BE                ;-637             xxx |= 6;
14BE                
14BE 80 4E 04 06     or  byte[bp+4], 6
14C2                
14C2                ;-638             len = 2;
14C2                
14C2 B8 02 00        mov ax, 2
14C5 88 46 FE        mov [bp-2], al
14C8                
14C8                ;-639         }
14C8                
14C8                
14C8                ;-640         else {
14C8                
14C8 E9 00 00      R jmp .writeEA118
14CB                .writeEA117:
14CB                
14CB                ;-641             xxx = xxx + rm;
14CB                
14CB 8A 46 04        mov al, [bp+4]
14CE 02 06 3B 01     add al, [rm]
14D2 88 46 04        mov [bp+4], al
14D5                
14D5                ;-642             if (rm == 6) {//make [BP+00]
14D5                
14D5 A0 3B 01        mov al, [rm]
14D8 3C 06           cmp al, 6
14DA 0F 85 00 00   r jne .writeEA119
14DE                
14DE                ;-643                 len=1;
14DE                
14DE B8 01 00        mov ax, 1
14E1 88 46 FE        mov [bp-2], al
14E4                
14E4                ;-644                 if (disp == 0) xxx |= 0x40;
14E4                
14E4 A1 3D 01        mov ax, [disp]
14E7 83 F8 00        cmp ax, 0
14EA 0F 85 00 00   r jne .writeEA120
14EE 80 4E 04 40     or  byte[bp+4], 64
14F2                
14F2                ;-645             }
14F2                
14F2                .writeEA120:
14F2                
14F2                ;-646 
14F2                
14F2                
14F2                ;-647             if (disp) {
14F2                
14F2                .writeEA119:
14F2 A1 3D 01        mov ax, [disp]
14F5 08 C0           or  al, al
14F7 0F 84 00 00   r je .writeEA121
14FB                
14FB                ;-648                 ax = disp;
14FB                
14FB A1 3D 01        mov  ax, [disp]
14FE                
14FE                ;-649                 if(ax > 127) len=2;
14FE                
14FE 83 F8 7F        cmp  ax, 127
1501 0F 8E 00 00   r jle .writeEA122
1505 B8 02 00        mov ax, 2
1508 88 46 FE        mov [bp-2], al
150B                
150B                ;-650                 else len=1;
150B                
150B E9 00 00      R jmp .writeEA123
150E                .writeEA122:
150E B8 01 00        mov ax, 1
1511 88 46 FE        mov [bp-2], al
1514                
1514                ;-651                 if (len == 1) xxx |= 0x40;
1514                
1514                .writeEA123:
1514 8A 46 FE        mov al, [bp-2]
1517 3C 01           cmp al, 1
1519 0F 85 00 00   r jne .writeEA124
151D 80 4E 04 40     or  byte[bp+4], 64
1521                
1521                ;-652                 else xxx |= 0x80;
1521                
1521 E9 00 00      R jmp .writeEA125
1524                .writeEA124:
1524 80 4E 04 80     or  byte[bp+4], 128
1528                
1528                ;-653             }
1528                
1528                .writeEA125:
1528                
1528                ;-654         }
1528                
1528                .writeEA121:
1528                
1528                ;-655     }
1528                
1528                .writeEA118:
1528                
1528                ;-656 
1528                
1528                
1528                ;-657     genCode8(xxx);// gen second byte
1528                
1528                .writeEA116:
1528 8A 46 04        mov al, byte [bp+4]
152B B4 00           mov ah, 0
152D 50              push ax
152E E8 48 FE        call genCode8
1531 83 C4 02        add  sp, 2
1534                
1534                ;-658     if (len == 1) genCode8 (disp);
1534                
1534 8A 46 FE        mov al, [bp-2]
1537 3C 01           cmp al, 1
1539 0F 85 00 00   r jne .writeEA126
153D FF 36 3D 01     push word [disp]
1541 E8 35 FE        call genCode8
1544 83 C4 02        add  sp, 2
1547                
1547                ;-659     if (len == 2) genCode16(disp);
1547                
1547                .writeEA126:
1547 8A 46 FE        mov al, [bp-2]
154A 3C 02           cmp al, 2
154C 0F 85 00 00   r jne .writeEA127
1550 FF 36 3D 01     push word [disp]
1554 E8 B8 FE        call genCode16
1557 83 C4 02        add  sp, 2
155A                
155A                ;-660 }
155A                
155A                .writeEA127:
155A                
155A                ;-661 
155A                
155A                
155A                ;-662 int genImmediate() {
155A C9              LEAVE
155B C3              ret
leaving: writeEA, loc labels: 17, loc jmp forward: 17
155C                ENDP
155C                
entering: genImmediate
155C                genImmediate: PROC
155C                
155C                ;-663     if (wflag) if (OpSize == DWORD) genCode32(imme);
155C                
155C A0 38 01        mov al, [wflag]
155F 08 C0           or  al, al
1561 0F 84 00 00   r je .genImmediate128
1565 A0 37 01        mov al, [OpSize]
1568 3C 03           cmp al, 3
156A 0F 85 00 00   r jne .genImmediate129
156E FF 36 3F 01     push word [imme]
1572 E8 B7 FE        call genCode32
1575 83 C4 02        add  sp, 2
1578                
1578                ;-664         //todo imme long
1578                
1578                
1578                ;-665         else genCode16(imme);
1578                
1578 E9 00 00      R jmp .genImmediate130
157B                .genImmediate129:
157B FF 36 3F 01     push word [imme]
157F E8 8D FE        call genCode16
1582 83 C4 02        add  sp, 2
1585                
1585                ;-666     else       genCode8 (imme);
1585                
1585                .genImmediate130:
1585 E9 00 00      R jmp .genImmediate131
1588                .genImmediate128:
1588 FF 36 3F 01     push word [imme]
158C E8 EA FD        call genCode8
158F 83 C4 02        add  sp, 2
1592                
1592                ;-667 }
1592                
1592                .genImmediate131:
1592                
1592                ;-668 
1592                
1592                
1592                ;-669 int setwflag() {//word size, bit 0
1592                
1592 C3              ret
leaving: genImmediate, loc labels: 4, loc jmp forward: 4
1593                ENDP
1593                
entering: setwflag
1593                setwflag: PROC
1593                
1593                ;-670     wflag=0;
1593                
1593 B8 00 00        mov ax, 0
1596 A2 38 01        mov byte [wflag], al
1599                
1599                ;-671     if (OpSize == 0) {//do not override OpSize
1599                
1599 A0 37 01        mov al, [OpSize]
159C 3C 00           cmp al, 0
159E 0F 85 00 00   r jne .setwflag132
15A2                
15A2                ;-672         if (Op == REG) OpSize=R1Type;
15A2                
15A2 A0 2D 01        mov al, [Op]
15A5 3C 02           cmp al, 2
15A7 0F 85 00 00   r jne .setwflag133
15AB A0 36 01        mov al, [R1Type]
15AE A2 37 01        mov byte [OpSize], al
15B1                
15B1                ;-673         if (Op2== REG) OpSize=R2Type;
15B1                
15B1                .setwflag133:
15B1 A0 2E 01        mov al, [Op2]
15B4 3C 02           cmp al, 2
15B6 0F 85 00 00   r jne .setwflag134
15BA A0 35 01        mov al, [R2Type]
15BD A2 37 01        mov byte [OpSize], al
15C0                
15C0                ;-674         if (R2Type== SEGREG) OpSize=WORD;
15C0                
15C0                .setwflag134:
15C0 A0 35 01        mov al, [R2Type]
15C3 3C 04           cmp al, 4
15C5 0F 85 00 00   r jne .setwflag135
15C9 B8 02 00        mov ax, 2
15CC A2 37 01        mov byte [OpSize], al
15CF                
15CF                ;-675         if (R1Type == SEGREG) OpSize=WORD;
15CF                
15CF                .setwflag135:
15CF A0 36 01        mov al, [R1Type]
15D2 3C 04           cmp al, 4
15D4 0F 85 00 00   r jne .setwflag136
15D8 B8 02 00        mov ax, 2
15DB A2 37 01        mov byte [OpSize], al
15DE                
15DE                ;-676     }
15DE                
15DE                .setwflag136:
15DE                
15DE                ;-677     if (OpSize  == DWORD) {gen66h(); wflag=1;}
15DE                
15DE                .setwflag132:
15DE A0 37 01        mov al, [OpSize]
15E1 3C 03           cmp al, 3
15E3 0F 85 00 00   r jne .setwflag137
15E7 E8 E5 FD        call gen66h
15EA B8 01 00        mov ax, 1
15ED A2 38 01        mov byte [wflag], al
15F0                
15F0                ;-678     if (OpSize  ==  WORD) wflag=1;
15F0                
15F0                .setwflag137:
15F0 A0 37 01        mov al, [OpSize]
15F3 3C 02           cmp al, 2
15F5 0F 85 00 00   r jne .setwflag138
15F9 B8 01 00        mov ax, 1
15FC A2 38 01        mov byte [wflag], al
15FF                
15FF                ;-679 }
15FF                
15FF                .setwflag138:
15FF                
15FF                ;-680 int setsflag() {//sign-extend, bit 1, only PUSH, ALU, IMUL3
15FF                
15FF C3              ret
leaving: setwflag, loc labels: 7, loc jmp forward: 7
1600                ENDP
1600                
entering: setsflag
1600                setsflag: PROC
1600                
1600                ;-681     unsigned int ui;
1600                
1600                
1600                ;-682     sflag=2;
1600                
1600                ;Function : setsflag, Number of local variables: 1
1600                ;   # type sign width addr used name   list of local variables
1600                ;  200 var unsg word   681 NULL ui = bp-2;
1600 C8 02 00 00     ENTER  2,0
1604 B8 02 00        mov ax, 2
1607 A2 3A 01        mov byte [sflag], al
160A                
160A                ;-683     ui = imme & 0xFF80;//is greater than signed 127?
160A                
160A A1 3F 01        mov ax, [imme]
160D 25 80 FF        and ax, 65408
1610 89 46 FE        mov [bp-2], ax
1613                
1613                ;-684     if(ui != 0) sflag = 0;
1613                
1613 8B 46 FE        mov ax, [bp-2]
1616 83 F8 00        cmp ax, 0
1619 0F 84 00 00   r je  .setsflag139
161D B8 00 00        mov ax, 0
1620 A2 3A 01        mov byte [sflag], al
1623                
1623                ;-685     if (OpSize == BYTE) {
1623                
1623                .setsflag139:
1623 A0 37 01        mov al, [OpSize]
1626 3C 01           cmp al, 1
1628 0F 85 00 00   r jne .setsflag140
162C                
162C                ;-686         if (imme > 255) error1("too big for byte r/m");
162C                
162C A1 3F 01        mov ax, [imme]
162F 3D FF 00        cmp ax, 255
1632 0F 8E 00 00   r jle .setsflag141
1636 68 AA AA      A push setsflag_0
1639 E8 FF F3        call error1
163C 83 C4 02        add  sp, 2
163F                
163F                ;-687         sflag=0;//byte reg does not need sign extended
163F                
163F                .setsflag141:
163F B8 00 00        mov ax, 0
1642 A2 3A 01        mov byte [sflag], al
1645                
1645                ;-688     }
1645                
1645                
1645                ;-689 }
1645                
1645                .setsflag140:
1645                
1645                ;-690 int checkConstSize(unsigned int ui) {
1645 C9              LEAVE
1646 C3              ret
1647 74 6F 6F 20 62 setsflag_0 db "too big for byte r/m",0
leaving: setsflag, loc labels: 4, loc jmp forward: 4
165C                ENDP
165C                
entering: checkConstSize
165C                checkConstSize: PROC
165C                
165C                ;-691     if (ui > 127   ) return 0;//is near; return sflag
165C                
165C                ;Function : checkConstSize, Number of local variables: 1
165C                ;   # type sign width addr used name   list of local variables
165C                ;  200 var unsg word   690 NULL ui = bp+4;
165C C8 00 00 00     ENTER  0,0
1660 8B 46 04        mov ax, [bp+4]
1663 83 F8 7F        cmp ax, 127
1666 0F 8E 00 00   r jle .checkConstSize142
166A B8 00 00        mov ax, 0
166D E9 00 00      R jmp .retncheckConstSize
1670                
1670                ;-692     if (ui < 0xFF80) return 0;//-128dez
1670                
1670                .checkConstSize142:
1670 8B 46 04        mov ax, [bp+4]
1673 3D 80 FF        cmp ax, 65408
1676 0F 8D 00 00   r jge .checkConstSize143
167A B8 00 00        mov ax, 0
167D E9 00 00      R jmp .retncheckConstSize
1680                
1680                ;-693     return 2;// is short
1680                
1680                .checkConstSize143:
1680 B8 02 00        mov ax, 2
1683 E9 00 00      R jmp .retncheckConstSize
1686                
1686                ;-694 }
1686                
1686                
1686                ;-695 
1686                
1686                
1686                ;-696 
1686                
1686                
1686                ;-697 int ChangeDirection() {
1686                
1686 C9              .retncheckConstSize: LEAVE
1687 C3              ret
leaving: checkConstSize, loc labels: 3, loc jmp forward: 5
1688                ENDP
1688                
entering: ChangeDirection
1688                ChangeDirection: PROC
1688                
1688                ;-698     char c;
1688                
1688                
1688                ;-699     c=Op;     Op    =Op2;    Op2   =c;
1688                
1688                ;Function : ChangeDirection, Number of local variables: 1
1688                ;   # type sign width addr used name   list of local variables
1688                ;  200 var sign byte   698 NULL c = bp-2;
1688 C8 02 00 00     ENTER  2,0
168C A0 2D 01        mov al, [Op]
168F 88 46 FE        mov [bp-2], al
1692 A0 2E 01        mov al, [Op2]
1695 A2 2D 01        mov byte [Op], al
1698 8A 46 FE        mov al, [bp-2]
169B A2 2E 01        mov byte [Op2], al
169E                
169E                ;-700     c=R1Type; R1Type=R2Type; R2Type=c;
169E                
169E A0 36 01        mov al, [R1Type]
16A1 88 46 FE        mov [bp-2], al
16A4 A0 35 01        mov al, [R2Type]
16A7 A2 36 01        mov byte [R1Type], al
16AA 8A 46 FE        mov al, [bp-2]
16AD A2 35 01        mov byte [R2Type], al
16B0                
16B0                ;-701     c=R1No;   R1No  =R2No;   R2No  =c;
16B0                
16B0 A0 34 01        mov al, [R1No]
16B3 88 46 FE        mov [bp-2], al
16B6 A0 33 01        mov al, [R2No]
16B9 A2 34 01        mov byte [R1No], al
16BC 8A 46 FE        mov al, [bp-2]
16BF A2 33 01        mov byte [R2No], al
16C2                
16C2                ;-702     dflag=2;
16C2                
16C2 B8 02 00        mov ax, 2
16C5 A2 39 01        mov byte [dflag], al
16C8                
16C8                ;-703 }
16C8                
16C8                
16C8                ;-704 
16C8                
16C8                
16C8                ;-705 int getTokeType() {
16C8 C9              LEAVE
16C9 C3              ret
leaving: ChangeDirection, loc labels: 0, loc jmp forward: 0
16CA                ENDP
16CA                
entering: getTokeType
16CA                getTokeType: PROC
16CA                
16CA                ;-706     char c;
16CA                
16CA                
16CA                ;-707     skipBlank();
16CA                
16CA                ;Function : getTokeType, Number of local variables: 1
16CA                ;   # type sign width addr used name   list of local variables
16CA                ;  200 var sign byte   706 NULL c = bp-2;
16CA C8 02 00 00     ENTER  2,0
16CE E8 F8 F6        call skipBlank
16D1                
16D1                ;-708     c = *InputPtr;
16D1                
16D1 8B 1E 14 01     mov bx, [InputPtr]
16D5 8A 07           mov al, [bx]
16D7 B4 00           mov ah, 0
16D9 88 46 FE        mov [bp-2], al
16DC                
16DC                ;-709     if (c == 0)   {TokeType=0; return; }//last line or empty line
16DC                
16DC 8A 46 FE        mov al, [bp-2]
16DF 3C 00           cmp al, 0
16E1 0F 85 00 00   r jne .getTokeType144
16E5 B8 00 00        mov ax, 0
16E8 A2 2C 01        mov byte [TokeType], al
16EB E9 00 00      R jmp .retngetTokeType
16EE                
16EE                ;-710     if (c == ';') {TokeType=0; return; }//comment
16EE                
16EE                .getTokeType144:
16EE 8A 46 FE        mov al, [bp-2]
16F1 3C 3B           cmp al, 59
16F3 0F 85 00 00   r jne .getTokeType145
16F7 B8 00 00        mov ax, 0
16FA A2 2C 01        mov byte [TokeType], al
16FD E9 00 00      R jmp .retngetTokeType
1700                
1700                ;-711     if (digit(c)) {getDigit(c); TokeType=DIGIT; return;}//ret:1=SymbolInt
1700                
1700                .getTokeType145:
1700 8A 46 FE        mov al, byte [bp-2]
1703 B4 00           mov ah, 0
1705 50              push ax
1706 E8 93 EA        call digit
1709 83 C4 02        add  sp, 2
170C 08 C0           or  al, al
170E 0F 84 00 00   r je .getTokeType146
1712 8A 46 FE        mov al, byte [bp-2]
1715 B4 00           mov ah, 0
1717 50              push ax
1718 E8 D9 F6        call getDigit
171B 83 C4 02        add  sp, 2
171E B8 01 00        mov ax, 1
1721 A2 2C 01        mov byte [TokeType], al
1724 E9 00 00      R jmp .retngetTokeType
1727                
1727                ;-712     if (letterE (c)) {getName(c); TokeType=ALNUME; return;}//ret:2=Symbol
1727                
1727                .getTokeType146:
1727 8A 46 FE        mov al, byte [bp-2]
172A B4 00           mov ah, 0
172C 50              push ax
172D E8 EE E9        call letterE
1730 83 C4 02        add  sp, 2
1733 08 C0           or  al, al
1735 0F 84 00 00   r je .getTokeType147
1739 8A 46 FE        mov al, byte [bp-2]
173C B4 00           mov ah, 0
173E 50              push ax
173F E8 02 F7        call getName
1742 83 C4 02        add  sp, 2
1745 B8 03 00        mov ax, 3
1748 A2 2C 01        mov byte [TokeType], al
174B E9 00 00      R jmp .retngetTokeType
174E                
174E                ;-713     TokeType=NOALNUME;
174E                
174E                .getTokeType147:
174E B8 04 00        mov ax, 4
1751 A2 2C 01        mov byte [TokeType], al
1754                
1754                ;-714 }
1754                
1754                
1754                ;-715 
1754                
1754                
1754                ;-716 int isToken(char c) {
1754                
1754 C9              .retngetTokeType: LEAVE
1755 C3              ret
leaving: getTokeType, loc labels: 5, loc jmp forward: 8
1756                ENDP
1756                
entering: isToken
1756                isToken: PROC
1756                
1756                ;-717     skipBlank();
1756                
1756                ;Function : isToken, Number of local variables: 1
1756                ;   # type sign width addr used name   list of local variables
1756                ;  200 var sign byte   716 NULL c = bp+4;
1756 C8 00 00 00     ENTER  0,0
175A E8 6C F6        call skipBlank
175D                
175D                ;-718     if (*InputPtr == c) {
175D                
175D 8B 1E 14 01     mov bx, [InputPtr]
1761 8A 07           mov al, [bx]
1763 B4 00           mov ah, 0
1765 3A 46 04        cmp al, [bp+4]
1768 0F 85 00 00   r jne .isToken148
176C                
176C                ;-719         InputPtr++;
176C                
176C FF 06 14 01     inc  word[InputPtr]
1770                
1770                ;-720         return 1;
1770                
1770 B8 01 00        mov ax, 1
1773 E9 00 00      R jmp .retnisToken
1776                
1776                ;-721         }
1776                
1776                
1776                ;-722     return 0;
1776                
1776                .isToken148:
1776 B8 00 00        mov ax, 0
1779 E9 00 00      R jmp .retnisToken
177C                
177C                ;-723 }
177C                
177C                
177C                ;-724 
177C                
177C                
177C                ;-725 
177C                
177C                
177C                ;-726 int need(char c) {
177C                
177C C9              .retnisToken: LEAVE
177D C3              ret
leaving: isToken, loc labels: 2, loc jmp forward: 3
177E                ENDP
177E                
entering: need
177E                need: PROC
177E                
177E                ;-727     if (isToken(c)) {
177E                
177E                ;Function : need, Number of local variables: 1
177E                ;   # type sign width addr used name   list of local variables
177E                ;  200 var sign byte   726 NULL c = bp+4;
177E C8 00 00 00     ENTER  0,0
1782 8A 46 04        mov al, byte [bp+4]
1785 B4 00           mov ah, 0
1787 50              push ax
1788 E8 CB FF        call isToken
178B 83 C4 02        add  sp, 2
178E 08 C0           or  al, al
1790 0F 84 00 00   r je .need149
1794                
1794                ;-728         getTokeType();
1794                
1794 E8 33 FF        call getTokeType
1797                
1797                ;-729         return;
1797                
1797 E9 00 00      R jmp .retnneed
179A                
179A                ;-730         }
179A                
179A                
179A                ;-731     error1();
179A                
179A                .need149:
179A E8 9E F2        call error1
179D                
179D                ;-732     prs(". need: ");
179D                
179D 68 AA AA      A push need_0
17A0 E8 8C EF        call prs
17A3 83 C4 02        add  sp, 2
17A6                
17A6                ;-733     prc(c);
17A6                
17A6 8A 46 04        mov al, byte [bp+4]
17A9 B4 00           mov ah, 0
17AB 50              push ax
17AC E8 28 EF        call prc
17AF 83 C4 02        add  sp, 2
17B2                
17B2                ;-734 }
17B2                
17B2                
17B2                ;-735 int skipRest() {
17B2                
17B2 C9              .retnneed: LEAVE
17B3 C3              ret
17B4 2E 20 6E 65 65 need_0 db ". need: ",0
leaving: need, loc labels: 3, loc jmp forward: 3
17BD                ENDP
17BD                
entering: skipRest
17BD                skipRest: PROC
17BD                
17BD                ;-736     getTokeType();
17BD                
17BD E8 0A FF        call getTokeType
17C0                
17C0                ;-737     if(TokeType)error1("extra char ignored");
17C0                
17C0 A0 2C 01        mov al, [TokeType]
17C3 08 C0           or  al, al
17C5 0F 84 00 00   r je .skipRest150
17C9 68 AA AA      A push skipRest_0
17CC E8 6C F2        call error1
17CF 83 C4 02        add  sp, 2
17D2                
17D2                ;-738 }
17D2                
17D2                .skipRest150:
17D2                
17D2                ;-739 
17D2                
17D2                
17D2                ;-740 
17D2                
17D2                
17D2                ;-741 int checkOpL() {
17D2                
17D2 C3              ret
17D3 65 78 74 72 61 skipRest_0 db "extra char ignored",0
leaving: skipRest, loc labels: 2, loc jmp forward: 2
17E6                ENDP
17E6                
entering: checkOpL
17E6                checkOpL: PROC
17E6                
17E6                ;-742     if (Op == ADR) implerror();
17E6                
17E6 A0 2D 01        mov al, [Op]
17E9 3C 03           cmp al, 3
17EB 0F 85 00 00   r jne .checkOpL151
17EF E8 57 F3        call implerror
17F2                
17F2                ;-743     if (R1Type==SEGREG) {segregerror();return;}//only move,push,pop
17F2                
17F2                .checkOpL151:
17F2 A0 36 01        mov al, [R1Type]
17F5 3C 04           cmp al, 4
17F7 0F 85 00 00   r jne .checkOpL152
17FB E8 13 F4        call segregerror
17FE E9 00 00      R jmp .retncheckOpL
1801                
1801                ;-744     setwflag();
1801                
1801                .checkOpL152:
1801 E8 8F FD        call setwflag
1804                
1804                ;-745     if (OpSize == 0) error1("no op size declared");
1804                
1804 A0 37 01        mov al, [OpSize]
1807 3C 00           cmp al, 0
1809 0F 85 00 00   r jne .checkOpL153
180D 68 AA AA      A push checkOpL_0
1810 E8 28 F2        call error1
1813 83 C4 02        add  sp, 2
1816                
1816                ;-746     if (OpSize == R1Type) return;
1816                
1816                .checkOpL153:
1816 A0 37 01        mov al, [OpSize]
1819 3A 06 36 01     cmp al, [R1Type]
181D 0F 85 00 00   r jne .checkOpL154
1821 E9 00 00      R jmp .retncheckOpL
1824                
1824                ;-747     if (Op == REG) if (R1Type==0) error1("no register defined");
1824                
1824                .checkOpL154:
1824 A0 2D 01        mov al, [Op]
1827 3C 02           cmp al, 2
1829 0F 85 00 00   r jne .checkOpL155
182D A0 36 01        mov al, [R1Type]
1830 3C 00           cmp al, 0
1832 0F 85 00 00   r jne .checkOpL156
1836 68 AA AA      A push checkOpL_1
1839 E8 FF F1        call error1
183C 83 C4 02        add  sp, 2
183F                
183F                ;-748 }
183F                
183F                .checkOpL156:
183F                .checkOpL155:
183F                
183F                ;-749 
183F                
183F                
183F                ;-750 int searchLabel() {
183F                
183F                 .retncheckOpL:
183F C3              ret
1840 6E 6F 20 6F 70 checkOpL_0 db "no op size declared",0
1854 6E 6F 20 72 65 checkOpL_1 db "no register defined",0
leaving: checkOpL, loc labels: 9, loc jmp forward: 10
1868                ENDP
1868                
entering: searchLabel
1868                searchLabel: PROC
1868                
1868                ;-751     int LIx; char *p;
1868                
1868                
1868                ;-752     p = &LabelNames;
1868                
1868                ;Function : searchLabel, Number of local variables: 2
1868                ;   # type sign width addr used name   list of local variables
1868                ;  200 var sign word   751 NULL LIx = bp-2
1868                ;  201 ptr sign byte   751 NULL p = bp-4;
1868 C8 04 00 00     ENTER  4,0
186C B8 5A 77        mov ax, LabelNames
186F 89 46 FC        mov [bp-4], ax
1872                
1872                ;-753     LIx = 1;
1872                
1872 B8 01 00        mov ax, 1
1875 89 46 FE        mov [bp-2], ax
1878                
1878                ;-754     while (LIx <= LabelMaxIx) {
1878                
1878                .searchLabel157:
1878 8B 46 FE        mov ax, [bp-2]
187B 3B 06 4A 01     cmp ax, [LabelMaxIx]
187F 0F 8F 00 00   r jg  .searchLabel158
1883                
1883                ;-755         if (eqstr(p, Symbol)) return LIx;//pos of label
1883                
1883 8D 06 30 75     lea  ax, [Symbol]
1887 50              push ax
1888 55              push word [bp-4]
1889 E8 D4 E9        call eqstr
188C 83 C4 04        add  sp, 4
188F 08 C0           or  al, al
1891 0F 84 00 00   r je .searchLabel159
1895 8B 46 FE        mov ax, [bp-2]
1898 E9 00 00      R jmp .retnsearchLabel
189B                
189B                ;-756         p=strlen(p) + p;
189B                
189B                .searchLabel159:
189B 55              push word [bp-4]
189C E8 63 E9        call strlen
189F 83 C4 02        add  sp, 2
18A2 03 46 FC        add ax, [bp-4]
18A5 89 46 FC        mov [bp-4], ax
18A8                
18A8                ;-757         p++;
18A8                
18A8 FF 46 FC        inc  word[bp-4]
18AB                
18AB                ;-758         LIx++;
18AB                
18AB FF 46 FE        inc  word[bp-2]
18AE                
18AE                ;-759     }
18AE                
18AE                
18AE                ;-760     return 0;
18AE                
18AE EB C8           jmp .searchLabel157
18B0                .searchLabel158:
18B0 B8 00 00        mov ax, 0
18B3 E9 00 00      R jmp .retnsearchLabel
18B6                
18B6                ;-761 }
18B6                
18B6                
18B6                ;-762 
18B6                
18B6                
18B6                ;-763 int getOp1() {//scan for a single operand
18B6                
18B6 C9              .retnsearchLabel: LEAVE
18B7 C3              ret
leaving: searchLabel, loc labels: 4, loc jmp forward: 4
18B8                ENDP
18B8                
entering: getOp1
18B8                getOp1: PROC
18B8                
18B8                ;-764 //return:0, IMM, REG, ADR (not MEM)
18B8                
18B8                
18B8                ;-765 //set   :R2Type, R2No by testReg
18B8                
18B8                
18B8                ;-766 //set   :LabelIx by searchLabel
18B8                
18B8                
18B8                ;-767     if (TokeType == 0)      return 0;
18B8                
18B8 A0 2C 01        mov al, [TokeType]
18BB 3C 00           cmp al, 0
18BD 0F 85 00 00   r jne .getOp1160
18C1 B8 00 00        mov ax, 0
18C4 E9 00 00      R jmp .retngetOp1
18C7                
18C7                ;-768     if (TokeType == DIGIT)  return IMM;
18C7                
18C7                .getOp1160:
18C7 A0 2C 01        mov al, [TokeType]
18CA 3C 01           cmp al, 1
18CC 0F 85 00 00   r jne .getOp1161
18D0 B8 01 00        mov ax, 1
18D3 E9 00 00      R jmp .retngetOp1
18D6                
18D6                ;-769     if (TokeType == ALNUME) {
18D6                
18D6                .getOp1161:
18D6 A0 2C 01        mov al, [TokeType]
18D9 3C 03           cmp al, 3
18DB 0F 85 00 00   r jne .getOp1162
18DF                
18DF                ;-770         R2No=testReg();
18DF                
18DF E8 2E EA        call testReg
18E2 A2 33 01        mov byte [R2No], al
18E5                
18E5                ;-771         if (R2Type)        return REG;
18E5                
18E5 A0 35 01        mov al, [R2Type]
18E8 08 C0           or  al, al
18EA 0F 84 00 00   r je .getOp1163
18EE B8 02 00        mov ax, 2
18F1 E9 00 00      R jmp .retngetOp1
18F4                
18F4                ;-772         LabelIx=searchLabel();
18F4                
18F4                .getOp1163:
18F4 E8 71 FF        call searchLabel
18F7 A3 4E 01        mov word [LabelIx], ax
18FA                
18FA                ;-773         return ADR;
18FA                
18FA B8 03 00        mov ax, 3
18FD E9 00 00      R jmp .retngetOp1
1900                
1900                ;-774     }
1900                
1900                
1900                ;-775     return 0;
1900                
1900                .getOp1162:
1900 B8 00 00        mov ax, 0
1903 E9 00 00      R jmp .retngetOp1
1906                
1906                ;-776 }
1906                
1906                
1906                ;-777 
1906                
1906                
1906                ;-778 int getIndReg1() {
1906                
1906                 .retngetOp1:
1906 C3              ret
leaving: getOp1, loc labels: 5, loc jmp forward: 9
1907                ENDP
1907                
entering: getIndReg1
1907                getIndReg1: PROC
1907                
1907                ;-779     if (R2Type !=WORD) indexerror();
1907                
1907 A0 35 01        mov al, [R2Type]
190A 3C 02           cmp al, 2
190C 0F 84 00 00   r je  .getIndReg1164
1910 E8 50 F2        call indexerror
1913                
1913                ;-780     if (R2No==3) rm=7;//BX
1913                
1913                .getIndReg1164:
1913 A0 33 01        mov al, [R2No]
1916 3C 03           cmp al, 3
1918 0F 85 00 00   r jne .getIndReg1165
191C B8 07 00        mov ax, 7
191F A2 3B 01        mov byte [rm], al
1922                
1922                ;-781     if (R2No==5) rm=6;//BP, change to BP+0
1922                
1922                .getIndReg1165:
1922 A0 33 01        mov al, [R2No]
1925 3C 05           cmp al, 5
1927 0F 85 00 00   r jne .getIndReg1166
192B B8 06 00        mov ax, 6
192E A2 3B 01        mov byte [rm], al
1931                
1931                ;-782     if (R2No==7) rm=5;//DI
1931                
1931                .getIndReg1166:
1931 A0 33 01        mov al, [R2No]
1934 3C 07           cmp al, 7
1936 0F 85 00 00   r jne .getIndReg1167
193A B8 05 00        mov ax, 5
193D A2 3B 01        mov byte [rm], al
1940                
1940                ;-783     if (R2No==6) rm=4;//SI
1940                
1940                .getIndReg1167:
1940 A0 33 01        mov al, [R2No]
1943 3C 06           cmp al, 6
1945 0F 85 00 00   r jne .getIndReg1168
1949 B8 04 00        mov ax, 4
194C A2 3B 01        mov byte [rm], al
194F                
194F                ;-784     if (rm==0) indexerror();
194F                
194F                .getIndReg1168:
194F A0 3B 01        mov al, [rm]
1952 3C 00           cmp al, 0
1954 0F 85 00 00   r jne .getIndReg1169
1958 E8 08 F2        call indexerror
195B                
195B                ;-785 }
195B                
195B                .getIndReg1169:
195B                
195B                ;-786 int getIndReg2() {char m; m=4;//because m=0 is BX+DI
195B                
195B C3              ret
leaving: getIndReg1, loc labels: 6, loc jmp forward: 6
195C                ENDP
195C                
entering: getIndReg2
195C                getIndReg2: PROC
195C                ;Function : getIndReg2, Number of local variables: 1
195C                ;   # type sign width addr used name   list of local variables
195C                ;  200 var sign byte   786 NULL m = bp-2;
195C C8 02 00 00     ENTER  2,0
1960 B8 04 00        mov ax, 4
1963 88 46 FE        mov [bp-2], al
1966                
1966                ;-787     if (R2Type !=WORD) indexerror();
1966                
1966 A0 35 01        mov al, [R2Type]
1969 3C 02           cmp al, 2
196B 0F 84 00 00   r je  .getIndReg2170
196F E8 F1 F1        call indexerror
1972                
1972                ;-788     if (R2No==7) if (rm==6) m=3;//BP+DI
1972                
1972                .getIndReg2170:
1972 A0 33 01        mov al, [R2No]
1975 3C 07           cmp al, 7
1977 0F 85 00 00   r jne .getIndReg2171
197B A0 3B 01        mov al, [rm]
197E 3C 06           cmp al, 6
1980 0F 85 00 00   r jne .getIndReg2172
1984 B8 03 00        mov ax, 3
1987 88 46 FE        mov [bp-2], al
198A                
198A                ;-789              else if (rm==7) m=1;//BX+DI
198A                
198A E9 00 00      R jmp .getIndReg2173
198D                .getIndReg2172:
198D A0 3B 01        mov al, [rm]
1990 3C 07           cmp al, 7
1992 0F 85 00 00   r jne .getIndReg2174
1996 B8 01 00        mov ax, 1
1999 88 46 FE        mov [bp-2], al
199C                
199C                ;-790     if (R2No==6) if (rm==6) m=2;//BP+SI
199C                
199C                .getIndReg2174:
199C                .getIndReg2173:
199C                .getIndReg2171:
199C A0 33 01        mov al, [R2No]
199F 3C 06           cmp al, 6
19A1 0F 85 00 00   r jne .getIndReg2175
19A5 A0 3B 01        mov al, [rm]
19A8 3C 06           cmp al, 6
19AA 0F 85 00 00   r jne .getIndReg2176
19AE B8 02 00        mov ax, 2
19B1 88 46 FE        mov [bp-2], al
19B4                
19B4                ;-791              else if (rm==7) m=0;//BX+SI
19B4                
19B4 E9 00 00      R jmp .getIndReg2177
19B7                .getIndReg2176:
19B7 A0 3B 01        mov al, [rm]
19BA 3C 07           cmp al, 7
19BC 0F 85 00 00   r jne .getIndReg2178
19C0 B8 00 00        mov ax, 0
19C3 88 46 FE        mov [bp-2], al
19C6                
19C6                ;-792     if (m > 3) indexerror();
19C6                
19C6                .getIndReg2178:
19C6                .getIndReg2177:
19C6                .getIndReg2175:
19C6 8A 46 FE        mov al, [bp-2]
19C9 3C 03           cmp al, 3
19CB 0F 8E 00 00   r jle .getIndReg2179
19CF E8 91 F1        call indexerror
19D2                
19D2                ;-793     return m;
19D2                
19D2                .getIndReg2179:
19D2 8A 46 FE        mov al, [bp-2]
19D5 E9 00 00      R jmp .retngetIndReg2
19D8                
19D8                ;-794 }
19D8                
19D8                
19D8                ;-795 int getMEM() {// e.g. [array+bp+si-4]
19D8                
19D8 C9              .retngetIndReg2: LEAVE
19D9 C3              ret
leaving: getIndReg2, loc labels: 11, loc jmp forward: 11
19DA                ENDP
19DA                
entering: getMEM
19DA                getMEM: PROC
19DA                
19DA                ;-796 //set: disp, rm, R2Type
19DA                
19DA                
19DA                ;-797     char c;
19DA                
19DA                
19DA                ;-798     disp=0; rm=0;
19DA                
19DA                ;Function : getMEM, Number of local variables: 1
19DA                ;   # type sign width addr used name   list of local variables
19DA                ;  200 var sign byte   797 NULL c = bp-2;
19DA C8 02 00 00     ENTER  2,0
19DE B8 00 00        mov ax, 0
19E1 A3 3D 01        mov word [disp], ax
19E4 B8 00 00        mov ax, 0
19E7 A2 3B 01        mov byte [rm], al
19EA                
19EA                ;-799     do {
19EA                
19EA                .getMEM180:
19EA                
19EA                ;-800         getTokeType();
19EA                
19EA E8 DD FC        call getTokeType
19ED                
19ED                ;-801         c=getOp1();
19ED                
19ED E8 C8 FE        call getOp1
19F0 88 46 FE        mov [bp-2], al
19F3                
19F3                ;-802         if (c ==   0) syntaxerror();
19F3                
19F3 8A 46 FE        mov al, [bp-2]
19F6 3C 00           cmp al, 0
19F8 0F 85 00 00   r jne .getMEM181
19FC E8 39 F2        call syntaxerror
19FF                
19FF                ;-803         if (c == REG) {
19FF                
19FF                .getMEM181:
19FF 8A 46 FE        mov al, [bp-2]
1A02 3C 02           cmp al, 2
1A04 0F 85 00 00   r jne .getMEM182
1A08                
1A08                ;-804             isDirect=0;
1A08                
1A08 B8 00 00        mov ax, 0
1A0B A2 3C 01        mov byte [isDirect], al
1A0E                
1A0E                ;-805             if (rm) rm=getIndReg2();
1A0E                
1A0E A0 3B 01        mov al, [rm]
1A11 08 C0           or  al, al
1A13 0F 84 00 00   r je .getMEM183
1A17 E8 42 FF        call getIndReg2
1A1A A2 3B 01        mov byte [rm], al
1A1D                
1A1D                ;-806             else getIndReg1();
1A1D                
1A1D E9 00 00      R jmp .getMEM184
1A20                .getMEM183:
1A20 E8 E4 FE        call getIndReg1
1A23                
1A23                ;-807         }
1A23                
1A23                .getMEM184:
1A23                
1A23                ;-808         if (c == ADR) {
1A23                
1A23                .getMEM182:
1A23 8A 46 FE        mov al, [bp-2]
1A26 3C 03           cmp al, 3
1A28 0F 85 00 00   r jne .getMEM185
1A2C                
1A2C                ;-809             if (LabelIx)    disp=disp+LabelAddr[LabelIx];
1A2C                
1A2C A1 4E 01        mov ax, [LabelIx]
1A2F 08 C0           or  al, al
1A31 0F 84 00 00   r je .getMEM186
1A35 A1 3D 01        mov ax, [disp]
1A38 8B 1E 4E 01     mov bx, [LabelIx]
1A3C D1 E3           shl bx, 1
1A3E 03 47 CA        add ax, [LabelAddr + bx]
1A41 A3 3D 01        mov word [disp], ax
1A44                
1A44                ;-810             else notfounderror();
1A44                
1A44 E9 00 00      R jmp .getMEM187
1A47                .getMEM186:
1A47 E8 5E F0        call notfounderror
1A4A                
1A4A                ;-811         }
1A4A                
1A4A                .getMEM187:
1A4A                
1A4A                ;-812         if (c == IMM) disp=disp+SymbolInt;
1A4A                
1A4A                .getMEM185:
1A4A 8A 46 FE        mov al, [bp-2]
1A4D 3C 01           cmp al, 1
1A4F 0F 85 00 00   r jne .getMEM188
1A53 A1 3D 01        mov ax, [disp]
1A56 03 06 0E 01     add ax, [SymbolInt]
1A5A A3 3D 01        mov word [disp], ax
1A5D                
1A5D                ;-813         if (isToken('-')) {
1A5D                
1A5D                .getMEM188:
1A5D 6A 2D           push 45
1A5F E8 F4 FC        call isToken
1A62 83 C4 02        add  sp, 2
1A65 08 C0           or  al, al
1A67 0F 84 00 00   r je .getMEM189
1A6B                
1A6B                ;-814             getTokeType();
1A6B                
1A6B E8 5C FC        call getTokeType
1A6E                
1A6E                ;-815             if (TokeType != DIGIT) numbererror();
1A6E                
1A6E A0 2C 01        mov al, [TokeType]
1A71 3C 01           cmp al, 1
1A73 0F 84 00 00   r je  .getMEM190
1A77 E8 2B F1        call numbererror
1A7A                
1A7A                ;-816             disp = disp - SymbolInt;
1A7A                
1A7A                .getMEM190:
1A7A A1 3D 01        mov ax, [disp]
1A7D 2B 06 0E 01     sub ax, [SymbolInt]
1A81 A3 3D 01        mov word [disp], ax
1A84                
1A84                ;-817         }
1A84                
1A84                
1A84                ;-818     } while (isToken('+'));
1A84                
1A84                .getMEM189:
1A84 6A 2B           push 43
1A86 E8 CD FC        call isToken
1A89 83 C4 02        add  sp, 2
1A8C 08 C0           or  al, al
1A8E 0F 84 00 00   r je .getMEM191
1A92 E9 55 FF        jmp .getMEM180
1A95                .getMEM191:
1A95                
1A95                ;-819     if (isToken(']') == 0) errorexit("] expected");
1A95                
1A95 6A 5D           push 93
1A97 E8 BC FC        call isToken
1A9A 83 C4 02        add  sp, 2
1A9D 83 F8 00        cmp ax, 0
1AA0 0F 85 00 00   r jne .getMEM192
1AA4 68 AA AA      A push getMEM_0
1AA7 E8 E6 EF        call errorexit
1AAA 83 C4 02        add  sp, 2
1AAD                
1AAD                ;-820 }
1AAD                
1AAD                .getMEM192:
1AAD                
1AAD                ;-821 
1AAD                
1AAD                
1AAD                ;-822 int getOpR() {
1AAD C9              LEAVE
1AAE C3              ret
1AAF 5D 20 65 78 70 getMEM_0 db "] expected",0
leaving: getMEM, loc labels: 14, loc jmp forward: 13
1ABA                ENDP
1ABA                
entering: getOpR
1ABA                getOpR: PROC
1ABA                
1ABA                ;-823     Op2=getOp1();
1ABA                
1ABA E8 FB FD        call getOp1
1ABD A2 2E 01        mov byte [Op2], al
1AC0                
1AC0                ;-824     if (isToken('[')) {Op2 = MEM; getMEM();    return;}
1AC0                
1AC0 6A 5B           push 91
1AC2 E8 91 FC        call isToken
1AC5 83 C4 02        add  sp, 2
1AC8 08 C0           or  al, al
1ACA 0F 84 00 00   r je .getOpR193
1ACE B8 04 00        mov ax, 4
1AD1 A2 2E 01        mov byte [Op2], al
1AD4 E8 03 FF        call getMEM
1AD7 E9 00 00      R jmp .retngetOpR
1ADA                
1ADA                ;-825     if (Op2 == 0)     {invaloperror();         return;}
1ADA                
1ADA                .getOpR193:
1ADA A0 2E 01        mov al, [Op2]
1ADD 3C 00           cmp al, 0
1ADF 0F 85 00 00   r jne .getOpR194
1AE3 E8 9E F0        call invaloperror
1AE6 E9 00 00      R jmp .retngetOpR
1AE9                
1AE9                ;-826     if (Op2 == IMM)   {imme=SymbolInt;         return;}
1AE9                
1AE9                .getOpR194:
1AE9 A0 2E 01        mov al, [Op2]
1AEC 3C 01           cmp al, 1
1AEE 0F 85 00 00   r jne .getOpR195
1AF2 A1 0E 01        mov ax, [SymbolInt]
1AF5 A3 3F 01        mov word [imme], ax
1AF8 E9 00 00      R jmp .retngetOpR
1AFB                
1AFB                ;-827     if (Op2 == REG)                            return;
1AFB                
1AFB                .getOpR195:
1AFB A0 2E 01        mov al, [Op2]
1AFE 3C 02           cmp al, 2
1B00 0F 85 00 00   r jne .getOpR196
1B04 E9 00 00      R jmp .retngetOpR
1B07                
1B07                ;-828     if (Op2 == ADR)   {
1B07                
1B07                .getOpR196:
1B07 A0 2E 01        mov al, [Op2]
1B0A 3C 03           cmp al, 3
1B0C 0F 85 00 00   r jne .getOpR197
1B10                
1B10                ;-829         if (LabelIx == 0) disp=0;
1B10                
1B10 A1 4E 01        mov ax, [LabelIx]
1B13 83 F8 00        cmp ax, 0
1B16 0F 85 00 00   r jne .getOpR198
1B1A B8 00 00        mov ax, 0
1B1D A3 3D 01        mov word [disp], ax
1B20                
1B20                ;-830         else disp=LabelAddr[LabelIx];
1B20                
1B20 E9 00 00      R jmp .getOpR199
1B23                .getOpR198:
1B23 8B 1E 4E 01     mov bx, [LabelIx]
1B27 D1 E3           shl bx, 1
1B29 8B 47 CA        mov ax, [LabelAddr + bx]
1B2C A3 3D 01        mov word [disp], ax
1B2F                
1B2F                ;-831         return;}
1B2F                
1B2F                .getOpR199:
1B2F E9 00 00      R jmp .retngetOpR
1B32                
1B32                ;-832     error1("Name of operand expected");
1B32                
1B32                .getOpR197:
1B32 68 AA AA      A push getOpR_0
1B35 E8 03 EF        call error1
1B38 83 C4 02        add  sp, 2
1B3B                
1B3B                ;-833 }
1B3B                
1B3B                
1B3B                ;-834 
1B3B                
1B3B                
1B3B                ;-835 int getOpL() {//set: op=0,IMM,REG,ADR,MEM
1B3B                
1B3B                 .retngetOpR:
1B3B C3              ret
1B3C 4E 61 6D 65 20 getOpR_0 db "Name of operand expected",0
leaving: getOpR, loc labels: 9, loc jmp forward: 13
1B55                ENDP
1B55                
entering: getOpL
1B55                getOpL: PROC
1B55                
1B55                ;-836     getOpR();
1B55                
1B55 E8 62 FF        call getOpR
1B58                
1B58                ;-837     Op=Op2;         Op2=0;
1B58                
1B58 A0 2E 01        mov al, [Op2]
1B5B A2 2D 01        mov byte [Op], al
1B5E B8 00 00        mov ax, 0
1B61 A2 2E 01        mov byte [Op2], al
1B64                
1B64                ;-838     R1No=R2No;      R2No=0;
1B64                
1B64 A0 33 01        mov al, [R2No]
1B67 A2 34 01        mov byte [R1No], al
1B6A B8 00 00        mov ax, 0
1B6D A2 33 01        mov byte [R2No], al
1B70                
1B70                ;-839     R1Type=R2Type; R2Type=0;
1B70                
1B70 A0 35 01        mov al, [R2Type]
1B73 A2 36 01        mov byte [R1Type], al
1B76 B8 00 00        mov ax, 0
1B79 A2 35 01        mov byte [R2Type], al
1B7C                
1B7C                ;-840 }
1B7C                
1B7C                
1B7C                ;-841 
1B7C                
1B7C                
1B7C                ;-842 int get2Ops() {
1B7C                
1B7C C3              ret
leaving: getOpL, loc labels: 0, loc jmp forward: 0
1B7D                ENDP
1B7D                
entering: get2Ops
1B7D                get2Ops: PROC
1B7D                
1B7D                ;-843     getOpL();
1B7D                
1B7D E8 D5 FF        call getOpL
1B80                
1B80                ;-844     need(',');
1B80                
1B80 6A 2C           push 44
1B82 E8 F9 FB        call need
1B85 83 C4 02        add  sp, 2
1B88                
1B88                ;-845     getOpR();
1B88                
1B88 E8 2F FF        call getOpR
1B8B                
1B8B                ;-846 }
1B8B                
1B8B                
1B8B                ;-847 int check2Ops() {
1B8B                
1B8B C3              ret
leaving: get2Ops, loc labels: 0, loc jmp forward: 0
1B8C                ENDP
1B8C                
entering: check2Ops
1B8C                check2Ops: PROC
1B8C                
1B8C                ;-848     get2Ops();
1B8C                
1B8C E8 EE FF        call get2Ops
1B8F                
1B8F                ;-849     if (Op ==   0) addrerror();
1B8F                
1B8F A0 2D 01        mov al, [Op]
1B92 3C 00           cmp al, 0
1B94 0F 85 00 00   r jne .check2Ops200
1B98 E8 6F EF        call addrerror
1B9B                
1B9B                ;-850     if (Op == ADR) invaloperror();
1B9B                
1B9B                .check2Ops200:
1B9B A0 2D 01        mov al, [Op]
1B9E 3C 03           cmp al, 3
1BA0 0F 85 00 00   r jne .check2Ops201
1BA4 E8 DD EF        call invaloperror
1BA7                
1BA7                ;-851     if (Op == IMM) immeerror();
1BA7                
1BA7                .check2Ops201:
1BA7 A0 2D 01        mov al, [Op]
1BAA 3C 01           cmp al, 1
1BAC 0F 85 00 00   r jne .check2Ops202
1BB0 E8 71 EF        call immeerror
1BB3                
1BB3                ;-852     if (Op2==   0) addrerror();
1BB3                
1BB3                .check2Ops202:
1BB3 A0 2E 01        mov al, [Op2]
1BB6 3C 00           cmp al, 0
1BB8 0F 85 00 00   r jne .check2Ops203
1BBC E8 4B EF        call addrerror
1BBF                
1BBF                ;-853     if (CodeType != 5) if (Op2==ADR) invaloperror();//only mov
1BBF                
1BBF                .check2Ops203:
1BBF A0 2F 01        mov al, [CodeType]
1BC2 3C 05           cmp al, 5
1BC4 0F 84 00 00   r je  .check2Ops204
1BC8 A0 2E 01        mov al, [Op2]
1BCB 3C 03           cmp al, 3
1BCD 0F 85 00 00   r jne .check2Ops205
1BD1 E8 B0 EF        call invaloperror
1BD4                
1BD4                ;-854     setwflag();
1BD4                
1BD4                .check2Ops205:
1BD4                .check2Ops204:
1BD4 E8 BC F9        call setwflag
1BD7                
1BD7                ;-855 }
1BD7                
1BD7                
1BD7                ;-856 
1BD7                
1BD7                
1BD7                ;-857 int storeJmp() {
1BD7                
1BD7 C3              ret
leaving: check2Ops, loc labels: 6, loc jmp forward: 6
1BD8                ENDP
1BD8                
entering: storeJmp
1BD8                storeJmp: PROC
1BD8                
1BD8                ;-858     unsigned int i;
1BD8                
1BD8                
1BD8                ;-859     JmpMaxIx++;
1BD8                
1BD8                ;Function : storeJmp, Number of local variables: 1
1BD8                ;   # type sign width addr used name   list of local variables
1BD8                ;  200 var unsg word   858 NULL i = bp-2;
1BD8 C8 02 00 00     ENTER  2,0
1BDC FF 06 54 01     inc  word[JmpMaxIx]
1BE0                
1BE0                ;-860     if (JmpMaxIx >= JMPMAX) errorexit("too many Jmp");
1BE0                
1BE0 A1 54 01        mov ax, [JmpMaxIx]
1BE3 3D C8 00        cmp ax, 200 ;unsigned : 1
1BE6 0F 8C 00 00   r jl  .storeJmp206
1BEA 68 AA AA      A push storeJmp_0
1BED E8 A0 EE        call errorexit
1BF0 83 C4 02        add  sp, 2
1BF3                
1BF3                ;-861     JmpNamePtr=strcpy(JmpNamePtr, Symbol);
1BF3                
1BF3                .storeJmp206:
1BF3 8D 06 30 75     lea  ax, [Symbol]
1BF7 50              push ax
1BF8 FF 36 50 01     push word [JmpNamePtr]
1BFC E8 2B E6        call strcpy
1BFF 83 C4 04        add  sp, 4
1C02 A3 50 01        mov word [JmpNamePtr], ax
1C05                
1C05                ;-862     JmpNamePtr++;
1C05                
1C05 FF 06 50 01     inc  word[JmpNamePtr]
1C09                
1C09                ;-863     i = JmpNamePtr - &JmpNames;
1C09                
1C09 A1 50 01        mov ax, [JmpNamePtr]
******* next line ERROR: invalid or no operands, Symbol: JmpNames
******* next line ERROR: syntax, Symbol: JmpNames
1C0C                 sub ax, JmpNames
1C0C 89 46 FE        mov [bp-2], ax
1C0F                
1C0F                ;-864     if ( i >= JMPNAMESMAX) errorexit("too many Jmp names");
1C0F                
1C0F 8B 46 FE        mov ax, [bp-2]
1C12 3D 81 0F        cmp ax, 3969 ;unsigned : 0
1C15 0F 82 00 00   r jb  .storeJmp207
1C19 68 AA AA      A push storeJmp_1
1C1C E8 71 EE        call errorexit
1C1F 83 C4 02        add  sp, 2
1C22                
1C22                ;-865     JmpAddr[JmpMaxIx] = PC;
1C22                
1C22                .storeJmp207:
1C22 A1 23 01        mov ax, [PC]
1C25 8B 1E 54 01     mov bx, [JmpMaxIx]
1C29 D1 E3           shl bx, 1
1C2B 89 47 1A        mov [JmpAddr+bx], ax
1C2E                
1C2E                ;-866 }
1C2E                
1C2E                
1C2E                ;-867 
1C2E                
1C2E                
1C2E                ;-868 int storeLabel() {
1C2E C9              LEAVE
1C2F C3              ret
1C30 74 6F 6F 20 6D storeJmp_0 db "too many Jmp",0
1C3D 74 6F 6F 20 6D storeJmp_1 db "too many Jmp names",0
leaving: storeJmp, loc labels: 4, loc jmp forward: 4
1C50                ENDP
1C50                
entering: storeLabel
1C50                storeLabel: PROC
1C50                
1C50                ;-869     unsigned int i;
1C50                
1C50                
1C50                ;-870     if(searchLabel()) error1("duplicate label");
1C50                
1C50                ;Function : storeLabel, Number of local variables: 1
1C50                ;   # type sign width addr used name   list of local variables
1C50                ;  200 var unsg word   869 NULL i = bp-2;
1C50 C8 02 00 00     ENTER  2,0
1C54 E8 11 FC        call searchLabel
1C57 08 C0           or  al, al
1C59 0F 84 00 00   r je .storeLabel208
1C5D 68 AA AA      A push storeLabel_0
1C60 E8 D8 ED        call error1
1C63 83 C4 02        add  sp, 2
1C66                
1C66                ;-871     LabelMaxIx++;
1C66                
1C66                .storeLabel208:
1C66 FF 06 4A 01     inc  word[LabelMaxIx]
1C6A                
1C6A                ;-872     if (LabelMaxIx >= LABELADRMAX) errorexit("too many labels");
1C6A                
1C6A A1 4A 01        mov ax, [LabelMaxIx]
1C6D 3D 58 02        cmp ax, 600 ;unsigned : 1
1C70 0F 8C 00 00   r jl  .storeLabel209
1C74 68 AA AA      A push storeLabel_1
1C77 E8 16 EE        call errorexit
1C7A 83 C4 02        add  sp, 2
1C7D                
1C7D                ;-873     LabelNamePtr=strcpy(LabelNamePtr, Symbol);
1C7D                
1C7D                .storeLabel209:
1C7D 8D 06 30 75     lea  ax, [Symbol]
1C81 50              push ax
1C82 FF 36 46 01     push word [LabelNamePtr]
1C86 E8 A1 E5        call strcpy
1C89 83 C4 04        add  sp, 4
1C8C A3 46 01        mov word [LabelNamePtr], ax
1C8F                
1C8F                ;-874     LabelNamePtr++;
1C8F                
1C8F FF 06 46 01     inc  word[LabelNamePtr]
1C93                
1C93                ;-875     i = LabelNamePtr - &LabelNames;
1C93                
1C93 A1 46 01        mov ax, [LabelNamePtr]
******* next line ERROR: invalid or no operands, Symbol: LabelNames
******* next line ERROR: syntax, Symbol: LabelNames
1C96                 sub ax, LabelNames
1C96 89 46 FE        mov [bp-2], ax
1C99                
1C99                ;-876     if (i >= LABELNAMESMAX) errorexit("too many label names");
1C99                
1C99 8B 46 FE        mov ax, [bp-2]
1C9C 3D 51 17        cmp ax, 5969 ;unsigned : 0
1C9F 0F 82 00 00   r jb  .storeLabel210
1CA3 68 AA AA      A push storeLabel_2
1CA6 E8 E7 ED        call errorexit
1CA9 83 C4 02        add  sp, 2
1CAC                
1CAC                ;-877     LabelAddr[LabelMaxIx] = PC + Origin;
1CAC                
1CAC                .storeLabel210:
1CAC A1 23 01        mov ax, [PC]
1CAF 03 06 25 01     add ax, [Origin]
1CB3 8B 1E 4A 01     mov bx, [LabelMaxIx]
1CB7 D1 E3           shl bx, 1
1CB9 89 47 CA        mov [LabelAddr+bx], ax
1CBC                
1CBC                ;-878 }
1CBC                
1CBC                
1CBC                ;-879 
1CBC                
1CBC                
1CBC                ;-880 
1CBC                
1CBC                
1CBC                ;-881 int genDB() {
1CBC C9              LEAVE
1CBD C3              ret
1CBE 64 75 70 6C 69 storeLabel_0 db "duplicate label",0
1CCE 74 6F 6F 20 6D storeLabel_1 db "too many labels",0
1CDE 74 6F 6F 20 6D storeLabel_2 db "too many label names",0
leaving: storeLabel, loc labels: 6, loc jmp forward: 6
1CF3                ENDP
1CF3                
entering: genDB
1CF3                genDB: PROC
1CF3                
1CF3                ;-882     char c;  char isloop;
1CF3                
1CF3                
1CF3                ;-883         isloop = 0;
1CF3                
1CF3                ;Function : genDB, Number of local variables: 2
1CF3                ;   # type sign width addr used name   list of local variables
1CF3                ;  200 var sign byte   882 NULL c = bp-2
1CF3                ;  201 var sign byte   882 NULL isloop = bp-4;
1CF3 C8 04 00 00     ENTER  4,0
1CF7 B8 00 00        mov ax, 0
1CFA 88 46 FC        mov [bp-4], al
1CFD                
1CFD                ;-884             do {
1CFD                
1CFD                .genDB211:
1CFD                
1CFD                ;-885                 if (isloop) getTokeType();//omit ,  
1CFD                
1CFD 8A 46 FC        mov al, [bp-4]
1D00 08 C0           or  al, al
1D02 0F 84 00 00   r je .genDB212
1D06 E8 C1 F9        call getTokeType
1D09                
1D09                ;-886                 if (TokeType == DIGIT) genCode8(SymbolInt);
1D09                
1D09                .genDB212:
1D09 A0 2C 01        mov al, [TokeType]
1D0C 3C 01           cmp al, 1
1D0E 0F 85 00 00   r jne .genDB213
1D12 FF 36 0E 01     push word [SymbolInt]
1D16 E8 60 F6        call genCode8
1D19 83 C4 02        add  sp, 2
1D1C                
1D1C                ;-887                 else {
1D1C                
1D1C E9 00 00      R jmp .genDB214
1D1F                .genDB213:
1D1F                
1D1F                ;-888                     skipBlank();
1D1F                
1D1F E8 A7 F0        call skipBlank
1D22                
1D22                ;-889                     if (isToken('"')) {
1D22                
1D22 6A 22           push 34
1D24 E8 2F FA        call isToken
1D27 83 C4 02        add  sp, 2
1D2A 08 C0           or  al, al
1D2C 0F 84 00 00   r je .genDB215
1D30                
1D30                ;-890                         do {
1D30                
1D30                .genDB216:
1D30                
1D30                ;-891                             c= *InputPtr;
1D30                
1D30 8B 1E 14 01     mov bx, [InputPtr]
1D34 8A 07           mov al, [bx]
1D36 B4 00           mov ah, 0
1D38 88 46 FE        mov [bp-2], al
1D3B                
1D3B                ;-892                             genCode8(c);
1D3B                
1D3B 8A 46 FE        mov al, byte [bp-2]
1D3E B4 00           mov ah, 0
1D40 50              push ax
1D41 E8 35 F6        call genCode8
1D44 83 C4 02        add  sp, 2
1D47                
1D47                ;-893                             InputPtr++;
1D47                
1D47 FF 06 14 01     inc  word[InputPtr]
1D4B                
1D4B                ;-894                         } while (*InputPtr != '"' );
1D4B                
1D4B 8B 1E 14 01     mov bx, [InputPtr]
1D4F 8A 07           mov al, [bx]
1D51 B4 00           mov ah, 0
1D53 83 F8 22        cmp ax, 34
1D56 0F 84 00 00   r je  .genDB217
1D5A EB D4           jmp .genDB216
1D5C                .genDB217:
1D5C                
1D5C                ;-895                         InputPtr++;
1D5C                
1D5C FF 06 14 01     inc  word[InputPtr]
1D60                
1D60                ;-896                     }
1D60                
1D60                
1D60                ;-897                 } 
1D60                
1D60                .genDB215:
1D60                
1D60                ;-898                 isloop = 1;
1D60                
1D60                .genDB214:
1D60 B8 01 00        mov ax, 1
1D63 88 46 FC        mov [bp-4], al
1D66                
1D66                ;-899             } while (isToken(','));
1D66                
1D66 6A 2C           push 44
1D68 E8 EB F9        call isToken
1D6B 83 C4 02        add  sp, 2
1D6E 08 C0           or  al, al
1D70 0F 84 00 00   r je .genDB218
1D74 EB 87           jmp .genDB211
1D76                .genDB218:
1D76                
1D76                ;-900 }
1D76                
1D76                
1D76                ;-901 
1D76                
1D76                
1D76                ;-902 int getVariable() {
1D76 C9              LEAVE
1D77 C3              ret
leaving: genDB, loc labels: 8, loc jmp forward: 6
1D78                ENDP
1D78                
entering: getVariable
1D78                getVariable: PROC
1D78                
1D78                ;-903     char c;
1D78                
1D78                
1D78                ;-904     storeLabel();
1D78                
1D78                ;Function : getVariable, Number of local variables: 1
1D78                ;   # type sign width addr used name   list of local variables
1D78                ;  200 var sign byte   903 NULL c = bp-2;
1D78 C8 02 00 00     ENTER  2,0
1D7C E8 D1 FE        call storeLabel
1D7F                
1D7F                ;-905     getTokeType();
1D7F                
1D7F E8 48 F9        call getTokeType
1D82                
1D82                ;-906     if(TokeType==ALNUME) {//getName
1D82                
1D82 A0 2C 01        mov al, [TokeType]
1D85 3C 03           cmp al, 3
1D87 0F 85 00 00   r jne .getVariable219
1D8B                
1D8B                ;-907         lookCode();
1D8B                
1D8B E8 74 F5        call lookCode
1D8E                
1D8E                ;-908         if (CodeType < 200) dataexit();
1D8E                
1D8E A0 2F 01        mov al, [CodeType]
1D91 3C C8           cmp al, 200
1D93 0F 8D 00 00   r jge .getVariable220
1D97 E8 C9 EE        call dataexit
1D9A                
1D9A                ;-909         if (CodeType > 205) dataexit();
1D9A                
1D9A                .getVariable220:
1D9A A0 2F 01        mov al, [CodeType]
1D9D 3C CD           cmp al, 205
1D9F 0F 8E 00 00   r jle .getVariable221
1DA3 E8 BD EE        call dataexit
1DA6                
1DA6                ;-910         if (CodeType== 200) {//DB
1DA6                
1DA6                .getVariable221:
1DA6 A0 2F 01        mov al, [CodeType]
1DA9 3C C8           cmp al, 200
1DAB 0F 85 00 00   r jne .getVariable222
1DAF                
1DAF                ;-911             do {
1DAF                
1DAF                .getVariable223:
1DAF                
1DAF                ;-912                 getTokeType();
1DAF                
1DAF E8 18 F9        call getTokeType
1DB2                
1DB2                ;-913                 if (TokeType == DIGIT) genCode8(SymbolInt);
1DB2                
1DB2 A0 2C 01        mov al, [TokeType]
1DB5 3C 01           cmp al, 1
1DB7 0F 85 00 00   r jne .getVariable224
1DBB FF 36 0E 01     push word [SymbolInt]
1DBF E8 B7 F5        call genCode8
1DC2 83 C4 02        add  sp, 2
1DC5                
1DC5                ;-914                 else {
1DC5                
1DC5 E9 00 00      R jmp .getVariable225
1DC8                .getVariable224:
1DC8                
1DC8                ;-915                     skipBlank();
1DC8                
1DC8 E8 FE EF        call skipBlank
1DCB                
1DCB                ;-916                     if (isToken('"')) {
1DCB                
1DCB 6A 22           push 34
1DCD E8 86 F9        call isToken
1DD0 83 C4 02        add  sp, 2
1DD3 08 C0           or  al, al
1DD5 0F 84 00 00   r je .getVariable226
1DD9                
1DD9                ;-917                         do {
1DD9                
1DD9                .getVariable227:
1DD9                
1DD9                ;-918                             c= *InputPtr;
1DD9                
1DD9 8B 1E 14 01     mov bx, [InputPtr]
1DDD 8A 07           mov al, [bx]
1DDF B4 00           mov ah, 0
1DE1 88 46 FE        mov [bp-2], al
1DE4                
1DE4                ;-919                             genCode8(c);
1DE4                
1DE4 8A 46 FE        mov al, byte [bp-2]
1DE7 B4 00           mov ah, 0
1DE9 50              push ax
1DEA E8 8C F5        call genCode8
1DED 83 C4 02        add  sp, 2
1DF0                
1DF0                ;-920                             InputPtr++;
1DF0                
1DF0 FF 06 14 01     inc  word[InputPtr]
1DF4                
1DF4                ;-921                         } while (*InputPtr != '"' );
1DF4                
1DF4 8B 1E 14 01     mov bx, [InputPtr]
1DF8 8A 07           mov al, [bx]
1DFA B4 00           mov ah, 0
1DFC 83 F8 22        cmp ax, 34
1DFF 0F 84 00 00   r je  .getVariable228
1E03 EB D4           jmp .getVariable227
1E05                .getVariable228:
1E05                
1E05                ;-922                         InputPtr++;
1E05                
1E05 FF 06 14 01     inc  word[InputPtr]
1E09                
1E09                ;-923                     }
1E09                
1E09                
1E09                ;-924                 }
1E09                
1E09                .getVariable226:
1E09                
1E09                ;-925             } while (isToken(','));
1E09                
1E09                .getVariable225:
1E09 6A 2C           push 44
1E0B E8 48 F9        call isToken
1E0E 83 C4 02        add  sp, 2
1E11 08 C0           or  al, al
1E13 0F 84 00 00   r je .getVariable229
1E17 EB 96           jmp .getVariable223
1E19                .getVariable229:
1E19                
1E19                ;-926         }
1E19                
1E19                
1E19                ;-927         if (CodeType == 201) {//DW
1E19                
1E19                .getVariable222:
1E19 A0 2F 01        mov al, [CodeType]
1E1C 3C C9           cmp al, 201
1E1E 0F 85 00 00   r jne .getVariable230
1E22                
1E22                ;-928             do {
1E22                
1E22                .getVariable231:
1E22                
1E22                ;-929                 getTokeType();
1E22                
1E22 E8 A5 F8        call getTokeType
1E25                
1E25                ;-930                 if (TokeType ==DIGIT) genCode16(SymbolInt);
1E25                
1E25 A0 2C 01        mov al, [TokeType]
1E28 3C 01           cmp al, 1
1E2A 0F 85 00 00   r jne .getVariable232
1E2E FF 36 0E 01     push word [SymbolInt]
1E32 E8 DA F5        call genCode16
1E35 83 C4 02        add  sp, 2
1E38                
1E38                ;-931             } while (isToken(','));
1E38                
1E38                .getVariable232:
1E38 6A 2C           push 44
1E3A E8 19 F9        call isToken
1E3D 83 C4 02        add  sp, 2
1E40 08 C0           or  al, al
1E42 0F 84 00 00   r je .getVariable233
1E46 EB DA           jmp .getVariable231
1E48                .getVariable233:
1E48                
1E48                ;-932         }
1E48                
1E48                
1E48                ;-933         if (CodeType == 202) {//DD
1E48                
1E48                .getVariable230:
1E48 A0 2F 01        mov al, [CodeType]
1E4B 3C CA           cmp al, 202
1E4D 0F 85 00 00   r jne .getVariable234
1E51                
1E51                ;-934             do {
1E51                
1E51                .getVariable235:
1E51                
1E51                ;-935                 getTokeType();
1E51                
1E51 E8 76 F8        call getTokeType
1E54                
1E54                ;-936                 if (TokeType ==DIGIT) { genCode16(SymbolInt);
1E54                
1E54 A0 2C 01        mov al, [TokeType]
1E57 3C 01           cmp al, 1
1E59 0F 85 00 00   r jne .getVariable236
1E5D FF 36 0E 01     push word [SymbolInt]
1E61 E8 AB F5        call genCode16
1E64 83 C4 02        add  sp, 2
1E67                
1E67                ;-937                                     genCode16(0);}//todo genCode32(SymbolLong);
1E67                
1E67 6A 00           push 0
1E69 E8 A3 F5        call genCode16
1E6C 83 C4 02        add  sp, 2
1E6F                
1E6F                ;-938             } while (isToken(','));
1E6F                
1E6F                .getVariable236:
1E6F 6A 2C           push 44
1E71 E8 E2 F8        call isToken
1E74 83 C4 02        add  sp, 2
1E77 08 C0           or  al, al
1E79 0F 84 00 00   r je .getVariable237
1E7D EB D2           jmp .getVariable235
1E7F                .getVariable237:
1E7F                
1E7F                ;-939         }
1E7F                
1E7F                
1E7F                ;-940         if (CodeType >= 203) {//resb, resw, resd
1E7F                
1E7F                .getVariable234:
1E7F A0 2F 01        mov al, [CodeType]
1E82 3C CB           cmp al, 203 ;unsigned : 1
1E84 0F 8C 00 00   r jl  .getVariable238
1E88                
1E88                ;-941             getTokeType();
1E88                
1E88 E8 3F F8        call getTokeType
1E8B                
1E8B                ;-942             if (TokeType == DIGIT) {
1E8B                
1E8B A0 2C 01        mov al, [TokeType]
1E8E 3C 01           cmp al, 1
1E90 0F 85 00 00   r jne .getVariable239
1E94                
1E94                ;-943                 if (SymbolInt <= 0) syntaxerror();
1E94                
1E94 A1 0E 01        mov ax, [SymbolInt]
1E97 83 F8 00        cmp ax, 0
1E9A 0F 87 00 00   r ja  .getVariable240
1E9E E8 97 ED        call syntaxerror
1EA1                
1EA1                ;-944                 if (AbsoluteLab == 0) error1("Absolute is null");
1EA1                
1EA1                .getVariable240:
1EA1 A1 27 01        mov ax, [AbsoluteLab]
1EA4 83 F8 00        cmp ax, 0
1EA7 0F 85 00 00   r jne .getVariable241
1EAB 68 AA AA      A push getVariable_0
1EAE E8 8A EB        call error1
1EB1 83 C4 02        add  sp, 2
1EB4                
1EB4                ;-945                 LabelAddr[LabelMaxIx] = AbsoluteLab;
1EB4                
1EB4                .getVariable241:
1EB4 A1 27 01        mov ax, [AbsoluteLab]
1EB7 8B 1E 4A 01     mov bx, [LabelMaxIx]
1EBB D1 E3           shl bx, 1
1EBD 89 47 CA        mov [LabelAddr+bx], ax
1EC0                
1EC0                ;-946                 if (CodeType == 204) SymbolInt=SymbolInt+SymbolInt;//resw
1EC0                
1EC0 A0 2F 01        mov al, [CodeType]
1EC3 3C CC           cmp al, 204
1EC5 0F 85 00 00   r jne .getVariable242
1EC9 A1 0E 01        mov ax, [SymbolInt]
1ECC 03 06 0E 01     add ax, [SymbolInt]
1ED0 A3 0E 01        mov word [SymbolInt], ax
1ED3                
1ED3                ;-947                 if (CodeType == 205) SymbolInt=SymbolInt * 4;//resd
1ED3                
1ED3                .getVariable242:
1ED3 A0 2F 01        mov al, [CodeType]
1ED6 3C CD           cmp al, 205
1ED8 0F 85 00 00   r jne .getVariable243
1EDC A1 0E 01        mov ax, [SymbolInt]
1EDF BB 04 00        mov bx, 4
1EE2 F7 E3           mul bx
1EE4 A3 0E 01        mov word [SymbolInt], ax
1EE7                
1EE7                ;-948                 AbsoluteLab = AbsoluteLab + SymbolInt;
1EE7                
1EE7                .getVariable243:
1EE7 A1 27 01        mov ax, [AbsoluteLab]
1EEA 03 06 0E 01     add ax, [SymbolInt]
1EEE A3 27 01        mov word [AbsoluteLab], ax
1EF1                
1EF1                ;-949             } else numbererror();
1EF1                
1EF1 E9 00 00      R jmp .getVariable244
1EF4                .getVariable239:
1EF4 E8 AE EC        call numbererror
1EF7                
1EF7                ;-950         }
1EF7                
1EF7                .getVariable244:
1EF7                
1EF7                ;-951     }
1EF7                
1EF7                .getVariable238:
1EF7                
1EF7                ;-952     else dataexit();
1EF7                
1EF7 E9 00 00      R jmp .getVariable245
1EFA                .getVariable219:
1EFA E8 66 ED        call dataexit
1EFD                
1EFD                ;-953 }
1EFD                
1EFD                .getVariable245:
1EFD                
1EFD                ;-954 
1EFD                
1EFD                
1EFD                ;-955 int getCodeSize() {
1EFD C9              LEAVE
1EFE C3              ret
1EFF 41 62 73 6F 6C getVariable_0 db "Absolute is null",0
leaving: getVariable, loc labels: 28, loc jmp forward: 24
1F10                ENDP
1F10                
entering: getCodeSize
1F10                getCodeSize: PROC
1F10                
1F10                ;-956     if (TokeType ==ALNUME) {
1F10                
1F10 A0 2C 01        mov al, [TokeType]
1F13 3C 03           cmp al, 3
1F15 0F 85 00 00   r jne .getCodeSize246
1F19                
1F19                ;-957         if (eqstr(SymbolUpper,"BYTE")) {getTokeType(); return BYTE;}
1F19                
1F19 68 AA AA      A push getCodeSize_0
1F1C 8D 06 4F 75     lea  ax, [SymbolUpper]
1F20 50              push ax
1F21 E8 3C E3        call eqstr
1F24 83 C4 04        add  sp, 4
1F27 08 C0           or  al, al
1F29 0F 84 00 00   r je .getCodeSize247
1F2D E8 9A F7        call getTokeType
1F30 B8 01 00        mov ax, 1
1F33 E9 00 00      R jmp .retngetCodeSize
1F36                
1F36                ;-958         if (eqstr(SymbolUpper,"WORD")) {getTokeType(); return WORD;}
1F36                
1F36                .getCodeSize247:
1F36 68 AA AA      A push getCodeSize_1
1F39 8D 06 4F 75     lea  ax, [SymbolUpper]
1F3D 50              push ax
1F3E E8 1F E3        call eqstr
1F41 83 C4 04        add  sp, 4
1F44 08 C0           or  al, al
1F46 0F 84 00 00   r je .getCodeSize248
1F4A E8 7D F7        call getTokeType
1F4D B8 02 00        mov ax, 2
1F50 E9 00 00      R jmp .retngetCodeSize
1F53                
1F53                ;-959         if (eqstr(SymbolUpper,"DWORD")){getTokeType(); return DWORD;}
1F53                
1F53                .getCodeSize248:
1F53 68 AA AA      A push getCodeSize_2
1F56 8D 06 4F 75     lea  ax, [SymbolUpper]
1F5A 50              push ax
1F5B E8 02 E3        call eqstr
1F5E 83 C4 04        add  sp, 4
1F61 08 C0           or  al, al
1F63 0F 84 00 00   r je .getCodeSize249
1F67 E8 60 F7        call getTokeType
1F6A B8 03 00        mov ax, 3
1F6D E9 00 00      R jmp .retngetCodeSize
1F70                
1F70                ;-960     }
1F70                
1F70                .getCodeSize249:
1F70                
1F70                ;-961     return 0;
1F70                
1F70                .getCodeSize246:
1F70 B8 00 00        mov ax, 0
1F73 E9 00 00      R jmp .retngetCodeSize
1F76                
1F76                ;-962 }
1F76                
1F76                
1F76                ;-963 
1F76                
1F76                
1F76                ;-964 
1F76                
1F76                
1F76                ;-965 int getarg() {
1F76                
1F76                 .retngetCodeSize:
1F76 C3              ret
1F77 42 59 54 45 00 getCodeSize_0 db "BYTE",0
1F7C 57 4F 52 44 00 getCodeSize_1 db "WORD",0
1F81 44 57 4F 52 44 getCodeSize_2 db "DWORD",0
leaving: getCodeSize, loc labels: 8, loc jmp forward: 11
1F87                ENDP
1F87                
entering: getarg
1F87                getarg: PROC
1F87                
1F87                ;-966     int arglen1; int i; char *c;
1F87                
1F87                
1F87                ;-967     arglen1=*arglen;
1F87                
1F87                ;Function : getarg, Number of local variables: 3
1F87                ;   # type sign width addr used name   list of local variables
1F87                ;  200 var sign word   966 NULL arglen1 = bp-2
1F87                ;  201 var sign word   966 NULL i = bp-4
1F87                ;  202 ptr sign byte   966 NULL c = bp-6;
1F87 C8 06 00 00     ENTER  6,0
1F8B 8B 1E 5A 01     mov bx, [arglen]
1F8F 8A 07           mov al, [bx]
1F91 B4 00           mov ah, 0
1F93 89 46 FE        mov [bp-2], ax
1F96                
1F96                ;-968     if (arglen1==0) {
1F96                
1F96 8B 46 FE        mov ax, [bp-2]
1F99 83 F8 00        cmp ax, 0
1F9C 0F 85 00 00   r jne .getarg250
1FA0                
1FA0                ;-969         cputs(Version1);
1FA0                
1FA0 8D 06 03 01     lea  ax, [Version1]
1FA4 50              push ax
1FA5 E8 D7 E0        call cputs
1FA8 83 C4 02        add  sp, 2
1FAB                
1FAB                ;-970         cputs(", Usage: AS.COM filename [w/o .S] : ");
1FAB                
1FAB 68 AA AA      A push getarg_0
1FAE E8 CE E0        call cputs
1FB1 83 C4 02        add  sp, 2
1FB4                
1FB4                ;-971         exitR(3);
1FB4                
1FB4 6A 03           push 3
1FB6 E8 2D E1        call exitR
1FB9 83 C4 02        add  sp, 2
1FBC                
1FBC                ;-972     }
1FBC                
1FBC                
1FBC                ;-973     i=arglen1+129;
1FBC                
1FBC                .getarg250:
1FBC 8B 46 FE        mov ax, [bp-2]
1FBF 05 81 00        add ax, 129
1FC2 89 46 FC        mov [bp-4], ax
1FC5                
1FC5                ;-974     *i=0;
1FC5                
1FC5 B8 00 00        mov ax, 0
1FC8 8B 5E FC        mov  bx, [bp-4]
1FCB 89 07           mov  [bx], ax
1FCD                
1FCD                ;-975     arglen1--;
1FCD                
1FCD FF 4E FE        dec  word[bp-2]
1FD0                
1FD0                ;-976     toupper(argv);
1FD0                
1FD0 FF 36 5C 01     push word [argv]
1FD4 E8 F6 E2        call toupper
1FD7 83 C4 02        add  sp, 2
1FDA                
1FDA                ;-977 
1FDA                
1FDA                
1FDA                ;-978     strcpy(namein, argv); strcat1(namein, ".S");
1FDA                
1FDA FF 36 5C 01     push word [argv]
1FDE 8D 06 8C 76     lea  ax, [namein]
1FE2 50              push ax
1FE3 E8 44 E2        call strcpy
1FE6 83 C4 04        add  sp, 4
1FE9 68 AA AA      A push getarg_1
1FEC 8D 06 8C 76     lea  ax, [namein]
1FF0 50              push ax
1FF1 E8 B8 E2        call strcat1
1FF4 83 C4 04        add  sp, 4
1FF7                
1FF7                ;-979     strcpy(namelst,argv); strcat1(namelst,".LST");
1FF7                
1FF7 FF 36 5C 01     push word [argv]
1FFB 8D 06 CF 76     lea  ax, [namelst]
1FFF 50              push ax
2000 E8 27 E2        call strcpy
2003 83 C4 04        add  sp, 4
2006 68 AA AA      A push getarg_2
2009 8D 06 CF 76     lea  ax, [namelst]
200D 50              push ax
200E E8 9B E2        call strcat1
2011 83 C4 04        add  sp, 4
2014                
2014                ;-980     strcpy(namebin,argv); strcat1(namebin,".COM");
2014                
2014 FF 36 5C 01     push word [argv]
2018 8D 06 12 77     lea  ax, [namebin]
201C 50              push ax
201D E8 0A E2        call strcpy
2020 83 C4 04        add  sp, 4
2023 68 AA AA      A push getarg_3
2026 8D 06 12 77     lea  ax, [namebin]
202A 50              push ax
202B E8 7E E2        call strcat1
202E 83 C4 04        add  sp, 4
2031                
2031                ;-981 
2031                
2031                
2031                ;-982   DOS_ERR=0; PC=0; ErrorCount=0;
2031                
2031 B8 00 00        mov ax, 0
2034 A3 1C 01        mov word [DOS_ERR], ax
2037 B8 00 00        mov ax, 0
203A A3 23 01        mov word [PC], ax
203D B8 00 00        mov ax, 0
2040 A3 1E 01        mov word [ErrorCount], ax
2043                
2043                ;-983 
2043                
2043                
2043                ;-984     asm_fd=openR (namein);
2043                
2043 8D 06 8C 76     lea  ax, [namein]
2047 50              push ax
2048 E8 6B E0        call openR
204B 83 C4 02        add  sp, 2
204E A3 16 01        mov word [asm_fd], ax
2051                
2051                ;-985     if(DOS_ERR){cputs("Source file missing: ") ;cputs(namein );exitR(1);}
2051                
2051 A1 1C 01        mov ax, [DOS_ERR]
2054 08 C0           or  al, al
2056 0F 84 00 00   r je .getarg251
205A 68 AA AA      A push getarg_4
205D E8 1F E0        call cputs
2060 83 C4 02        add  sp, 2
2063 8D 06 8C 76     lea  ax, [namein]
2067 50              push ax
2068 E8 14 E0        call cputs
206B 83 C4 02        add  sp, 2
206E 6A 01           push 1
2070 E8 73 E0        call exitR
2073 83 C4 02        add  sp, 2
2076                
2076                ;-986     lst_fd=creatR(namelst);
2076                
2076                .getarg251:
2076 8D 06 CF 76     lea  ax, [namelst]
207A 50              push ax
207B E8 47 E0        call creatR
207E 83 C4 02        add  sp, 2
2081 A3 18 01        mov word [lst_fd], ax
2084                
2084                ;-987     if(DOS_ERR){cputs("List file not create: ");cputs(namelst);exitR(2);}
2084                
2084 A1 1C 01        mov ax, [DOS_ERR]
2087 08 C0           or  al, al
2089 0F 84 00 00   r je .getarg252
208D 68 AA AA      A push getarg_5
2090 E8 EC DF        call cputs
2093 83 C4 02        add  sp, 2
2096 8D 06 CF 76     lea  ax, [namelst]
209A 50              push ax
209B E8 E1 DF        call cputs
209E 83 C4 02        add  sp, 2
20A1 6A 02           push 2
20A3 E8 40 E0        call exitR
20A6 83 C4 02        add  sp, 2
20A9                
20A9                ;-988     bin_fd=creatR(namebin);
20A9                
20A9                .getarg252:
20A9 8D 06 12 77     lea  ax, [namebin]
20AD 50              push ax
20AE E8 14 E0        call creatR
20B1 83 C4 02        add  sp, 2
20B4 A3 1A 01        mov word [bin_fd], ax
20B7                
20B7                ;-989     if(DOS_ERR){cputs("COM file not create: ") ;cputs(namebin);exitR(2);}
20B7                
20B7 A1 1C 01        mov ax, [DOS_ERR]
20BA 08 C0           or  al, al
20BC 0F 84 00 00   r je .getarg253
20C0 68 AA AA      A push getarg_6
20C3 E8 B9 DF        call cputs
20C6 83 C4 02        add  sp, 2
20C9 8D 06 12 77     lea  ax, [namebin]
20CD 50              push ax
20CE E8 AE DF        call cputs
20D1 83 C4 02        add  sp, 2
20D4 6A 02           push 2
20D6 E8 0D E0        call exitR
20D9 83 C4 02        add  sp, 2
20DC                
20DC                ;-990 
20DC                
20DC                
20DC                ;-991     prs(";");
20DC                
20DC                .getarg253:
20DC 68 AA AA      A push getarg_7
20DF E8 4D E6        call prs
20E2 83 C4 02        add  sp, 2
20E5                
20E5                ;-992     prs(Version1);
20E5                
20E5 8D 06 03 01     lea  ax, [Version1]
20E9 50              push ax
20EA E8 42 E6        call prs
20ED 83 C4 02        add  sp, 2
20F0                
20F0                ;-993     prs(", Source: "); prs(namein);
20F0                
20F0 68 AA AA      A push getarg_8
20F3 E8 39 E6        call prs
20F6 83 C4 02        add  sp, 2
20F9 8D 06 8C 76     lea  ax, [namein]
20FD 50              push ax
20FE E8 2E E6        call prs
2101 83 C4 02        add  sp, 2
2104                
2104                ;-994     prs(", Output: "); prs(namelst);
2104                
2104 68 AA AA      A push getarg_9
2107 E8 25 E6        call prs
210A 83 C4 02        add  sp, 2
210D 8D 06 CF 76     lea  ax, [namelst]
2111 50              push ax
2112 E8 1A E6        call prs
2115 83 C4 02        add  sp, 2
2118                
2118                ;-995     prs(", "); prs(namebin);
2118                
2118 68 AA AA      A push getarg_10
211B E8 11 E6        call prs
211E 83 C4 02        add  sp, 2
2121 8D 06 12 77     lea  ax, [namebin]
2125 50              push ax
2126 E8 06 E6        call prs
2129 83 C4 02        add  sp, 2
212C                
212C                ;-996     prs("\n");
212C                
212C 68 AA AA      A push getarg_11
212F E8 FD E5        call prs
2132 83 C4 02        add  sp, 2
2135                
2135                ;-997 }
2135                
2135                
2135                ;-998 
2135                
2135                
2135                ;-999 int fixJmp() {   
2135 C9              LEAVE
2136 C3              ret
2137 2C 20 55 73 61 getarg_0 db ", Usage: AS.COM filename [w/o .S] : ",0
215C 2E 53 00       getarg_1 db ".S",0
215F 2E 4C 53 54 00 getarg_2 db ".LST",0
2164 2E 43 4F 4D 00 getarg_3 db ".COM",0
2169 53 6F 75 72 63 getarg_4 db "Source file missing: ",0
217F 4C 69 73 74 20 getarg_5 db "List file not create: ",0
2196 43 4F 4D 20 66 getarg_6 db "COM file not create: ",0
21AC 3B 00          getarg_7 db ";",0
21AE 2C 20 53 6F 75 getarg_8 db ", Source: ",0
21B9 2C 20 4F 75 74 getarg_9 db ", Output: ",0
21C4 2C 20 00       getarg_10 db ", ",0
21C7 5C 6E 00       getarg_11 db "\n",0
leaving: getarg, loc labels: 16, loc jmp forward: 16
21CA                ENDP
21CA                
entering: fixJmp
21CA                fixJmp: PROC
21CA                
21CA                ;-1000     unsigned int hex; int i;
21CA                
21CA                
21CA                ;-1001     char *p; int Ix; char c;
21CA                
21CA                
21CA                ;-1002 //    prs("\, jmp to fix:"); printIntU(JmpMaxIx);
21CA                
21CA                
21CA                ;-1003     p = &JmpNames;
21CA                
21CA                ;Function : fixJmp, Number of local variables: 5
21CA                ;   # type sign width addr used name   list of local variables
21CA                ;  200 var unsg word  1000 NULL hex = bp-2
21CA                ;  201 var sign word  1000 NULL i = bp-4
21CA                ;  202 ptr sign byte  1001 NULL p = bp-6
21CA                ;  203 var sign word  1001 NULL Ix = bp-8
21CA                ;  204 var sign byte  1001 NULL c = bp-10;
21CA C8 0A 00 00     ENTER  10,0
21CE B8 7A 93        mov ax, JmpNames
21D1 89 46 FA        mov [bp-6], ax
21D4                
21D4                ;-1004     i = 1;
21D4                
21D4 B8 01 00        mov ax, 1
21D7 89 46 FC        mov [bp-4], ax
21DA                
21DA                ;-1005     while (i <= JmpMaxIx) {
21DA                
21DA                .fixJmp254:
21DA 8B 46 FC        mov ax, [bp-4]
21DD 3B 06 54 01     cmp ax, [JmpMaxIx]
21E1 0F 8F 00 00   r jg  .fixJmp255
21E5                
21E5                ;-1006         strcpy(Symbol, p);
21E5                
21E5 55              push word [bp-6]
21E6 8D 06 30 75     lea  ax, [Symbol]
21EA 50              push ax
21EB E8 3C E0        call strcpy
21EE 83 C4 04        add  sp, 4
21F1                
21F1                ;-1007         p = strlen(Symbol) + p;
21F1                
21F1 8D 06 30 75     lea  ax, [Symbol]
21F5 50              push ax
21F6 E8 09 E0        call strlen
21F9 83 C4 02        add  sp, 2
21FC 03 46 FA        add ax, [bp-6]
21FF 89 46 FA        mov [bp-6], ax
2202                
2202                ;-1008         p++;
2202                
2202 FF 46 FA        inc  word[bp-6]
2205                
2205                ;-1009         hex = JmpAddr[i];
2205                
2205 8B 5E FC        mov bx, [bp-4]
2208 D1 E3           shl bx, 1
220A 8B 47 1A        mov ax, [JmpAddr + bx]
220D 89 46 FE        mov [bp-2], ax
2210                
2210                ;-1010 //        prs("\n"); printIntU(i);
2210                
2210                
2210                ;-1011 //        prs("  "); prs(Symbol); prs(", from:");
2210                
2210                
2210                ;-1012 //        printhex16(hex);
2210                
2210                
2210                ;-1013         
2210                
2210                
2210                ;-1014         Ix=searchLabel();
2210                
2210 E8 55 F6        call searchLabel
2213 89 46 F8        mov [bp-8], ax
2216                
2216                ;-1015         if (Ix == 0) notfounderror();
2216                
2216 8B 46 F8        mov ax, [bp-8]
2219 83 F8 00        cmp ax, 0
221C 0F 85 00 00   r jne .fixJmp256
2220 E8 85 E8        call notfounderror
2223                
2223                ;-1016         disp = LabelAddr[Ix];   
2223                
2223                .fixJmp256:
2223 8B 5E F8        mov bx, [bp-8]
2226 D1 E3           shl bx, 1
2228 8B 47 CA        mov ax, [LabelAddr + bx]
222B A3 3D 01        mov word [disp], ax
222E                
222E                ;-1017         c = FileBin[hex];//look for 'A' push Absolute 
222E                
222E 8B 5E FE        mov bx, [bp-2]
2231 8A 47 AA        mov al, [FileBin + bx]
2234 88 46 F6        mov [bp-10], al
2237                
2237                ;-1018 //        prs(", Label+ORG:"); printhex16(disp);
2237                
2237                
2237                ;-1019         if (c != 0xAA) {
2237                
2237 8A 46 F6        mov al, [bp-10]
223A 3C AA           cmp al, 170
223C 0F 84 00 00   r je  .fixJmp257
2240                
2240                ;-1020             disp = disp - hex;
2240                
2240 A1 3D 01        mov ax, [disp]
2243 2B 46 FE        sub ax, [bp-2]
2246 A3 3D 01        mov word [disp], ax
2249                
2249                ;-1021             disp = disp -2;//PC points to next instruction
2249                
2249 A1 3D 01        mov ax, [disp]
224C 83 E8 02        sub ax, 2
224F A3 3D 01        mov word [disp], ax
2252                
2252                ;-1022             disp = disp - Origin; 
2252                
2252 A1 3D 01        mov ax, [disp]
2255 2B 06 25 01     sub ax, [Origin]
2259 A3 3D 01        mov word [disp], ax
225C                
225C                ;-1023 //            prs(", rel:"); printhex16(disp);
225C                
225C                
225C                ;-1024         }
225C                
225C                
225C                ;-1025             FileBin[hex] = disp;//fix low byte
225C                
225C                .fixJmp257:
225C A1 3D 01        mov ax, [disp]
225F 8B 5E FE        mov bx, [bp-2]
2262 88 47 AA        mov [FileBin+bx], al
2265                
2265                ;-1026             hex++;
2265                
2265 FF 46 FE        inc  word[bp-2]
2268                
2268                ;-1027             disp = disp >> 8;
2268                
2268 A1 3D 01        mov ax, [disp]
226B C1 E8 08        shr ax, 8
226E A3 3D 01        mov word [disp], ax
2271                
2271                ;-1028             FileBin[hex] = disp; 
2271                
2271 A1 3D 01        mov ax, [disp]
2274 8B 5E FE        mov bx, [bp-2]
2277 88 47 AA        mov [FileBin+bx], al
227A                
227A                ;-1029         i++;  
227A                
227A FF 46 FC        inc  word[bp-4]
227D                
227D                ;-1030     }
227D                
227D                
227D                ;-1031 }
227D                
227D E9 5A FF        jmp .fixJmp254
2280                .fixJmp255:
2280                
2280                ;-1032 int fixJmpMain() {   
2280 C9              LEAVE
2281 C3              ret
leaving: fixJmp, loc labels: 4, loc jmp forward: 3
2282                ENDP
2282                
entering: fixJmpMain
2282                fixJmpMain: PROC
2282                
2282                ;-1033     unsigned int hex; 
2282                
2282                
2282                ;-1034     int Ix; char c;
2282                
2282                
2282                ;-1035     prs("\nfix jmp to main. resting global jmp: ");
2282                
2282                ;Function : fixJmpMain, Number of local variables: 3
2282                ;   # type sign width addr used name   list of local variables
2282                ;  200 var unsg word  1033 NULL hex = bp-2
2282                ;  201 var sign word  1034 NULL Ix = bp-4
2282                ;  202 var sign byte  1034 NULL c = bp-6;
2282 C8 06 00 00     ENTER  6,0
2286 68 AA AA      A push fixJmpMain_0
2289 E8 A3 E4        call prs
228C 83 C4 02        add  sp, 2
228F                
228F                ;-1036     printIntU(JmpMaxIx);  
228F                
228F FF 36 54 01     push word [JmpMaxIx]
2293 E8 A5 E5        call printIntU
2296 83 C4 02        add  sp, 2
2299                
2299                ;-1037     if (JmpMaxIx ) error1("resting global jmp");
2299                
2299 A1 54 01        mov ax, [JmpMaxIx]
229C 08 C0           or  al, al
229E 0F 84 00 00   r je .fixJmpMain258
22A2 68 AA AA      A push fixJmpMain_1
22A5 E8 93 E7        call error1
22A8 83 C4 02        add  sp, 2
22AB                
22AB                ;-1038         strcpy(Symbol, "main");
22AB                
22AB                .fixJmpMain258:
22AB 68 AA AA      A push fixJmpMain_2
22AE 8D 06 30 75     lea  ax, [Symbol]
22B2 50              push ax
22B3 E8 74 DF        call strcpy
22B6 83 C4 04        add  sp, 4
22B9                
22B9                ;-1039         hex = 1;//first instruction, PC=1
22B9                
22B9 B8 01 00        mov ax, 1
22BC 89 46 FE        mov [bp-2], ax
22BF                
22BF                ;-1040         Ix=searchLabel();
22BF                
22BF E8 A6 F5        call searchLabel
22C2 89 46 FC        mov [bp-4], ax
22C5                
22C5                ;-1041         if (Ix == 0) notfounderror();
22C5                
22C5 8B 46 FC        mov ax, [bp-4]
22C8 83 F8 00        cmp ax, 0
22CB 0F 85 00 00   r jne .fixJmpMain259
22CF E8 D6 E7        call notfounderror
22D2                
22D2                ;-1042         disp = LabelAddr[Ix];   
22D2                
22D2                .fixJmpMain259:
22D2 8B 5E FC        mov bx, [bp-4]
22D5 D1 E3           shl bx, 1
22D7 8B 47 CA        mov ax, [LabelAddr + bx]
22DA A3 3D 01        mov word [disp], ax
22DD                
22DD                ;-1043         c = FileBin[hex];//look for 'A' push Absolute 
22DD                
22DD 8B 5E FE        mov bx, [bp-2]
22E0 8A 47 AA        mov al, [FileBin + bx]
22E3 88 46 FA        mov [bp-6], al
22E6                
22E6                ;-1044         prs("\nmain ,Label+ORG:"); printhex16(disp);
22E6                
22E6 68 AA AA      A push fixJmpMain_3
22E9 E8 43 E4        call prs
22EC 83 C4 02        add  sp, 2
22EF FF 36 3D 01     push word [disp]
22F3 E8 1F E5        call printhex16
22F6 83 C4 02        add  sp, 2
22F9                
22F9                ;-1045         if (c != 0xAA) {
22F9                
22F9 8A 46 FA        mov al, [bp-6]
22FC 3C AA           cmp al, 170
22FE 0F 84 00 00   r je  .fixJmpMain260
2302                
2302                ;-1046             disp = disp - hex;
2302                
2302 A1 3D 01        mov ax, [disp]
2305 2B 46 FE        sub ax, [bp-2]
2308 A3 3D 01        mov word [disp], ax
230B                
230B                ;-1047             disp = disp -2;//PC points to next instruction
230B                
230B A1 3D 01        mov ax, [disp]
230E 83 E8 02        sub ax, 2
2311 A3 3D 01        mov word [disp], ax
2314                
2314                ;-1048             disp = disp - Origin; 
2314                
2314 A1 3D 01        mov ax, [disp]
2317 2B 06 25 01     sub ax, [Origin]
231B A3 3D 01        mov word [disp], ax
231E                
231E                ;-1049             prs(",rel:"); printhex16(disp);
231E                
231E 68 AA AA      A push fixJmpMain_4
2321 E8 0B E4        call prs
2324 83 C4 02        add  sp, 2
2327 FF 36 3D 01     push word [disp]
232B E8 E7 E4        call printhex16
232E 83 C4 02        add  sp, 2
2331                
2331                ;-1050         }
2331                
2331                
2331                ;-1051             FileBin[hex] = disp;//fix low byte
2331                
2331                .fixJmpMain260:
2331 A1 3D 01        mov ax, [disp]
2334 8B 5E FE        mov bx, [bp-2]
2337 88 47 AA        mov [FileBin+bx], al
233A                
233A                ;-1052             hex++;
233A                
233A FF 46 FE        inc  word[bp-2]
233D                
233D                ;-1053             disp = disp >> 8;
233D                
233D A1 3D 01        mov ax, [disp]
2340 C1 E8 08        shr ax, 8
2343 A3 3D 01        mov word [disp], ax
2346                
2346                ;-1054             FileBin[hex] = disp; 
2346                
2346 A1 3D 01        mov ax, [disp]
2349 8B 5E FE        mov bx, [bp-2]
234C 88 47 AA        mov [FileBin+bx], al
234F                
234F                ;-1055 }
234F                
234F                
234F                ;-1056 
234F                
234F                
234F                ;-1057 
234F                
234F                
234F                ;-1058 int getCodes() {
234F C9              LEAVE
2350 C3              ret
2351 5C 6E 66 69 78 fixJmpMain_0 db "\nfix jmp to main. resting global jmp: ",0
2379 72 65 73 74 69 fixJmpMain_1 db "resting global jmp",0
238C 6D 61 69 6E 00 fixJmpMain_2 db "main",0
2391 5C 6E 6D 61 69 fixJmpMain_3 db "\nmain ,Label+ORG:",0
23A4 2C 72 65 6C 3A fixJmpMain_4 db ",rel:",0
leaving: fixJmpMain, loc labels: 8, loc jmp forward: 8
23AA                ENDP
23AA                
entering: getCodes
23AA                getCodes: PROC
23AA                
23AA                ;-1059     OpCodePtr ++; Code1 = *OpCodePtr;
23AA                
23AA FF 06 43 01     inc  word[OpCodePtr]
23AE 8B 1E 43 01     mov bx, [OpCodePtr]
23B2 8A 07           mov al, [bx]
23B4 B4 00           mov ah, 0
23B6 A2 30 01        mov byte [Code1], al
23B9                
23B9                ;-1060     OpCodePtr ++; Code2 = *OpCodePtr;
23B9                
23B9 FF 06 43 01     inc  word[OpCodePtr]
23BD 8B 1E 43 01     mov bx, [OpCodePtr]
23C1 8A 07           mov al, [bx]
23C3 B4 00           mov ah, 0
23C5 A2 31 01        mov byte [Code2], al
23C8                
23C8                ;-1061     OpCodePtr ++; Code3 = *OpCodePtr;
23C8                
23C8 FF 06 43 01     inc  word[OpCodePtr]
23CC 8B 1E 43 01     mov bx, [OpCodePtr]
23D0 8A 07           mov al, [bx]
23D2 B4 00           mov ah, 0
23D4 A2 32 01        mov byte [Code3], al
23D7                
23D7                ;-1062 }
23D7                
23D7                
23D7                ;-1063 
23D7                
23D7                
23D7                ;-1064 int process() {
23D7                
23D7 C3              ret
leaving: getCodes, loc labels: 0, loc jmp forward: 0
23D8                ENDP
23D8                
entering: process
23D8                process: PROC
23D8                
23D8                ;-1065     char c;
23D8                
23D8                
23D8                ;-1066     int i;
23D8                
23D8                
23D8                ;-1067     Op=Op2=R1Type=R2Type=R1No=R2No=dflag=wflag=rm=0;//char
23D8                
23D8                ;Function : process, Number of local variables: 2
23D8                ;   # type sign width addr used name   list of local variables
23D8                ;  200 var sign byte  1065 NULL c = bp-2
23D8                ;  201 var sign word  1066 NULL i = bp-4;
23D8 C8 04 00 00     ENTER  4,0
23DC B8 00 00        mov ax, 0
23DF A2 3B 01        mov byte [rm], al
23E2 A2 38 01        mov byte [wflag], al
23E5 A2 39 01        mov byte [dflag], al
23E8 A2 33 01        mov byte [R2No], al
23EB A2 34 01        mov byte [R1No], al
23EE A2 35 01        mov byte [R2Type], al
23F1 A2 36 01        mov byte [R1Type], al
23F4 A2 2E 01        mov byte [Op2], al
23F7 A2 2D 01        mov byte [Op], al
23FA                
23FA                ;-1068     disp=imme=0;//int
23FA                
23FA B8 00 00        mov ax, 0
23FD A3 3F 01        mov word [imme], ax
2400 A3 3D 01        mov word [disp], ax
2403                
2403                ;-1069     isDirect=1; //set in getMeM=0, need in WriteEA
2403                
2403 B8 01 00        mov ax, 1
2406 A2 3C 01        mov byte [isDirect], al
2409                
2409                ;-1070     getTokeType();//0, DIGIT, ALNUME, NOALNUME
2409                
2409 E8 BE F2        call getTokeType
240C                
240C                ;-1071     OpSize=getCodeSize();//0, BYTE, WORD, DWORD
240C                
240C E8 01 FB        call getCodeSize
240F A2 37 01        mov byte [OpSize], al
2412                
2412                ;-1072     getCodes();//set: Code1, Code2, Code3
2412                
2412 E8 95 FF        call getCodes
2415                
2415                ;-1073 
2415                
2415                
2415                ;-1074     if (CodeType ==  1) {//1 byte opcode
2415                
2415 A0 2F 01        mov al, [CodeType]
2418 3C 01           cmp al, 1
241A 0F 85 00 00   r jne .process261
241E                
241E                ;-1075         genCode8(Code1);
241E                
241E A0 30 01        mov al, byte [Code1]
2421 B4 00           mov ah, 0
2423 50              push ax
2424 E8 52 EF        call genCode8
2427 83 C4 02        add  sp, 2
242A                
242A                ;-1076         return;
242A                
242A E9 00 00      R jmp .retnprocess
242D                
242D                ;-1077     }
242D                
242D                
242D                ;-1078 
242D                
242D                
242D                ;-1079     if (CodeType ==  2) {//inc,dec,not,neg,mul,imul,div,idiv
242D                
242D                .process261:
242D A0 2F 01        mov al, [CodeType]
2430 3C 02           cmp al, 2
2432 0F 85 00 00   r jne .process262
2436                
2436                ;-1080         getOpL();
2436                
2436 E8 1C F7        call getOpL
2439                
2439                ;-1081         checkOpL();
2439                
2439 E8 AA F3        call checkOpL
243C                
243C                ;-1082         if (Code2 <= 1) {//inc,dec
243C                
243C A0 31 01        mov al, [Code2]
243F 3C 01           cmp al, 1
2441 0F 8F 00 00   r jg  .process263
2445                
2445                ;-1083   	        if (Op == REG) {//short
2445                
2445 A0 2D 01        mov al, [Op]
2448 3C 02           cmp al, 2
244A 0F 85 00 00   r jne .process264
244E                
244E                ;-1084                 if (wflag) {genCode2(Code3, R1No); return; }
244E                
244E A0 38 01        mov al, [wflag]
2451 08 C0           or  al, al
2453 0F 84 00 00   r je .process265
2457 A0 34 01        mov al, byte [R1No]
245A B4 00           mov ah, 0
245C 50              push ax
245D A0 32 01        mov al, byte [Code3]
2460 B4 00           mov ah, 0
2462 50              push ax
2463 E8 72 EF        call genCode2
2466 83 C4 04        add  sp, 4
2469 E9 00 00      R jmp .retnprocess
246C                
246C                ;-1085             }
246C                
246C                .process265:
246C                
246C                ;-1086         }
246C                
246C                .process264:
246C                
246C                ;-1087         if (Code2 == 5) {//imul extension?
246C                
246C                .process263:
246C A0 31 01        mov al, [Code2]
246F 3C 05           cmp al, 5
2471 0F 85 00 00   r jne .process266
2475                
2475                ;-1088             getTokeType();
2475                
2475 E8 52 F2        call getTokeType
2478                
2478                ;-1089             if (TokeType) implerror();
2478                
2478 A0 2C 01        mov al, [TokeType]
247B 08 C0           or  al, al
247D 0F 84 00 00   r je .process267
2481 E8 C5 E6        call implerror
2484                
2484                ;-1090         }
2484                
2484                .process267:
2484                
2484                ;-1091         genCodeW(Code1);
2484                
2484                .process266:
2484 A0 30 01        mov al, byte [Code1]
2487 B4 00           mov ah, 0
2489 50              push ax
248A E8 66 EF        call genCodeW
248D 83 C4 02        add  sp, 2
2490                
2490                ;-1092         writeEA(Code2);
2490                
2490 A0 31 01        mov al, byte [Code2]
2493 B4 00           mov ah, 0
2495 50              push ax
2496 E8 BD EF        call writeEA
2499 83 C4 02        add  sp, 2
249C                
249C                ;-1093         return;
249C                
249C E9 00 00      R jmp .retnprocess
249F                
249F                ;-1094     }
249F                
249F                
249F                ;-1095 
249F                
249F                
249F                ;-1096     if (CodeType == 3) {//les,lds,lea,lss,lfs,lgs
249F                
249F                .process262:
249F A0 2F 01        mov al, [CodeType]
24A2 3C 03           cmp al, 3
24A4 0F 85 00 00   r jne .process268
24A8                
24A8                ;-1097         check2Ops();    //setwflag not applicable
24A8                
24A8 E8 E1 F6        call check2Ops
24AB                
24AB                ;-1098         if (R1Type != WORD) reg16error();//only r16
24AB                
24AB A0 36 01        mov al, [R1Type]
24AE 3C 02           cmp al, 2
24B0 0F 84 00 00   r je  .process269
24B4 E8 32 E7        call reg16error
24B7                
24B7                ;-1099         if (Op2 != MEM) addrerror();//only m16
24B7                
24B7                .process269:
24B7 A0 2E 01        mov al, [Op2]
24BA 3C 04           cmp al, 4
24BC 0F 84 00 00   r je  .process270
24C0 E8 47 E6        call addrerror
24C3                
24C3                ;-1100 
24C3                
24C3                
24C3                ;-1101         genCode8(Code1);//les,lds,lea
24C3                
24C3                .process270:
24C3 A0 30 01        mov al, byte [Code1]
24C6 B4 00           mov ah, 0
24C8 50              push ax
24C9 E8 AD EE        call genCode8
24CC 83 C4 02        add  sp, 2
24CF                
24CF                ;-1102         if (Code1 == 0x0F) genCode8(Code2);//lss,lfs,lgs
24CF                
24CF A0 30 01        mov al, [Code1]
24D2 3C 0F           cmp al, 15
24D4 0F 85 00 00   r jne .process271
24D8 A0 31 01        mov al, byte [Code2]
24DB B4 00           mov ah, 0
24DD 50              push ax
24DE E8 98 EE        call genCode8
24E1 83 C4 02        add  sp, 2
24E4                
24E4                ;-1103         Op=Op2;//set MEM for writeEA
24E4                
24E4                .process271:
24E4 A0 2E 01        mov al, [Op2]
24E7 A2 2D 01        mov byte [Op], al
24EA                
24EA                ;-1104         writeEA(R1No);
24EA                
24EA A0 34 01        mov al, byte [R1No]
24ED B4 00           mov ah, 0
24EF 50              push ax
24F0 E8 63 EF        call writeEA
24F3 83 C4 02        add  sp, 2
24F6                
24F6                ;-1105         return;
24F6                
24F6 E9 00 00      R jmp .retnprocess
24F9                
24F9                ;-1106     }
24F9                
24F9                
24F9                ;-1107 
24F9                
24F9                
24F9                ;-1108     if (CodeType == 4) {//add,or,adc,sbb,and,sub,xor,cmp,->test
24F9                
24F9                .process268:
24F9 A0 2F 01        mov al, [CodeType]
24FC 3C 04           cmp al, 4
24FE 0F 85 00 00   r jne .process272
2502                
2502                ;-1109         check2Ops();
2502                
2502 E8 87 F6        call check2Ops
2505                
2505                ;-1110         if (Op2 == IMM) {//second operand is imm
2505                
2505 A0 2E 01        mov al, [Op2]
2508 3C 01           cmp al, 1
250A 0F 85 00 00   r jne .process273
250E                
250E                ;-1111             setsflag();
250E                
250E E8 EF F0        call setsflag
2511                
2511                ;-1112             if (Op == REG) {
2511                
2511 A0 2D 01        mov al, [Op]
2514 3C 02           cmp al, 2
2516 0F 85 00 00   r jne .process274
251A                
251A                ;-1113                 if (R1No == 0) {// acc,imm
251A                
251A A0 34 01        mov al, [R1No]
251D 3C 00           cmp al, 0
251F 0F 85 00 00   r jne .process275
2523                
2523                ;-1114                     if (sflag == 0) {
2523                
2523 A0 3A 01        mov al, [sflag]
2526 3C 00           cmp al, 0
2528 0F 85 00 00   r jne .process276
252C                
252C                ;-1115                         c = Code1 << 3;
252C                
252C A0 30 01        mov al, [Code1]
252F C0 E0 03        shl al, 3
2532 88 46 FE        mov [bp-2], al
2535                
2535                ;-1116                         c += 4;
2535                
2535 80 46 FE 04     add  byte[bp-2], 4
2539                
2539                ;-1117                         genCodeW(c);
2539                
2539 8A 46 FE        mov al, byte [bp-2]
253C B4 00           mov ah, 0
253E 50              push ax
253F E8 B1 EE        call genCodeW
2542 83 C4 02        add  sp, 2
2545                
2545                ;-1118                         genImmediate();
2545                
2545 E8 14 F0        call genImmediate
2548                
2548                ;-1119                         return;
2548                
2548 E9 00 00      R jmp .retnprocess
254B                
254B                ;-1120                     }
254B                
254B                
254B                ;-1121                 }
254B                
254B                .process276:
254B                
254B                ;-1122             }
254B                
254B                .process275:
254B                
254B                ;-1123             //r/m, imm: 80 sign-extended,TTT,imm
254B                
254B                
254B                ;-1124             c = sflag + 0x80;
254B                
254B                .process274:
254B A0 3A 01        mov al, [sflag]
254E 04 80           add al, 128
2550 88 46 FE        mov [bp-2], al
2553                
2553                ;-1125             genCodeW(c);
2553                
2553 8A 46 FE        mov al, byte [bp-2]
2556 B4 00           mov ah, 0
2558 50              push ax
2559 E8 97 EE        call genCodeW
255C 83 C4 02        add  sp, 2
255F                
255F                ;-1126             writeEA(Code1);
255F                
255F A0 30 01        mov al, byte [Code1]
2562 B4 00           mov ah, 0
2564 50              push ax
2565 E8 EE EE        call writeEA
2568 83 C4 02        add  sp, 2
256B                
256B                ;-1127             if (sflag) genCode8(imme);
256B                
256B A0 3A 01        mov al, [sflag]
256E 08 C0           or  al, al
2570 0F 84 00 00   r je .process277
2574 FF 36 3F 01     push word [imme]
2578 E8 FE ED        call genCode8
257B 83 C4 02        add  sp, 2
257E                
257E                ;-1128             else genImmediate();
257E                
257E E9 00 00      R jmp .process278
2581                .process277:
2581 E8 D8 EF        call genImmediate
2584                
2584                ;-1129             return;
2584                
2584                .process278:
2584 E9 00 00      R jmp .retnprocess
2587                
2587                ;-1130         }
2587                
2587                
2587                ;-1131         c = Code1 << 3;//r/m, r/r
2587                
2587                .process273:
2587 A0 30 01        mov al, [Code1]
258A C0 E0 03        shl al, 3
258D 88 46 FE        mov [bp-2], al
2590                
2590                ;-1132         if (Op == REG) {
2590                
2590 A0 2D 01        mov al, [Op]
2593 3C 02           cmp al, 2
2595 0F 85 00 00   r jne .process279
2599                
2599                ;-1133             if (Op2 == MEM) {//reg, mem
2599                
2599 A0 2E 01        mov al, [Op2]
259C 3C 04           cmp al, 4
259E 0F 85 00 00   r jne .process280
25A2                
25A2                ;-1134                 c += 2;//add direction flag
25A2                
25A2 80 46 FE 02     add  byte[bp-2], 2
25A6                
25A6                ;-1135                 genCodeW(c);
25A6                
25A6 8A 46 FE        mov al, byte [bp-2]
25A9 B4 00           mov ah, 0
25AB 50              push ax
25AC E8 44 EE        call genCodeW
25AF 83 C4 02        add  sp, 2
25B2                
25B2                ;-1136                 Op=Op2;//set MEM for writeEA
25B2                
25B2 A0 2E 01        mov al, [Op2]
25B5 A2 2D 01        mov byte [Op], al
25B8                
25B8                ;-1137                 writeEA(R1No);
25B8                
25B8 A0 34 01        mov al, byte [R1No]
25BB B4 00           mov ah, 0
25BD 50              push ax
25BE E8 95 EE        call writeEA
25C1 83 C4 02        add  sp, 2
25C4                
25C4                ;-1138                 return;
25C4                
25C4 E9 00 00      R jmp .retnprocess
25C7                
25C7                ;-1139             }
25C7                
25C7                
25C7                ;-1140         }
25C7                
25C7                .process280:
25C7                
25C7                ;-1141         if (Op2 == REG) {//mem,reg    reg,reg
25C7                
25C7                .process279:
25C7 A0 2E 01        mov al, [Op2]
25CA 3C 02           cmp al, 2
25CC 0F 85 00 00   r jne .process281
25D0                
25D0                ;-1142             genCodeW(c);
25D0                
25D0 8A 46 FE        mov al, byte [bp-2]
25D3 B4 00           mov ah, 0
25D5 50              push ax
25D6 E8 1A EE        call genCodeW
25D9 83 C4 02        add  sp, 2
25DC                
25DC                ;-1143             writeEA(R2No);//2. Op in reg-field
25DC                
25DC A0 33 01        mov al, byte [R2No]
25DF B4 00           mov ah, 0
25E1 50              push ax
25E2 E8 71 EE        call writeEA
25E5 83 C4 02        add  sp, 2
25E8                
25E8                ;-1144             return;
25E8                
25E8 E9 00 00      R jmp .retnprocess
25EB                
25EB                ;-1145         }
25EB                
25EB                
25EB                ;-1146         syntaxerror();
25EB                
25EB                .process281:
25EB E8 4A E6        call syntaxerror
25EE                
25EE                ;-1147         return;
25EE                
25EE E9 00 00      R jmp .retnprocess
25F1                
25F1                ;-1148     }
25F1                
25F1                
25F1                ;-1149 
25F1                
25F1                
25F1                ;-1150     if (CodeType == 5) {//mov (movsx, movzx=51)
25F1                
25F1                .process272:
25F1 A0 2F 01        mov al, [CodeType]
25F4 3C 05           cmp al, 5
25F6 0F 85 00 00   r jne .process282
25FA                
25FA                ;-1151         check2Ops();
25FA                
25FA E8 8F F5        call check2Ops
25FD                
25FD                ;-1152 /*    prs("\n Op:"); printhex8a(Op);
25FD                
25FD                
25FD                ;-1153     prs(", Op2:"); printhex8a(Op2);
25FD                
25FD                
25FD                ;-1154     prs(", R1No:"); printhex8a(R1No);
25FD                
25FD                
25FD                ;-1155     prs(", R2No:"); printhex8a(R2No);   */
25FD                
25FD                
25FD                ;-1156         if (Op2 == ADR) {
25FD                
25FD A0 2E 01        mov al, [Op2]
2600 3C 03           cmp al, 3
2602 0F 85 00 00   r jne .process283
2606                
2606                ;-1157             if (disp) imme=disp;
2606                
2606 A1 3D 01        mov ax, [disp]
2609 08 C0           or  al, al
260B 0F 84 00 00   r je .process284
260F A1 3D 01        mov ax, [disp]
2612 A3 3F 01        mov word [imme], ax
2615                
2615                ;-1158             else notfounderror();
2615                
2615 E9 00 00      R jmp .process285
2618                .process284:
2618 E8 8D E4        call notfounderror
261B                
261B                ;-1159             Op2=IMM;//continue with IMM
261B                
261B                .process285:
261B B8 01 00        mov ax, 1
261E A2 2E 01        mov byte [Op2], al
2621                
2621                ;-1160         }
2621                
2621                
2621                ;-1161         if (Op2 == IMM) {// r,i
2621                
2621                .process283:
2621 A0 2E 01        mov al, [Op2]
2624 3C 01           cmp al, 1
2626 0F 85 00 00   r jne .process286
262A                
262A                ;-1162             if (Op == REG) {
262A                
262A A0 2D 01        mov al, [Op]
262D 3C 02           cmp al, 2
262F 0F 85 00 00   r jne .process287
2633                
2633                ;-1163                 c = wflag << 3;
2633                
2633 A0 38 01        mov al, [wflag]
2636 C0 E0 03        shl al, 3
2639 88 46 FE        mov [bp-2], al
263C                
263C                ;-1164                 c += 0xB0;
263C                
263C 80 46 FE B0     add  byte[bp-2], 176
2640                
2640                ;-1165                 genCode2(c, R1No);
2640                
2640 A0 34 01        mov al, byte [R1No]
2643 B4 00           mov ah, 0
2645 50              push ax
2646 8A 46 FE        mov al, byte [bp-2]
2649 B4 00           mov ah, 0
264B 50              push ax
264C E8 89 ED        call genCode2
264F 83 C4 04        add  sp, 4
2652                
2652                ;-1166                 genImmediate();
2652                
2652 E8 07 EF        call genImmediate
2655                
2655                ;-1167                 return;
2655                
2655 E9 00 00      R jmp .retnprocess
2658                
2658                ;-1168             }
2658                
2658                
2658                ;-1169             if (Op == MEM) {// m,i
2658                
2658                .process287:
2658 A0 2D 01        mov al, [Op]
265B 3C 04           cmp al, 4
265D 0F 85 00 00   r jne .process288
2661                
2661                ;-1170                 genCodeW(0xC6);
2661                
2661 68 C6 00        push 198
2664 E8 8C ED        call genCodeW
2667 83 C4 02        add  sp, 2
266A                
266A                ;-1171                 writeEA( 0 );
266A                
266A 6A 00           push 0
266C E8 E7 ED        call writeEA
266F 83 C4 02        add  sp, 2
2672                
2672                ;-1172                 genImmediate();
2672                
2672 E8 E7 EE        call genImmediate
2675                
2675                ;-1173                 return;
2675                
2675 E9 00 00      R jmp .retnprocess
2678                
2678                ;-1174             }
2678                
2678                
2678                ;-1175             regmemerror();
2678                
2678                .process288:
2678 E8 44 E5        call regmemerror
267B                
267B                ;-1176             return;
267B                
267B E9 00 00      R jmp .retnprocess
267E                
267E                ;-1177         }
267E                
267E                
267E                ;-1178         if (R1Type == SEGREG) ChangeDirection();//sreg,rm
267E                
267E                .process286:
267E A0 36 01        mov al, [R1Type]
2681 3C 04           cmp al, 4
2683 0F 85 00 00   r jne .process289
2687 E8 FE EF        call ChangeDirection
268A                
268A                ;-1179         if (R2Type == SEGREG) {//rm,sreg
268A                
268A                .process289:
268A A0 35 01        mov al, [R2Type]
268D 3C 04           cmp al, 4
268F 0F 85 00 00   r jne .process290
2693                
2693                ;-1180             if (OpSize != WORD) reg16error();
2693                
2693 A0 37 01        mov al, [OpSize]
2696 3C 02           cmp al, 2
2698 0F 84 00 00   r je  .process291
269C E8 4A E5        call reg16error
269F                
269F                ;-1181                 genCode2(0x8C, dflag);
269F                
269F                .process291:
269F A0 39 01        mov al, byte [dflag]
26A2 B4 00           mov ah, 0
26A4 50              push ax
26A5 68 8C 00        push 140
26A8 E8 2D ED        call genCode2
26AB 83 C4 04        add  sp, 4
26AE                
26AE                ;-1182                 writeEA(R2No);
26AE                
26AE A0 33 01        mov al, byte [R2No]
26B1 B4 00           mov ah, 0
26B3 50              push ax
26B4 E8 9F ED        call writeEA
26B7 83 C4 02        add  sp, 2
26BA                
26BA                ;-1183                 return;
26BA                
26BA E9 00 00      R jmp .retnprocess
26BD                
26BD                ;-1184         }
26BD                
26BD                
26BD                ;-1185         if (Op2 == MEM) {//acc, moffs16
26BD                
26BD                .process290:
26BD A0 2E 01        mov al, [Op2]
26C0 3C 04           cmp al, 4
26C2 0F 85 00 00   r jne .process292
26C6                
26C6                ;-1186             if (Op == REG) {
26C6                
26C6 A0 2D 01        mov al, [Op]
26C9 3C 02           cmp al, 2
26CB 0F 85 00 00   r jne .process293
26CF                
26CF                ;-1187                 if (R1No == 0) {
26CF                
26CF A0 34 01        mov al, [R1No]
26D2 3C 00           cmp al, 0
26D4 0F 85 00 00   r jne .process294
26D8                
26D8                ;-1188                     if (isDirect) {
26D8                
26D8 A0 3C 01        mov al, [isDirect]
26DB 08 C0           or  al, al
26DD 0F 84 00 00   r je .process295
26E1                
26E1                ;-1189                         genCodeW(0xA0);
26E1                
26E1 68 A0 00        push 160
26E4 E8 0C ED        call genCodeW
26E7 83 C4 02        add  sp, 2
26EA                
26EA                ;-1190                         genCode16(disp);
26EA                
26EA FF 36 3D 01     push word [disp]
26EE E8 1E ED        call genCode16
26F1 83 C4 02        add  sp, 2
26F4                
26F4                ;-1191                         return;
26F4                
26F4 E9 00 00      R jmp .retnprocess
26F7                
26F7                ;-1192                     }
26F7                
26F7                
26F7                ;-1193                 }
26F7                
26F7                .process295:
26F7                
26F7                ;-1194             }
26F7                
26F7                .process294:
26F7                
26F7                ;-1195         }
26F7                
26F7                .process293:
26F7                
26F7                ;-1196         if (Op == MEM) {//moffs16, acc
26F7                
26F7                .process292:
26F7 A0 2D 01        mov al, [Op]
26FA 3C 04           cmp al, 4
26FC 0F 85 00 00   r jne .process296
2700                
2700                ;-1197             if (Op2 == REG) {
2700                
2700 A0 2E 01        mov al, [Op2]
2703 3C 02           cmp al, 2
2705 0F 85 00 00   r jne .process297
2709                
2709                ;-1198                 if (R2No == 0) {
2709                
2709 A0 33 01        mov al, [R2No]
270C 3C 00           cmp al, 0
270E 0F 85 00 00   r jne .process298
2712                
2712                ;-1199                     if (isDirect) {
2712                
2712 A0 3C 01        mov al, [isDirect]
2715 08 C0           or  al, al
2717 0F 84 00 00   r je .process299
271B                
271B                ;-1200                         genCodeW(0xA2);
271B                
271B 68 A2 00        push 162
271E E8 D2 EC        call genCodeW
2721 83 C4 02        add  sp, 2
2724                
2724                ;-1201                         genCode16(disp);
2724                
2724 FF 36 3D 01     push word [disp]
2728 E8 E4 EC        call genCode16
272B 83 C4 02        add  sp, 2
272E                
272E                ;-1202                         return;
272E                
272E E9 00 00      R jmp .retnprocess
2731                
2731                ;-1203                     }
2731                
2731                
2731                ;-1204                 }
2731                
2731                .process299:
2731                
2731                ;-1205             }
2731                
2731                .process298:
2731                
2731                ;-1206 
2731                
2731                
2731                ;-1207         }
2731                
2731                .process297:
2731                
2731                ;-1208         if (Op2 == REG) {//rm, r
2731                
2731                .process296:
2731 A0 2E 01        mov al, [Op2]
2734 3C 02           cmp al, 2
2736 0F 85 00 00   r jne .process300
273A                
273A                ;-1209             genCodeW(0x88);
273A                
273A 68 88 00        push 136
273D E8 B3 EC        call genCodeW
2740 83 C4 02        add  sp, 2
2743                
2743                ;-1210             writeEA(R2No);
2743                
2743 A0 33 01        mov al, byte [R2No]
2746 B4 00           mov ah, 0
2748 50              push ax
2749 E8 0A ED        call writeEA
274C 83 C4 02        add  sp, 2
274F                
274F                ;-1211             return;
274F                
274F E9 00 00      R jmp .retnprocess
2752                
2752                ;-1212         }
2752                
2752                
2752                ;-1213         if (Op2 == MEM) {//r, m
2752                
2752                .process300:
2752 A0 2E 01        mov al, [Op2]
2755 3C 04           cmp al, 4
2757 0F 85 00 00   r jne .process301
275B                
275B                ;-1214             if (Op == REG) {
275B                
275B A0 2D 01        mov al, [Op]
275E 3C 02           cmp al, 2
2760 0F 85 00 00   r jne .process302
2764                
2764                ;-1215                 ChangeDirection();
2764                
2764 E8 21 EF        call ChangeDirection
2767                
2767                ;-1216                 genCodeW(0x8A);
2767                
2767 68 8A 00        push 138
276A E8 86 EC        call genCodeW
276D 83 C4 02        add  sp, 2
2770                
2770                ;-1217                 writeEA(R2No);
2770                
2770 A0 33 01        mov al, byte [R2No]
2773 B4 00           mov ah, 0
2775 50              push ax
2776 E8 DD EC        call writeEA
2779 83 C4 02        add  sp, 2
277C                
277C                ;-1218                 return;
277C                
277C E9 00 00      R jmp .retnprocess
277F                
277F                ;-1219             }
277F                
277F                
277F                ;-1220         }
277F                
277F                .process302:
277F                
277F                ;-1221         syntaxerror();
277F                
277F                .process301:
277F E8 B6 E4        call syntaxerror
2782                
2782                ;-1222         return;
2782                
2782 E9 00 00      R jmp .retnprocess
2785                
2785                ;-1223     }
2785                
2785                
2785                ;-1224 
2785                
2785                
2785                ;-1225     if (CodeType == 6) {//Jcc
2785                
2785                .process282:
2785 A0 2F 01        mov al, [CodeType]
2788 3C 06           cmp al, 6
278A 0F 85 00 00   r jne .process303
278E                
278E                ;-1226         if (TokeType == ALNUME) {
278E                
278E A0 2C 01        mov al, [TokeType]
2791 3C 03           cmp al, 3
2793 0F 85 00 00   r jne .process304
2797                
2797                ;-1227             LabelIx=searchLabel();
2797                
2797 E8 CE F0        call searchLabel
279A A3 4E 01        mov word [LabelIx], ax
279D                
279D                ;-1228             if (LabelIx > 0) {
279D                
279D A1 4E 01        mov ax, [LabelIx]
27A0 83 F8 00        cmp ax, 0
27A3 0F 8E 00 00   r jle .process305
27A7                
27A7                ;-1229                 disp=LabelAddr[LabelIx];
27A7                
27A7 8B 1E 4E 01     mov bx, [LabelIx]
27AB D1 E3           shl bx, 1
27AD 8B 47 CA        mov ax, [LabelAddr + bx]
27B0 A3 3D 01        mov word [disp], ax
27B3                
27B3                ;-1230                 disp = disp - PC;
27B3                
27B3 A1 3D 01        mov ax, [disp]
27B6 2B 06 23 01     sub ax, [PC]
27BA A3 3D 01        mov word [disp], ax
27BD                
27BD                ;-1231                 disp = disp - Origin;
27BD                
27BD A1 3D 01        mov ax, [disp]
27C0 2B 06 25 01     sub ax, [Origin]
27C4 A3 3D 01        mov word [disp], ax
27C7                
27C7                ;-1232                 if (checkConstSize(disp) ) {
27C7                
27C7 FF 36 3D 01     push word [disp]
27CB E8 8E EE        call checkConstSize
27CE 83 C4 02        add  sp, 2
27D1 08 C0           or  al, al
27D3 0F 84 00 00   r je .process306
27D7                
27D7                ;-1233                     genCode2(Code1, 0x70);//short
27D7                
27D7 6A 70           push 112
27D9 A0 30 01        mov al, byte [Code1]
27DC B4 00           mov ah, 0
27DE 50              push ax
27DF E8 F6 EB        call genCode2
27E2 83 C4 04        add  sp, 4
27E5                
27E5                ;-1234                     disp -= 2;
27E5                
27E5 83 2E 3D 01 02  sub  word[disp], 2
27EA                
27EA                ;-1235                     genCode8(disp);
27EA                
27EA FF 36 3D 01     push word [disp]
27EE E8 88 EB        call genCode8
27F1 83 C4 02        add  sp, 2
27F4                
27F4                ;-1236                 } else {
27F4                
27F4 E9 00 00      R jmp .process307
27F7                .process306:
27F7                
27F7                ;-1237                     genCode8(0x0F);
27F7                
27F7 6A 0F           push 15
27F9 E8 7D EB        call genCode8
27FC 83 C4 02        add  sp, 2
27FF                
27FF                ;-1238                     genCode2(Code1, 0x80);//near
27FF                
27FF 68 80 00        push 128
2802 A0 30 01        mov al, byte [Code1]
2805 B4 00           mov ah, 0
2807 50              push ax
2808 E8 CD EB        call genCode2
280B 83 C4 04        add  sp, 4
280E                
280E                ;-1239                     disp -= 4;
280E                
280E 83 2E 3D 01 04  sub  word[disp], 4
2813                
2813                ;-1240                     genCode16(disp);
2813                
2813 FF 36 3D 01     push word [disp]
2817 E8 F5 EB        call genCode16
281A 83 C4 02        add  sp, 2
281D                
281D                ;-1241                 }
281D                
281D                
281D                ;-1242             }
281D                
281D                .process307:
281D                
281D                ;-1243             else {//jump forward, near only
281D                
281D E9 00 00      R jmp .process308
2820                .process305:
2820                
2820                ;-1244                 genCode8(0x0F);
2820                
2820 6A 0F           push 15
2822 E8 54 EB        call genCode8
2825 83 C4 02        add  sp, 2
2828                
2828                ;-1245                 genCode2(Code1, 0x80);
2828                
2828 68 80 00        push 128
282B A0 30 01        mov al, byte [Code1]
282E B4 00           mov ah, 0
2830 50              push ax
2831 E8 A4 EB        call genCode2
2834 83 C4 04        add  sp, 4
2837                
2837                ;-1246                 storeJmp();
2837                
2837 E8 9E F3        call storeJmp
283A                
283A                ;-1247                 genCode16(0);
283A                
283A 6A 00           push 0
283C E8 D0 EB        call genCode16
283F 83 C4 02        add  sp, 2
2842                
2842                ;-1248                 PrintRA='r';
2842                
2842 B8 72 00        mov ax, 114
2845 A2 45 01        mov byte [PrintRA], al
2848                
2848                ;-1249             }
2848                
2848                
2848                ;-1250         return;
2848                
2848                .process308:
2848 E9 00 00      R jmp .retnprocess
284B                
284B                ;-1251         }
284B                
284B                
284B                ;-1252     }
284B                
284B                .process304:
284B                
284B                ;-1253 
284B                
284B                
284B                ;-1254     if (CodeType == 7) {//jmp, call
284B                
284B                .process303:
284B A0 2F 01        mov al, [CodeType]
284E 3C 07           cmp al, 7
2850 0F 85 00 00   r jne .process309
2854                
2854                ;-1255         if (TokeType == ALNUME) {
2854                
2854 A0 2C 01        mov al, [TokeType]
2857 3C 03           cmp al, 3
2859 0F 85 00 00   r jne .process310
285D                
285D                ;-1256             LabelIx=searchLabel();
285D                
285D E8 08 F0        call searchLabel
2860 A3 4E 01        mov word [LabelIx], ax
2863                
2863                ;-1257             if (LabelIx > 0) {
2863                
2863 A1 4E 01        mov ax, [LabelIx]
2866 83 F8 00        cmp ax, 0
2869 0F 8E 00 00   r jle .process311
286D                
286D                ;-1258                 disp=LabelAddr[LabelIx];
286D                
286D 8B 1E 4E 01     mov bx, [LabelIx]
2871 D1 E3           shl bx, 1
2873 8B 47 CA        mov ax, [LabelAddr + bx]
2876 A3 3D 01        mov word [disp], ax
2879                
2879                ;-1259                 disp = disp - PC;
2879                
2879 A1 3D 01        mov ax, [disp]
287C 2B 06 23 01     sub ax, [PC]
2880 A3 3D 01        mov word [disp], ax
2883                
2883                ;-1260                 disp = disp - Origin;
2883                
2883 A1 3D 01        mov ax, [disp]
2886 2B 06 25 01     sub ax, [Origin]
288A A3 3D 01        mov word [disp], ax
288D                
288D                ;-1261                 if (checkConstSize(disp) ) {
288D                
288D FF 36 3D 01     push word [disp]
2891 E8 C8 ED        call checkConstSize
2894 83 C4 02        add  sp, 2
2897 08 C0           or  al, al
2899 0F 84 00 00   r je .process312
289D                
289D                ;-1262                     if (Code1 == 0xE9) {//jmp only
289D                
289D A0 30 01        mov al, [Code1]
28A0 3C E9           cmp al, 233
28A2 0F 85 00 00   r jne .process313
28A6                
28A6                ;-1263                         genCode8(0xEB);//short
28A6                
28A6 68 EB 00        push 235
28A9 E8 CD EA        call genCode8
28AC 83 C4 02        add  sp, 2
28AF                
28AF                ;-1264                         disp -= 2;
28AF                
28AF 83 2E 3D 01 02  sub  word[disp], 2
28B4                
28B4                ;-1265                         genCode8(disp);
28B4                
28B4 FF 36 3D 01     push word [disp]
28B8 E8 BE EA        call genCode8
28BB 83 C4 02        add  sp, 2
28BE                
28BE                ;-1266                     }
28BE                
28BE                
28BE                ;-1267                     else {
28BE                
28BE E9 00 00      R jmp .process314
28C1                .process313:
28C1                
28C1                ;-1268                         genCode8(Code1);//near
28C1                
28C1 A0 30 01        mov al, byte [Code1]
28C4 B4 00           mov ah, 0
28C6 50              push ax
28C7 E8 AF EA        call genCode8
28CA 83 C4 02        add  sp, 2
28CD                
28CD                ;-1269                         disp -= 3;
28CD                
28CD 83 2E 3D 01 03  sub  word[disp], 3
28D2                
28D2                ;-1270                         genCode16(disp);
28D2                
28D2 FF 36 3D 01     push word [disp]
28D6 E8 36 EB        call genCode16
28D9 83 C4 02        add  sp, 2
28DC                
28DC                ;-1271                     }
28DC                
28DC                
28DC                ;-1272                 }
28DC                
28DC                .process314:
28DC                
28DC                ;-1273                 else {
28DC                
28DC E9 00 00      R jmp .process315
28DF                .process312:
28DF                
28DF                ;-1274                     genCode8(Code1);//near
28DF                
28DF A0 30 01        mov al, byte [Code1]
28E2 B4 00           mov ah, 0
28E4 50              push ax
28E5 E8 91 EA        call genCode8
28E8 83 C4 02        add  sp, 2
28EB                
28EB                ;-1275                     disp -= 3;
28EB                
28EB 83 2E 3D 01 03  sub  word[disp], 3
28F0                
28F0                ;-1276                     genCode16(disp);
28F0                
28F0 FF 36 3D 01     push word [disp]
28F4 E8 18 EB        call genCode16
28F7 83 C4 02        add  sp, 2
28FA                
28FA                ;-1277                 }
28FA                
28FA                
28FA                ;-1278             }
28FA                
28FA                .process315:
28FA                
28FA                ;-1279             else {//jump forward, near only
28FA                
28FA E9 00 00      R jmp .process316
28FD                .process311:
28FD                
28FD                ;-1280                 genCode8(Code1);  
28FD                
28FD A0 30 01        mov al, byte [Code1]
2900 B4 00           mov ah, 0
2902 50              push ax
2903 E8 73 EA        call genCode8
2906 83 C4 02        add  sp, 2
2909                
2909                ;-1281                 if (PC != 1) storeJmp();//omit jmp main
2909                
2909 A1 23 01        mov ax, [PC]
290C 83 F8 01        cmp ax, 1
290F 0F 84 00 00   r je  .process317
2913 E8 C2 F2        call storeJmp
2916                
2916                ;-1282                 genCode16(0);
2916                
2916                .process317:
2916 6A 00           push 0
2918 E8 F4 EA        call genCode16
291B 83 C4 02        add  sp, 2
291E                
291E                ;-1283                 PrintRA='R';
291E                
291E B8 52 00        mov ax, 82
2921 A2 45 01        mov byte [PrintRA], al
2924                
2924                ;-1284             }
2924                
2924                
2924                ;-1285         return;
2924                
2924                .process316:
2924 E9 00 00      R jmp .retnprocess
2927                
2927                ;-1286         }
2927                
2927                
2927                ;-1287     }
2927                
2927                .process310:
2927                
2927                ;-1288 
2927                
2927                
2927                ;-1289     if (CodeType ==  8) {//ret,retf
2927                
2927                .process309:
2927 A0 2F 01        mov al, [CodeType]
292A 3C 08           cmp al, 8
292C 0F 85 00 00   r jne .process318
2930                
2930                ;-1290         if (TokeType == DIGIT) {
2930                
2930 A0 2C 01        mov al, [TokeType]
2933 3C 01           cmp al, 1
2935 0F 85 00 00   r jne .process319
2939                
2939                ;-1291             genCode8(Code2);
2939                
2939 A0 31 01        mov al, byte [Code2]
293C B4 00           mov ah, 0
293E 50              push ax
293F E8 37 EA        call genCode8
2942 83 C4 02        add  sp, 2
2945                
2945                ;-1292             genCode16(SymbolInt);
2945                
2945 FF 36 0E 01     push word [SymbolInt]
2949 E8 C3 EA        call genCode16
294C 83 C4 02        add  sp, 2
294F                
294F                ;-1293             return;
294F                
294F E9 00 00      R jmp .retnprocess
2952                
2952                ;-1294         }
2952                
2952                
2952                ;-1295         genCode8(Code1);
2952                
2952                .process319:
2952 A0 30 01        mov al, byte [Code1]
2955 B4 00           mov ah, 0
2957 50              push ax
2958 E8 1E EA        call genCode8
295B 83 C4 02        add  sp, 2
295E                
295E                ;-1296         return;
295E                
295E E9 00 00      R jmp .retnprocess
2961                
2961                ;-1297     }
2961                
2961                
2961                ;-1298 
2961                
2961                
2961                ;-1299     if (CodeType == 9) {//push, pop
2961                
2961                .process318:
2961 A0 2F 01        mov al, [CodeType]
2964 3C 09           cmp al, 9
2966 0F 85 00 00   r jne .process320
296A                
296A                ;-1300         getOpL();
296A                
296A E8 E8 F1        call getOpL
296D                
296D                ;-1301         if (Code1 == 0x50) {//push only
296D                
296D A0 30 01        mov al, [Code1]
2970 3C 50           cmp al, 80
2972 0F 85 00 00   r jne .process321
2976                
2976                ;-1302             if (Op == IMM) {//push imm8,16
2976                
2976 A0 2D 01        mov al, [Op]
2979 3C 01           cmp al, 1
297B 0F 85 00 00   r jne .process322
297F                
297F                ;-1303                 setsflag();
297F                
297F E8 7E EC        call setsflag
2982                
2982                ;-1304                 genCode2(0x68, sflag);
2982                
2982 A0 3A 01        mov al, byte [sflag]
2985 B4 00           mov ah, 0
2987 50              push ax
2988 6A 68           push 104
298A E8 4B EA        call genCode2
298D 83 C4 04        add  sp, 4
2990                
2990                ;-1305                 if (sflag) genCode8 (imme);
2990                
2990 A0 3A 01        mov al, [sflag]
2993 08 C0           or  al, al
2995 0F 84 00 00   r je .process323
2999 FF 36 3F 01     push word [imme]
299D E8 D9 E9        call genCode8
29A0 83 C4 02        add  sp, 2
29A3                
29A3                ;-1306                 else       genCode16(imme);
29A3                
29A3 E9 00 00      R jmp .process324
29A6                .process323:
29A6 FF 36 3F 01     push word [imme]
29AA E8 62 EA        call genCode16
29AD 83 C4 02        add  sp, 2
29B0                
29B0                ;-1307                 return;
29B0                
29B0                .process324:
29B0 E9 00 00      R jmp .retnprocess
29B3                
29B3                ;-1308             }
29B3                
29B3                
29B3                ;-1309             if (Op == ADR) {//push string ABSOLUTE i16 
29B3                
29B3                .process322:
29B3 A0 2D 01        mov al, [Op]
29B6 3C 03           cmp al, 3
29B8 0F 85 00 00   r jne .process325
29BC                
29BC                ;-1310 //prscomment("\n push disp: "); printhex16 (disp);
29BC                
29BC                
29BC                ;-1311                 if (disp) {
29BC                
29BC A1 3D 01        mov ax, [disp]
29BF 08 C0           or  al, al
29C1 0F 84 00 00   r je .process326
29C5                
29C5                ;-1312                     genCode8(0x68);
29C5                
29C5 6A 68           push 104
29C7 E8 AF E9        call genCode8
29CA 83 C4 02        add  sp, 2
29CD                
29CD                ;-1313                     genCode16(disp);
29CD                
29CD FF 36 3D 01     push word [disp]
29D1 E8 3B EA        call genCode16
29D4 83 C4 02        add  sp, 2
29D7                
29D7                ;-1314                     return;
29D7                
29D7 E9 00 00      R jmp .retnprocess
29DA                
29DA                ;-1315                 }
29DA                
29DA                
29DA                ;-1316                 else {
29DA                
29DA E9 00 00      R jmp .process327
29DD                .process326:
29DD                
29DD                ;-1317                     genCode8(0x68);
29DD                
29DD 6A 68           push 104
29DF E8 97 E9        call genCode8
29E2 83 C4 02        add  sp, 2
29E5                
29E5                ;-1318                     storeJmp();
29E5                
29E5 E8 F0 F1        call storeJmp
29E8                
29E8                ;-1319                     genCode16(0xAAAA);//magic for abs ADR
29E8                
29E8 68 AA AA        push 43690
29EB E8 21 EA        call genCode16
29EE 83 C4 02        add  sp, 2
29F1                
29F1                ;-1320                     PrintRA='A';
29F1                
29F1 B8 41 00        mov ax, 65
29F4 A2 45 01        mov byte [PrintRA], al
29F7                
29F7                ;-1321                     return;
29F7                
29F7 E9 00 00      R jmp .retnprocess
29FA                
29FA                ;-1322                 }
29FA                
29FA                
29FA                ;-1323             }
29FA                
29FA                .process327:
29FA                
29FA                ;-1324         }
29FA                
29FA                .process325:
29FA                
29FA                ;-1325         if (R1Type == SEGREG) {
29FA                
29FA                .process321:
29FA A0 36 01        mov al, [R1Type]
29FD 3C 04           cmp al, 4
29FF 0F 85 00 00   r jne .process328
2A03                
2A03                ;-1326             if (Code1 == 0x58) {//pop only
2A03                
2A03 A0 30 01        mov al, [Code1]
2A06 3C 58           cmp al, 88
2A08 0F 85 00 00   r jne .process329
2A0C                
2A0C                ;-1327                 if (R1No == 1) error1("pop cs not allowed");
2A0C                
2A0C A0 34 01        mov al, [R1No]
2A0F 3C 01           cmp al, 1
2A11 0F 85 00 00   r jne .process330
2A15 68 AA AA      A push process_0
2A18 E8 20 E0        call error1
2A1B 83 C4 02        add  sp, 2
2A1E                
2A1E                ;-1328             }
2A1E                
2A1E                .process330:
2A1E                
2A1E                ;-1329             c = R1No <<3;
2A1E                
2A1E                .process329:
2A1E A0 34 01        mov al, [R1No]
2A21 C0 E0 03        shl al, 3
2A24 88 46 FE        mov [bp-2], al
2A27                
2A27                ;-1330             if (R1No > 3) {//FS, GS
2A27                
2A27 A0 34 01        mov al, [R1No]
2A2A 3C 03           cmp al, 3
2A2C 0F 8E 00 00   r jle .process331
2A30                
2A30                ;-1331                 c += 122;
2A30                
2A30 80 46 FE 7A     add  byte[bp-2], 122
2A34                
2A34                ;-1332                 genCode8(0x0F);
2A34                
2A34 6A 0F           push 15
2A36 E8 40 E9        call genCode8
2A39 83 C4 02        add  sp, 2
2A3C                
2A3C                ;-1333             }
2A3C                
2A3C                
2A3C                ;-1334             OpCodePtr++;
2A3C                
2A3C                .process331:
2A3C FF 06 43 01     inc  word[OpCodePtr]
2A40                
2A40                ;-1335             c = c + *OpCodePtr;////////////////is Code4
2A40                
2A40 8A 46 FE        mov al, [bp-2]
2A43 8B 1E 43 01     mov bx, [OpCodePtr]
2A47 02 07           add al, [bx]
2A49 B4 00           mov ah, 0
2A4B 88 46 FE        mov [bp-2], al
2A4E                
2A4E                ;-1336             genCode8(c);
2A4E                
2A4E 8A 46 FE        mov al, byte [bp-2]
2A51 B4 00           mov ah, 0
2A53 50              push ax
2A54 E8 22 E9        call genCode8
2A57 83 C4 02        add  sp, 2
2A5A                
2A5A                ;-1337             return;
2A5A                
2A5A E9 00 00      R jmp .retnprocess
2A5D                
2A5D                ;-1338         }
2A5D                
2A5D                
2A5D                ;-1339         checkOpL();//no ADR, SEGREG
2A5D                
2A5D                .process328:
2A5D E8 86 ED        call checkOpL
2A60                
2A60                ;-1340         if (R1Type == BYTE) reg16error();
2A60                
2A60 A0 36 01        mov al, [R1Type]
2A63 3C 01           cmp al, 1
2A65 0F 85 00 00   r jne .process332
2A69 E8 7D E1        call reg16error
2A6C                
2A6C                ;-1341         if (R1Type == WORD) {
2A6C                
2A6C                .process332:
2A6C A0 36 01        mov al, [R1Type]
2A6F 3C 02           cmp al, 2
2A71 0F 85 00 00   r jne .process333
2A75                
2A75                ;-1342             genCode2(Code1, R1No);
2A75                
2A75 A0 34 01        mov al, byte [R1No]
2A78 B4 00           mov ah, 0
2A7A 50              push ax
2A7B A0 30 01        mov al, byte [Code1]
2A7E B4 00           mov ah, 0
2A80 50              push ax
2A81 E8 54 E9        call genCode2
2A84 83 C4 04        add  sp, 4
2A87                
2A87                ;-1343             return;
2A87                
2A87 E9 00 00      R jmp .retnprocess
2A8A                
2A8A                ;-1344         }
2A8A                
2A8A                
2A8A                ;-1345         if (Op == MEM) {
2A8A                
2A8A                .process333:
2A8A A0 2D 01        mov al, [Op]
2A8D 3C 04           cmp al, 4
2A8F 0F 85 00 00   r jne .process334
2A93                
2A93                ;-1346             genCode8(Code2);
2A93                
2A93 A0 31 01        mov al, byte [Code2]
2A96 B4 00           mov ah, 0
2A98 50              push ax
2A99 E8 DD E8        call genCode8
2A9C 83 C4 02        add  sp, 2
2A9F                
2A9F                ;-1347             writeEA(Code3);//////////////////Code3
2A9F                
2A9F A0 32 01        mov al, byte [Code3]
2AA2 B4 00           mov ah, 0
2AA4 50              push ax
2AA5 E8 AE E9        call writeEA
2AA8 83 C4 02        add  sp, 2
2AAB                
2AAB                ;-1348             return;
2AAB                
2AAB E9 00 00      R jmp .retnprocess
2AAE                
2AAE                ;-1349         }
2AAE                
2AAE                
2AAE                ;-1350         syntaxerror();
2AAE                
2AAE                .process334:
2AAE E8 87 E1        call syntaxerror
2AB1                
2AB1                ;-1351         return;
2AB1                
2AB1 E9 00 00      R jmp .retnprocess
2AB4                
2AB4                ;-1352     }
2AB4                
2AB4                
2AB4                ;-1353 
2AB4                
2AB4                
2AB4                ;-1354     if (CodeType == 11) {//shift, rotate
2AB4                
2AB4                .process320:
2AB4 A0 2F 01        mov al, [CodeType]
2AB7 3C 0B           cmp al, 11
2AB9 0F 85 00 00   r jne .process335
2ABD                
2ABD                ;-1355         check2Ops();
2ABD                
2ABD E8 CC F0        call check2Ops
2AC0                
2AC0                ;-1356         if (Op2 == IMM) {
2AC0                
2AC0 A0 2E 01        mov al, [Op2]
2AC3 3C 01           cmp al, 1
2AC5 0F 85 00 00   r jne .process336
2AC9                
2AC9                ;-1357             if (imme == 1) {
2AC9                
2AC9 A1 3F 01        mov ax, [imme]
2ACC 83 F8 01        cmp ax, 1
2ACF 0F 85 00 00   r jne .process337
2AD3                
2AD3                ;-1358                 genCodeW(0xD0);
2AD3                
2AD3 68 D0 00        push 208
2AD6 E8 1A E9        call genCodeW
2AD9 83 C4 02        add  sp, 2
2ADC                
2ADC                ;-1359                 writeEA(Code1);
2ADC                
2ADC A0 30 01        mov al, byte [Code1]
2ADF B4 00           mov ah, 0
2AE1 50              push ax
2AE2 E8 71 E9        call writeEA
2AE5 83 C4 02        add  sp, 2
2AE8                
2AE8                ;-1360                 return;
2AE8                
2AE8 E9 00 00      R jmp .retnprocess
2AEB                
2AEB                ;-1361             }
2AEB                
2AEB                
2AEB                ;-1362             genCodeW(0xC0);//80186
2AEB                
2AEB                .process337:
2AEB 68 C0 00        push 192
2AEE E8 02 E9        call genCodeW
2AF1 83 C4 02        add  sp, 2
2AF4                
2AF4                ;-1363             writeEA(Code1);
2AF4                
2AF4 A0 30 01        mov al, byte [Code1]
2AF7 B4 00           mov ah, 0
2AF9 50              push ax
2AFA E8 59 E9        call writeEA
2AFD 83 C4 02        add  sp, 2
2B00                
2B00                ;-1364             genCode8(imme);
2B00                
2B00 FF 36 3F 01     push word [imme]
2B04 E8 72 E8        call genCode8
2B07 83 C4 02        add  sp, 2
2B0A                
2B0A                ;-1365             return;
2B0A                
2B0A E9 00 00      R jmp .retnprocess
2B0D                
2B0D                ;-1366         }
2B0D                
2B0D                
2B0D                ;-1367         if (Op2 == REG) {
2B0D                
2B0D                .process336:
2B0D A0 2E 01        mov al, [Op2]
2B10 3C 02           cmp al, 2
2B12 0F 85 00 00   r jne .process338
2B16                
2B16                ;-1368             if (R2Type == BYTE) {
2B16                
2B16 A0 35 01        mov al, [R2Type]
2B19 3C 01           cmp al, 1
2B1B 0F 85 00 00   r jne .process339
2B1F                
2B1F                ;-1369                 if (R2No == 1) {//CL-REG
2B1F                
2B1F A0 33 01        mov al, [R2No]
2B22 3C 01           cmp al, 1
2B24 0F 85 00 00   r jne .process340
2B28                
2B28                ;-1370                     if (R1Type == WORD) wflag=1;//hack
2B28                
2B28 A0 36 01        mov al, [R1Type]
2B2B 3C 02           cmp al, 2
2B2D 0F 85 00 00   r jne .process341
2B31 B8 01 00        mov ax, 1
2B34 A2 38 01        mov byte [wflag], al
2B37                
2B37                ;-1371                     genCodeW(0xD2);
2B37                
2B37                .process341:
2B37 68 D2 00        push 210
2B3A E8 B6 E8        call genCodeW
2B3D 83 C4 02        add  sp, 2
2B40                
2B40                ;-1372                     writeEA(Code1);
2B40                
2B40 A0 30 01        mov al, byte [Code1]
2B43 B4 00           mov ah, 0
2B45 50              push ax
2B46 E8 0D E9        call writeEA
2B49 83 C4 02        add  sp, 2
2B4C                
2B4C                ;-1373                     return;
2B4C                
2B4C E9 00 00      R jmp .retnprocess
2B4F                
2B4F                ;-1374                 }
2B4F                
2B4F                
2B4F                ;-1375             }
2B4F                
2B4F                .process340:
2B4F                
2B4F                ;-1376         }
2B4F                
2B4F                .process339:
2B4F                
2B4F                ;-1377     }
2B4F                
2B4F                .process338:
2B4F                
2B4F                ;-1378 
2B4F                
2B4F                
2B4F                ;-1379     if (CodeType == 12) {//int
2B4F                
2B4F                .process335:
2B4F A0 2F 01        mov al, [CodeType]
2B52 3C 0C           cmp al, 12
2B54 0F 85 00 00   r jne .process342
2B58                
2B58                ;-1380         if (TokeType == DIGIT) {
2B58                
2B58 A0 2C 01        mov al, [TokeType]
2B5B 3C 01           cmp al, 1
2B5D 0F 85 00 00   r jne .process343
2B61                
2B61                ;-1381             genCode8(Code1);
2B61                
2B61 A0 30 01        mov al, byte [Code1]
2B64 B4 00           mov ah, 0
2B66 50              push ax
2B67 E8 0F E8        call genCode8
2B6A 83 C4 02        add  sp, 2
2B6D                
2B6D                ;-1382             genCode8(SymbolInt);
2B6D                
2B6D FF 36 0E 01     push word [SymbolInt]
2B71 E8 05 E8        call genCode8
2B74 83 C4 02        add  sp, 2
2B77                
2B77                ;-1383             return;
2B77                
2B77 E9 00 00      R jmp .retnprocess
2B7A                
2B7A                ;-1384         }
2B7A                
2B7A                
2B7A                ;-1385     }
2B7A                
2B7A                .process343:
2B7A                
2B7A                ;-1386 
2B7A                
2B7A                
2B7A                ;-1387     if (CodeType == 30) {//enter i18,i8
2B7A                
2B7A                .process342:
2B7A A0 2F 01        mov al, [CodeType]
2B7D 3C 1E           cmp al, 30
2B7F 0F 85 00 00   r jne .process344
2B83                
2B83                ;-1388         genCode8(0xC8);
2B83                
2B83 68 C8 00        push 200
2B86 E8 F0 E7        call genCode8
2B89 83 C4 02        add  sp, 2
2B8C                
2B8C                ;-1389         Op=getOp1();
2B8C                
2B8C E8 29 ED        call getOp1
2B8F A2 2D 01        mov byte [Op], al
2B92                
2B92                ;-1390         if (Op == IMM) genCode16(SymbolInt);
2B92                
2B92 A0 2D 01        mov al, [Op]
2B95 3C 01           cmp al, 1
2B97 0F 85 00 00   r jne .process345
2B9B FF 36 0E 01     push word [SymbolInt]
2B9F E8 6D E8        call genCode16
2BA2 83 C4 02        add  sp, 2
2BA5                
2BA5                ;-1391         else numbererror();
2BA5                
2BA5 E9 00 00      R jmp .process346
2BA8                .process345:
2BA8 E8 FA DF        call numbererror
2BAB                
2BAB                ;-1392         need(',');
2BAB                
2BAB                .process346:
2BAB 6A 2C           push 44
2BAD E8 CE EB        call need
2BB0 83 C4 02        add  sp, 2
2BB3                
2BB3                ;-1393         Op=getOp1();
2BB3                
2BB3 E8 02 ED        call getOp1
2BB6 A2 2D 01        mov byte [Op], al
2BB9                
2BB9                ;-1394         if (Op == IMM) genCode8 (SymbolInt);
2BB9                
2BB9 A0 2D 01        mov al, [Op]
2BBC 3C 01           cmp al, 1
2BBE 0F 85 00 00   r jne .process347
2BC2 FF 36 0E 01     push word [SymbolInt]
2BC6 E8 B0 E7        call genCode8
2BC9 83 C4 02        add  sp, 2
2BCC                
2BCC                ;-1395         else numbererror();
2BCC                
2BCC E9 00 00      R jmp .process348
2BCF                .process347:
2BCF E8 D3 DF        call numbererror
2BD2                
2BD2                ;-1396         return;
2BD2                
2BD2                .process348:
2BD2 E9 00 00      R jmp .retnprocess
2BD5                
2BD5                ;-1397     }
2BD5                
2BD5                
2BD5                ;-1398 
2BD5                
2BD5                
2BD5                ;-1399     if (CodeType==101) {//ORG nn
2BD5                
2BD5                .process344:
2BD5 A0 2F 01        mov al, [CodeType]
2BD8 3C 65           cmp al, 101
2BDA 0F 85 00 00   r jne .process349
2BDE                
2BDE                ;-1400         if (TokeType != DIGIT) numbererror();
2BDE                
2BDE A0 2C 01        mov al, [TokeType]
2BE1 3C 01           cmp al, 1
2BE3 0F 84 00 00   r je  .process350
2BE7 E8 BB DF        call numbererror
2BEA                
2BEA                ;-1401         Origin=SymbolInt;
2BEA                
2BEA                .process350:
2BEA A1 0E 01        mov ax, [SymbolInt]
2BED A3 25 01        mov word [Origin], ax
2BF0                
2BF0                ;-1402         return;
2BF0                
2BF0 E9 00 00      R jmp .retnprocess
2BF3                
2BF3                ;-1403     }
2BF3                
2BF3                
2BF3                ;-1404 
2BF3                
2BF3                
2BF3                ;-1405     if (CodeType == 102) {//section, segment
2BF3                
2BF3                .process349:
2BF3 A0 2F 01        mov al, [CodeType]
2BF6 3C 66           cmp al, 102
2BF8 0F 85 00 00   r jne .process351
2BFC                
2BFC                ;-1406         //getTokeType();//ignore .bss .text .data
2BFC                
2BFC                
2BFC                ;-1407         AbsoluteLab=0;//nasm resets erevy time
2BFC                
2BFC B8 00 00        mov ax, 0
2BFF A3 27 01        mov word [AbsoluteLab], ax
2C02                
2C02                ;-1408         return;
2C02                
2C02 E9 00 00      R jmp .retnprocess
2C05                
2C05                ;-1409     }
2C05                
2C05                
2C05                ;-1410 
2C05                
2C05                
2C05                ;-1411     if (CodeType == 110) {//absolute
2C05                
2C05                .process351:
2C05 A0 2F 01        mov al, [CodeType]
2C08 3C 6E           cmp al, 110
2C0A 0F 85 00 00   r jne .process352
2C0E                
2C0E                ;-1412         if (TokeType != DIGIT) numbererror();
2C0E                
2C0E A0 2C 01        mov al, [TokeType]
2C11 3C 01           cmp al, 1
2C13 0F 84 00 00   r je  .process353
2C17 E8 8B DF        call numbererror
2C1A                
2C1A                ;-1413         AbsoluteLab=SymbolInt;
2C1A                
2C1A                .process353:
2C1A A1 0E 01        mov ax, [SymbolInt]
2C1D A3 27 01        mov word [AbsoluteLab], ax
2C20                
2C20                ;-1414         return;
2C20                
2C20 E9 00 00      R jmp .retnprocess
2C23                
2C23                ;-1415     }
2C23                
2C23                
2C23                ;-1416     if (CodeType == 111) {//name: PROC
2C23                
2C23                .process352:
2C23 A0 2F 01        mov al, [CodeType]
2C26 3C 6F           cmp al, 111
2C28 0F 85 00 00   r jne .process354
2C2C                
2C2C                ;-1417         if (isInProc == 0)  {
2C2C                
2C2C A0 0D 01        mov al, [isInProc]
2C2F 3C 00           cmp al, 0
2C31 0F 85 00 00   r jne .process355
2C35                
2C35                ;-1418             prs("\nentering: ");
2C35                
2C35 68 AA AA      A push process_1
2C38 E8 F4 DA        call prs
2C3B 83 C4 02        add  sp, 2
2C3E                
2C3E                ;-1419             prs(ProcName);
2C3E                
2C3E 8D 06 6E 75     lea  ax, [ProcName]
2C42 50              push ax
2C43 E8 E9 DA        call prs
2C46 83 C4 02        add  sp, 2
2C49                
2C49                ;-1420             isInProc=1;
2C49                
2C49 B8 01 00        mov ax, 1
2C4C A2 0D 01        mov byte [isInProc], al
2C4F                
2C4F                ;-1421             tmpLabelNamePtr = LabelNamePtr;
2C4F                
2C4F A1 46 01        mov ax, [LabelNamePtr]
2C52 A3 48 01        mov word [tmpLabelNamePtr], ax
2C55                
2C55                ;-1422             tmpLabelMaxIx   = LabelMaxIx;
2C55                
2C55 A1 4A 01        mov ax, [LabelMaxIx]
2C58 A3 4C 01        mov word [tmpLabelMaxIx], ax
2C5B                
2C5B                ;-1423             tmpJmpNamePtr   = JmpNamePtr;
2C5B                
2C5B A1 50 01        mov ax, [JmpNamePtr]
2C5E A3 52 01        mov word [tmpJmpNamePtr], ax
2C61                
2C61                ;-1424             tmpJmpMaxIx     = JmpMaxIx;
2C61                
2C61 A1 54 01        mov ax, [JmpMaxIx]
2C64 A3 56 01        mov word [tmpJmpMaxIx], ax
2C67                
2C67                ;-1425         } else error1("already in PROC");
2C67                
2C67 E9 00 00      R jmp .process356
2C6A                .process355:
2C6A 68 AA AA      A push process_2
2C6D E8 CB DD        call error1
2C70 83 C4 02        add  sp, 2
2C73                
2C73                ;-1426         return;
2C73                
2C73                .process356:
2C73 E9 00 00      R jmp .retnprocess
2C76                
2C76                ;-1427     }
2C76                
2C76                
2C76                ;-1428     if (CodeType == 112) {//ENDP 
2C76                
2C76                .process354:
2C76 A0 2F 01        mov al, [CodeType]
2C79 3C 70           cmp al, 112
2C7B 0F 85 00 00   r jne .process357
2C7F                
2C7F                ;-1429         if (isInProc == 0) error1("not in PROC");
2C7F                
2C7F A0 0D 01        mov al, [isInProc]
2C82 3C 00           cmp al, 0
2C84 0F 85 00 00   r jne .process358
2C88 68 AA AA      A push process_3
2C8B E8 AD DD        call error1
2C8E 83 C4 02        add  sp, 2
2C91                
2C91                ;-1430         prs("\nleaving: ");
2C91                
2C91                .process358:
2C91 68 AA AA      A push process_4
2C94 E8 98 DA        call prs
2C97 83 C4 02        add  sp, 2
2C9A                
2C9A                ;-1431         prs(ProcName);
2C9A                
2C9A 8D 06 6E 75     lea  ax, [ProcName]
2C9E 50              push ax
2C9F E8 8D DA        call prs
2CA2 83 C4 02        add  sp, 2
2CA5                
2CA5                ;-1432         prs(", loc labels: ");
2CA5                
2CA5 68 AA AA      A push process_5
2CA8 E8 84 DA        call prs
2CAB 83 C4 02        add  sp, 2
2CAE                
2CAE                ;-1433         i = LabelMaxIx - tmpLabelMaxIx;
2CAE                
2CAE A1 4A 01        mov ax, [LabelMaxIx]
2CB1 2B 06 4C 01     sub ax, [tmpLabelMaxIx]
2CB5 89 46 FC        mov [bp-4], ax
2CB8                
2CB8                ;-1434         printIntU(i);
2CB8                
2CB8 55              push word [bp-4]
2CB9 E8 7F DB        call printIntU
2CBC 83 C4 02        add  sp, 2
2CBF                
2CBF                ;-1435         prs(", loc jmp forward: ");
2CBF                
2CBF 68 AA AA      A push process_6
2CC2 E8 6A DA        call prs
2CC5 83 C4 02        add  sp, 2
2CC8                
2CC8                ;-1436         i = JmpMaxIx - tmpJmpMaxIx;
2CC8                
2CC8 A1 54 01        mov ax, [JmpMaxIx]
2CCB 2B 06 56 01     sub ax, [tmpJmpMaxIx]
2CCF 89 46 FC        mov [bp-4], ax
2CD2                
2CD2                ;-1437         printIntU(i);        
2CD2                
2CD2 55              push word [bp-4]
2CD3 E8 65 DB        call printIntU
2CD6 83 C4 02        add  sp, 2
2CD9                
2CD9                ;-1438         fixJmp();
2CD9                
2CD9 E8 EE F4        call fixJmp
2CDC                
2CDC                ;-1439         isInProc=0;
2CDC                
2CDC B8 00 00        mov ax, 0
2CDF A2 0D 01        mov byte [isInProc], al
2CE2                
2CE2                ;-1440         LabelNamePtr = tmpLabelNamePtr;//delete local Labels
2CE2                
2CE2 A1 48 01        mov ax, [tmpLabelNamePtr]
2CE5 A3 46 01        mov word [LabelNamePtr], ax
2CE8                
2CE8                ;-1441         LabelMaxIx   = tmpLabelMaxIx;                       
2CE8                
2CE8 A1 4C 01        mov ax, [tmpLabelMaxIx]
2CEB A3 4A 01        mov word [LabelMaxIx], ax
2CEE                
2CEE                ;-1442         JmpNamePtr   = tmpJmpNamePtr;//delete local Jmp
2CEE                
2CEE A1 52 01        mov ax, [tmpJmpNamePtr]
2CF1 A3 50 01        mov word [JmpNamePtr], ax
2CF4                
2CF4                ;-1443         JmpMaxIx     = tmpJmpMaxIx;
2CF4                
2CF4 A1 56 01        mov ax, [tmpJmpMaxIx]
2CF7 A3 54 01        mov word [JmpMaxIx], ax
2CFA                
2CFA                ;-1444         return;
2CFA                
2CFA E9 00 00      R jmp .retnprocess
2CFD                
2CFD                ;-1445     } 
2CFD                
2CFD                
2CFD                ;-1446     if (CodeType == 200) {//db  
2CFD                
2CFD                .process357:
2CFD A0 2F 01        mov al, [CodeType]
2D00 3C C8           cmp al, 200
2D02 0F 85 00 00   r jne .process359
2D06                
2D06                ;-1447         genDB();
2D06                
2D06 E8 EA EF        call genDB
2D09                
2D09                ;-1448         return;
2D09                
2D09 E9 00 00      R jmp .retnprocess
2D0C                
2D0C                ;-1449     }
2D0C                
2D0C                
2D0C                ;-1450     
2D0C                
2D0C                
2D0C                ;-1451     error1("Command not implemented or syntax error");
2D0C                
2D0C                .process359:
2D0C 68 AA AA      A push process_7
2D0F E8 29 DD        call error1
2D12 83 C4 02        add  sp, 2
2D15                
2D15                ;-1452 }
2D15                
2D15                
2D15                ;-1453 
2D15                
2D15                
2D15                ;-1454 int parse() {
2D15                
2D15 C9              .retnprocess: LEAVE
2D16 C3              ret
2D17 70 6F 70 20 63 process_0 db "pop cs not allowed",0
2D2A 5C 6E 65 6E 74 process_1 db "\nentering: ",0
2D37 61 6C 72 65 61 process_2 db "already in PROC",0
2D47 6E 6F 74 20 69 process_3 db "not in PROC",0
2D53 5C 6E 6C 65 61 process_4 db "\nleaving: ",0
2D5F 2C 20 6C 6F 63 process_5 db ", loc labels: ",0
2D6E 2C 20 6C 6F 63 process_6 db ", loc jmp forward: ",0
2D82 43 6F 6D 6D 61 process_7 db "Command not implemented or syntax error",0
leaving: process, loc labels: 108, loc jmp forward: 147
2DAA                ENDP
2DAA                
entering: parse
2DAA                parse: PROC
2DAA                
2DAA                ;-1455     LabelNamePtr  = &LabelNames;
2DAA                
2DAA B8 5A 77        mov ax, LabelNames
2DAD A3 46 01        mov word [LabelNamePtr], ax
2DB0                
2DB0                ;-1456     JmpNamePtr= &JmpNames;
2DB0                
2DB0 B8 7A 93        mov ax, JmpNames
2DB3 A3 50 01        mov word [JmpNamePtr], ax
2DB6                
2DB6                ;-1457     LabelMaxIx=0;
2DB6                
2DB6 B8 00 00        mov ax, 0
2DB9 A3 4A 01        mov word [LabelMaxIx], ax
2DBC                
2DBC                ;-1458     JmpMaxIx=0;
2DBC                
2DBC B8 00 00        mov ax, 0
2DBF A3 54 01        mov word [JmpMaxIx], ax
2DC2                
2DC2                ;-1459     BinLen=0;
2DC2                
2DC2 B8 00 00        mov ax, 0
2DC5 A3 58 01        mov word [BinLen], ax
2DC8                
2DC8                ;-1460     isInProc=0;
2DC8                
2DC8 B8 00 00        mov ax, 0
2DCB A2 0D 01        mov byte [isInProc], al
2DCE                
2DCE                ;-1461 
2DCE                
2DCE                
2DCE                ;-1462     do {//process a new line
2DCE                
2DCE                .parse360:
2DCE                
2DCE                ;-1463         PCStart=PC;
2DCE                
2DCE A1 23 01        mov ax, [PC]
2DD1 A3 29 01        mov word [PCStart], ax
2DD4                
2DD4                ;-1464         OpSize=0;
2DD4                
2DD4 B8 00 00        mov ax, 0
2DD7 A2 37 01        mov byte [OpSize], al
2DDA                
2DDA                ;-1465         OpPrintIndex=0;
2DDA                
2DDA B8 00 00        mov ax, 0
2DDD A3 41 01        mov word [OpPrintIndex], ax
2DE0                
2DE0                ;-1466         PrintRA=' ';
2DE0                
2DE0 B8 20 00        mov ax, 32
2DE3 A2 45 01        mov byte [PrintRA], al
2DE6                
2DE6                ;-1467         getLine();
2DE6                
2DE6 E8 2E DF        call getLine
2DE9                
2DE9                ;-1468         InputPtr = &InputBuf;
2DE9                
2DE9 B8 8D 75        mov ax, InputBuf
2DEC A3 14 01        mov word [InputPtr], ax
2DEF                
2DEF                ;-1469         getTokeType();//getCode in SymbolUpper,
2DEF                
2DEF E8 D8 E8        call getTokeType
2DF2                
2DF2                ;-1470                       //set TokeType,isLabel by getName
2DF2                
2DF2                
2DF2                ;-1471         if (TokeType == ALNUME) {
2DF2                
2DF2 A0 2C 01        mov al, [TokeType]
2DF5 3C 03           cmp al, 3
2DF7 0F 85 00 00   r jne .parse361
2DFB                
2DFB                ;-1472             if (isLabel) {//set in getName
2DFB                
2DFB A0 2B 01        mov al, [isLabel]
2DFE 08 C0           or  al, al
2E00 0F 84 00 00   r je .parse362
2E04                
2E04                ;-1473               if (isInProc == 0)  strcpy(ProcName, Symbol);
2E04                
2E04 A0 0D 01        mov al, [isInProc]
2E07 3C 00           cmp al, 0
2E09 0F 85 00 00   r jne .parse363
2E0D 8D 06 30 75     lea  ax, [Symbol]
2E11 50              push ax
2E12 8D 06 6E 75     lea  ax, [ProcName]
2E16 50              push ax
2E17 E8 10 D4        call strcpy
2E1A 83 C4 04        add  sp, 4
2E1D                
2E1D                ;-1474                 storeLabel();
2E1D                
2E1D                .parse363:
2E1D E8 30 EE        call storeLabel
2E20                
2E20                ;-1475                 InputPtr++;//remove :
2E20                
2E20 FF 06 14 01     inc  word[InputPtr]
2E24                
2E24                ;-1476                 getTokeType();
2E24                
2E24 E8 A3 E8        call getTokeType
2E27                
2E27                ;-1477             }
2E27                
2E27                
2E27                ;-1478         }
2E27                
2E27                .parse362:
2E27                
2E27                ;-1479         if (TokeType == ALNUME) {
2E27                
2E27                .parse361:
2E27 A0 2C 01        mov al, [TokeType]
2E2A 3C 03           cmp al, 3
2E2C 0F 85 00 00   r jne .parse364
2E30                
2E30                ;-1480             lookCode();// and OpCodePtr
2E30                
2E30 E8 CF E4        call lookCode
2E33                
2E33                ;-1481             if(CodeType) process();
2E33                
2E33 A0 2F 01        mov al, [CodeType]
2E36 08 C0           or  al, al
2E38 0F 84 00 00   r je .parse365
2E3C E8 99 F5        call process
2E3F                
2E3F                ;-1482             else getVariable();
2E3F                
2E3F E9 00 00      R jmp .parse366
2E42                .parse365:
2E42 E8 33 EF        call getVariable
2E45                
2E45                ;-1483             skipRest();
2E45                
2E45                .parse366:
2E45 E8 75 E9        call skipRest
2E48                
2E48                ;-1484         }
2E48                
2E48                
2E48                ;-1485         else if (TokeType >ALNUME) error1("Label or instruction expected");
2E48                
2E48 E9 00 00      R jmp .parse367
2E4B                .parse364:
2E4B A0 2C 01        mov al, [TokeType]
2E4E 3C 03           cmp al, 3
2E50 0F 8E 00 00   r jle .parse368
2E54 68 AA AA      A push parse_0
2E57 E8 E1 DB        call error1
2E5A 83 C4 02        add  sp, 2
2E5D                
2E5D                ;-1486         else if (TokeType==DIGIT ) error1("No digit allowed at start of line");
2E5D                
2E5D E9 00 00      R jmp .parse369
2E60                .parse368:
2E60 A0 2C 01        mov al, [TokeType]
2E63 3C 01           cmp al, 1
2E65 0F 85 00 00   r jne .parse370
2E69 68 AA AA      A push parse_1
2E6C E8 CC DB        call error1
2E6F 83 C4 02        add  sp, 2
2E72                
2E72                ;-1487         printLine();
2E72                
2E72                .parse370:
2E72                .parse369:
2E72                .parse367:
2E72 E8 04 DA        call printLine
2E75                
2E75                ;-1488     } while (DOS_NoBytes != 0 );
2E75                
2E75 A1 20 01        mov ax, [DOS_NoBytes]
2E78 83 F8 00        cmp ax, 0
2E7B 0F 84 00 00   r je  .parse371
2E7F E9 4C FF        jmp .parse360
2E82                .parse371:
2E82                
2E82                ;-1489 }
2E82                
2E82                
2E82                ;-1490 
2E82                
2E82                
2E82                ;-1491 int main() {
2E82                
2E82 C3              ret
2E83 4C 61 62 65 6C parse_0 db "Label or instruction expected",0
2EA1 4E 6F 20 64 69 parse_1 db "No digit allowed at start of line",0
leaving: parse, loc labels: 14, loc jmp forward: 13
2EC3                ENDP
2EC3                
entering: main
2EC3                main: PROC
2EC3                
2EC3                ;-1492     getarg();
2EC3                
2EC3 E8 C1 F0        call getarg
2EC6                
2EC6                ;-1493     parse();
2EC6                
2EC6 E8 E1 FE        call parse
2EC9                
2EC9                ;-1494     fixJmpMain();
2EC9                
2EC9 E8 B6 F3        call fixJmpMain
2ECC                
2ECC                ;-1495     epilog();
2ECC                
2ECC E8 53 DA        call epilog
2ECF                
2ECF                ;-1496     end1();
2ECF                
2ECF E8 3E DB        call end1
2ED2                
2ED2                ;-1497 }
2ED2                
2ED2 C3              ret
leaving: main, loc labels: 0, loc jmp forward: 0
2ED3                ENDP
2ED3                 
2ED3                ; missing functions: 
2ED3                ; Number of unresolved CALLs :    0 All FUNCTIONs in place
******* next line ERROR: extra char ignored, Symbol: E8h
2ED3 00             LastFunctionByt:db 0E8h, 0, 0
2ED4 58             pop ax
2ED5 C3             ret
2ED6                 
2ED6                ;   # type sign width  adr used name   list of global variables
2ED6                
2ED6                ;    1 arr sign byte     1    2 Version1[9]
2ED6                ;    2 def unsg byte     3    - SYMBOLMAX=31
2ED6                ;    3 arr sign byte     4   14 Symbol[31]
2ED6                ;    4 arr sign byte     5   36 SymbolUpper[31]
2ED6                ;    5 arr sign byte     6    3 ProcName[31]
2ED6                ;    6 var sign byte     7    6 isInProc
2ED6                ;    7 var unsg word     8   25 SymbolInt
2ED6                ;    8 var unsg dwrd     9 NULL SymbolLong
2ED6                ;    9 def unsg byte    10    - INPUTBUFMAX=255
2ED6                ;   10 arr sign byte    11    4 InputBuf[255]
2ED6                ;   11 ptr unsg byte    12   28 InputPtr
2ED6                ;   12 arr sign byte    13    5 namein[67]
2ED6                ;   13 arr sign byte    14    6 namelst[67]
2ED6                ;   14 arr sign byte    15    6 namebin[67]
2ED6                ;   15 var sign word    16    4 asm_fd
2ED6                ;   16 var sign word    17    3 lst_fd
2ED6                ;   17 var sign word    18    3 bin_fd
2ED6                ;   18 var sign word    19    6 DOS_ERR
2ED6                ;   19 var sign word    20    5 ErrorCount
2ED6                ;   20 var sign word    21    4 DOS_NoBytes
2ED6                ;   21 var sign byte    22    5 DOS_ByteRead
2ED6                ;   22 var unsg word    24    8 PC
2ED6                ;   23 var unsg word    25    6 Origin
2ED6                ;   24 var unsg word    26    6 AbsoluteLab
2ED6                ;   25 var unsg word    27    2 PCStart
2ED6                ;   26 var sign byte    28    3 isLabel
2ED6                ;   27 def unsg byte    29    - DIGIT=1
2ED6                ;   28 def unsg byte    30    - LETTERE=2
2ED6                ;   29 def unsg byte    31    - ALNUME=3
2ED6                ;   30 def unsg byte    32    - NOALNUME=4
2ED6                ;   31 var sign byte    33   28 TokeType
2ED6                ;   32 def unsg byte    34    - BYTE=1
2ED6                ;   33 def unsg byte    35    - WORD=2
2ED6                ;   34 def unsg byte    36    - DWORD=3
2ED6                ;   35 def unsg byte    37    - SEGREG=4
2ED6                ;   36 def unsg byte    38    - IMM=1
2ED6                ;   37 def unsg byte    39    - REG=2
2ED6                ;   38 def unsg byte    40    - ADR=3
2ED6                ;   39 def unsg byte    41    - MEM=4
2ED6                ;   40 var sign byte    42   29 Op
2ED6                ;   41 var sign byte    43   31 Op2
2ED6                ;   42 var sign byte    44   30 CodeType
2ED6                ;   43 var sign byte    45   23 Code1
2ED6                ;   44 var sign byte    46    7 Code2
2ED6                ;   45 var sign byte    47    3 Code3
2ED6                ;   46 var sign byte    48   19 R2No
2ED6                ;   47 var sign byte    49   16 R1No
2ED6                ;   48 var sign byte    50   18 R2Type
2ED6                ;   49 var sign byte    51   15 R1Type
2ED6                ;   50 var sign byte    52   14 OpSize
2ED6                ;   51 var sign byte    53    9 wflag
2ED6                ;   52 var sign byte    54    3 dflag
2ED6                ;   53 var sign byte    55    8 sflag
2ED6                ;   54 var sign byte    56   15 rm
2ED6                ;   55 var sign byte    57    5 isDirect
2ED6                ;   56 var sign word    58   67 disp
2ED6                ;   57 var unsg word    59   13 imme
2ED6                ;   58 def unsg byte    61    - OPMAXLEN=5
2ED6                ;   59 arr sign byte    62    2 OpPos[5]
2ED6                ;   60 var sign word    63    6 OpPrintIndex
2ED6                ;   61 ptr sign byte    64   19 OpCodePtr
2ED6                ;   62 var sign byte    65    5 PrintRA
2ED6                ;   63 def unsg byte    67    - LABELNAMESMAX=5969
2ED6                ;   64 arr sign byte    68    3 LabelNames[6000]
2ED6                ;   65 ptr sign byte    69    7 LabelNamePtr
2ED6                ;   66 ptr sign byte    70    2 tmpLabelNamePtr
2ED6                ;   67 def unsg byte    72    - LABELADRMAX=600
2ED6                ;   68 arr unsg word    73    8 LabelAddr[600]
2ED6                ;   69 var sign word    74   10 LabelMaxIx
2ED6                ;   70 var sign word    75    3 tmpLabelMaxIx
2ED6                ;   71 var sign word    76   11 LabelIx
2ED6                ;   72 def unsg byte    78    - JMPNAMESMAX=3969
2ED6                ;   73 arr sign byte    79    3 JmpNames[4000]
2ED6                ;   74 ptr sign byte    80    7 JmpNamePtr
2ED6                ;   75 ptr sign byte    81    2 tmpJmpNamePtr
2ED6                ;   76 def unsg byte    83    - JMPMAX=200
2ED6                ;   77 arr unsg word    84    2 JmpAddr[200]
2ED6                ;   78 var sign word    85   10 JmpMaxIx
2ED6                ;   79 var sign word    86    3 tmpJmpMaxIx
2ED6                ;   80 def unsg byte    88    - FILEBINMAX=17000
2ED6                ;   81 arr sign byte    89    8 FileBin[17000]
2ED6                ;   82 var unsg word    90    6 BinLen
2ED6                ;   83 ptr sign byte    92    1 arglen
2ED6                ;   84 ptr sign byte    93    4 argv
2ED6                ;   85 var sign byte   451    1 I_START
2ED6                ;   86 arr sign byte   454 NULL I_PUSHA[8125]
2ED6                ;   87 arr sign byte   455 NULL I_NOP[24260]
2ED6                ;   88 arr sign byte   456 NULL I_CWDE[9734]
2ED6                ;   89 arr sign byte   457 NULL I_CDQ[1931]
2ED6                ;   90 arr sign byte   458 NULL I_PUSHF[35622]
2ED6                ;   91 arr sign byte   459 NULL I_SAHF[599]
2ED6                ;   92 arr sign byte   460 NULL I_MOVSB[53495]
2ED6                ;   93 arr sign byte   461 NULL I_CMPSB[54007]
2ED6                ;   94 arr sign byte   462 NULL I_STOSB[37]
2ED6                ;   95 arr sign byte   463 NULL I_LODSB[33600]
2ED6                ;   96 arr sign byte   464 NULL I_SCASB[8418]
2ED6                ;   97 arr sign byte   465 NULL I_LEAVE[53259]
2ED6                ;   98 arr sign byte   466 NULL I_INTO[12917]
2ED6                ;   99 arr sign byte   467 NULL I_XLAT[35622]
2ED6                ;  100 arr sign byte   468 NULL I_REPNE[2119]
2ED6                ;  101 arr sign byte   469 NULL I_REPE[18057]
2ED6                ;  102 arr sign byte   470 NULL I_HLT[9982]
2ED6                ;  103 arr sign byte   471 NULL I_STC[18315]
2ED6                ;  104 arr sign byte   472 NULL I_STI[9734]
2ED6                ;  105 arr sign byte   473 NULL I_STD[32643]
2ED6                ;  106 arr sign byte   475 NULL I_INC[10]
2ED6                ;  107 arr sign byte   476 NULL I_DEC[1397]
2ED6                ;  108 arr sign byte   477 NULL I_NOT[18119]
2ED6                ;  109 arr sign byte   478 NULL I_NEG[65534]
2ED6                ;  110 arr sign byte   479 NULL I_MUL[33791]
2ED6                ;  111 arr sign byte   480 NULL I_IMUL[65150]
2ED6                ;  112 arr sign byte   481 NULL I_DIV[30207]
2ED6                ;  113 arr sign byte   482 NULL I_IDIV[15642]
2ED6                ;  114 arr sign byte   484 NULL I_LES[65535]
2ED6                ;  115 arr sign byte   485 NULL I_LDS[5493]
2ED6                ;  116 arr sign byte   486 NULL I_LEA[33574]
2ED6                ;  117 arr sign byte   487 NULL I_LSS[1151]
2ED6                ;  118 arr sign byte   488 NULL I_LFS[29696]
2ED6                ;  119 arr sign byte   489 NULL I_LGS[35593]
2ED6                ;  120 arr sign byte   491 NULL I_ADD[2630]
2ED6                ;  121 arr sign byte   492 NULL I_OR[14630]
2ED6                ;  122 arr sign byte   493 NULL I_ADC[1095]
2ED6                ;  123 arr sign byte   494 NULL I_SBB[26997]
2ED6                ;  124 arr sign byte   495 NULL I_AND[49203]
2ED6                ;  125 arr sign byte   496 NULL I_SUB[52169]
2ED6                ;  126 arr sign byte   497 NULL I_XOR[33680]
2ED6                ;  127 arr sign byte   498 NULL I_CMP[65150]
2ED6                ;  128 arr sign byte   499 NULL I_TEST[29729]
2ED6                ;  129 arr sign byte   501 NULL I_MOV[33618]
2ED6                ;  130 arr sign byte   502 NULL I_MOVSX[65150]
2ED6                ;  131 arr sign byte   503 NULL I_MOVZX[29731]
2ED6                ;  132 arr sign byte   505 NULL I_JO[33612]
2ED6                ;  133 arr sign byte   506 NULL I_JNO[65150]
2ED6                ;  134 arr sign byte   507 NULL I_JB[29732]
2ED6                ;  135 arr sign byte   508 NULL I_JNB[33606]
2ED6                ;  136 arr sign byte   509 NULL I_JAE[65150]
2ED6                ;  137 arr sign byte   510 NULL I_JE[29734]
2ED6                ;  138 arr sign byte   511 NULL I_JNE[33600]
2ED6                ;  139 arr sign byte   512 NULL I_JBE[65150]
2ED6                ;  140 arr sign byte   513 NULL I_JA[29730]
2ED6                ;  141 arr sign byte   514 NULL I_JS[33594]
2ED6                ;  142 arr sign byte   515 NULL I_JNS[65150]
2ED6                ;  143 arr sign byte   516 NULL I_JP[29737]
2ED6                ;  144 arr sign byte   517 NULL I_JNP[33588]
2ED6                ;  145 arr sign byte   518 NULL I_JL[65150]
2ED6                ;  146 arr sign byte   519 NULL I_JNL[29736]
2ED6                ;  147 arr sign byte   520 NULL I_JLE[33582]
2ED6                ;  148 arr sign byte   521 NULL I_JG[65150]
2ED6                ;  149 arr sign byte   523 NULL I_JMP[29733]
2ED6                ;  150 arr sign byte   524 NULL I_CALL[15656]
2ED6                ;  151 arr sign byte   526 NULL I_RET[33]
2ED6                ;  152 arr sign byte   527 NULL I_RETF[9076]
2ED6                ;  153 arr sign byte   529 NULL I_PUSH[9021]
2ED6                ;  154 arr sign byte   530 NULL I_POP[29696]
2ED6                ;  155 arr sign byte   532 NULL I_ROL[15646]
2ED6                ;  156 arr sign byte   533 NULL I_RCL[36]
2ED6                ;  157 arr sign byte   534 NULL I_SHL[6516]
2ED6                ;  158 arr sign byte   535 NULL I_SHR[9789]
2ED6                ;  159 arr sign byte   537 NULL I_INT[29696]
2ED6                ;  160 arr sign byte   539 NULL I_IN[15636]
2ED6                ;  161 arr sign byte   540 NULL I_INSB[34]
2ED6                ;  162 arr sign byte   541 NULL I_INSW[3956]
2ED6                ;  163 arr sign byte   542 NULL I_INSD[10557]
2ED6                ;  164 arr sign byte   543 NULL I_OUT[29696]
2ED6                ;  165 arr sign byte   544 NULL I_OUTSB[15626]
2ED6                ;  166 arr sign byte   545 NULL I_OUTSW[40]
2ED6                ;  167 arr sign byte   546 NULL I_OUTSD[1396]
2ED6                ;  168 arr sign byte   548 NULL I_XCHG[9533]
2ED6                ;  169 arr sign byte   550 NULL I_LOOPNZ[29952]
2ED6                ;  170 arr sign byte   551 NULL I_LOOPNE[33542]
2ED6                ;  171 arr sign byte   552 NULL I_LOOPZ[2686]
2ED6                ;  172 arr sign byte   553 NULL I_LOOPE[60176]
2ED6                ;  173 arr sign byte   554 NULL I_LOOP[33540]
2ED6                ;  174 arr sign byte   555 NULL I_JCXZ[2686]
2ED6                ;  175 arr sign byte   556 NULL I_JECXZ[29984]
2ED6                ;  176 arr sign byte   558 NULL I_ENTER[47255]
2ED6                ;  177 arr sign byte   560 NULL I_ORG[1]
2ED6                ;  178 arr sign byte   562 NULL I_SECTION[52169]
2ED6                ;  179 arr sign byte   563 NULL I_SEGMENT[21904]
2ED6                ;  180 arr sign byte   564 NULL I_ABSOLUTE[60555]
2ED6                ;  181 arr sign byte   565 NULL I_PROC[5816]
2ED6                ;  182 arr sign byte   566 NULL I_ENDP[39424]
2ED6                ;  183 arr sign byte   567 NULL I_DB[674]
2ED6                ;  184 arr sign byte   568 NULL I_DW[8125]
2ED6                ;  185 arr sign byte   569 NULL I_DD[51030]
2ED6                ;  186 arr sign byte   570 NULL I_RESB[65094]
2ED6                ;  187 arr sign byte   571 NULL I_RESW[0]
2ED6                ;  188 arr sign byte   572 NULL I_RESD[1678]
2ED6                ;  189 var sign byte   573 NULL I_END
2ED6                
2ED6                
2ED6                ;   # Calls Line Width  Name   list of functions
2ED6                
2ED6                ;    0    4   97   writetty
2ED6                ;    1    1   98   putch
2ED6                ;    2    8   99   cputs
2ED6                ;    3    6  101   DosInt
2ED6                ;    4    1  106   openR
2ED6                ;    5    2  107   creatR
2ED6                ;    6    3  108   fcloseR
2ED6                ;    7    5  109   exitR
2ED6                ;    8    2  110   readRL
2ED6                ;    9    2  112   fputcR
2ED6                ;   10    2  115   letterE
2ED6                ;   11    3  125   digit
2ED6                ;   12    1  130   alnumE
2ED6                ;   13    4  135   strlen
2ED6                ;   14   10  140   strcpy
2ED6                ;   15   35  146   eqstr
2ED6                ;   16    3  155   strcat1
2ED6                ;   17    2  159   toupper
2ED6                ;   18    1  166   testReg
2ED6                ;   19    7  209   prc
2ED6                ;   20    1  219   prscomment
2ED6                ;   21   38  227   prs
2ED6                ;   22    2  249   printhex4
2ED6                ;   23    3  254   printhex8a
2ED6                ;   24    3  259   printhex16
2ED6                ;   25    7  264   printIntU
2ED6                ;   26    1  274   printLine
2ED6                ;   27    2  297   epilog
2ED6                ;   28    2  345   end1
2ED6                ;   29   27  353   error1
2ED6                ;   30   13  360   errorexit
2ED6                ;   31    4  365   notfounderror
2ED6                ;   32 NULL  371   allowederror
2ED6                ;   33    3  372   addrerror
2ED6                ;   34    1  373   immeerror
2ED6                ;   35    2  374   implerror
2ED6                ;   36    4  375   indexerror
2ED6                ;   37    3  376   invaloperror
2ED6                ;   38    6  377   numbererror
2ED6                ;   39    1  378   regmemerror
2ED6                ;   40    3  379   reg16error
2ED6                ;   41    1  380   segregerror
2ED6                ;   42    5  381   syntaxerror
2ED6                ;   43 NULL  383   addrexit
2ED6                ;   44    3  384   dataexit
2ED6                ;   45 NULL  385   internexit
2ED6                ;   46    1  387   ifEOL
2ED6                ;   47    1  396   getLine
2ED6                ;   48    4  412   skipBlank
2ED6                ;   49    1  418   getDigit
2ED6                ;   50    1  430   getName
2ED6                ;   51    2  575   lookCode
2ED6                ;   52   37  591   genCode8
2ED6                ;   53    1  602   gen66h
2ED6                ;   54    8  604   genCode2
2ED6                ;   55   13  608   genCodeW
2ED6                ;   56   19  612   genCode16
2ED6                ;   57    1  616   genCode32
2ED6                ;   58   13  620   writeEA
2ED6                ;   59    4  662   genImmediate
2ED6                ;   60    2  669   setwflag
2ED6                ;   61    2  680   setsflag
2ED6                ;   62    2  690   checkConstSize
2ED6                ;   63    2  697   ChangeDirection
2ED6                ;   64   17  705   getTokeType
2ED6                ;   65   11  716   isToken
2ED6                ;   66    2  726   need
2ED6                ;   67    1  735   skipRest
2ED6                ;   68    2  741   checkOpL
2ED6                ;   69    6  750   searchLabel
2ED6                ;   70    4  763   getOp1
2ED6                ;   71    1  778   getIndReg1
2ED6                ;   72    1  786   getIndReg2
2ED6                ;   73    1  795   getMEM
2ED6                ;   74    2  822   getOpR
2ED6                ;   75    3  835   getOpL
2ED6                ;   76    1  842   get2Ops
2ED6                ;   77    4  847   check2Ops
2ED6                ;   78    3  857   storeJmp
2ED6                ;   79    2  868   storeLabel
2ED6                ;   80    1  881   genDB
2ED6                ;   81    1  902   getVariable
2ED6                ;   82    1  955   getCodeSize
2ED6                ;   83    1  965   getarg
2ED6                ;   84    1  999   fixJmp
2ED6                ;   85    1 1032   fixJmpMain
2ED6                ;   86    1 1058   getCodes
2ED6                ;   87    1 1064   process
2ED6                ;   88    1 1454   parse
2ED6                ;   89 NULL 1491   main
2ED6                ;   90 NULL 1497   LastFunctionByt
2ED6                
2ED6                ;    #  addr name   list of CALLs
2ED6                
2ED6                ;    0     0 writetty
2ED6                ;    1     9 writetty
2ED6                ;    2    18 putch
2ED6                ;    3    24 DosInt
2ED6                ;    4    31 DosInt
2ED6                ;    5    38 DosInt
2ED6                ;    6    45 DosInt
2ED6                ;    7    52 DosInt
2ED6                ;    8    59 DosInt
2ED6                ;    9    66 digit
2ED6                ;   10    72 letterE
2ED6                ;   11    80 strcpy
2ED6                ;   12    87 strlen
2ED6                ;   13    94 strlen
2ED6                ;   14   101 eqstr
2ED6                ;   15   107 eqstr
2ED6                ;   16   113 eqstr
2ED6                ;   17   119 eqstr
2ED6                ;   18   125 eqstr
2ED6                ;   19   131 eqstr
2ED6                ;   20   137 eqstr
2ED6                ;   21   143 eqstr
2ED6                ;   22   149 eqstr
2ED6                ;   23   155 eqstr
2ED6                ;   24   161 eqstr
2ED6                ;   25   167 eqstr
2ED6                ;   26   173 eqstr
2ED6                ;   27   179 eqstr
2ED6                ;   28   185 eqstr
2ED6                ;   29   191 eqstr
2ED6                ;   30   197 eqstr
2ED6                ;   31   203 eqstr
2ED6                ;   32   209 eqstr
2ED6                ;   33   215 eqstr
2ED6                ;   34   221 eqstr
2ED6                ;   35   227 eqstr
2ED6                ;   36   233 eqstr
2ED6                ;   37   239 eqstr
2ED6                ;   38   245 eqstr
2ED6                ;   39   251 eqstr
2ED6                ;   40   257 eqstr
2ED6                ;   41   263 eqstr
2ED6                ;   42   269 eqstr
2ED6                ;   43   275 eqstr
2ED6                ;   44   281 writetty
2ED6                ;   45   290 writetty
2ED6                ;   46   299 fputcR
2ED6                ;   47   306 prc
2ED6                ;   48   310 prc
2ED6                ;   49   314 prc
2ED6                ;   50   318 printhex4
2ED6                ;   51   328 printhex4
2ED6                ;   52   338 printhex8a
2ED6                ;   53   349 printhex8a
2ED6                ;   54   360 printIntU
2ED6                ;   55   370 prc
2ED6                ;   56   374 prs
2ED6                ;   57   378 printhex16
2ED6                ;   58   389 prs
2ED6                ;   59   393 prc
2ED6                ;   60   397 printhex8a
2ED6                ;   61   408 prs
2ED6                ;   62   412 prc
2ED6                ;   63   416 prscomment
2ED6                ;   64   427 prs
2ED6                ;   65   431 printIntU
2ED6                ;   66   441 prs
2ED6                ;   67   445 prs
2ED6                ;   68   449 prs
2ED6                ;   69   453 prs
2ED6                ;   70   457 prs
2ED6                ;   71   461 prs
2ED6                ;   72   465 printIntU
2ED6                ;   73   475 prs
2ED6                ;   74   479 prs
2ED6                ;   75   483 printIntU
2ED6                ;   76   493 fputcR
2ED6                ;   77   500 fcloseR
2ED6                ;   78   508 fcloseR
2ED6                ;   79   516 fcloseR
2ED6                ;   80   524 exitR
2ED6                ;   81   530 prs
2ED6                ;   82   534 prs
2ED6                ;   83   538 prs
2ED6                ;   84   542 prs
2ED6                ;   85   546 error1
2ED6                ;   86   553 epilog
2ED6                ;   87   560 end1
2ED6                ;   88   565 prs
2ED6                ;   89   569 prs
2ED6                ;   90   573 prs
2ED6                ;   91   577 error1
2ED6                ;   92   584 error1
2ED6                ;   93   591 error1
2ED6                ;   94   598 error1
2ED6                ;   95   605 error1
2ED6                ;   96   612 error1
2ED6                ;   97   619 error1
2ED6                ;   98   626 error1
2ED6                ;   99   633 error1
2ED6                ;  100   640 error1
2ED6                ;  101   647 error1
2ED6                ;  102   654 errorexit
2ED6                ;  103   664 errorexit
2ED6                ;  104   674 errorexit
2ED6                ;  105   684 readRL
2ED6                ;  106   691 errorexit
2ED6                ;  107   701 readRL
2ED6                ;  108   708 errorexit
2ED6                ;  109   718 errorexit
2ED6                ;  110   728 ifEOL
2ED6                ;  111   734 digit
2ED6                ;  112   740 alnumE
2ED6                ;  113   747 errorexit
2ED6                ;  114   757 strcpy
2ED6                ;  115   764 toupper
2ED6                ;  116   772 eqstr
2ED6                ;  117   778 errorexit
2ED6                ;  118   788 genCode8
2ED6                ;  119   797 genCode8
2ED6                ;  120   806 genCode8
2ED6                ;  121   815 genCode8
2ED6                ;  122   824 genCode8
2ED6                ;  123   833 genCode16
2ED6                ;  124   843 genCode16
2ED6                ;  125   853 genCode8
2ED6                ;  126   862 genCode8
2ED6                ;  127   871 genCode16
2ED6                ;  128   881 genCode32
2ED6                ;  129   891 genCode16
2ED6                ;  130   901 genCode8
2ED6                ;  131   910 gen66h
2ED6                ;  132   917 error1
2ED6                ;  133   924 skipBlank
2ED6                ;  134   934 digit
2ED6                ;  135   940 getDigit
2ED6                ;  136   949 letterE
2ED6                ;  137   957 getName
2ED6                ;  138   965 skipBlank
2ED6                ;  139   975 isToken
2ED6                ;  140   983 getTokeType
2ED6                ;  141   995 error1
2ED6                ;  142  1002 prs
2ED6                ;  143  1006 prc
2ED6                ;  144  1010 getTokeType
2ED6                ;  145  1022 error1
2ED6                ;  146  1029 implerror
2ED6                ;  147  1039 segregerror
2ED6                ;  148  1051 setwflag
2ED6                ;  149  1060 error1
2ED6                ;  150  1067 error1
2ED6                ;  151  1074 eqstr
2ED6                ;  152  1080 strlen
2ED6                ;  153  1087 testReg
2ED6                ;  154  1095 searchLabel
2ED6                ;  155  1107 indexerror
2ED6                ;  156  1118 indexerror
2ED6                ;  157  1129 indexerror
2ED6                ;  158  1140 indexerror
2ED6                ;  159  1151 getTokeType
2ED6                ;  160  1163 getOp1
2ED6                ;  161  1170 syntaxerror
2ED6                ;  162  1182 getIndReg2
2ED6                ;  163  1193 getIndReg1
2ED6                ;  164  1204 notfounderror
2ED6                ;  165  1218 isToken
2ED6                ;  166  1226 getTokeType
2ED6                ;  167  1238 numbererror
2ED6                ;  168  1250 isToken
2ED6                ;  169  1258 isToken
2ED6                ;  170  1266 errorexit
2ED6                ;  171  1276 getOp1
2ED6                ;  172  1283 isToken
2ED6                ;  173  1291 getMEM
2ED6                ;  174  1298 invaloperror
2ED6                ;  175  1311 error1
2ED6                ;  176  1318 getOpR
2ED6                ;  177  1325 getOpL
2ED6                ;  178  1332 need
2ED6                ;  179  1337 getOpR
2ED6                ;  180  1344 get2Ops
2ED6                ;  181  1352 addrerror
2ED6                ;  182  1362 invaloperror
2ED6                ;  183  1375 immeerror
2ED6                ;  184  1385 addrerror
2ED6                ;  185  1395 invaloperror
2ED6                ;  186  1408 setwflag
2ED6                ;  187  1417 errorexit
2ED6                ;  188  1427 strcpy
2ED6                ;  189  1434 errorexit
2ED6                ;  190  1444 searchLabel
2ED6                ;  191  1456 error1
2ED6                ;  192  1463 errorexit
2ED6                ;  193  1473 strcpy
2ED6                ;  194  1480 errorexit
2ED6                ;  195  1490 getTokeType
2ED6                ;  196  1502 genCode8
2ED6                ;  197  1511 skipBlank
2ED6                ;  198  1521 isToken
2ED6                ;  199  1529 genCode8
2ED6                ;  200  1538 isToken
2ED6                ;  201  1546 storeLabel
2ED6                ;  202  1557 getTokeType
2ED6                ;  203  1569 lookCode
2ED6                ;  204  1578 dataexit
2ED6                ;  205  1587 dataexit
2ED6                ;  206  1596 getTokeType
2ED6                ;  207  1608 genCode8
2ED6                ;  208  1617 skipBlank
2ED6                ;  209  1627 isToken
2ED6                ;  210  1635 genCode8
2ED6                ;  211  1644 isToken
2ED6                ;  212  1652 getTokeType
2ED6                ;  213  1664 genCode16
2ED6                ;  214  1674 isToken
2ED6                ;  215  1682 getTokeType
2ED6                ;  216  1694 genCode16
2ED6                ;  217  1704 genCode16
2ED6                ;  218  1714 isToken
2ED6                ;  219  1722 getTokeType
2ED6                ;  220  1734 syntaxerror
2ED6                ;  221  1746 error1
2ED6                ;  222  1753 numbererror
2ED6                ;  223  1765 dataexit
2ED6                ;  224  1774 eqstr
2ED6                ;  225  1780 getTokeType
2ED6                ;  226  1792 eqstr
2ED6                ;  227  1798 getTokeType
2ED6                ;  228  1810 eqstr
2ED6                ;  229  1816 getTokeType
2ED6                ;  230  1828 cputs
2ED6                ;  231  1834 cputs
2ED6                ;  232  1840 exitR
2ED6                ;  233  1846 toupper
2ED6                ;  234  1854 strcpy
2ED6                ;  235  1861 strcat1
2ED6                ;  236  1869 strcpy
2ED6                ;  237  1876 strcat1
2ED6                ;  238  1884 strcpy
2ED6                ;  239  1891 strcat1
2ED6                ;  240  1899 openR
2ED6                ;  241  1905 cputs
2ED6                ;  242  1911 cputs
2ED6                ;  243  1917 exitR
2ED6                ;  244  1923 creatR
2ED6                ;  245  1930 cputs
2ED6                ;  246  1936 cputs
2ED6                ;  247  1942 exitR
2ED6                ;  248  1948 creatR
2ED6                ;  249  1955 cputs
2ED6                ;  250  1961 cputs
2ED6                ;  251  1967 exitR
2ED6                ;  252  1973 prs
2ED6                ;  253  1977 prs
2ED6                ;  254  1981 prs
2ED6                ;  255  1985 prs
2ED6                ;  256  1989 prs
2ED6                ;  257  1993 prs
2ED6                ;  258  1997 prs
2ED6                ;  259  2001 prs
2ED6                ;  260  2005 prs
2ED6                ;  261  2009 strcpy
2ED6                ;  262  2016 strlen
2ED6                ;  263  2023 searchLabel
2ED6                ;  264  2035 notfounderror
2ED6                ;  265  2049 prs
2ED6                ;  266  2053 printIntU
2ED6                ;  267  2063 error1
2ED6                ;  268  2070 strcpy
2ED6                ;  269  2077 searchLabel
2ED6                ;  270  2089 notfounderror
2ED6                ;  271  2103 prs
2ED6                ;  272  2107 printhex16
2ED6                ;  273  2118 prs
2ED6                ;  274  2122 printhex16
2ED6                ;  275  2133 getTokeType
2ED6                ;  276  2145 getCodeSize
2ED6                ;  277  2157 getCodes
2ED6                ;  278  2166 genCode8
2ED6                ;  279  2175 getOpL
2ED6                ;  280  2182 checkOpL
2ED6                ;  281  2191 genCode2
2ED6                ;  282  2200 getTokeType
2ED6                ;  283  2212 implerror
2ED6                ;  284  2222 genCodeW
2ED6                ;  285  2231 writeEA
2ED6                ;  286  2239 check2Ops
2ED6                ;  287  2249 reg16error
2ED6                ;  288  2260 addrerror
2ED6                ;  289  2270 genCode8
2ED6                ;  290  2279 genCode8
2ED6                ;  291  2288 writeEA
2ED6                ;  292  2296 check2Ops
2ED6                ;  293  2306 setsflag
2ED6                ;  294  2315 genCodeW
2ED6                ;  295  2324 genImmediate
2ED6                ;  296  2337 genCodeW
2ED6                ;  297  2346 writeEA
2ED6                ;  298  2354 genCode8
2ED6                ;  299  2363 genImmediate
2ED6                ;  300  2376 genCodeW
2ED6                ;  301  2385 writeEA
2ED6                ;  302  2393 genCodeW
2ED6                ;  303  2402 writeEA
2ED6                ;  304  2410 syntaxerror
2ED6                ;  305  2422 check2Ops
2ED6                ;  306  2432 notfounderror
2ED6                ;  307  2446 genCode2
2ED6                ;  308  2455 genImmediate
2ED6                ;  309  2468 genCodeW
2ED6                ;  310  2477 writeEA
2ED6                ;  311  2485 genImmediate
2ED6                ;  312  2498 regmemerror
2ED6                ;  313  2510 ChangeDirection
2ED6                ;  314  2526 reg16error
2ED6                ;  315  2537 genCode2
2ED6                ;  316  2546 writeEA
2ED6                ;  317  2554 genCodeW
2ED6                ;  318  2563 genCode16
2ED6                ;  319  2573 genCodeW
2ED6                ;  320  2582 genCode16
2ED6                ;  321  2592 genCodeW
2ED6                ;  322  2601 writeEA
2ED6                ;  323  2609 ChangeDirection
2ED6                ;  324  2625 genCodeW
2ED6                ;  325  2634 writeEA
2ED6                ;  326  2642 syntaxerror
2ED6                ;  327  2654 searchLabel
2ED6                ;  328  2666 checkConstSize
2ED6                ;  329  2681 genCode2
2ED6                ;  330  2690 genCode8
2ED6                ;  331  2699 genCode8
2ED6                ;  332  2708 genCode2
2ED6                ;  333  2717 genCode16
2ED6                ;  334  2727 genCode8
2ED6                ;  335  2736 genCode2
2ED6                ;  336  2745 storeJmp
2ED6                ;  337  2754 genCode16
2ED6                ;  338  2764 searchLabel
2ED6                ;  339  2776 checkConstSize
2ED6                ;  340  2791 genCode8
2ED6                ;  341  2800 genCode8
2ED6                ;  342  2809 genCode8
2ED6                ;  343  2818 genCode16
2ED6                ;  344  2828 genCode8
2ED6                ;  345  2837 genCode16
2ED6                ;  346  2847 genCode8
2ED6                ;  347  2856 storeJmp
2ED6                ;  348  2865 genCode16
2ED6                ;  349  2875 genCode8
2ED6                ;  350  2884 genCode16
2ED6                ;  351  2894 genCode8
2ED6                ;  352  2903 getOpL
2ED6                ;  353  2910 setsflag
2ED6                ;  354  2919 genCode2
2ED6                ;  355  2928 genCode8
2ED6                ;  356  2937 genCode16
2ED6                ;  357  2947 genCode8
2ED6                ;  358  2956 genCode16
2ED6                ;  359  2966 genCode8
2ED6                ;  360  2975 storeJmp
2ED6                ;  361  2984 genCode16
2ED6                ;  362  2994 error1
2ED6                ;  363  3001 genCode8
2ED6                ;  364  3010 genCode8
2ED6                ;  365  3019 checkOpL
2ED6                ;  366  3028 reg16error
2ED6                ;  367  3039 genCode2
2ED6                ;  368  3048 genCode8
2ED6                ;  369  3057 writeEA
2ED6                ;  370  3065 syntaxerror
2ED6                ;  371  3077 check2Ops
2ED6                ;  372  3087 genCodeW
2ED6                ;  373  3096 writeEA
2ED6                ;  374  3104 genCodeW
2ED6                ;  375  3113 writeEA
2ED6                ;  376  3121 genCode8
2ED6                ;  377  3130 genCodeW
2ED6                ;  378  3139 writeEA
2ED6                ;  379  3147 genCode8
2ED6                ;  380  3156 genCode8
2ED6                ;  381  3165 genCode8
2ED6                ;  382  3174 getOp1
2ED6                ;  383  3181 genCode16
2ED6                ;  384  3191 numbererror
2ED6                ;  385  3203 need
2ED6                ;  386  3208 getOp1
2ED6                ;  387  3215 genCode8
2ED6                ;  388  3224 numbererror
2ED6                ;  389  3236 numbererror
2ED6                ;  390  3248 numbererror
2ED6                ;  391  3260 prs
2ED6                ;  392  3264 prs
2ED6                ;  393  3268 error1
2ED6                ;  394  3275 error1
2ED6                ;  395  3282 prs
2ED6                ;  396  3286 prs
2ED6                ;  397  3290 prs
2ED6                ;  398  3294 printIntU
2ED6                ;  399  3304 prs
2ED6                ;  400  3308 printIntU
2ED6                ;  401  3318 fixJmp
2ED6                ;  402  3325 genDB
2ED6                ;  403  3331 error1
2ED6                ;  404  3338 getLine
2ED6                ;  405  3346 getTokeType
2ED6                ;  406  3358 strcpy
2ED6                ;  407  3365 storeLabel
2ED6                ;  408  3376 getTokeType
2ED6                ;  409  3388 lookCode
2ED6                ;  410  3397 process
2ED6                ;  411  3405 getVariable
2ED6                ;  412  3417 skipRest
2ED6                ;  413  3426 error1
2ED6                ;  414  3433 error1
2ED6                ;  415  3440 printLine
2ED6                ;  416  3450 getarg
2ED6                ;  417  3457 parse
2ED6                ;  418  3463 fixJmpMain
2ED6                ;  419  3474 epilog
2ED6                ;  420  3481 end1
2ED6                ;Input: AS.C, List: AS.S,  Lines: 1498
2ED6                ;Glob. variables:  189 max.:  200
2ED6                ;Functions      :   91 max.:  300
2ED6                ;Calls          :  421 max.: 2000, NameField: 3486 max.:    65535
2ED6                ;Code until     :21667 max.: 30000, free: 8333
2ED6                ;Data (HeapEnd) :59154, resting stacksize:  6381
2ED6                ;Max. Const in 'testReg' :  658 max. 3000, free: 2342x.:    65535
fix jmp to main. resting global jmp: 0
main ,Label+ORG:2FC3,rel:2EC0
 Errors: 9 *** ERRORS *** , Out: TE.LST, TE.COM= 11990 bytes. Labels: 260