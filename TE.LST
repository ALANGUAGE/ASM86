;AS.C V0.2, Source: TE.S, Output: TE.LST, TE.COM

0000                
0000                ; A.COM V0.9, Source: AS.C, Output asm: AS.S
0000                org  256 
0000 E9 00 00      Rjmp main
0003                
0003                ;-1 char Version1[]="AS.C V0.2";//BAS.BAT, AS TE, NAS.BAT
0003                
0003 41 53 2E 43 20 Version1 db "AS.C V0.2",0
000D                
000D                ;-2 //#include "DECL.C"
000D                
000D                
000D                ;-3 #define SYMBOLMAX    31
000D                
000D                
000D                ;-4 char Symbol[SYMBOLMAX]; //next symbol to decode
000D                
000D                section .bss
000D                absolute 30000
000D                Symbol resb 31
000D                section .text
000D                
000D                ;-5 char SymbolUpper[SYMBOLMAX];//set toupper in getName
000D                
000D                section .bss
000D                absolute 30031
000D                SymbolUpper resb 31
000D                section .text
000D                
000D                ;-6 char ProcName[SYMBOLMAX];//name of actual proc
000D                
000D                section .bss
000D                absolute 30062
000D                ProcName resb 31
000D                section .text
000D                
000D                ;-7 char isInProc=0;        //is inside a procedure
000D                
000D 00             isInProc db 0
000E                
000E                ;-8 unsigned int SymbolInt; //integer value set in getDigit
000E                
000E 00 00          SymbolInt dw 0
0010                
0010                ;-9 unsigned long SymbolLong;//integer value set in getDigit
0010                
0010 00 00 00 00    SymbolLong dd 0
0014                
0014                ;-10 #define INPUTBUFMAX 255
0014                
0014                
0014                ;-11 char InputBuf[INPUTBUFMAX];//filled in getLine, no overflow test
0014                
0014                section .bss
0014                absolute 30093
0014                InputBuf resb 255
0014                section .text
0014                
0014                ;-12 unsigned char *InputPtr;//position in InputBuf
0014                
0014 00 00          InputPtr dw 0
0016                
0016                ;-13 char namein [67];       //input file name  .S
0016                
0016                section .bss
0016                absolute 30348
0016                namein resb 67
0016                section .text
0016                
0016                ;-14 char namelst[67];       //list file name   .LST
0016                
0016                section .bss
0016                absolute 30415
0016                namelst resb 67
0016                section .text
0016                
0016                ;-15 char namebin[67];       //output file name .COM
0016                
0016                section .bss
0016                absolute 30482
0016                namebin resb 67
0016                section .text
0016                
0016                ;-16 int  asm_fd;            //input file descriptor
0016                
0016 00 00          asm_fd dw 0
0018                
0018                ;-17 int lst_fd;             //list file descriptor
0018                
0018 00 00          lst_fd dw 0
001A                
001A                ;-18 int bin_fd;             //output file descriptor
001A                
001A 00 00          bin_fd dw 0
001C                
001C                ;-19 int DOS_ERR=0;          //global var
001C                
001C 00 00          DOS_ERR dw 0
001E                
001E                ;-20 int ErrorCount=0;       //number of errors
001E                
001E 00 00          ErrorCount dw 0
0020                
0020                ;-21 int DOS_NoBytes;        //number of bytes read (0 or 1)
0020                
0020 00 00          DOS_NoBytes dw 0
0022                
0022                ;-22 char DOS_ByteRead;      //the byte just read by DOS
0022                
0022 00             DOS_ByteRead db 0
0023                
0023                ;-23 
0023                
0023                
0023                ;-24 unsigned int PC=0;      //program counter
0023                
0023 00 00          PC dw 0
0025                
0025                ;-25 unsigned int Origin=0;  //ORG nn
0025                
0025 00 00          Origin dw 0
0027                
0027                ;-26 unsigned int AbsoluteLab=0;//uninitialised data
0027                
0027 00 00          AbsoluteLab dw 0
0029                
0029                ;-27 unsigned int PCStart;   //PC at start of line by PrintLine()
0029                
0029 00 00          PCStart dw 0
002B                
002B                ;-28 char isLabel;           //by getName()
002B                
002B 00             isLabel db 0
002C                
002C                ;-29 #define DIGIT    1      //0-9
002C                
002C                
002C                ;-30 #define LETTERE  2      //a-z A-Z @ . _
002C                
002C                
002C                ;-31 #define ALNUME   3      //a-z A-Z @ . _  0-9
002C                
002C                
002C                ;-32 #define NOALNUME 4      //other char
002C                
002C                
002C                ;-33 char TokeType;          //0, DIGIT, LETTERE, ALNUME, NOALNUME
002C                
002C 00             TokeType db 0
002D                
002D                ;-34 #define BYTE     1
002D                
002D                
002D                ;-35 #define WORD     2
002D                
002D                
002D                ;-36 #define DWORD    3
002D                
002D                
002D                ;-37 #define SEGREG   4
002D                
002D                
002D                ;-38 #define IMM      1      //const  ,123
002D                
002D                
002D                ;-39 #define REG      2      //       ,BX    mode=11
002D                
002D                
002D                ;-40 #define ADR      3      //DIRECT: VALUE  ,var1  mod=00, r/m=110
002D                
002D                
002D                ;-41 #define MEM      4      //[var1],[BX+SI],[table+BX],[bp-4] disp0,8,16
002D                
002D                
002D                ;-42 char Op;                //1. operand: 0, IMM, REG, ADR, MEM
002D                
002D 00             Op db 0
002E                
002E                ;-43 char Op2;               //2. operand
002E                
002E 00             Op2 db 0
002F                
002F                ;-44 char CodeType;          //1-207 by searchSymbol(), must be byte size
002F                
002F 00             CodeType db 0
0030                
0030                ;-45 char Code1;             //1. Opcode
0030                
0030 00             Code1 db 0
0031                
0031                ;-46 char Code2;             //2. Opcode
0031                
0031 00             Code2 db 0
0032                
0032                ;-47 char Code3;             //3. Opcode
0032                
0032 00             Code3 db 0
0033                
0033                ;-48 char R2No;              //0 - 7 AL, CL, ...  set in testReg()
0033                
0033 00             R2No db 0
0034                
0034                ;-49 char R1No;              //temp for 1. register
0034                
0034 00             R1No db 0
0035                
0035                ;-50 char R2Type;            //0=no reg, BYTE, WORD, DWORD, SEGREG
0035                
0035 00             R2Type db 0
0036                
0036                ;-51 char R1Type;            //temp for 1. register
0036                
0036 00             R1Type db 0
0037                
0037                ;-52 char OpSize;            //0, BYTE, WORD, DWORD by getCodeSize()
0037                
0037 00             OpSize db 0
0038                
0038                ;-53 char wflag;             //wordflag: 0=byte, 1=word/dword
0038                
0038 00             wflag db 0
0039                
0039                ;-54 char dflag;             //directionflag: 1=to reg MOV,ALU
0039                
0039 00             dflag db 0
003A                
003A                ;-55 char sflag;             //sign extended, imm8 to word PUSH,ALU,IMUL3
003A                
003A 00             sflag db 0
003B                
003B                ;-56 char rm;                //combination of index and base reg
003B                
003B 00             rm db 0
003C                
003C                ;-57 char isDirect;          //set in process and getMeM, need in WriteEA
003C                
003C 00             isDirect db 0
003D                
003D                ;-58 int disp;               //displacement      0-8 bytes
003D                
003D 00 00          disp dw 0
003F                
003F                ;-59 unsigned int imme;      //immediate         0-8 bytes
003F                
003F 00 00          imme dw 0
0041                
0041                ;-60 
0041                
0041                
0041                ;-61 #define OPMAXLEN 5
0041                
0041                
0041                ;-62 char OpPos[OPMAXLEN];   //array for one opcode to list
0041                
0041                section .bss
0041                absolute 30549
0041                OpPos resb 5
0041                section .text
0041                
0041                ;-63 int OpPrintIndex;       //0-OPMAXLEN, pos to print opcode, by genCode8
0041                
0041 00 00          OpPrintIndex dw 0
0043                
0043                ;-64 char *OpCodePtr;        //position in OpCodeTable by searchSymbol
0043                
0043 00 00          OpCodePtr dw 0
0045                
0045                ;-65 char PrintRA;           //print * for forward relocative jmp
0045                
0045 00             PrintRA db 0
0046                
0046                ;-66 
0046                
0046                
0046                ;-67 #define LABELNAMESMAX 5969//next number - SYMBOLMAX
0046                
0046                
0046                ;-68 char LabelNames[6000];  //space for names of all labels
0046                
0046                section .bss
0046                absolute 30554
0046                LabelNames resb 6000
0046                section .text
0046                
0046                ;-69 char *LabelNamePtr;     //first free position
0046                
0046 00 00          LabelNamePtr dw 0
0048                
0048                ;-70 char *tmpLabelNamePtr;  //set after PROC to LabelNamePtr
0048                
0048 00 00          tmpLabelNamePtr dw 0
004A                
004A                ;-71 
004A                
004A                
004A                ;-72 #define LABELADRMAX 600
004A                
004A                
004A                ;-73 unsigned int LabelAddr[LABELADRMAX];//addr of each label
004A                
004A                section .bss
004A                absolute 36554
004A                LabelAddr resw 600
004A                section .text
004A                
004A                ;-74 int LabelMaxIx=0;       //actual # of stored labels. 1 to LABELADRMAX-1
004A                
004A 00 00          LabelMaxIx dw 0
004C                
004C                ;-75 int tmpLabelMaxIx;      //set after PROC to LabelMaxIx
004C                
004C 00 00          tmpLabelMaxIx dw 0
004E                
004E                ;-76 int LabelIx;            //actual # of just searched label
004E                
004E 00 00          LabelIx dw 0
0050                
0050                ;-77 
0050                
0050                
0050                ;-78 #define JMPNAMESMAX 3969//next number - SYMBOLMAX
0050                
0050                
0050                ;-79 char JmpNames[4000];    //space for names of jmp, call
0050                
0050                section .bss
0050                absolute 37754
0050                JmpNames resb 4000
0050                section .text
0050                
0050                ;-80 char *JmpNamePtr;       //first free position
0050                
0050 00 00          JmpNamePtr dw 0
0052                
0052                ;-81 char *tmpJmpNamePtr;    //set after PROC to JmpNamePtr
0052                
0052 00 00          tmpJmpNamePtr dw 0
0054                
0054                ;-82 
0054                
0054                
0054                ;-83 #define JMPMAX 200      //max. jmp and call
0054                
0054                
0054                ;-84 unsigned int JmpAddr[JMPMAX];//addr to be fixed
0054                
0054                section .bss
0054                absolute 41754
0054                JmpAddr resw 200
0054                section .text
0054                
0054                ;-85 int JmpMaxIx=0;         //actual # of jmp, call. 1 to JMPMAX-1
0054                
0054 00 00          JmpMaxIx dw 0
0056                
0056                ;-86 int tmpJmpMaxIx=0;      //set after PROC to JmpMaxIx
0056                
0056 00 00          tmpJmpMaxIx dw 0
0058                
0058                ;-87 
0058                
0058                
0058                ;-88 #define FILEBINMAX 17000
0058                
0058                
0058                ;-89 char FileBin  [FILEBINMAX];//output binary file
0058                
0058                section .bss
0058                absolute 42154
0058                FileBin resb 17000
0058                section .text
0058                
0058                ;-90 unsigned int BinLen=0;  //length of binary file
0058                
0058 00 00          BinLen dw 0
005A                
005A                ;-91 
005A                
005A                
005A                ;-92 char *arglen=0x80;      // for main only
005A                
005A 80 00          arglen dw 128
005C                
005C                ;-93 char *argv=0x82;        // for main only
005C                
005C 82 00          argv dw 130
005E                
005E                ;-94 
005E                
005E                
005E                ;-95 
005E                
005E                
005E                ;-96 //#include "HELPER.C"
005E                
005E                
005E                ;-97 int writetty()     { ah=0x0E; bx=0; __emit__(0xCD,0x10); }
005E                
005E                
entering: writetty
005E                writetty: PROC
005E B4 0E           mov  ah, 14
0060 BB 00 00        mov  bx, 0
0063 CD 10           db 205,16
0065                
0065                ;-98 int putch(char c)  {if (_ c==10) {al=13; writetty();} al=c; writetty(); }
0065                
0065 C3              ret
leaving: writetty, loc labels: 0, loc jmp forward: 0
0066                ENDP
0066                
entering: putch
0066                putch: PROC
0066                ;Function : putch, Number of local variables: 1
0066                ;   # type sign width addr used name   list of local variables
0066                ;  200 var sign byte    98 NULL c = bp+4;
0066 C8 00 00 00     ENTER  0,0 ; constant expression
006A 80 7E 04 0A    cmp byte[bp+4], 10
006E 0F 85 00 00   r jne .putch1
0072 B0 0D           mov  al, 13
0074 E8 E7 FF        call writetty
0077                .putch1:
0077 8A 46 04        mov  al, [bp+4]
007A E8 E1 FF        call writetty
007D                
007D                ;-99 int cputs(char *s) {char c;  while(*s) { c=*s; putch(c); s++; } }
007D C9              LEAVE
007E C3              ret
leaving: putch, loc labels: 1, loc jmp forward: 1
007F                ENDP
007F                
entering: cputs
007F                cputs: PROC
007F                ;Function : cputs, Number of local variables: 2
007F                ;   # type sign width addr used name   list of local variables
007F                ;  200 ptr sign byte    99 NULL s = bp+4
007F                ;  201 var sign byte    99 NULL c = bp-2;
007F C8 02 00 00     ENTER  2,0
0083                .cputs2:
0083 8B 5E 04        mov bx, [bp+4]
0086 8A 07           mov al, [bx]
0088 B4 00           mov ah, 0
008A 08 C0           or  al, al
008C 0F 84 00 00   r je .cputs3
0090 8B 5E 04        mov bx, [bp+4]
0093 8A 07           mov al, [bx]
0095 B4 00           mov ah, 0
0097 88 46 FE        mov [bp-2], al
009A 8A 46 FE        mov al, byte [bp-2]
009D B4 00           mov ah, 0
009F 50              push ax
00A0 E8 C3 FF        call putch
00A3 83 C4 02        add  sp, 2
00A6 FF 46 04        inc  word[bp+4]
00A9 EB D8           jmp .cputs2
00AB                .cputs3:
00AB                
00AB                ;-100 
00AB                
00AB                
00AB                ;-101 int DosInt() {
00AB C9              LEAVE
00AC C3              ret
leaving: cputs, loc labels: 2, loc jmp forward: 1
00AD                ENDP
00AD                
entering: DosInt
00AD                DosInt: PROC
00AD                
00AD                ;-102     __emit__(0xCD,0x21);//inth 0x21;
00AD                
00AD CD 21           db 205,33
00AF                
00AF                ;-103     __emit__(0x73, 04); //ifcarry DOS_ERR++;
00AF                
00AF 73 04           db 115,4
00B1                
00B1                ;-104     DOS_ERR++;
00B1                
00B1 FF 06 1C 01     inc  word[DOS_ERR]
00B5                
00B5                ;-105 }
00B5                
00B5                
00B5                ;-106 int openR (char *s) { dx=s;       ax=0x3D02; DosInt(); }
00B5                
00B5 C3              ret
leaving: DosInt, loc labels: 0, loc jmp forward: 0
00B6                ENDP
00B6                
entering: openR
00B6                openR: PROC
00B6                ;Function : openR, Number of local variables: 1
00B6                ;   # type sign width addr used name   list of local variables
00B6                ;  200 ptr sign byte   106 NULL s = bp+4;
00B6 C8 00 00 00     ENTER  0,0
00BA 8B 56 04        mov  dx, [bp+4]
00BD B8 02 3D        mov  ax, 15618
00C0 E8 EA FF        call DosInt
00C3                
00C3                ;-107 int creatR(char *s) { dx=s; cx=0; ax=0x3C00; DosInt(); }
00C3 C9              LEAVE
00C4 C3              ret
leaving: openR, loc labels: 0, loc jmp forward: 0
00C5                ENDP
00C5                
entering: creatR
00C5                creatR: PROC
00C5                ;Function : creatR, Number of local variables: 1
00C5                ;   # type sign width addr used name   list of local variables
00C5                ;  200 ptr sign byte   107 NULL s = bp+4;
00C5 C8 00 00 00     ENTER  0,0
00C9 8B 56 04        mov  dx, [bp+4]
00CC B9 00 00        mov  cx, 0
00CF B8 00 3C        mov  ax, 15360
00D2 E8 D8 FF        call DosInt
00D5                
00D5                ;-108 int fcloseR(int fd) {bx=fd;       ax=0x3E00; DosInt(); }
00D5 C9              LEAVE
00D6 C3              ret
leaving: creatR, loc labels: 0, loc jmp forward: 0
00D7                ENDP
00D7                
entering: fcloseR
00D7                fcloseR: PROC
00D7                ;Function : fcloseR, Number of local variables: 1
00D7                ;   # type sign width addr used name   list of local variables
00D7                ;  200 var sign word   108 NULL fd = bp+4;
00D7 C8 00 00 00     ENTER  0,0
00DB 8B 5E 04        mov  bx, [bp+4]
00DE B8 00 3E        mov  ax, 15872
00E1 E8 C9 FF        call DosInt
00E4                
00E4                ;-109 int exitR  (char c) {ah=0x4C; al=c;          DosInt(); }
00E4 C9              LEAVE
00E5 C3              ret
leaving: fcloseR, loc labels: 0, loc jmp forward: 0
00E6                ENDP
00E6                
entering: exitR
00E6                exitR: PROC
00E6                ;Function : exitR, Number of local variables: 1
00E6                ;   # type sign width addr used name   list of local variables
00E6                ;  200 var sign byte   109 NULL c = bp+4;
00E6 C8 00 00 00     ENTER  0,0
00EA B4 4C           mov  ah, 76
00EC 8A 46 04        mov  al, [bp+4]
00EF E8 BB FF        call DosInt
00F2                
00F2                ;-110 int readRL(char *s, int fd, int len){
00F2 C9              LEAVE
00F3 C3              ret
leaving: exitR, loc labels: 0, loc jmp forward: 0
00F4                ENDP
00F4                
entering: readRL
00F4                readRL: PROC
00F4                
00F4                ;-111     dx=s; cx=len; bx=fd; ax=0x3F00; DosInt();}
00F4                
00F4                ;Function : readRL, Number of local variables: 3
00F4                ;   # type sign width addr used name   list of local variables
00F4                ;  200 ptr sign byte   110 NULL s = bp+4
00F4                ;  201 var sign word   110 NULL fd = bp+6
00F4                ;  202 var sign word   110 NULL len = bp+8;
00F4 C8 00 00 00     ENTER  0,0
00F8 8B 56 04        mov  dx, [bp+4]
00FB 8B 4E 08        mov  cx, [bp+8]
00FE 8B 5E 06        mov  bx, [bp+6]
0101 B8 00 3F        mov  ax, 16128
0104 E8 A6 FF        call DosInt
0107                
0107                ;-112 int fputcR(char *n, int fd) { __asm{lea dx, [bp+4]}; /* = *n */
0107 C9              LEAVE
0108 C3              ret
leaving: readRL, loc labels: 0, loc jmp forward: 0
0109                ENDP
0109                
entering: fputcR
0109                fputcR: PROC
0109                ;Function : fputcR, Number of local variables: 2
0109                ;   # type sign width addr used name   list of local variables
0109                ;  200 ptr sign byte   112 NULL n = bp+4
0109                ;  201 var sign word   112 NULL fd = bp+6;
0109 C8 00 00 00     ENTER  0,0
010D 8D 56 04       lea dx, [bp+4]
0110                
0110                ;-113   cx=1; bx=fd; ax=0x4000; DosInt(); }
0110                
0110 B9 01 00        mov  cx, 1
0113 8B 5E 06        mov  bx, [bp+6]
0116 B8 00 40        mov  ax, 16384
0119 E8 91 FF        call DosInt
011C                
011C                ;-114 
011C                
011C                
011C                ;-115 int letterE(char c) {
011C C9              LEAVE
011D C3              ret
leaving: fputcR, loc labels: 0, loc jmp forward: 0
011E                ENDP
011E                
entering: letterE
011E                letterE: PROC
011E                
011E                ;-116   if (c=='_') return 1;
011E                
011E                ;Function : letterE, Number of local variables: 1
011E                ;   # type sign width addr used name   list of local variables
011E                ;  200 var sign byte   115 NULL c = bp+4;
011E C8 00 00 00     ENTER  0,0
0122 8A 46 04        mov al, [bp+4]
0125 3C 5F           cmp al, 95
0127 0F 85 00 00   r jne .letterE4
012B B8 01 00        mov ax, 1
012E E9 00 00      R jmp .retnletterE
0131                
0131                ;-117   if (c=='.') return 1;
0131                
0131                .letterE4:
0131 8A 46 04        mov al, [bp+4]
0134 3C 2E           cmp al, 46
0136 0F 85 00 00   r jne .letterE5
013A B8 01 00        mov ax, 1
013D E9 00 00      R jmp .retnletterE
0140                
0140                ;-118   if (c=='?') return 1;
0140                
0140                .letterE5:
0140 8A 46 04        mov al, [bp+4]
0143 3C 3F           cmp al, 63
0145 0F 85 00 00   r jne .letterE6
0149 B8 01 00        mov ax, 1
014C E9 00 00      R jmp .retnletterE
014F                
014F                ;-119   if (c=='$') return 1;
014F                
014F                .letterE6:
014F 8A 46 04        mov al, [bp+4]
0152 3C 24           cmp al, 36
0154 0F 85 00 00   r jne .letterE7
0158 B8 01 00        mov ax, 1
015B E9 00 00      R jmp .retnletterE
015E                
015E                ;-120   if (c> 'z') return 0;
015E                
015E                .letterE7:
015E 8A 46 04        mov al, [bp+4]
0161 3C 7A           cmp al, 122
0163 0F 8E 00 00   r jle .letterE8
0167 B8 00 00        mov ax, 0
016A E9 00 00      R jmp .retnletterE
016D                
016D                ;-121   if (c< '@') return 0; // at included
016D                
016D                .letterE8:
016D 8A 46 04        mov al, [bp+4]
0170 3C 40           cmp al, 64
0172 0F 8D 00 00   r jge .letterE9
0176 B8 00 00        mov ax, 0
0179 E9 00 00      R jmp .retnletterE
017C                
017C                ;-122   if (c> 'Z') { if (c< 'a') return 0; }
017C                
017C                .letterE9:
017C 8A 46 04        mov al, [bp+4]
017F 3C 5A           cmp al, 90
0181 0F 8E 00 00   r jle .letterE10
0185 8A 46 04        mov al, [bp+4]
0188 3C 61           cmp al, 97
018A 0F 8D 00 00   r jge .letterE11
018E B8 00 00        mov ax, 0
0191 E9 00 00      R jmp .retnletterE
0194                .letterE11:
0194                
0194                ;-123   return 1;
0194                
0194                .letterE10:
0194 B8 01 00        mov ax, 1
0197 E9 00 00      R jmp .retnletterE
019A                
019A                ;-124 }
019A                
019A                
019A                ;-125 int digit(char c){
019A                
019A C9              .retnletterE: LEAVE
019B C3              ret
leaving: letterE, loc labels: 9, loc jmp forward: 16
019C                ENDP
019C                
entering: digit
019C                digit: PROC
019C                
019C                ;-126     if(c<'0') return 0;
019C                
019C                ;Function : digit, Number of local variables: 1
019C                ;   # type sign width addr used name   list of local variables
019C                ;  200 var sign byte   125 NULL c = bp+4;
019C C8 00 00 00     ENTER  0,0
01A0 8A 46 04        mov al, [bp+4]
01A3 3C 30           cmp al, 48
01A5 0F 8D 00 00   r jge .digit12
01A9 B8 00 00        mov ax, 0
01AC E9 00 00      R jmp .retndigit
01AF                
01AF                ;-127     if(c>'9') return 0;
01AF                
01AF                .digit12:
01AF 8A 46 04        mov al, [bp+4]
01B2 3C 39           cmp al, 57
01B4 0F 8E 00 00   r jle .digit13
01B8 B8 00 00        mov ax, 0
01BB E9 00 00      R jmp .retndigit
01BE                
01BE                ;-128     return 1;
01BE                
01BE                .digit13:
01BE B8 01 00        mov ax, 1
01C1 E9 00 00      R jmp .retndigit
01C4                
01C4                ;-129 }
01C4                
01C4                
01C4                ;-130 int alnumE(char c) {
01C4                
01C4 C9              .retndigit: LEAVE
01C5 C3              ret
leaving: digit, loc labels: 3, loc jmp forward: 5
01C6                ENDP
01C6                
entering: alnumE
01C6                alnumE: PROC
01C6                
01C6                ;-131   if (digit(c)) return 1;
01C6                
01C6                ;Function : alnumE, Number of local variables: 1
01C6                ;   # type sign width addr used name   list of local variables
01C6                ;  200 var sign byte   130 NULL c = bp+4;
01C6 C8 00 00 00     ENTER  0,0
01CA 8A 46 04        mov al, byte [bp+4]
01CD B4 00           mov ah, 0
01CF 50              push ax
01D0 E8 C9 FF        call digit
01D3 83 C4 02        add  sp, 2
01D6 08 C0           or  al, al
01D8 0F 84 00 00   r je .alnumE14
01DC B8 01 00        mov ax, 1
01DF E9 00 00      R jmp .retnalnumE
01E2                
01E2                ;-132   if (letterE(c)) return 1;
01E2                
01E2                .alnumE14:
01E2 8A 46 04        mov al, byte [bp+4]
01E5 B4 00           mov ah, 0
01E7 50              push ax
01E8 E8 33 FF        call letterE
01EB 83 C4 02        add  sp, 2
01EE 08 C0           or  al, al
01F0 0F 84 00 00   r je .alnumE15
01F4 B8 01 00        mov ax, 1
01F7 E9 00 00      R jmp .retnalnumE
01FA                
01FA                ;-133   return 0;
01FA                
01FA                .alnumE15:
01FA B8 00 00        mov ax, 0
01FD E9 00 00      R jmp .retnalnumE
0200                
0200                ;-134 }
0200                
0200                
0200                ;-135 int strlen(char *s) { int c;
0200                
0200 C9              .retnalnumE: LEAVE
0201 C3              ret
leaving: alnumE, loc labels: 3, loc jmp forward: 5
0202                ENDP
0202                
entering: strlen
0202                strlen: PROC
0202                
0202                ;-136     c=0;
0202                
0202                ;Function : strlen, Number of local variables: 2
0202                ;   # type sign width addr used name   list of local variables
0202                ;  200 ptr sign byte   135 NULL s = bp+4
0202                ;  201 var sign word   135 NULL c = bp-2;
0202 C8 02 00 00     ENTER  2,0
0206 B8 00 00        mov ax, 0
0209 89 46 FE        mov [bp-2], ax
020C                
020C                ;-137     while (*s!=0) {s++; c++;}
020C                
020C                .strlen16:
020C 8B 5E 04        mov bx, [bp+4]
020F 8A 07           mov al, [bx]
0211 B4 00           mov ah, 0
0213 83 F8 00        cmp ax, 0
0216 0F 84 00 00   r je  .strlen17
021A FF 46 04        inc  word[bp+4]
021D FF 46 FE        inc  word[bp-2]
0220                
0220                ;-138     return c;
0220                
0220 EB EA           jmp .strlen16
0222                .strlen17:
0222 8B 46 FE        mov ax, [bp-2]
0225 E9 00 00      R jmp .retnstrlen
0228                
0228                ;-139     }
0228                
0228                
0228                ;-140 int strcpy(char *s, char *t) {
0228                
0228 C9              .retnstrlen: LEAVE
0229 C3              ret
leaving: strlen, loc labels: 3, loc jmp forward: 2
022A                ENDP
022A                
entering: strcpy
022A                strcpy: PROC
022A                
022A                ;-141     do { *s=*t; s++; t++; }
022A                
022A                ;Function : strcpy, Number of local variables: 2
022A                ;   # type sign width addr used name   list of local variables
022A                ;  200 ptr sign byte   140 NULL s = bp+4
022A                ;  201 ptr sign byte   140 NULL t = bp+6;
022A C8 00 00 00     ENTER  0,0
022E                .strcpy18:
022E 8B 5E 06        mov bx, [bp+6]
0231 8A 07           mov al, [bx]
0233 B4 00           mov ah, 0
0235 8B 5E 04        mov  bx, [bp+4]
0238 88 07           mov  [bx], al
023A FF 46 04        inc  word[bp+4]
023D FF 46 06        inc  word[bp+6]
0240                
0240                ;-142     while (*t!=0);
0240                
0240 8B 5E 06        mov bx, [bp+6]
0243 8A 07           mov al, [bx]
0245 B4 00           mov ah, 0
0247 83 F8 00        cmp ax, 0
024A 0F 84 00 00   r je  .strcpy19
024E EB DE           jmp .strcpy18
0250                .strcpy19:
0250                
0250                ;-143     *s=0;
0250                
0250 B8 00 00        mov ax, 0
0253 8B 5E 04        mov  bx, [bp+4]
0256 88 07           mov  [bx], al
0258                
0258                ;-144     return s;
0258                
0258 8B 46 04        mov ax, [bp+4]
025B E9 00 00      R jmp .retnstrcpy
025E                
025E                ;-145     }
025E                
025E                
025E                ;-146 int eqstr(char *p, char *q) {
025E                
025E C9              .retnstrcpy: LEAVE
025F C3              ret
leaving: strcpy, loc labels: 3, loc jmp forward: 2
0260                ENDP
0260                
entering: eqstr
0260                eqstr: PROC
0260                
0260                ;-147     while(*p) {
0260                
0260                ;Function : eqstr, Number of local variables: 2
0260                ;   # type sign width addr used name   list of local variables
0260                ;  200 ptr sign byte   146 NULL p = bp+4
0260                ;  201 ptr sign byte   146 NULL q = bp+6;
0260 C8 00 00 00     ENTER  0,0
0264                .eqstr20:
0264 8B 5E 04        mov bx, [bp+4]
0267 8A 07           mov al, [bx]
0269 B4 00           mov ah, 0
026B 08 C0           or  al, al
026D 0F 84 00 00   r je .eqstr21
0271                
0271                ;-148         if (*p != *q) return 0;
0271                
0271 8B 5E 04        mov bx, [bp+4]
0274 8A 07           mov al, [bx]
0276 B4 00           mov ah, 0
0278 8B 5E 06        mov bx, [bp+6]
027B 3A 07           cmp al, [bx]
027D B4 00           mov ah, 0
027F 0F 84 00 00   r je  .eqstr22
0283 B8 00 00        mov ax, 0
0286 E9 00 00      R jmp .retneqstr
0289                
0289                ;-149             p++;
0289                
0289                .eqstr22:
0289 FF 46 04        inc  word[bp+4]
028C                
028C                ;-150             q++;
028C                
028C FF 46 06        inc  word[bp+6]
028F                
028F                ;-151             }
028F                
028F                
028F                ;-152     if(*q) return 0;
028F                
028F EB D3           jmp .eqstr20
0291                .eqstr21:
0291 8B 5E 06        mov bx, [bp+6]
0294 8A 07           mov al, [bx]
0296 B4 00           mov ah, 0
0298 08 C0           or  al, al
029A 0F 84 00 00   r je .eqstr23
029E B8 00 00        mov ax, 0
02A1 E9 00 00      R jmp .retneqstr
02A4                
02A4                ;-153     return 1;
02A4                
02A4                .eqstr23:
02A4 B8 01 00        mov ax, 1
02A7 E9 00 00      R jmp .retneqstr
02AA                
02AA                ;-154     }
02AA                
02AA                
02AA                ;-155 int strcat1(char *s, char *t) {
02AA                
02AA C9              .retneqstr: LEAVE
02AB C3              ret
leaving: eqstr, loc labels: 5, loc jmp forward: 6
02AC                ENDP
02AC                
entering: strcat1
02AC                strcat1: PROC
02AC                
02AC                ;-156     while (*s != 0) s++;
02AC                
02AC                ;Function : strcat1, Number of local variables: 2
02AC                ;   # type sign width addr used name   list of local variables
02AC                ;  200 ptr sign byte   155 NULL s = bp+4
02AC                ;  201 ptr sign byte   155 NULL t = bp+6;
02AC C8 00 00 00     ENTER  0,0
02B0                .strcat124:
02B0 8B 5E 04        mov bx, [bp+4]
02B3 8A 07           mov al, [bx]
02B5 B4 00           mov ah, 0
02B7 83 F8 00        cmp ax, 0
02BA 0F 84 00 00   r je  .strcat125
02BE FF 46 04        inc  word[bp+4]
02C1                
02C1                ;-157     strcpy(s, t);
02C1                
02C1 EB ED           jmp .strcat124
02C3                .strcat125:
02C3 55              push word [bp+6]
02C4 55              push word [bp+4]
02C5 E8 62 FF        call strcpy
02C8 83 C4 04        add  sp, 4
02CB                
02CB                ;-158     }
02CB                
02CB                
02CB                ;-159 int toupper(char *s) {
02CB C9              LEAVE
02CC C3              ret
leaving: strcat1, loc labels: 2, loc jmp forward: 1
02CD                ENDP
02CD                
entering: toupper
02CD                toupper: PROC
02CD                
02CD                ;-160     while(*s) {
02CD                
02CD                ;Function : toupper, Number of local variables: 1
02CD                ;   # type sign width addr used name   list of local variables
02CD                ;  200 ptr sign byte   159 NULL s = bp+4;
02CD C8 00 00 00     ENTER  0,0
02D1                .toupper26:
02D1 8B 5E 04        mov bx, [bp+4]
02D4 8A 07           mov al, [bx]
02D6 B4 00           mov ah, 0
02D8 08 C0           or  al, al
02DA 0F 84 00 00   r je .toupper27
02DE                
02DE                ;-161         if (*s >= 'a') if (*s <= 'z') *s=*s-32;
02DE                
02DE 8B 5E 04        mov bx, [bp+4]
02E1 8A 07           mov al, [bx]
02E3 B4 00           mov ah, 0
02E5 83 F8 61        cmp ax, 97 ;unsigned : 1
02E8 0F 8C 00 00   r jl  .toupper28
02EC 8B 5E 04        mov bx, [bp+4]
02EF 8A 07           mov al, [bx]
02F1 B4 00           mov ah, 0
02F3 83 F8 7A        cmp ax, 122
02F6 0F 8F 00 00   r jg  .toupper29
02FA 8B 5E 04        mov bx, [bp+4]
02FD 8A 07           mov al, [bx]
02FF B4 00           mov ah, 0
0301 83 E8 20        sub ax, 32
0304 8B 5E 04        mov  bx, [bp+4]
0307 88 07           mov  [bx], al
0309                
0309                ;-162             s++;
0309                
0309                .toupper29:
0309                .toupper28:
0309 FF 46 04        inc  word[bp+4]
030C                
030C                ;-163               }
030C                
030C                
030C                ;-164     }
030C                
030C EB C3           jmp .toupper26
030E                .toupper27:
030E                
030E                ;-165 
030E                
030E                
030E                ;-166 int testReg() {
030E C9              LEAVE
030F C3              ret
leaving: toupper, loc labels: 4, loc jmp forward: 3
0310                ENDP
0310                
entering: testReg
0310                testReg: PROC
0310                
0310                ;-167 //ret:RegNo: 0 - 7 AL, CL  set:R2Type: 0=no reg,BYTE,WORD,SEGREG,DWORD
0310                
0310                
0310                ;-168   R2Type=0;
0310                
0310 B8 00 00        mov ax, 0
0313 A2 35 01        mov byte [R2Type], al
0316                
0316                ;-169   if (strlen(Symbol) < 2) return 0;
0316                
0316 8D 06 30 75     lea  ax, [Symbol]
031A 50              push ax
031B E8 E4 FE        call strlen
031E 83 C4 02        add  sp, 2
0321 3C 02           cmp al, 2
0323 0F 8D 00 00   r jge .testReg30
0327 B8 00 00        mov ax, 0
032A E9 00 00      R jmp .retntestReg
032D                
032D                ;-170   if (strlen(Symbol) > 3) return 0;
032D                
032D                .testReg30:
032D 8D 06 30 75     lea  ax, [Symbol]
0331 50              push ax
0332 E8 CD FE        call strlen
0335 83 C4 02        add  sp, 2
0338 3C 03           cmp al, 3
033A 0F 8E 00 00   r jle .testReg31
033E B8 00 00        mov ax, 0
0341 E9 00 00      R jmp .retntestReg
0344                
0344                ;-171   R2Type=BYTE;
0344                
0344                .testReg31:
0344 B8 01 00        mov ax, 1
0347 A2 35 01        mov byte [R2Type], al
034A                
034A                ;-172   if (eqstr(SymbolUpper, "AL")) return 0;
034A                
034A 68 AA AA      A push testReg_0
034D 8D 06 4F 75     lea  ax, [SymbolUpper]
0351 50              push ax
0352 E8 0B FF        call eqstr
0355 83 C4 04        add  sp, 4
0358 08 C0           or  al, al
035A 0F 84 00 00   r je .testReg32
035E B8 00 00        mov ax, 0
0361 E9 00 00      R jmp .retntestReg
0364                
0364                ;-173   if (eqstr(SymbolUpper, "CL")) return 1;
0364                
0364                .testReg32:
0364 68 AA AA      A push testReg_1
0367 8D 06 4F 75     lea  ax, [SymbolUpper]
036B 50              push ax
036C E8 F1 FE        call eqstr
036F 83 C4 04        add  sp, 4
0372 08 C0           or  al, al
0374 0F 84 00 00   r je .testReg33
0378 B8 01 00        mov ax, 1
037B E9 00 00      R jmp .retntestReg
037E                
037E                ;-174   if (eqstr(SymbolUpper, "DL")) return 2;
037E                
037E                .testReg33:
037E 68 AA AA      A push testReg_2
0381 8D 06 4F 75     lea  ax, [SymbolUpper]
0385 50              push ax
0386 E8 D7 FE        call eqstr
0389 83 C4 04        add  sp, 4
038C 08 C0           or  al, al
038E 0F 84 00 00   r je .testReg34
0392 B8 02 00        mov ax, 2
0395 E9 00 00      R jmp .retntestReg
0398                
0398                ;-175   if (eqstr(SymbolUpper, "BL")) return 3;
0398                
0398                .testReg34:
0398 68 AA AA      A push testReg_3
039B 8D 06 4F 75     lea  ax, [SymbolUpper]
039F 50              push ax
03A0 E8 BD FE        call eqstr
03A3 83 C4 04        add  sp, 4
03A6 08 C0           or  al, al
03A8 0F 84 00 00   r je .testReg35
03AC B8 03 00        mov ax, 3
03AF E9 00 00      R jmp .retntestReg
03B2                
03B2                ;-176   if (eqstr(SymbolUpper, "AH")) return 4;
03B2                
03B2                .testReg35:
03B2 68 AA AA      A push testReg_4
03B5 8D 06 4F 75     lea  ax, [SymbolUpper]
03B9 50              push ax
03BA E8 A3 FE        call eqstr
03BD 83 C4 04        add  sp, 4
03C0 08 C0           or  al, al
03C2 0F 84 00 00   r je .testReg36
03C6 B8 04 00        mov ax, 4
03C9 E9 00 00      R jmp .retntestReg
03CC                
03CC                ;-177   if (eqstr(SymbolUpper, "CH")) return 5;
03CC                
03CC                .testReg36:
03CC 68 AA AA      A push testReg_5
03CF 8D 06 4F 75     lea  ax, [SymbolUpper]
03D3 50              push ax
03D4 E8 89 FE        call eqstr
03D7 83 C4 04        add  sp, 4
03DA 08 C0           or  al, al
03DC 0F 84 00 00   r je .testReg37
03E0 B8 05 00        mov ax, 5
03E3 E9 00 00      R jmp .retntestReg
03E6                
03E6                ;-178   if (eqstr(SymbolUpper, "DH")) return 6;
03E6                
03E6                .testReg37:
03E6 68 AA AA      A push testReg_6
03E9 8D 06 4F 75     lea  ax, [SymbolUpper]
03ED 50              push ax
03EE E8 6F FE        call eqstr
03F1 83 C4 04        add  sp, 4
03F4 08 C0           or  al, al
03F6 0F 84 00 00   r je .testReg38
03FA B8 06 00        mov ax, 6
03FD E9 00 00      R jmp .retntestReg
0400                
0400                ;-179   if (eqstr(SymbolUpper, "BH")) return 7;
0400                
0400                .testReg38:
0400 68 AA AA      A push testReg_7
0403 8D 06 4F 75     lea  ax, [SymbolUpper]
0407 50              push ax
0408 E8 55 FE        call eqstr
040B 83 C4 04        add  sp, 4
040E 08 C0           or  al, al
0410 0F 84 00 00   r je .testReg39
0414 B8 07 00        mov ax, 7
0417 E9 00 00      R jmp .retntestReg
041A                
041A                ;-180   R2Type=WORD;
041A                
041A                .testReg39:
041A B8 02 00        mov ax, 2
041D A2 35 01        mov byte [R2Type], al
0420                
0420                ;-181   if (eqstr(SymbolUpper, "AX")) return 0;
0420                
0420 68 AA AA      A push testReg_8
0423 8D 06 4F 75     lea  ax, [SymbolUpper]
0427 50              push ax
0428 E8 35 FE        call eqstr
042B 83 C4 04        add  sp, 4
042E 08 C0           or  al, al
0430 0F 84 00 00   r je .testReg40
0434 B8 00 00        mov ax, 0
0437 E9 00 00      R jmp .retntestReg
043A                
043A                ;-182   if (eqstr(SymbolUpper, "CX")) return 1;
043A                
043A                .testReg40:
043A 68 AA AA      A push testReg_9
043D 8D 06 4F 75     lea  ax, [SymbolUpper]
0441 50              push ax
0442 E8 1B FE        call eqstr
0445 83 C4 04        add  sp, 4
0448 08 C0           or  al, al
044A 0F 84 00 00   r je .testReg41
044E B8 01 00        mov ax, 1
0451 E9 00 00      R jmp .retntestReg
0454                
0454                ;-183   if (eqstr(SymbolUpper, "DX")) return 2;
0454                
0454                .testReg41:
0454 68 AA AA      A push testReg_10
0457 8D 06 4F 75     lea  ax, [SymbolUpper]
045B 50              push ax
045C E8 01 FE        call eqstr
045F 83 C4 04        add  sp, 4
0462 08 C0           or  al, al
0464 0F 84 00 00   r je .testReg42
0468 B8 02 00        mov ax, 2
046B E9 00 00      R jmp .retntestReg
046E                
046E                ;-184   if (eqstr(SymbolUpper, "BX")) return 3;
046E                
046E                .testReg42:
046E 68 AA AA      A push testReg_11
0471 8D 06 4F 75     lea  ax, [SymbolUpper]
0475 50              push ax
0476 E8 E7 FD        call eqstr
0479 83 C4 04        add  sp, 4
047C 08 C0           or  al, al
047E 0F 84 00 00   r je .testReg43
0482 B8 03 00        mov ax, 3
0485 E9 00 00      R jmp .retntestReg
0488                
0488                ;-185   if (eqstr(SymbolUpper, "SP")) return 4;
0488                
0488                .testReg43:
0488 68 AA AA      A push testReg_12
048B 8D 06 4F 75     lea  ax, [SymbolUpper]
048F 50              push ax
0490 E8 CD FD        call eqstr
0493 83 C4 04        add  sp, 4
0496 08 C0           or  al, al
0498 0F 84 00 00   r je .testReg44
049C B8 04 00        mov ax, 4
049F E9 00 00      R jmp .retntestReg
04A2                
04A2                ;-186   if (eqstr(SymbolUpper, "BP")) return 5;
04A2                
04A2                .testReg44:
04A2 68 AA AA      A push testReg_13
04A5 8D 06 4F 75     lea  ax, [SymbolUpper]
04A9 50              push ax
04AA E8 B3 FD        call eqstr
04AD 83 C4 04        add  sp, 4
04B0 08 C0           or  al, al
04B2 0F 84 00 00   r je .testReg45
04B6 B8 05 00        mov ax, 5
04B9 E9 00 00      R jmp .retntestReg
04BC                
04BC                ;-187   if (eqstr(SymbolUpper, "SI")) return 6;
04BC                
04BC                .testReg45:
04BC 68 AA AA      A push testReg_14
04BF 8D 06 4F 75     lea  ax, [SymbolUpper]
04C3 50              push ax
04C4 E8 99 FD        call eqstr
04C7 83 C4 04        add  sp, 4
04CA 08 C0           or  al, al
04CC 0F 84 00 00   r je .testReg46
04D0 B8 06 00        mov ax, 6
04D3 E9 00 00      R jmp .retntestReg
04D6                
04D6                ;-188   if (eqstr(SymbolUpper, "DI")) return 7;
04D6                
04D6                .testReg46:
04D6 68 AA AA      A push testReg_15
04D9 8D 06 4F 75     lea  ax, [SymbolUpper]
04DD 50              push ax
04DE E8 7F FD        call eqstr
04E1 83 C4 04        add  sp, 4
04E4 08 C0           or  al, al
04E6 0F 84 00 00   r je .testReg47
04EA B8 07 00        mov ax, 7
04ED E9 00 00      R jmp .retntestReg
04F0                
04F0                ;-189   R2Type=SEGREG;
04F0                
04F0                .testReg47:
04F0 B8 04 00        mov ax, 4
04F3 A2 35 01        mov byte [R2Type], al
04F6                
04F6                ;-190   if (eqstr(SymbolUpper, "ES")) return 0;
04F6                
04F6 68 AA AA      A push testReg_16
04F9 8D 06 4F 75     lea  ax, [SymbolUpper]
04FD 50              push ax
04FE E8 5F FD        call eqstr
0501 83 C4 04        add  sp, 4
0504 08 C0           or  al, al
0506 0F 84 00 00   r je .testReg48
050A B8 00 00        mov ax, 0
050D E9 00 00      R jmp .retntestReg
0510                
0510                ;-191   if (eqstr(SymbolUpper, "CS")) return 1;
0510                
0510                .testReg48:
0510 68 AA AA      A push testReg_17
0513 8D 06 4F 75     lea  ax, [SymbolUpper]
0517 50              push ax
0518 E8 45 FD        call eqstr
051B 83 C4 04        add  sp, 4
051E 08 C0           or  al, al
0520 0F 84 00 00   r je .testReg49
0524 B8 01 00        mov ax, 1
0527 E9 00 00      R jmp .retntestReg
052A                
052A                ;-192   if (eqstr(SymbolUpper, "SS")) return 2;
052A                
052A                .testReg49:
052A 68 AA AA      A push testReg_18
052D 8D 06 4F 75     lea  ax, [SymbolUpper]
0531 50              push ax
0532 E8 2B FD        call eqstr
0535 83 C4 04        add  sp, 4
0538 08 C0           or  al, al
053A 0F 84 00 00   r je .testReg50
053E B8 02 00        mov ax, 2
0541 E9 00 00      R jmp .retntestReg
0544                
0544                ;-193   if (eqstr(SymbolUpper, "DS")) return 3;
0544                
0544                .testReg50:
0544 68 AA AA      A push testReg_19
0547 8D 06 4F 75     lea  ax, [SymbolUpper]
054B 50              push ax
054C E8 11 FD        call eqstr
054F 83 C4 04        add  sp, 4
0552 08 C0           or  al, al
0554 0F 84 00 00   r je .testReg51
0558 B8 03 00        mov ax, 3
055B E9 00 00      R jmp .retntestReg
055E                
055E                ;-194   if (eqstr(SymbolUpper, "FS")) return 4;
055E                
055E                .testReg51:
055E 68 AA AA      A push testReg_20
0561 8D 06 4F 75     lea  ax, [SymbolUpper]
0565 50              push ax
0566 E8 F7 FC        call eqstr
0569 83 C4 04        add  sp, 4
056C 08 C0           or  al, al
056E 0F 84 00 00   r je .testReg52
0572 B8 04 00        mov ax, 4
0575 E9 00 00      R jmp .retntestReg
0578                
0578                ;-195   if (eqstr(SymbolUpper, "GS")) return 5;
0578                
0578                .testReg52:
0578 68 AA AA      A push testReg_21
057B 8D 06 4F 75     lea  ax, [SymbolUpper]
057F 50              push ax
0580 E8 DD FC        call eqstr
0583 83 C4 04        add  sp, 4
0586 08 C0           or  al, al
0588 0F 84 00 00   r je .testReg53
058C B8 05 00        mov ax, 5
058F E9 00 00      R jmp .retntestReg
0592                
0592                ;-196   R2Type=DWORD;
0592                
0592                .testReg53:
0592 B8 03 00        mov ax, 3
0595 A2 35 01        mov byte [R2Type], al
0598                
0598                ;-197   if (eqstr(SymbolUpper, "EAX"))return 0;
0598                
0598 68 AA AA      A push testReg_22
059B 8D 06 4F 75     lea  ax, [SymbolUpper]
059F 50              push ax
05A0 E8 BD FC        call eqstr
05A3 83 C4 04        add  sp, 4
05A6 08 C0           or  al, al
05A8 0F 84 00 00   r je .testReg54
05AC B8 00 00        mov ax, 0
05AF E9 00 00      R jmp .retntestReg
05B2                
05B2                ;-198   if (eqstr(SymbolUpper, "ECX"))return 1;
05B2                
05B2                .testReg54:
05B2 68 AA AA      A push testReg_23
05B5 8D 06 4F 75     lea  ax, [SymbolUpper]
05B9 50              push ax
05BA E8 A3 FC        call eqstr
05BD 83 C4 04        add  sp, 4
05C0 08 C0           or  al, al
05C2 0F 84 00 00   r je .testReg55
05C6 B8 01 00        mov ax, 1
05C9 E9 00 00      R jmp .retntestReg
05CC                
05CC                ;-199   if (eqstr(SymbolUpper, "EDX"))return 2;
05CC                
05CC                .testReg55:
05CC 68 AA AA      A push testReg_24
05CF 8D 06 4F 75     lea  ax, [SymbolUpper]
05D3 50              push ax
05D4 E8 89 FC        call eqstr
05D7 83 C4 04        add  sp, 4
05DA 08 C0           or  al, al
05DC 0F 84 00 00   r je .testReg56
05E0 B8 02 00        mov ax, 2
05E3 E9 00 00      R jmp .retntestReg
05E6                
05E6                ;-200   if (eqstr(SymbolUpper, "EBX"))return 3;
05E6                
05E6                .testReg56:
05E6 68 AA AA      A push testReg_25
05E9 8D 06 4F 75     lea  ax, [SymbolUpper]
05ED 50              push ax
05EE E8 6F FC        call eqstr
05F1 83 C4 04        add  sp, 4
05F4 08 C0           or  al, al
05F6 0F 84 00 00   r je .testReg57
05FA B8 03 00        mov ax, 3
05FD E9 00 00      R jmp .retntestReg
0600                
0600                ;-201   if (eqstr(SymbolUpper, "ESP"))return 4;
0600                
0600                .testReg57:
0600 68 AA AA      A push testReg_26
0603 8D 06 4F 75     lea  ax, [SymbolUpper]
0607 50              push ax
0608 E8 55 FC        call eqstr
060B 83 C4 04        add  sp, 4
060E 08 C0           or  al, al
0610 0F 84 00 00   r je .testReg58
0614 B8 04 00        mov ax, 4
0617 E9 00 00      R jmp .retntestReg
061A                
061A                ;-202   if (eqstr(SymbolUpper, "EBP"))return 5;
061A                
061A                .testReg58:
061A 68 AA AA      A push testReg_27
061D 8D 06 4F 75     lea  ax, [SymbolUpper]
0621 50              push ax
0622 E8 3B FC        call eqstr
0625 83 C4 04        add  sp, 4
0628 08 C0           or  al, al
062A 0F 84 00 00   r je .testReg59
062E B8 05 00        mov ax, 5
0631 E9 00 00      R jmp .retntestReg
0634                
0634                ;-203   if (eqstr(SymbolUpper, "ESI"))return 6;
0634                
0634                .testReg59:
0634 68 AA AA      A push testReg_28
0637 8D 06 4F 75     lea  ax, [SymbolUpper]
063B 50              push ax
063C E8 21 FC        call eqstr
063F 83 C4 04        add  sp, 4
0642 08 C0           or  al, al
0644 0F 84 00 00   r je .testReg60
0648 B8 06 00        mov ax, 6
064B E9 00 00      R jmp .retntestReg
064E                
064E                ;-204   if (eqstr(SymbolUpper, "EDI"))return 7;
064E                
064E                .testReg60:
064E 68 AA AA      A push testReg_29
0651 8D 06 4F 75     lea  ax, [SymbolUpper]
0655 50              push ax
0656 E8 07 FC        call eqstr
0659 83 C4 04        add  sp, 4
065C 08 C0           or  al, al
065E 0F 84 00 00   r je .testReg61
0662 B8 07 00        mov ax, 7
0665 E9 00 00      R jmp .retntestReg
0668                
0668                ;-205   R2Type=0; return 0;
0668                
0668                .testReg61:
0668 B8 00 00        mov ax, 0
066B A2 35 01        mov byte [R2Type], al
066E B8 00 00        mov ax, 0
0671 E9 00 00      R jmp .retntestReg
0674                
0674                ;-206 }
0674                
0674                
0674                ;-207 
0674                
0674                
0674                ;-208 
0674                
0674                
0674                ;-209 int prc(unsigned char c) {//print char
0674                
0674                 .retntestReg:
0674 C3              ret
0675 41 4C 00       testReg_0 db "AL",0
0678 43 4C 00       testReg_1 db "CL",0
067B 44 4C 00       testReg_2 db "DL",0
067E 42 4C 00       testReg_3 db "BL",0
0681 41 48 00       testReg_4 db "AH",0
0684 43 48 00       testReg_5 db "CH",0
0687 44 48 00       testReg_6 db "DH",0
068A 42 48 00       testReg_7 db "BH",0
068D 41 58 00       testReg_8 db "AX",0
0690 43 58 00       testReg_9 db "CX",0
0693 44 58 00       testReg_10 db "DX",0
0696 42 58 00       testReg_11 db "BX",0
0699 53 50 00       testReg_12 db "SP",0
069C 42 50 00       testReg_13 db "BP",0
069F 53 49 00       testReg_14 db "SI",0
06A2 44 49 00       testReg_15 db "DI",0
06A5 45 53 00       testReg_16 db "ES",0
06A8 43 53 00       testReg_17 db "CS",0
06AB 53 53 00       testReg_18 db "SS",0
06AE 44 53 00       testReg_19 db "DS",0
06B1 46 53 00       testReg_20 db "FS",0
06B4 47 53 00       testReg_21 db "GS",0
06B7 45 41 58 00    testReg_22 db "EAX",0
06BB 45 43 58 00    testReg_23 db "ECX",0
06BF 45 44 58 00    testReg_24 db "EDX",0
06C3 45 42 58 00    testReg_25 db "EBX",0
06C7 45 53 50 00    testReg_26 db "ESP",0
06CB 45 42 50 00    testReg_27 db "EBP",0
06CF 45 53 49 00    testReg_28 db "ESI",0
06D3 45 44 49 00    testReg_29 db "EDI",0
leaving: testReg, loc labels: 63, loc jmp forward: 95
06D7                ENDP
06D7                
entering: prc
06D7                prc: PROC
06D7                
06D7                ;-210         if ( _ c==10) {
06D7                
06D7                ;Function : prc, Number of local variables: 1
06D7                ;   # type sign width addr used name   list of local variables
06D7                ;  200 var unsg byte   209 NULL c = bp+4;
06D7 C8 00 00 00     ENTER  0,0 ; constant expression
06DB 80 7E 04 0A    cmp byte[bp+4], 10
06DF 0F 85 00 00   r jne .prc62
06E3                
06E3                ;-211             ax=13;
06E3                
06E3 B8 0D 00        mov  ax, 13
06E6                
06E6                ;-212             writetty();
06E6                
06E6 E8 75 F9        call writetty
06E9                
06E9                ;-213             }
06E9                
06E9                
06E9                ;-214         al=c;
06E9                
06E9                .prc62:
06E9 8A 46 04        mov  al, [bp+4]
06EC                
06EC                ;-215         writetty();
06EC                
06EC E8 6F F9        call writetty
06EF                
06EF                ;-216     fputcR(c,lst_fd);
06EF                
06EF FF 36 18 01     push word [lst_fd]
06F3 8A 46 04        mov al, byte [bp+4]
06F6 B4 00           mov ah, 0
06F8 50              push ax
06F9 E8 0D FA        call fputcR
06FC 83 C4 04        add  sp, 4
06FF                
06FF                ;-217 }
06FF                
06FF                
06FF                ;-218 
06FF                
06FF                
06FF                ;-219 int prscomment(unsigned char *s) {
06FF C9              LEAVE
0700 C3              ret
leaving: prc, loc labels: 1, loc jmp forward: 1
0701                ENDP
0701                
entering: prscomment
0701                prscomment: PROC
0701                
0701                ;-220     unsigned char c;
0701                
0701                
0701                ;-221     while (*s){
0701                
0701                ;Function : prscomment, Number of local variables: 2
0701                ;   # type sign width addr used name   list of local variables
0701                ;  200 ptr unsg byte   219 NULL s = bp+4
0701                ;  201 var unsg byte   220 NULL c = bp-2;
0701 C8 02 00 00     ENTER  2,0
0705                .prscomment63:
0705 8B 5E 04        mov bx, [bp+4]
0708 8A 07           mov al, [bx]
070A B4 00           mov ah, 0
070C 08 C0           or  al, al
070E 0F 84 00 00   r je .prscomment64
0712                
0712                ;-222         c=*s;
0712                
0712 8B 5E 04        mov bx, [bp+4]
0715 8A 07           mov al, [bx]
0717 B4 00           mov ah, 0
0719 88 46 FE        mov [bp-2], al
071C                
071C                ;-223         prc(c);
071C                
071C 8A 46 FE        mov al, byte [bp-2]
071F B4 00           mov ah, 0
0721 50              push ax
0722 E8 B2 FF        call prc
0725 83 C4 02        add  sp, 2
0728                
0728                ;-224         s++;
0728                
0728 FF 46 04        inc  word[bp+4]
072B                
072B                ;-225     }
072B                
072B                
072B                ;-226 }
072B                
072B EB D8           jmp .prscomment63
072D                .prscomment64:
072D                
072D                ;-227 int prs(unsigned char *s) {
072D C9              LEAVE
072E C3              ret
leaving: prscomment, loc labels: 2, loc jmp forward: 1
072F                ENDP
072F                
entering: prs
072F                prs: PROC
072F                
072F                ;-228     unsigned char c;
072F                
072F                
072F                ;-229     int com;
072F                
072F                
072F                ;-230     com=0;
072F                
072F                ;Function : prs, Number of local variables: 3
072F                ;   # type sign width addr used name   list of local variables
072F                ;  200 ptr unsg byte   227 NULL s = bp+4
072F                ;  201 var unsg byte   228 NULL c = bp-2
072F                ;  202 var sign word   229 NULL com = bp-4;
072F C8 04 00 00     ENTER  4,0
0733 B8 00 00        mov ax, 0
0736 89 46 FC        mov [bp-4], ax
0739                
0739                ;-231     while (*s) {
0739                
0739                .prs65:
0739 8B 5E 04        mov bx, [bp+4]
073C 8A 07           mov al, [bx]
073E B4 00           mov ah, 0
0740 08 C0           or  al, al
0742 0F 84 00 00   r je .prs66
0746                
0746                ;-232         c=*s;
0746                
0746 8B 5E 04        mov bx, [bp+4]
0749 8A 07           mov al, [bx]
074B B4 00           mov ah, 0
074D 88 46 FE        mov [bp-2], al
0750                
0750                ;-233         if (c==34) {
0750                
0750 8A 46 FE        mov al, [bp-2]
0753 3C 22           cmp al, 34
0755 0F 85 00 00   r jne .prs67
0759                
0759                ;-234             if (com) com=0;
0759                
0759 8B 46 FC        mov ax, [bp-4]
075C 08 C0           or  al, al
075E 0F 84 00 00   r je .prs68
0762 B8 00 00        mov ax, 0
0765 89 46 FC        mov [bp-4], ax
0768                
0768                ;-235                 else com=1;
0768                
0768 E9 00 00      R jmp .prs69
076B                .prs68:
076B B8 01 00        mov ax, 1
076E 89 46 FC        mov [bp-4], ax
0771                
0771                ;-236         }
0771                
0771                .prs69:
0771                
0771                ;-237         if (c==92) {
0771                
0771                .prs67:
0771 8A 46 FE        mov al, [bp-2]
0774 3C 5C           cmp al, 92
0776 0F 85 00 00   r jne .prs70
077A                
077A                ;-238             if (com==0) {
077A                
077A 8B 46 FC        mov ax, [bp-4]
077D 83 F8 00        cmp ax, 0
0780 0F 85 00 00   r jne .prs71
0784                
0784                ;-239                 s++;
0784                
0784 FF 46 04        inc  word[bp+4]
0787                
0787                ;-240                 c=*s;
0787                
0787 8B 5E 04        mov bx, [bp+4]
078A 8A 07           mov al, [bx]
078C B4 00           mov ah, 0
078E 88 46 FE        mov [bp-2], al
0791                
0791                ;-241                 if (c=='n') c=10;
0791                
0791 8A 46 FE        mov al, [bp-2]
0794 3C 6E           cmp al, 110
0796 0F 85 00 00   r jne .prs72
079A B8 0A 00        mov ax, 10
079D 88 46 FE        mov [bp-2], al
07A0                
07A0                ;-242                 if (c=='t') c= 9;
07A0                
07A0                .prs72:
07A0 8A 46 FE        mov al, [bp-2]
07A3 3C 74           cmp al, 116
07A5 0F 85 00 00   r jne .prs73
07A9 B8 09 00        mov ax, 9
07AC 88 46 FE        mov [bp-2], al
07AF                
07AF                ;-243             }
07AF                
07AF                .prs73:
07AF                
07AF                ;-244         }
07AF                
07AF                .prs71:
07AF                
07AF                ;-245         prc(c);
07AF                
07AF                .prs70:
07AF 8A 46 FE        mov al, byte [bp-2]
07B2 B4 00           mov ah, 0
07B4 50              push ax
07B5 E8 1F FF        call prc
07B8 83 C4 02        add  sp, 2
07BB                
07BB                ;-246         s++;
07BB                
07BB FF 46 04        inc  word[bp+4]
07BE                
07BE                ;-247     }
07BE                
07BE                
07BE                ;-248 }
07BE                
07BE E9 78 FF        jmp .prs65
07C1                .prs66:
07C1                
07C1                ;-249 int printhex4(unsigned char c) {
07C1 C9              LEAVE
07C2 C3              ret
leaving: prs, loc labels: 9, loc jmp forward: 8
07C3                ENDP
07C3                
entering: printhex4
07C3                printhex4: PROC
07C3                
07C3                ;-250     c += 48;
07C3                
07C3                ;Function : printhex4, Number of local variables: 1
07C3                ;   # type sign width addr used name   list of local variables
07C3                ;  200 var unsg byte   249 NULL c = bp+4;
07C3 C8 00 00 00     ENTER  0,0
07C7 80 46 04 30     add  byte[bp+4], 48
07CB                
07CB                ;-251     if (c > 57) c += 7;
07CB                
07CB 8A 46 04        mov al, [bp+4]
07CE 3C 39           cmp al, 57
07D0 0F 8E 00 00   r jle .printhex474
07D4 80 46 04 07     add  byte[bp+4], 7
07D8                
07D8                ;-252     prc(c);
07D8                
07D8                .printhex474:
07D8 8A 46 04        mov al, byte [bp+4]
07DB B4 00           mov ah, 0
07DD 50              push ax
07DE E8 F6 FE        call prc
07E1 83 C4 02        add  sp, 2
07E4                
07E4                ;-253 }
07E4                
07E4                
07E4                ;-254 int printhex8a(unsigned char c) {
07E4 C9              LEAVE
07E5 C3              ret
leaving: printhex4, loc labels: 1, loc jmp forward: 1
07E6                ENDP
07E6                
entering: printhex8a
07E6                printhex8a: PROC
07E6                
07E6                ;-255     unsigned char nib;
07E6                
07E6                
07E6                ;-256     nib = c >> 4; printhex4(nib);
07E6                
07E6                ;Function : printhex8a, Number of local variables: 2
07E6                ;   # type sign width addr used name   list of local variables
07E6                ;  200 var unsg byte   254 NULL c = bp+4
07E6                ;  201 var unsg byte   255 NULL nib = bp-2;
07E6 C8 02 00 00     ENTER  2,0
07EA 8A 46 04        mov al, [bp+4]
07ED C0 E8 04        shr al, 4
07F0 88 46 FE        mov [bp-2], al
07F3 8A 46 FE        mov al, byte [bp-2]
07F6 B4 00           mov ah, 0
07F8 50              push ax
07F9 E8 C7 FF        call printhex4
07FC 83 C4 02        add  sp, 2
07FF                
07FF                ;-257     nib = c & 15; printhex4(nib);
07FF                
07FF 8A 46 04        mov al, [bp+4]
0802 24 0F           and al, 15
0804 88 46 FE        mov [bp-2], al
0807 8A 46 FE        mov al, byte [bp-2]
080A B4 00           mov ah, 0
080C 50              push ax
080D E8 B3 FF        call printhex4
0810 83 C4 02        add  sp, 2
0813                
0813                ;-258 }
0813                
0813                
0813                ;-259 int printhex16(unsigned int i) {
0813 C9              LEAVE
0814 C3              ret
leaving: printhex8a, loc labels: 0, loc jmp forward: 0
0815                ENDP
0815                
entering: printhex16
0815                printhex16: PROC
0815                
0815                ;-260     unsigned int half;
0815                
0815                
0815                ;-261     half = i >>  8; printhex8a(half);
0815                
0815                ;Function : printhex16, Number of local variables: 2
0815                ;   # type sign width addr used name   list of local variables
0815                ;  200 var unsg word   259 NULL i = bp+4
0815                ;  201 var unsg word   260 NULL half = bp-2;
0815 C8 02 00 00     ENTER  2,0
0819 8B 46 04        mov ax, [bp+4]
081C C1 E8 08        shr ax, 8
081F 89 46 FE        mov [bp-2], ax
0822 55              push word [bp-2]
0823 E8 C0 FF        call printhex8a
0826 83 C4 02        add  sp, 2
0829                
0829                ;-262     half = i & 255; printhex8a(half);
0829                
0829 8B 46 04        mov ax, [bp+4]
082C 25 FF 00        and ax, 255
082F 89 46 FE        mov [bp-2], ax
0832 55              push word [bp-2]
0833 E8 B0 FF        call printhex8a
0836 83 C4 02        add  sp, 2
0839                
0839                ;-263 }
0839                
0839                
0839                ;-264 int printIntU(unsigned int n) {
0839 C9              LEAVE
083A C3              ret
leaving: printhex16, loc labels: 0, loc jmp forward: 0
083B                ENDP
083B                
entering: printIntU
083B                printIntU: PROC
083B                
083B                ;-265     unsigned int e;
083B                
083B                
083B                ;-266     if ( _ n >= 10) {
083B                
083B                ;Function : printIntU, Number of local variables: 2
083B                ;   # type sign width addr used name   list of local variables
083B                ;  200 var unsg word   264 NULL n = bp+4
083B                ;  201 var unsg word   265 NULL e = bp-2;
083B C8 02 00 00     ENTER  2,0 ; constant expression
083F 83 7E 04 0A    cmp word[bp+4], 10 ;unsigned : 0
0843 0F 82 00 00   r jb  .printIntU75
0847                
0847                ;-267         e=n/10; //DIV
0847                
0847 8B 46 04        mov ax, [bp+4]
084A BB 0A 00        mov bx, 10
084D BA 00 00        mov dx, 0
0850 F7 F3           div bx
0852 89 46 FE        mov [bp-2], ax
0855                
0855                ;-268         printIntU(e);
0855                
0855 55              push word [bp-2]
0856 E8 E2 FF        call printIntU
0859 83 C4 02        add  sp, 2
085C                
085C                ;-269     }
085C                
085C                
085C                ;-270     n = n % 10; //unsigned mod
085C                
085C                .printIntU75:
085C 8B 46 04        mov ax, [bp+4]
085F BB 0A 00        mov bx, 10
0862 BA 00 00        mov dx, 0
0865 F7 F3           div bx
0867 89 D0           mov ax, dx
0869 89 46 04        mov [bp+4], ax
086C                
086C                ;-271     n += '0';
086C                
086C 83 46 04 30     add  word[bp+4], 48
0870                
0870                ;-272     prc(n);
0870                
0870 55              push word [bp+4]
0871 E8 63 FE        call prc
0874 83 C4 02        add  sp, 2
0877                
0877                ;-273 }
0877                
0877                
0877                ;-274 int printLine() {
0877 C9              LEAVE
0878 C3              ret
leaving: printIntU, loc labels: 1, loc jmp forward: 1
0879                ENDP
0879                
entering: printLine
0879                printLine: PROC
0879                
0879                ;-275     int i; char c;
0879                
0879                
0879                ;-276     prs("\n");
0879                
0879                ;Function : printLine, Number of local variables: 2
0879                ;   # type sign width addr used name   list of local variables
0879                ;  200 var sign word   275 NULL i = bp-2
0879                ;  201 var sign byte   275 NULL c = bp-4;
0879 C8 04 00 00     ENTER  4,0
087D 68 AA AA      A push printLine_0
0880 E8 AC FE        call prs
0883 83 C4 02        add  sp, 2
0886                
0886                ;-277     printhex16(PCStart);
0886                
0886 FF 36 29 01     push word [PCStart]
088A E8 88 FF        call printhex16
088D 83 C4 02        add  sp, 2
0890                
0890                ;-278     if (OpPrintIndex == 0) prs("               ");
0890                
0890 A1 41 01        mov ax, [OpPrintIndex]
0893 83 F8 00        cmp ax, 0
0896 0F 85 00 00   r jne .printLine76
089A 68 AA AA      A push printLine_1
089D E8 8F FE        call prs
08A0 83 C4 02        add  sp, 2
08A3                
08A3                ;-279     else {
08A3                
08A3 E9 00 00      R jmp .printLine77
08A6                .printLine76:
08A6                
08A6                ;-280 //        prc(' ');
08A6                
08A6                
08A6                ;-281         i=0;
08A6                
08A6 B8 00 00        mov ax, 0
08A9 89 46 FE        mov [bp-2], ax
08AC                
08AC                ;-282         do {
08AC                
08AC                .printLine78:
08AC                
08AC                ;-283             c=OpPos[i];
08AC                
08AC 8B 5E FE        mov bx, [bp-2]
08AF 8A 87 55 77     mov al, [OpPos + bx]
08B3 88 46 FC        mov [bp-4], al
08B6                
08B6                ;-284             prc(' ');
08B6                
08B6 6A 20           push 32
08B8 E8 1C FE        call prc
08BB 83 C4 02        add  sp, 2
08BE                
08BE                ;-285             printhex8a(c);
08BE                
08BE 8A 46 FC        mov al, byte [bp-4]
08C1 B4 00           mov ah, 0
08C3 50              push ax
08C4 E8 1F FF        call printhex8a
08C7 83 C4 02        add  sp, 2
08CA                
08CA                ;-286             i++;
08CA                
08CA FF 46 FE        inc  word[bp-2]
08CD                
08CD                ;-287         } while (i < OpPrintIndex);
08CD                
08CD 8B 46 FE        mov ax, [bp-2]
08D0 3B 06 41 01     cmp ax, [OpPrintIndex]
08D4 0F 8D 00 00   r jge .printLine79
08D8 EB D2           jmp .printLine78
08DA                .printLine79:
08DA                
08DA                ;-288         while (i < OPMAXLEN) {// fill rest with blank
08DA                
08DA                .printLine80:
08DA 8B 46 FE        mov ax, [bp-2]
08DD 83 F8 05        cmp ax, 5
08E0 0F 8D 00 00   r jge .printLine81
08E4                
08E4                ;-289             prs("   ");
08E4                
08E4 68 AA AA      A push printLine_2
08E7 E8 45 FE        call prs
08EA 83 C4 02        add  sp, 2
08ED                
08ED                ;-290             i++;
08ED                
08ED FF 46 FE        inc  word[bp-2]
08F0                
08F0                ;-291         }
08F0                
08F0                
08F0                ;-292     }
08F0                
08F0 EB E8           jmp .printLine80
08F2                .printLine81:
08F2                
08F2                ;-293     prc(PrintRA);
08F2                
08F2                .printLine77:
08F2 A0 45 01        mov al, byte [PrintRA]
08F5 B4 00           mov ah, 0
08F7 50              push ax
08F8 E8 DC FD        call prc
08FB 83 C4 02        add  sp, 2
08FE                
08FE                ;-294     prscomment(InputBuf);
08FE                
08FE 8D 06 8D 75     lea  ax, [InputBuf]
0902 50              push ax
0903 E8 FB FD        call prscomment
0906 83 C4 02        add  sp, 2
0909                
0909                ;-295 }
0909                
0909                
0909                ;-296 
0909                
0909                
0909                ;-297 int epilog() {
0909 C9              LEAVE
090A C3              ret
090B 5C 6E 00       printLine_0 db "\n",0
090E 20 20 20 20 20 printLine_1 db "               ",0
091E 20 20 20 00    printLine_2 db "   ",0
leaving: printLine, loc labels: 9, loc jmp forward: 7
0922                ENDP
0922                
entering: epilog
0922                epilog: PROC
0922                
0922                ;-298     unsigned int i; char c;     int j;
0922                
0922                
0922                ;-299     prs("\n Errors: ");
0922                
0922                ;Function : epilog, Number of local variables: 3
0922                ;   # type sign width addr used name   list of local variables
0922                ;  200 var unsg word   298 NULL i = bp-2
0922                ;  201 var sign byte   298 NULL c = bp-4
0922                ;  202 var sign word   298 NULL j = bp-6;
0922 C8 06 00 00     ENTER  6,0
0926 68 AA AA      A push epilog_0
0929 E8 03 FE        call prs
092C 83 C4 02        add  sp, 2
092F                
092F                ;-300     printIntU(ErrorCount);
092F                
092F FF 36 1E 01     push word [ErrorCount]
0933 E8 05 FF        call printIntU
0936 83 C4 02        add  sp, 2
0939                
0939                ;-301     if (ErrorCount) prs(" *** ERRORS *** ");
0939                
0939 A1 1E 01        mov ax, [ErrorCount]
093C 08 C0           or  al, al
093E 0F 84 00 00   r je .epilog82
0942 68 AA AA      A push epilog_1
0945 E8 E7 FD        call prs
0948 83 C4 02        add  sp, 2
094B                
094B                ;-302     prs(", Out: ");
094B                
094B                .epilog82:
094B 68 AA AA      A push epilog_2
094E E8 DE FD        call prs
0951 83 C4 02        add  sp, 2
0954                
0954                ;-303     prs(namelst);
0954                
0954 8D 06 CF 76     lea  ax, [namelst]
0958 50              push ax
0959 E8 D3 FD        call prs
095C 83 C4 02        add  sp, 2
095F                
095F                ;-304     prs(", ");
095F                
095F 68 AA AA      A push epilog_3
0962 E8 CA FD        call prs
0965 83 C4 02        add  sp, 2
0968                
0968                ;-305     prs(namebin);
0968                
0968 8D 06 12 77     lea  ax, [namebin]
096C 50              push ax
096D E8 BF FD        call prs
0970 83 C4 02        add  sp, 2
0973                
0973                ;-306     prs("= ");
0973                
0973 68 AA AA      A push epilog_4
0976 E8 B6 FD        call prs
0979 83 C4 02        add  sp, 2
097C                
097C                ;-307     printIntU(BinLen);
097C                
097C FF 36 58 01     push word [BinLen]
0980 E8 B8 FE        call printIntU
0983 83 C4 02        add  sp, 2
0986                
0986                ;-308     prs(" bytes.");
0986                
0986 68 AA AA      A push epilog_5
0989 E8 A3 FD        call prs
098C 83 C4 02        add  sp, 2
098F                
098F                ;-309     prs(" Labels: ");
098F                
098F 68 AA AA      A push epilog_6
0992 E8 9A FD        call prs
0995 83 C4 02        add  sp, 2
0998                
0998                ;-310     printIntU(LabelMaxIx);
0998                
0998 FF 36 4A 01     push word [LabelMaxIx]
099C E8 9C FE        call printIntU
099F 83 C4 02        add  sp, 2
09A2                
09A2                ;-311 // prs(", code:\n ");//debug
09A2                
09A2                
09A2                ;-312 
09A2                
09A2                
09A2                ;-313     i=0;
09A2                
09A2 B8 00 00        mov ax, 0
09A5 89 46 FE        mov [bp-2], ax
09A8                
09A8                ;-314     do {
09A8                
09A8                .epilog83:
09A8                
09A8                ;-315         c = FileBin[i];
09A8                
09A8 8B 5E FE        mov bx, [bp-2]
09AB 8A 47 AA        mov al, [FileBin + bx]
09AE 88 46 FC        mov [bp-4], al
09B1                
09B1                ;-316         fputcR(c, bin_fd);
09B1                
09B1 FF 36 1A 01     push word [bin_fd]
09B5 8A 46 FC        mov al, byte [bp-4]
09B8 B4 00           mov ah, 0
09BA 50              push ax
09BB E8 4B F7        call fputcR
09BE 83 C4 04        add  sp, 4
09C1                
09C1                ;-317 // printhex8a(c); prc(' ');//debug
09C1                
09C1                
09C1                ;-318         i++;
09C1                
09C1 FF 46 FE        inc  word[bp-2]
09C4                
09C4                ;-319     } while (i < BinLen);
09C4                
09C4 8B 46 FE        mov ax, [bp-2]
09C7 3B 06 58 01     cmp ax, [BinLen]
09CB 0F 8D 00 00   r jge .epilog84
09CF EB D7           jmp .epilog83
09D1                .epilog84:
09D1                
09D1                ;-320 
09D1                
09D1                
09D1                ;-321 /* 
09D1                
09D1                
09D1                ;-322   prs("\n\n LabelNamePtr:"); printIntU(LabelNamePtr);
09D1                
09D1                
09D1                ;-323   i= &LabelNames;
09D1                
09D1                
09D1                ;-324   prs(" &LabelNames:"); printIntU(i);
09D1                
09D1                
09D1                ;-325   i=LabelNamePtr-i;
09D1                
09D1                
09D1                ;-326   prs(", size: ");
09D1                
09D1                
09D1                ;-327   printIntU(i);
09D1                
09D1                
09D1                ;-328   prs(".\n >>");
09D1                
09D1                
09D1                ;-329   i= &LabelNames;
09D1                
09D1                
09D1                ;-330   do { c=*i; if (c==0) c=' '; prc(c); i++;
09D1                
09D1                
09D1                ;-331   } while (i < LabelNamePtr); prs("<< \n");
09D1                
09D1                
09D1                ;-332    i = 1;
09D1                
09D1                
09D1                ;-333     LabelNamePtr= &LabelNames;
09D1                
09D1                
09D1                ;-334     do {
09D1                
09D1                
09D1                ;-335       prs(LabelNamePtr); prc(' ');
09D1                
09D1                
09D1                ;-336       j=LabelAddr[i]; printhex16(j); prs(", ");
09D1                
09D1                
09D1                ;-337       j=strlen(LabelNamePtr);//get end of actual name
09D1                
09D1                
09D1                ;-338       LabelNamePtr=LabelNamePtr+j;
09D1                
09D1                
09D1                ;-339       LabelNamePtr++;
09D1                
09D1                
09D1                ;-340       i++;
09D1                
09D1                
09D1                ;-341     } while (i <= LabelMaxIx);
09D1                
09D1                
09D1                ;-342 */
09D1                
09D1                
09D1                ;-343 }
09D1                
09D1                
09D1                ;-344 
09D1                
09D1                
09D1                ;-345 int end1(int n) {
09D1 C9              LEAVE
09D2 C3              ret
09D3 5C 6E 20 45 72 epilog_0 db "\n Errors: ",0
09DF 20 2A 2A 2A 20 epilog_1 db " *** ERRORS *** ",0
09F0 2C 20 4F 75 74 epilog_2 db ", Out: ",0
09F8 2C 20 00       epilog_3 db ", ",0
09FB 3D 20 00       epilog_4 db "= ",0
09FE 20 62 79 74 65 epilog_5 db " bytes.",0
0A06 20 4C 61 62 65 epilog_6 db " Labels: ",0
leaving: epilog, loc labels: 10, loc jmp forward: 9
0A10                ENDP
0A10                
entering: end1
0A10                end1: PROC
0A10                
0A10                ;-346     fcloseR(asm_fd);
0A10                
0A10                ;Function : end1, Number of local variables: 1
0A10                ;   # type sign width addr used name   list of local variables
0A10                ;  200 var sign word   345 NULL n = bp+4;
0A10 C8 00 00 00     ENTER  0,0
0A14 FF 36 16 01     push word [asm_fd]
0A18 E8 BC F6        call fcloseR
0A1B 83 C4 02        add  sp, 2
0A1E                
0A1E                ;-347     fcloseR(lst_fd);
0A1E                
0A1E FF 36 18 01     push word [lst_fd]
0A22 E8 B2 F6        call fcloseR
0A25 83 C4 02        add  sp, 2
0A28                
0A28                ;-348     fcloseR(bin_fd);
0A28                
0A28 FF 36 1A 01     push word [bin_fd]
0A2C E8 A8 F6        call fcloseR
0A2F 83 C4 02        add  sp, 2
0A32                
0A32                ;-349     exitR(n);
0A32                
0A32 55              push word [bp+4]
0A33 E8 B0 F6        call exitR
0A36 83 C4 02        add  sp, 2
0A39                
0A39                ;-350 }
0A39                
0A39                
0A39                ;-351 
0A39                
0A39                
0A39                ;-352 
0A39                
0A39                
0A39                ;-353 int error1(char *s) {
0A39 C9              LEAVE
0A3A C3              ret
leaving: end1, loc labels: 0, loc jmp forward: 0
0A3B                ENDP
0A3B                
entering: error1
0A3B                error1: PROC
0A3B                
0A3B                ;-354     ErrorCount++;
0A3B                
0A3B                ;Function : error1, Number of local variables: 1
0A3B                ;   # type sign width addr used name   list of local variables
0A3B                ;  200 ptr sign byte   353 NULL s = bp+4;
0A3B C8 00 00 00     ENTER  0,0
0A3F FF 06 1E 01     inc  word[ErrorCount]
0A43                
0A43                ;-355     prs("\n******* next line ERROR: ");
0A43                
0A43 68 AA AA      A push error1_0
0A46 E8 E6 FC        call prs
0A49 83 C4 02        add  sp, 2
0A4C                
0A4C                ;-356     prs(s);
0A4C                
0A4C 55              push word [bp+4]
0A4D E8 DF FC        call prs
0A50 83 C4 02        add  sp, 2
0A53                
0A53                ;-357     prs(", Symbol: ");
0A53                
0A53 68 AA AA      A push error1_1
0A56 E8 D6 FC        call prs
0A59 83 C4 02        add  sp, 2
0A5C                
0A5C                ;-358     prs(Symbol);
0A5C                
0A5C 8D 06 30 75     lea  ax, [Symbol]
0A60 50              push ax
0A61 E8 CB FC        call prs
0A64 83 C4 02        add  sp, 2
0A67                
0A67                ;-359 }
0A67                
0A67                
0A67                ;-360 int errorexit(char *s) {
0A67 C9              LEAVE
0A68 C3              ret
0A69 5C 6E 2A 2A 2A error1_0 db "\n******* next line ERROR: ",0
0A85 2C 20 53 79 6D error1_1 db ", Symbol: ",0
leaving: error1, loc labels: 2, loc jmp forward: 2
0A90                ENDP
0A90                
entering: errorexit
0A90                errorexit: PROC
0A90                
0A90                ;-361     error1(s);
0A90                
0A90                ;Function : errorexit, Number of local variables: 1
0A90                ;   # type sign width addr used name   list of local variables
0A90                ;  200 ptr sign byte   360 NULL s = bp+4;
0A90 C8 00 00 00     ENTER  0,0
0A94 55              push word [bp+4]
0A95 E8 A3 FF        call error1
0A98 83 C4 02        add  sp, 2
0A9B                
0A9B                ;-362     epilog();
0A9B                
0A9B E8 84 FE        call epilog
0A9E                
0A9E                ;-363     end1(1);
0A9E                
0A9E 6A 01           push 1
0AA0 E8 6D FF        call end1
0AA3 83 C4 02        add  sp, 2
0AA6                
0AA6                ;-364 }
0AA6                
0AA6                
0AA6                ;-365 int notfounderror(){
0AA6 C9              LEAVE
0AA7 C3              ret
leaving: errorexit, loc labels: 0, loc jmp forward: 0
0AA8                ENDP
0AA8                
entering: notfounderror
0AA8                notfounderror: PROC
0AA8                
0AA8                ;-366     ErrorCount++;
0AA8                
0AA8 FF 06 1E 01     inc  word[ErrorCount]
0AAC                
0AAC                ;-367     prs("\n******* ERROR: label not found: ");
0AAC                
0AAC 68 AA AA      A push notfounderror_0
0AAF E8 7D FC        call prs
0AB2 83 C4 02        add  sp, 2
0AB5                
0AB5                ;-368     prs(Symbol);
0AB5                
0AB5 8D 06 30 75     lea  ax, [Symbol]
0AB9 50              push ax
0ABA E8 72 FC        call prs
0ABD 83 C4 02        add  sp, 2
0AC0                
0AC0                ;-369     prs(" ");
0AC0                
0AC0 68 AA AA      A push notfounderror_1
0AC3 E8 69 FC        call prs
0AC6 83 C4 02        add  sp, 2
0AC9                
0AC9                ;-370 }
0AC9                
0AC9                
0AC9                ;-371 int allowederror() {error1("not allowed here"); }
0AC9                
0AC9 C3              ret
0ACA 5C 6E 2A 2A 2A notfounderror_0 db "\n******* ERROR: label not found: ",0
0AED 20 00          notfounderror_1 db " ",0
leaving: notfounderror, loc labels: 2, loc jmp forward: 2
0AEF                ENDP
0AEF                
entering: allowederror
0AEF                allowederror: PROC
0AEF 68 AA AA      A push allowederror_0
0AF2 E8 46 FF        call error1
0AF5 83 C4 02        add  sp, 2
0AF8                
0AF8                ;-372 int addrerror()    {error1("address missing");}
0AF8                
0AF8 C3              ret
0AF9 6E 6F 74 20 61 allowederror_0 db "not allowed here",0
leaving: allowederror, loc labels: 1, loc jmp forward: 1
0B0A                ENDP
0B0A                
entering: addrerror
0B0A                addrerror: PROC
0B0A 68 AA AA      A push addrerror_0
0B0D E8 2B FF        call error1
0B10 83 C4 02        add  sp, 2
0B13                
0B13                ;-373 int immeerror()    {error1("immediate not allowed here");}
0B13                
0B13 C3              ret
0B14 61 64 64 72 65 addrerror_0 db "address missing",0
leaving: addrerror, loc labels: 1, loc jmp forward: 1
0B24                ENDP
0B24                
entering: immeerror
0B24                immeerror: PROC
0B24 68 AA AA      A push immeerror_0
0B27 E8 11 FF        call error1
0B2A 83 C4 02        add  sp, 2
0B2D                
0B2D                ;-374 int implerror()    {error1("not implemented");}
0B2D                
0B2D C3              ret
0B2E 69 6D 6D 65 64 immeerror_0 db "immediate not allowed here",0
leaving: immeerror, loc labels: 1, loc jmp forward: 1
0B49                ENDP
0B49                
entering: implerror
0B49                implerror: PROC
0B49 68 AA AA      A push implerror_0
0B4C E8 EC FE        call error1
0B4F 83 C4 02        add  sp, 2
0B52                
0B52                ;-375 int indexerror()   {error1("invalid index register");}
0B52                
0B52 C3              ret
0B53 6E 6F 74 20 69 implerror_0 db "not implemented",0
leaving: implerror, loc labels: 1, loc jmp forward: 1
0B63                ENDP
0B63                
entering: indexerror
0B63                indexerror: PROC
0B63 68 AA AA      A push indexerror_0
0B66 E8 D2 FE        call error1
0B69 83 C4 02        add  sp, 2
0B6C                
0B6C                ;-376 int invaloperror() {error1("invalid or no operands");}
0B6C                
0B6C C3              ret
0B6D 69 6E 76 61 6C indexerror_0 db "invalid index register",0
leaving: indexerror, loc labels: 1, loc jmp forward: 1
0B84                ENDP
0B84                
entering: invaloperror
0B84                invaloperror: PROC
0B84 68 AA AA      A push invaloperror_0
0B87 E8 B1 FE        call error1
0B8A 83 C4 02        add  sp, 2
0B8D                
0B8D                ;-377 int numbererror()  {error1("number expected");}
0B8D                
0B8D C3              ret
0B8E 69 6E 76 61 6C invaloperror_0 db "invalid or no operands",0
leaving: invaloperror, loc labels: 1, loc jmp forward: 1
0BA5                ENDP
0BA5                
entering: numbererror
0BA5                numbererror: PROC
0BA5 68 AA AA      A push numbererror_0
0BA8 E8 90 FE        call error1
0BAB 83 C4 02        add  sp, 2
0BAE                
0BAE                ;-378 int regmemerror()  {error1("only register or memory allowed");}
0BAE                
0BAE C3              ret
0BAF 6E 75 6D 62 65 numbererror_0 db "number expected",0
leaving: numbererror, loc labels: 1, loc jmp forward: 1
0BBF                ENDP
0BBF                
entering: regmemerror
0BBF                regmemerror: PROC
0BBF 68 AA AA      A push regmemerror_0
0BC2 E8 76 FE        call error1
0BC5 83 C4 02        add  sp, 2
0BC8                
0BC8                ;-379 int reg16error()   {error1("only reg16, no segreg allowed");}
0BC8                
0BC8 C3              ret
0BC9 6F 6E 6C 79 20 regmemerror_0 db "only register or memory allowed",0
leaving: regmemerror, loc labels: 1, loc jmp forward: 1
0BE9                ENDP
0BE9                
entering: reg16error
0BE9                reg16error: PROC
0BE9 68 AA AA      A push reg16error_0
0BEC E8 4C FE        call error1
0BEF 83 C4 02        add  sp, 2
0BF2                
0BF2                ;-380 int segregerror()  {error1("segment register not allowed");}
0BF2                
0BF2 C3              ret
0BF3 6F 6E 6C 79 20 reg16error_0 db "only reg16, no segreg allowed",0
leaving: reg16error, loc labels: 1, loc jmp forward: 1
0C11                ENDP
0C11                
entering: segregerror
0C11                segregerror: PROC
0C11 68 AA AA      A push segregerror_0
0C14 E8 24 FE        call error1
0C17 83 C4 02        add  sp, 2
0C1A                
0C1A                ;-381 int syntaxerror()  {error1("syntax");}
0C1A                
0C1A C3              ret
0C1B 73 65 67 6D 65 segregerror_0 db "segment register not allowed",0
leaving: segregerror, loc labels: 1, loc jmp forward: 1
0C38                ENDP
0C38                
entering: syntaxerror
0C38                syntaxerror: PROC
0C38 68 AA AA      A push syntaxerror_0
0C3B E8 FD FD        call error1
0C3E 83 C4 02        add  sp, 2
0C41                
0C41                ;-382 
0C41                
0C41                
0C41                ;-383 int addrexit()     {errorexit("illegal address");}
0C41                
0C41 C3              ret
0C42 73 79 6E 74 61 syntaxerror_0 db "syntax",0
leaving: syntaxerror, loc labels: 1, loc jmp forward: 1
0C49                ENDP
0C49                
entering: addrexit
0C49                addrexit: PROC
0C49 68 AA AA      A push addrexit_0
0C4C E8 41 FE        call errorexit
0C4F 83 C4 02        add  sp, 2
0C52                
0C52                ;-384 int dataexit()     {errorexit("DB,DW,DD or RESB,W,D expected");}
0C52                
0C52 C3              ret
0C53 69 6C 6C 65 67 addrexit_0 db "illegal address",0
leaving: addrexit, loc labels: 1, loc jmp forward: 1
0C63                ENDP
0C63                
entering: dataexit
0C63                dataexit: PROC
0C63 68 AA AA      A push dataexit_0
0C66 E8 27 FE        call errorexit
0C69 83 C4 02        add  sp, 2
0C6C                
0C6C                ;-385 int internexit()   {errorexit("intern compiler error");}
0C6C                
0C6C C3              ret
0C6D 44 42 2C 44 57 dataexit_0 db "DB,DW,DD or RESB,W,D expected",0
leaving: dataexit, loc labels: 1, loc jmp forward: 1
0C8B                ENDP
0C8B                
entering: internexit
0C8B                internexit: PROC
0C8B 68 AA AA      A push internexit_0
0C8E E8 FF FD        call errorexit
0C91 83 C4 02        add  sp, 2
0C94                
0C94                ;-386 
0C94                
0C94                
0C94                ;-387 int ifEOL(char c) {//unix LF, win CRLF= 13/10, mac CR
0C94                
0C94 C3              ret
0C95 69 6E 74 65 72 internexit_0 db "intern compiler error",0
leaving: internexit, loc labels: 1, loc jmp forward: 1
0CAB                ENDP
0CAB                
entering: ifEOL
0CAB                ifEOL: PROC
0CAB                
0CAB                ;-388   if (c == 10) return 1;//LF
0CAB                
0CAB                ;Function : ifEOL, Number of local variables: 1
0CAB                ;   # type sign width addr used name   list of local variables
0CAB                ;  200 var sign byte   387 NULL c = bp+4;
0CAB C8 00 00 00     ENTER  0,0
0CAF 8A 46 04        mov al, [bp+4]
0CB2 3C 0A           cmp al, 10
0CB4 0F 85 00 00   r jne .ifEOL85
0CB8 B8 01 00        mov ax, 1
0CBB E9 00 00      R jmp .retnifEOL
0CBE                
0CBE                ;-389   if (c == 13) {//CR
0CBE                
0CBE                .ifEOL85:
0CBE 8A 46 04        mov al, [bp+4]
0CC1 3C 0D           cmp al, 13
0CC3 0F 85 00 00   r jne .ifEOL86
0CC7                
0CC7                ;-390     DOS_NoBytes=readRL(&DOS_ByteRead, asm_fd, 1);
0CC7                
0CC7 6A 01           push 1
0CC9 FF 36 16 01     push word [asm_fd]
0CCD 8D 06 22 01     lea  ax, [DOS_ByteRead]
0CD1 50              push ax
0CD2 E8 1F F4        call readRL
0CD5 83 C4 06        add  sp, 6
0CD8 A3 20 01        mov word [DOS_NoBytes], ax
0CDB                
0CDB                ;-391     if (DOS_ByteRead != 10) errorexit("missing LF(10) after CR(13)");
0CDB                
0CDB A0 22 01        mov al, [DOS_ByteRead]
0CDE 3C 0A           cmp al, 10
0CE0 0F 84 00 00   r je  .ifEOL87
0CE4 68 AA AA      A push ifEOL_0
0CE7 E8 A6 FD        call errorexit
0CEA 83 C4 02        add  sp, 2
0CED                
0CED                ;-392     return 1;
0CED                
0CED                .ifEOL87:
0CED B8 01 00        mov ax, 1
0CF0 E9 00 00      R jmp .retnifEOL
0CF3                
0CF3                ;-393   }
0CF3                
0CF3                
0CF3                ;-394   return 0;
0CF3                
0CF3                .ifEOL86:
0CF3 B8 00 00        mov ax, 0
0CF6 E9 00 00      R jmp .retnifEOL
0CF9                
0CF9                ;-395 }
0CF9                
0CF9                
0CF9                ;-396 int getLine() {// make ASCIIZ, skip LF=10 and CR=13
0CF9                
0CF9 C9              .retnifEOL: LEAVE
0CFA C3              ret
0CFB 6D 69 73 73 69 ifEOL_0 db "missing LF(10) after CR(13)",0
leaving: ifEOL, loc labels: 5, loc jmp forward: 7
0D17                ENDP
0D17                
entering: getLine
0D17                getLine: PROC
0D17                
0D17                ;-397   unsigned int i;
0D17                
0D17                
0D17                ;-398   InputPtr= &InputBuf;
0D17                
0D17                ;Function : getLine, Number of local variables: 1
0D17                ;   # type sign width addr used name   list of local variables
0D17                ;  200 var unsg word   397 NULL i = bp-2;
0D17 C8 02 00 00     ENTER  2,0
0D1B B8 8D 75        mov ax, InputBuf
0D1E A3 14 01        mov word [InputPtr], ax
0D21                
0D21                ;-399   *InputPtr=0;//if last line is empty
0D21                
0D21 B8 00 00        mov ax, 0
0D24 8B 1E 14 01     mov  bx, [InputPtr]
0D28 88 07           mov  [bx], al
0D2A                
0D2A                ;-400   do {
0D2A                
0D2A                .getLine88:
0D2A                
0D2A                ;-401     DOS_NoBytes=readRL(&DOS_ByteRead, asm_fd, 1);
0D2A                
0D2A 6A 01           push 1
0D2C FF 36 16 01     push word [asm_fd]
0D30 8D 06 22 01     lea  ax, [DOS_ByteRead]
0D34 50              push ax
0D35 E8 BC F3        call readRL
0D38 83 C4 06        add  sp, 6
0D3B A3 20 01        mov word [DOS_NoBytes], ax
0D3E                
0D3E                ;-402     if (DOS_ERR) errorexit("Reading Source");
0D3E                
0D3E A1 1C 01        mov ax, [DOS_ERR]
0D41 08 C0           or  al, al
0D43 0F 84 00 00   r je .getLine89
0D47 68 AA AA      A push getLine_0
0D4A E8 43 FD        call errorexit
0D4D 83 C4 02        add  sp, 2
0D50                
0D50                ;-403     if (DOS_NoBytes == 0) return;
0D50                
0D50                .getLine89:
0D50 A1 20 01        mov ax, [DOS_NoBytes]
0D53 83 F8 00        cmp ax, 0
0D56 0F 85 00 00   r jne .getLine90
0D5A E9 00 00      R jmp .retngetLine
0D5D                
0D5D                ;-404     *InputPtr = DOS_ByteRead;
0D5D                
0D5D                .getLine90:
0D5D A0 22 01        mov al, [DOS_ByteRead]
0D60 8B 1E 14 01     mov  bx, [InputPtr]
0D64 88 07           mov  [bx], al
0D66                
0D66                ;-405     InputPtr++;
0D66                
0D66 FF 06 14 01     inc  word[InputPtr]
0D6A                
0D6A                ;-406     i = InputPtr - &InputBuf;
0D6A                
0D6A A1 14 01        mov ax, [InputPtr]
0D6D 2D 8D 75        sub ax, InputBuf
0D70 89 46 FE        mov [bp-2], ax
0D73                
0D73                ;-407     if (i >= INPUTBUFMAX) errorexit("input line too long");
0D73                
0D73 8B 46 FE        mov ax, [bp-2]
0D76 3D FF 00        cmp ax, 255 ;unsigned : 0
0D79 0F 82 00 00   r jb  .getLine91
0D7D 68 AA AA      A push getLine_1
0D80 E8 0D FD        call errorexit
0D83 83 C4 02        add  sp, 2
0D86                
0D86                ;-408   } while (ifEOL(DOS_ByteRead) == 0);
0D86                
0D86                .getLine91:
0D86 A0 22 01        mov al, byte [DOS_ByteRead]
0D89 B4 00           mov ah, 0
0D8B 50              push ax
0D8C E8 1C FF        call ifEOL
0D8F 83 C4 02        add  sp, 2
0D92 3C 00           cmp al, 0
0D94 0F 85 00 00   r jne .getLine92
0D98 EB 90           jmp .getLine88
0D9A                .getLine92:
0D9A                
0D9A                ;-409   InputPtr--;
0D9A                
0D9A FF 0E 14 01     dec  word[InputPtr]
0D9E                
0D9E                ;-410   *InputPtr=0;
0D9E                
0D9E B8 00 00        mov ax, 0
0DA1 8B 1E 14 01     mov  bx, [InputPtr]
0DA5 88 07           mov  [bx], al
0DA7                
0DA7                ;-411 }
0DA7                
0DA7                
0DA7                ;-412 int skipBlank() {
0DA7                
0DA7 C9              .retngetLine: LEAVE
0DA8 C3              ret
0DA9 52 65 61 64 69 getLine_0 db "Reading Source",0
0DB8 69 6E 70 75 74 getLine_1 db "input line too long",0
leaving: getLine, loc labels: 8, loc jmp forward: 7
0DCC                ENDP
0DCC                
entering: skipBlank
0DCC                skipBlank: PROC
0DCC                
0DCC                ;-413   skipblank1:
0DCC                
0DCC                .skipblank1:
0DCC                
0DCC                ;-414     if (*InputPtr == ' ') { InputPtr++; goto skipblank1; }
0DCC                
0DCC 8B 1E 14 01     mov bx, [InputPtr]
0DD0 8A 07           mov al, [bx]
0DD2 B4 00           mov ah, 0
0DD4 83 F8 20        cmp ax, 32
0DD7 0F 85 00 00   r jne .skipBlank93
0DDB FF 06 14 01     inc  word[InputPtr]
0DDF EB EB           jmp .skipblank1
0DE1                
0DE1                ;-415     if (*InputPtr == 9  ) { InputPtr++; goto skipblank1; }
0DE1                
0DE1                .skipBlank93:
0DE1 8B 1E 14 01     mov bx, [InputPtr]
0DE5 8A 07           mov al, [bx]
0DE7 B4 00           mov ah, 0
0DE9 83 F8 09        cmp ax, 9
0DEC 0F 85 00 00   r jne .skipBlank94
0DF0 FF 06 14 01     inc  word[InputPtr]
0DF4 EB D6           jmp .skipblank1
0DF6                
0DF6                ;-416 }
0DF6                
0DF6                .skipBlank94:
0DF6                
0DF6                ;-417 
0DF6                
0DF6                
0DF6                ;-418 int getDigit(unsigned char c) {//ret: SymbolInt
0DF6                
0DF6 C3              ret
leaving: skipBlank, loc labels: 3, loc jmp forward: 2
0DF7                ENDP
0DF7                
entering: getDigit
0DF7                getDigit: PROC
0DF7                
0DF7                ;-419   unsigned int CastInt;
0DF7                
0DF7                
0DF7                ;-420   SymbolInt=0;
0DF7                
0DF7                ;Function : getDigit, Number of local variables: 2
0DF7                ;   # type sign width addr used name   list of local variables
0DF7                ;  200 var unsg byte   418 NULL c = bp+4
0DF7                ;  201 var unsg word   419 NULL CastInt = bp-2;
0DF7 C8 02 00 00     ENTER  2,0
0DFB B8 00 00        mov ax, 0
0DFE A3 0E 01        mov word [SymbolInt], ax
0E01                
0E01                ;-421   do {
0E01                
0E01                .getDigit95:
0E01                
0E01                ;-422     c-='0';
0E01                
0E01 80 6E 04 30     sub  byte[bp+4], 48
0E05                
0E05                ;-423     SymbolInt=SymbolInt*10;
0E05                
0E05 A1 0E 01        mov ax, [SymbolInt]
0E08 BB 0A 00        mov bx, 10
0E0B F7 E3           mul bx
0E0D A3 0E 01        mov word [SymbolInt], ax
0E10                
0E10                ;-424     ax=0; CastInt=c; //cast b2w
0E10                
0E10 B8 00 00        mov  ax, 0
0E13 8A 46 04        mov al, [bp+4]
0E16 89 46 FE        mov [bp-2], ax
0E19                
0E19                ;-425     SymbolInt=SymbolInt+CastInt;
0E19                
0E19 A1 0E 01        mov ax, [SymbolInt]
0E1C 03 46 FE        add ax, [bp-2]
0E1F A3 0E 01        mov word [SymbolInt], ax
0E22                
0E22                ;-426     InputPtr++;
0E22                
0E22 FF 06 14 01     inc  word[InputPtr]
0E26                
0E26                ;-427     c = *InputPtr;
0E26                
0E26 8B 1E 14 01     mov bx, [InputPtr]
0E2A 8A 07           mov al, [bx]
0E2C B4 00           mov ah, 0
0E2E 88 46 04        mov [bp+4], al
0E31                
0E31                ;-428   } while(digit(c));
0E31                
0E31 8A 46 04        mov al, byte [bp+4]
0E34 B4 00           mov ah, 0
0E36 50              push ax
0E37 E8 62 F3        call digit
0E3A 83 C4 02        add  sp, 2
0E3D 08 C0           or  al, al
0E3F 0F 84 00 00   r je .getDigit96
0E43 EB BC           jmp .getDigit95
0E45                .getDigit96:
0E45                
0E45                ;-429 }
0E45                
0E45                
0E45                ;-430 int getName(unsigned char c) {//ret: Symbol, SymbolUpper, isLabel
0E45 C9              LEAVE
0E46 C3              ret
leaving: getDigit, loc labels: 2, loc jmp forward: 1
0E47                ENDP
0E47                
entering: getName
0E47                getName: PROC
0E47                
0E47                ;-431   char *p; unsigned int i;
0E47                
0E47                
0E47                ;-432   p = &Symbol;
0E47                
0E47                ;Function : getName, Number of local variables: 3
0E47                ;   # type sign width addr used name   list of local variables
0E47                ;  200 var unsg byte   430 NULL c = bp+4
0E47                ;  201 ptr sign byte   431 NULL p = bp-2
0E47                ;  202 var unsg word   431 NULL i = bp-4;
0E47 C8 04 00 00     ENTER  4,0
0E4B B8 30 75        mov ax, Symbol
0E4E 89 46 FE        mov [bp-2], ax
0E51                
0E51                ;-433   *p = c;
0E51                
0E51 8A 46 04        mov al, [bp+4]
0E54 8B 5E FE        mov  bx, [bp-2]
0E57 88 07           mov  [bx], al
0E59                
0E59                ;-434   p++;
0E59                
0E59 FF 46 FE        inc  word[bp-2]
0E5C                
0E5C                ;-435   while (alnumE(c)) {
0E5C                
0E5C                .getName97:
0E5C 8A 46 04        mov al, byte [bp+4]
0E5F B4 00           mov ah, 0
0E61 50              push ax
0E62 E8 61 F3        call alnumE
0E65 83 C4 02        add  sp, 2
0E68 08 C0           or  al, al
0E6A 0F 84 00 00   r je .getName98
0E6E                
0E6E                ;-436     InputPtr++;
0E6E                
0E6E FF 06 14 01     inc  word[InputPtr]
0E72                
0E72                ;-437     c = *InputPtr;
0E72                
0E72 8B 1E 14 01     mov bx, [InputPtr]
0E76 8A 07           mov al, [bx]
0E78 B4 00           mov ah, 0
0E7A 88 46 04        mov [bp+4], al
0E7D                
0E7D                ;-438     *p = c;
0E7D                
0E7D 8A 46 04        mov al, [bp+4]
0E80 8B 5E FE        mov  bx, [bp-2]
0E83 88 07           mov  [bx], al
0E85                
0E85                ;-439     p++;
0E85                
0E85 FF 46 FE        inc  word[bp-2]
0E88                
0E88                ;-440     i = p - &Symbol;
0E88                
0E88 8B 46 FE        mov ax, [bp-2]
0E8B 2D 30 75        sub ax, Symbol
0E8E 89 46 FC        mov [bp-4], ax
0E91                
0E91                ;-441     if (i >= SYMBOLMAX) errorexit("symbol too long");
0E91                
0E91 8B 46 FC        mov ax, [bp-4]
0E94 83 F8 1F        cmp ax, 31 ;unsigned : 0
0E97 0F 82 00 00   r jb  .getName99
0E9B 68 AA AA      A push getName_0
0E9E E8 EF FB        call errorexit
0EA1 83 C4 02        add  sp, 2
0EA4                
0EA4                ;-442   }
0EA4                
0EA4                .getName99:
0EA4                
0EA4                ;-443   if (c == ':') isLabel=1; else isLabel=0;
0EA4                
0EA4 EB B6           jmp .getName97
0EA6                .getName98:
0EA6 8A 46 04        mov al, [bp+4]
0EA9 3C 3A           cmp al, 58
0EAB 0F 85 00 00   r jne .getName100
0EAF B8 01 00        mov ax, 1
0EB2 A2 2B 01        mov byte [isLabel], al
0EB5 E9 00 00      R jmp .getName101
0EB8                .getName100:
0EB8 B8 00 00        mov ax, 0
0EBB A2 2B 01        mov byte [isLabel], al
0EBE                
0EBE                ;-444   p--;
0EBE                
0EBE                .getName101:
0EBE FF 4E FE        dec  word[bp-2]
0EC1                
0EC1                ;-445   *p = 0;
0EC1                
0EC1 B8 00 00        mov ax, 0
0EC4 8B 5E FE        mov  bx, [bp-2]
0EC7 88 07           mov  [bx], al
0EC9                
0EC9                ;-446   strcpy(SymbolUpper, Symbol);
0EC9                
0EC9 8D 06 30 75     lea  ax, [Symbol]
0ECD 50              push ax
0ECE 8D 06 4F 75     lea  ax, [SymbolUpper]
0ED2 50              push ax
0ED3 E8 54 F3        call strcpy
0ED6 83 C4 04        add  sp, 4
0ED9                
0ED9                ;-447   toupper(SymbolUpper);
0ED9                
0ED9 8D 06 4F 75     lea  ax, [SymbolUpper]
0EDD 50              push ax
0EDE E8 EC F3        call toupper
0EE1 83 C4 02        add  sp, 2
0EE4                
0EE4                ;-448 }
0EE4                
0EE4                
0EE4                ;-449 
0EE4                
0EE4                
0EE4                ;-450 //#include "OPTABL.C"
0EE4                
0EE4                
0EE4                ;-451 char I_START=0xF1;
0EE4 C9              LEAVE
0EE5 C3              ret
0EE6 73 79 6D 62 6F getName_0 db "symbol too long",0
leaving: getName, loc labels: 6, loc jmp forward: 5
0EF6                ENDP
0EF6 F1             I_START db 241
0EF7                
0EF7                ;-452 //OpName, 0, CodeType, OpCode1-n, F1h
0EF7                
0EF7                
0EF7                ;-453 //  1:   1 byte opcode
0EF7                
0EF7                
0EF7                ;-454 char I_PUSHA[]={'P','U','S','H','A',0,1,0x60,0xF1, 'P','O','P','A',0,    1,0x61,0xF1};
0EF7                
0EF7 50 55 53 48 41 I_PUSHA db 80,85,83,72,65,0,1,96,241,80,79,80,65,0,1,97,241
0F08                
0F08                ;-455 char I_NOP[]=  {'N','O','P',0,        1,0x90,0xF1, 'C','B','W',0,        1,0x98,0xF1};
0F08                
0F08 4E 4F 50 00 01 I_NOP db 78,79,80,0,1,144,241,67,66,87,0,1,152,241
0F16                
0F16                ;-456 char I_CWDE[]= {'C','W','D','E',0,    1,0x98,0xF1, 'C','W','D',0,        1,0x99,0xF1};
0F16                
0F16 43 57 44 45 00 I_CWDE db 67,87,68,69,0,1,152,241,67,87,68,0,1,153,241
0F25                
0F25                ;-457 char I_CDQ[]=  {'C','D','Q',0,        1,0x99,0xF1, 'W','A','I','T',0,    1,0x9B,0xF1};
0F25                
0F25 43 44 51 00 01 I_CDQ db 67,68,81,0,1,153,241,87,65,73,84,0,1,155,241
0F34                
0F34                ;-458 char I_PUSHF[]={'P','U','S','H','F',0,1,0x9C,0xF1, 'P','O','P','F',0,    1,0x9D,0xF1};
0F34                
0F34 50 55 53 48 46 I_PUSHF db 80,85,83,72,70,0,1,156,241,80,79,80,70,0,1,157,241
0F45                
0F45                ;-459 char I_SAHF[]= {'S','A','H','F',0,    1,0x9E,0xF1, 'L','A','H','F',0,    1,0x9F,0xF1};
0F45                
0F45 53 41 48 46 00 I_SAHF db 83,65,72,70,0,1,158,241,76,65,72,70,0,1,159,241
0F55                
0F55                ;-460 char I_MOVSB[]={'M','O','V','S','B',0,1,0xA4,0xF1, 'M','O','V','S','W',0,1,0xA5,0xF1};
0F55                
0F55 4D 4F 56 53 42 I_MOVSB db 77,79,86,83,66,0,1,164,241,77,79,86,83,87,0,1,165,241
0F67                
0F67                ;-461 char I_CMPSB[]={'C','M','P','S','B',0,1,0xA6,0xF1, 'C','M','P','S','W',0,1,0xA7,0xF1};
0F67                
0F67 43 4D 50 53 42 I_CMPSB db 67,77,80,83,66,0,1,166,241,67,77,80,83,87,0,1,167,241
0F79                
0F79                ;-462 char I_STOSB[]={'S','T','O','S','B',0,1,0xAA,0xF1, 'S','T','O','S','W',0,1,0xAB,0xF1};
0F79                
0F79 53 54 4F 53 42 I_STOSB db 83,84,79,83,66,0,1,170,241,83,84,79,83,87,0,1,171,241
0F8B                
0F8B                ;-463 char I_LODSB[]={'L','O','D','S','B',0,1,0xAC,0xF1, 'L','O','D','S','W',0,1,0xAD,0xF1};
0F8B                
0F8B 4C 4F 44 53 42 I_LODSB db 76,79,68,83,66,0,1,172,241,76,79,68,83,87,0,1,173,241
0F9D                
0F9D                ;-464 char I_SCASB[]={'S','C','A','S','B',0,1,0xAE,0xF1, 'S','C','A','S','W',0,1,0xAF,0xF1};
0F9D                
0F9D 53 43 41 53 42 I_SCASB db 83,67,65,83,66,0,1,174,241,83,67,65,83,87,0,1,175,241
0FAF                
0FAF                ;-465 char I_LEAVE[]={'L','E','A','V','E',0,1,0xC9,0xF1, 'I','N','T','3',0,    1,0xCC,0xF1};
0FAF                
0FAF 4C 45 41 56 45 I_LEAVE db 76,69,65,86,69,0,1,201,241,73,78,84,51,0,1,204,241
0FC0                
0FC0                ;-466 char I_INTO[]= {'I','N','T','O',0,    1,0xCE,0xF1, 'I','R','E','T',0,    1,0xCF,0xF1};
0FC0                
0FC0 49 4E 54 4F 00 I_INTO db 73,78,84,79,0,1,206,241,73,82,69,84,0,1,207,241
0FD0                
0FD0                ;-467 char I_XLAT[]= {'X','L','A','T',0,    1,0xD7,0xF1, 'L','O','C','K',0,    1,0xF0,0xF1};
0FD0                
0FD0 58 4C 41 54 00 I_XLAT db 88,76,65,84,0,1,215,241,76,79,67,75,0,1,240,241
0FE0                
0FE0                ;-468 char I_REPNE[]={'R','E','P','N','E',0,1,0xF2,0xF1, 'R','E','P','N','Z',0,1,0xF2,0xF1};
0FE0                
0FE0 52 45 50 4E 45 I_REPNE db 82,69,80,78,69,0,1,242,241,82,69,80,78,90,0,1,242,241
0FF2                
0FF2                ;-469 char I_REPE[]= {'R','E','P','E',0,    1,0xF3,0xF1, 'R','E','P','Z',0,    1,0xF3,0xF1};
0FF2                
0FF2 52 45 50 45 00 I_REPE db 82,69,80,69,0,1,243,241,82,69,80,90,0,1,243,241
1002                
1002                ;-470 char I_HLT[]=  {'H','L','T',0,        1,0xF4,0xF1, 'C','L','C',0,        1,0xF8,0xF1};
1002                
1002 48 4C 54 00 01 I_HLT db 72,76,84,0,1,244,241,67,76,67,0,1,248,241
1010                
1010                ;-471 char I_STC[]=  {'S','T','C',0,        1,0xF9,0xF1, 'C','L','I',0,        1,0xFA,0xF1};
1010                
1010 53 54 43 00 01 I_STC db 83,84,67,0,1,249,241,67,76,73,0,1,250,241
101E                
101E                ;-472 char I_STI[]=  {'S','T','I',0,        1,0xFB,0xF1, 'C','L','D',0,        1,0xFC,0xF1};
101E                
101E 53 54 49 00 01 I_STI db 83,84,73,0,1,251,241,67,76,68,0,1,252,241
102C                
102C                ;-473 char I_STD[]=  {'S','T','D',0,        1,0xFD,0xF1};
102C                
102C 53 54 44 00 01 I_STD db 83,84,68,0,1,253,241
1033                
1033                ;-474 // 2: mem reg 16 bit
1033                
1033                
1033                ;-475 char I_INC[]=  {'I','N','C',0,          2,0xFE, 0,0x40,0xF1};
1033                
1033 49 4E 43 00 02 I_INC db 73,78,67,0,2,254,0,64,241
103C                
103C                ;-476 char I_DEC[]=  {'D','E','C',0,          2,0xFE, 1,0x48,0xF1};
103C                
103C 44 45 43 00 02 I_DEC db 68,69,67,0,2,254,1,72,241
1045                
1045                ;-477 char I_NOT[]=  {'N','O','T',0,          2,0xF6, 2,     0xF1};
1045                
1045 4E 4F 54 00 02 I_NOT db 78,79,84,0,2,246,2,241
104D                
104D                ;-478 char I_NEG[]=  {'N','E','G',0,          2,0xF6, 3,     0xF1};
104D                
104D 4E 45 47 00 02 I_NEG db 78,69,71,0,2,246,3,241
1055                
1055                ;-479 char I_MUL[]=  {'M','U','L',0,          2,0xF6, 4,     0xF1};
1055                
1055 4D 55 4C 00 02 I_MUL db 77,85,76,0,2,246,4,241
105D                
105D                ;-480 char I_IMUL[]= {'I','M','U','L',0,      2,0xF6, 5,     0xF1};//only acc
105D                
105D 49 4D 55 4C 00 I_IMUL db 73,77,85,76,0,2,246,5,241
1066                
1066                ;-481 char I_DIV[]=  {'D','I','V',0,          2,0xF6, 6,     0xF1};
1066                
1066 44 49 56 00 02 I_DIV db 68,73,86,0,2,246,6,241
106E                
106E                ;-482 char I_IDIV[]= {'I','D','I','V',0,      2,0xF6, 7,     0xF1};
106E                
106E 49 44 49 56 00 I_IDIV db 73,68,73,86,0,2,246,7,241
1077                
1077                ;-483 //  3: les, lda, lea, lss, lfs, lgs
1077                
1077                
1077                ;-484 char I_LES[]=  {'L','E','S',0,          3,0xC4,     0xF1};
1077                
1077 4C 45 53 00 03 I_LES db 76,69,83,0,3,196,241
107E                
107E                ;-485 char I_LDS[]=  {'L','D','S',0,          3,0xC5,     0xF1};
107E                
107E 4C 44 53 00 03 I_LDS db 76,68,83,0,3,197,241
1085                
1085                ;-486 char I_LEA[]=  {'L','E','A',0,          3,0x8D,     0xF1};//r, m16
1085                
1085 4C 45 41 00 03 I_LEA db 76,69,65,0,3,141,241
108C                
108C                ;-487 char I_LSS[]=  {'L','S','S',0,          3,0x0F,0xB2,0xF1};
108C                
108C 4C 53 53 00 03 I_LSS db 76,83,83,0,3,15,178,241
1094                
1094                ;-488 char I_LFS[]=  {'L','F','S',0,          3,0x0F,0xB4,0xF1};
1094                
1094 4C 46 53 00 03 I_LFS db 76,70,83,0,3,15,180,241
109C                
109C                ;-489 char I_LGS[]=  {'L','G','S',0,          3,0x0F,0xB5,0xF1};
109C                
109C 4C 47 53 00 03 I_LGS db 76,71,83,0,3,15,181,241
10A4                
10A4                ;-490 //  4: acc,imm  reg,imm  index,reg
10A4                
10A4                
10A4                ;-491 char I_ADD[]=  {'A','D','D',0,          4, 0,     0xF1};
10A4                
10A4 41 44 44 00 04 I_ADD db 65,68,68,0,4,0,241
10AB                
10AB                ;-492 char I_OR []=  {'O','R',0,              4, 1,     0xF1};
10AB                
10AB 4F 52 00 04 01 I_OR db 79,82,0,4,1,241
10B1                
10B1                ;-493 char I_ADC[]=  {'A','D','C',0,          4, 2,     0xF1};
10B1                
10B1 41 44 43 00 04 I_ADC db 65,68,67,0,4,2,241
10B8                
10B8                ;-494 char I_SBB[]=  {'S','B','B',0,          4, 3,     0xF1};
10B8                
10B8 53 42 42 00 04 I_SBB db 83,66,66,0,4,3,241
10BF                
10BF                ;-495 char I_AND[]=  {'A','N','D',0,          4, 4,     0xF1};
10BF                
10BF 41 4E 44 00 04 I_AND db 65,78,68,0,4,4,241
10C6                
10C6                ;-496 char I_SUB[]=  {'S','U','B',0,          4, 5,     0xF1};
10C6                
10C6 53 55 42 00 04 I_SUB db 83,85,66,0,4,5,241
10CD                
10CD                ;-497 char I_XOR[]=  {'X','O','R',0,          4, 6,     0xF1};
10CD                
10CD 58 4F 52 00 04 I_XOR db 88,79,82,0,4,6,241
10D4                
10D4                ;-498 char I_CMP[]=  {'C','M','P',0,          4, 7,     0xF1};
10D4                
10D4 43 4D 50 00 04 I_CMP db 67,77,80,0,4,7,241
10DB                
10DB                ;-499 char I_TEST[]= {'T','E','S','T',0,     41,0xA8,0x84,0xF6,0,0xF1};
10DB                
10DB 54 45 53 54 00 I_TEST db 84,69,83,84,0,41,168,132,246,0,241
10E6                
10E6                ;-500 //  5: mov
10E6                
10E6                
10E6                ;-501 char I_MOV[]=  {'M','O','V',0,          5,        0xF1};
10E6                
10E6 4D 4F 56 00 05 I_MOV db 77,79,86,0,5,241
10EC                
10EC                ;-502 char I_MOVSX[]={'M','O','V','S','X',0, 51,0xBE,   0xF1};
10EC                
10EC 4D 4F 56 53 58 I_MOVSX db 77,79,86,83,88,0,51,190,241
10F5                
10F5                ;-503 char I_MOVZX[]={'M','O','V','Z','X',0, 51,0xB6,   0xF1};
10F5                
10F5 4D 4F 56 5A 58 I_MOVZX db 77,79,86,90,88,0,51,182,241
10FE                
10FE                ;-504 //  6: single byte relative jump
10FE                
10FE                
10FE                ;-505 char I_JO []=  {'J','O',0,     6, 0,0xF1};
10FE                
10FE 4A 4F 00 06 00 I_JO db 74,79,0,6,0,241
1104                
1104                ;-506 char I_JNO[]=  {'J','N','O',0, 6, 1,0xF1};
1104                
1104 4A 4E 4F 00 06 I_JNO db 74,78,79,0,6,1,241
110B                
110B                ;-507 char I_JB []=  {'J','B',0,     6, 2,0xF1, 'J','C',0,     6, 2,0xF1};
110B                
110B 4A 42 00 06 02 I_JB db 74,66,0,6,2,241,74,67,0,6,2,241
1117                
1117                ;-508 char I_JNB[]=  {'J','N','B',0, 6, 3,0xF1};
1117                
1117 4A 4E 42 00 06 I_JNB db 74,78,66,0,6,3,241
111E                
111E                ;-509 char I_JAE[]=  {'J','A','E',0, 6, 3,0xF1, 'J','N','C',0, 6, 3,0xF1};
111E                
111E 4A 41 45 00 06 I_JAE db 74,65,69,0,6,3,241,74,78,67,0,6,3,241
112C                
112C                ;-510 char I_JE []=  {'J','E',0,     6, 4,0xF1, 'J','Z',0,     6, 4,0xF1};
112C                
112C 4A 45 00 06 04 I_JE db 74,69,0,6,4,241,74,90,0,6,4,241
1138                
1138                ;-511 char I_JNE[]=  {'J','N','E',0, 6, 5,0xF1, 'J','N','Z',0, 6, 5,0xF1};
1138                
1138 4A 4E 45 00 06 I_JNE db 74,78,69,0,6,5,241,74,78,90,0,6,5,241
1146                
1146                ;-512 char I_JBE[]=  {'J','B','E',0, 6, 6,0xF1, 'J','N','A',0, 6, 6,0xF1};
1146                
1146 4A 42 45 00 06 I_JBE db 74,66,69,0,6,6,241,74,78,65,0,6,6,241
1154                
1154                ;-513 char I_JA []=  {'J','A',0,     6, 7,0xF1};
1154                
1154 4A 41 00 06 07 I_JA db 74,65,0,6,7,241
115A                
115A                ;-514 char I_JS []=  {'J','S',0,     6, 8,0xF1};
115A                
115A 4A 53 00 06 08 I_JS db 74,83,0,6,8,241
1160                
1160                ;-515 char I_JNS[]=  {'J','N','S',0, 6, 9,0xF1};
1160                
1160 4A 4E 53 00 06 I_JNS db 74,78,83,0,6,9,241
1167                
1167                ;-516 char I_JP []=  {'J','P',0,     6,10,0xF1, 'J','P','E',0, 6,10,0xF1};
1167                
1167 4A 50 00 06 0A I_JP db 74,80,0,6,10,241,74,80,69,0,6,10,241
1174                
1174                ;-517 char I_JNP[]=  {'J','N','P',0, 6,11,0xF1, 'J','P','O',0, 6,11,0xF1};
1174                
1174 4A 4E 50 00 06 I_JNP db 74,78,80,0,6,11,241,74,80,79,0,6,11,241
1182                
1182                ;-518 char I_JL []=  {'J','L',0,     6,12,0xF1};
1182                
1182 4A 4C 00 06 0C I_JL db 74,76,0,6,12,241
1188                
1188                ;-519 char I_JNL[]=  {'J','N','L',0, 6,13,0xF1, 'J','G','E',0, 6,13,0xF1};
1188                
1188 4A 4E 4C 00 06 I_JNL db 74,78,76,0,6,13,241,74,71,69,0,6,13,241
1196                
1196                ;-520 char I_JLE[]=  {'J','L','E',0, 6,14,0xF1, 'J','N','G',0, 6,14,0xF1};
1196                
1196 4A 4C 45 00 06 I_JLE db 74,76,69,0,6,14,241,74,78,71,0,6,14,241
11A4                
11A4                ;-521 char I_JG []=  {'J','G',0,     6,15,0xF1};
11A4                
11A4 4A 47 00 06 0F I_JG db 74,71,0,6,15,241
11AA                
11AA                ;-522 //  7: jmp, call
11AA                
11AA                
11AA                ;-523 char I_JMP[]=  {'J','M','P',0,          7,0xE9, 4,0xF1};
11AA                
11AA 4A 4D 50 00 07 I_JMP db 74,77,80,0,7,233,4,241
11B2                
11B2                ;-524 char I_CALL[]= {'C','A','L','L',0,      7,0xE8, 2,0xF1};
11B2                
11B2 43 41 4C 4C 00 I_CALL db 67,65,76,76,0,7,232,2,241
11BB                
11BB                ;-525 //  8: ret
11BB                
11BB                
11BB                ;-526 char I_RET[]=  {'R','E','T',0,          8,0xC3,0xC2,0xF1};
11BB                
11BB 52 45 54 00 08 I_RET db 82,69,84,0,8,195,194,241
11C3                
11C3                ;-527 char I_RETF[]= {'R','E','T','F',0,      8,0xCB,0xCA,0xF1};
11C3                
11C3 52 45 54 46 00 I_RETF db 82,69,84,70,0,8,203,202,241
11CC                
11CC                ;-528 //  9: seg, r/m
11CC                
11CC                
11CC                ;-529 char I_PUSH[]= {'P','U','S','H',0,      9,0x50,0xFF,6,6,0xF1};//r16
11CC                
11CC 50 55 53 48 00 I_PUSH db 80,85,83,72,0,9,80,255,6,6,241
11D7                
11D7                ;-530 char I_POP[]=  {'P','O','P',0,          9,0x58,0x8F,0,7,0xF1};//r16
11D7                
11D7 50 4F 50 00 09 I_POP db 80,79,80,0,9,88,143,0,7,241
11E1                
11E1                ;-531 //  11: shift, rotates
11E1                
11E1                
11E1                ;-532 char I_ROL[]=  {'R','O','L',0, 11, 0,0xF1, 'R','O','R',0, 11, 1,0xF1};
11E1                
11E1 52 4F 4C 00 0B I_ROL db 82,79,76,0,11,0,241,82,79,82,0,11,1,241
11EF                
11EF                ;-533 char I_RCL[]=  {'R','C','L',0, 11, 2,0xF1, 'R','C','R',0, 11, 3,0xF1};
11EF                
11EF 52 43 4C 00 0B I_RCL db 82,67,76,0,11,2,241,82,67,82,0,11,3,241
11FD                
11FD                ;-534 char I_SHL[]=  {'S','H','L',0, 11, 4,0xF1, 'S','A','L',0, 11, 4,0xF1};
11FD                
11FD 53 48 4C 00 0B I_SHL db 83,72,76,0,11,4,241,83,65,76,0,11,4,241
120B                
120B                ;-535 char I_SHR[]=  {'S','H','R',0, 11, 5,0xF1, 'S','A','R',0, 11, 7,0xF1};
120B                
120B 53 48 52 00 0B I_SHR db 83,72,82,0,11,5,241,83,65,82,0,11,7,241
1219                
1219                ;-536 //  12: int
1219                
1219                
1219                ;-537 char I_INT[]=  {'I','N','T',0,          12,0xCD,0xCC,0xF1};
1219                
1219 49 4E 54 00 0C I_INT db 73,78,84,0,12,205,204,241
1221                
1221                ;-538 //  14: in/out
1221                
1221                
1221                ;-539 char I_IN[]=   {'I','N',0,              14,0xE4,0xEC,0xF1};
1221                
1221 49 4E 00 0E E4 I_IN db 73,78,0,14,228,236,241
1228                
1228                ;-540 char I_INSB[]= {'I','N','S','B',0,      14,0x6C,   0xF1};
1228                
1228 49 4E 53 42 00 I_INSB db 73,78,83,66,0,14,108,241
1230                
1230                ;-541 char I_INSW[]= {'I','N','S','W',0,      14,0x6D,   0xF1};
1230                
1230 49 4E 53 57 00 I_INSW db 73,78,83,87,0,14,109,241
1238                
1238                ;-542 char I_INSD[]= {'I','N','S','D',0,      14,0x6D,   0xF1};
1238                
1238 49 4E 53 44 00 I_INSD db 73,78,83,68,0,14,109,241
1240                
1240                ;-543 char I_OUT[]=  {'O','U','T',0,          14,0xE6,0xEE,0xF1};
1240                
1240 4F 55 54 00 0E I_OUT db 79,85,84,0,14,230,238,241
1248                
1248                ;-544 char I_OUTSB[]={'O','U','T','B',0,      14,0x6E,   0xF1};
1248                
1248 4F 55 54 42 00 I_OUTSB db 79,85,84,66,0,14,110,241
1250                
1250                ;-545 char I_OUTSW[]={'O','U','T','W',0,      14,0x6F,   0xF1};
1250                
1250 4F 55 54 57 00 I_OUTSW db 79,85,84,87,0,14,111,241
1258                
1258                ;-546 char I_OUTSD[]={'O','U','T','D',0,      14,0x6F,   0xF1};
1258                
1258 4F 55 54 44 00 I_OUTSD db 79,85,84,68,0,14,111,241
1260                
1260                ;-547 //  15: xchg
1260                
1260                
1260                ;-548 char I_XCHG[]= {'X','C','H','G',0,      15,0x86,0x90,0xF1};
1260                
1260 58 43 48 47 00 I_XCHG db 88,67,72,71,0,15,134,144,241
1269                
1269                ;-549 //  16: loop, jcxz
1269                
1269                
1269                ;-550 char I_LOOPNZ[]={'L','O','O','P','N','Z',0, 16,0xE0,0xF1};
1269                
1269 4C 4F 4F 50 4E I_LOOPNZ db 76,79,79,80,78,90,0,16,224,241
1273                
1273                ;-551 char I_LOOPNE[]={'L','O','O','P','N','E',0, 16,0xE0,0xF1};
1273                
1273 4C 4F 4F 50 4E I_LOOPNE db 76,79,79,80,78,69,0,16,224,241
127D                
127D                ;-552 char I_LOOPZ[]={'L','O','O','P','Z',0,      16,0xE1,0xF1};
127D                
127D 4C 4F 4F 50 5A I_LOOPZ db 76,79,79,80,90,0,16,225,241
1286                
1286                ;-553 char I_LOOPE[]={'L','O','O','P','E',0,      16,0xE1,0xF1};
1286                
1286 4C 4F 4F 50 45 I_LOOPE db 76,79,79,80,69,0,16,225,241
128F                
128F                ;-554 char I_LOOP[]= {'L','O','O','P',0,          16,0xE2,0xF1};
128F                
128F 4C 4F 4F 50 00 I_LOOP db 76,79,79,80,0,16,226,241
1297                
1297                ;-555 char I_JCXZ[]= {'J','C','X','Z',0,          16,0xE3,0xF1};
1297                
1297 4A 43 58 5A 00 I_JCXZ db 74,67,88,90,0,16,227,241
129F                
129F                ;-556 char I_JECXZ[]= {'J','E','C','X','Z',0,     16,0xE3,0xF1};
129F                
129F 4A 45 43 58 5A I_JECXZ db 74,69,67,88,90,0,16,227,241
12A8                
12A8                ;-557 //  30: enter
12A8                
12A8                
12A8                ;-558 char I_ENTER[]={'E','N','T','E','R',0, 30,        0xF1};
12A8                
12A8 45 4E 54 45 52 I_ENTER db 69,78,84,69,82,0,30,241
12B0                
12B0                ;-559 // 100: directives
12B0                
12B0                
12B0                ;-560 char I_ORG[]=  {'O','R','G',0,        101,        0xF1};
12B0                
12B0 4F 52 47 00 65 I_ORG db 79,82,71,0,101,241
12B6                
12B6                ;-561 // section, segment .TEXT .DATA .BSS
12B6                
12B6                
12B6                ;-562 char I_SECTION[]={'S','E','C','T','I','O','N',0,      102, 0xF1};
12B6                
12B6 53 45 43 54 49 I_SECTION db 83,69,67,84,73,79,78,0,102,241
12C0                
12C0                ;-563 char I_SEGMENT[]={'S','E','G','M','E','N','T',0,      102, 0xF1};
12C0                
12C0 53 45 47 4D 45 I_SEGMENT db 83,69,71,77,69,78,84,0,102,241
12CA                
12CA                ;-564 char I_ABSOLUTE[]={'A','B','S','O','L','U','T','E',0, 110, 0xF1};
12CA                
12CA 41 42 53 4F 4C I_ABSOLUTE db 65,66,83,79,76,85,84,69,0,110,241
12D5                
12D5                ;-565 char I_PROC[]= {'P','R','O','C',0,    111,        0xF1};
12D5                
12D5 50 52 4F 43 00 I_PROC db 80,82,79,67,0,111,241
12DC                
12DC                ;-566 char I_ENDP[]= {'E','N','D','P',0,    112,        0xF1};
12DC                
12DC 45 4E 44 50 00 I_ENDP db 69,78,68,80,0,112,241
12E3                
12E3                ;-567 char I_DB[]=   {'D','B',0,            200,        0xF1};
12E3                
12E3 44 42 00 C8 F1 I_DB db 68,66,0,200,241
12E8                
12E8                ;-568 char I_DW[]=   {'D','W',0,            201,        0xF1};
12E8                
12E8 44 57 00 C9 F1 I_DW db 68,87,0,201,241
12ED                
12ED                ;-569 char I_DD[]=   {'D','D',0,            202,        0xF1};
12ED                
12ED 44 44 00 CA F1 I_DD db 68,68,0,202,241
12F2                
12F2                ;-570 char I_RESB[]= {'R','E','S','B',0,    203,        0xF1};
12F2                
12F2 52 45 53 42 00 I_RESB db 82,69,83,66,0,203,241
12F9                
12F9                ;-571 char I_RESW[]= {'R','E','S','W',0,    204,        0xF1};
12F9                
12F9 52 45 53 57 00 I_RESW db 82,69,83,87,0,204,241
1300                
1300                ;-572 char I_RESD[]= {'R','E','S','D',0,    205,        0xF1};
1300                
1300 52 45 53 44 00 I_RESD db 82,69,83,68,0,205,241
1307                
1307                ;-573 char I_END=0;// end of table char
1307                
1307 00             I_END db 0
1308                
1308                ;-574 
1308                
1308                
1308                ;-575 int lookCode() {//ret: CodeType, *OpCodePtr
1308                
1308                
entering: lookCode
1308                lookCode: PROC
1308                
1308                ;-576     CodeType=0;
1308                
1308 B8 00 00        mov ax, 0
130B A2 2F 01        mov byte [CodeType], al
130E                
130E                ;-577     OpCodePtr= &I_START;
130E                
130E B8 F6 0F        mov ax, I_START
1311 A3 43 01        mov word [OpCodePtr], ax
1314                
1314                ;-578     OpCodePtr++;
1314                
1314 FF 06 43 01     inc  word[OpCodePtr]
1318                
1318                ;-579     do  {
1318                
1318                .lookCode102:
1318                
1318                ;-580         if (eqstr(SymbolUpper, OpCodePtr))  {
1318                
1318 FF 36 43 01     push word [OpCodePtr]
131C 8D 06 4F 75     lea  ax, [SymbolUpper]
1320 50              push ax
1321 E8 3C EF        call eqstr
1324 83 C4 04        add  sp, 4
1327 08 C0           or  al, al
1329 0F 84 00 00   r je .lookCode103
132D                
132D                ;-581             while(*OpCodePtr!=0) OpCodePtr++;
132D                
132D                .lookCode104:
132D 8B 1E 43 01     mov bx, [OpCodePtr]
1331 8A 07           mov al, [bx]
1333 B4 00           mov ah, 0
1335 83 F8 00        cmp ax, 0
1338 0F 84 00 00   r je  .lookCode105
133C FF 06 43 01     inc  word[OpCodePtr]
1340                
1340                ;-582             OpCodePtr++;
1340                
1340 EB EB           jmp .lookCode104
1342                .lookCode105:
1342 FF 06 43 01     inc  word[OpCodePtr]
1346                
1346                ;-583             CodeType =*OpCodePtr;
1346                
1346 8B 1E 43 01     mov bx, [OpCodePtr]
134A 8A 07           mov al, [bx]
134C B4 00           mov ah, 0
134E A2 2F 01        mov byte [CodeType], al
1351                
1351                ;-584             return;
1351                
1351 E9 00 00      R jmp .retnlookCode
1354                
1354                ;-585         }
1354                
1354                
1354                ;-586     while(*OpCodePtr!=0xF1) OpCodePtr++;
1354                
1354                .lookCode103:
1354                .lookCode106:
1354 8B 1E 43 01     mov bx, [OpCodePtr]
1358 8A 07           mov al, [bx]
135A B4 00           mov ah, 0
135C 3D F1 00        cmp ax, 241
135F 0F 84 00 00   r je  .lookCode107
1363 FF 06 43 01     inc  word[OpCodePtr]
1367                
1367                ;-587     OpCodePtr++;
1367                
1367 EB EB           jmp .lookCode106
1369                .lookCode107:
1369 FF 06 43 01     inc  word[OpCodePtr]
136D                
136D                ;-588     } while(*OpCodePtr!=0);
136D                
136D 8B 1E 43 01     mov bx, [OpCodePtr]
1371 8A 07           mov al, [bx]
1373 B4 00           mov ah, 0
1375 83 F8 00        cmp ax, 0
1378 0F 84 00 00   r je  .lookCode108
137C EB 9A           jmp .lookCode102
137E                .lookCode108:
137E                
137E                ;-589 }
137E                
137E                
137E                ;-590 
137E                
137E                
137E                ;-591 int genCode8(char c) {
137E                
137E                 .retnlookCode:
137E C3              ret
leaving: lookCode, loc labels: 8, loc jmp forward: 5
137F                ENDP
137F                
entering: genCode8
137F                genCode8: PROC
137F                
137F                ;-592 //set: BinLen++, OpPrintIndex++
137F                
137F                
137F                ;-593     FileBin[BinLen]=c;
137F                
137F                ;Function : genCode8, Number of local variables: 1
137F                ;   # type sign width addr used name   list of local variables
137F                ;  200 var sign byte   591 NULL c = bp+4;
137F C8 00 00 00     ENTER  0,0
1383 8A 46 04        mov al, [bp+4]
1386 8B 1E 58 01     mov bx, [BinLen]
138A 88 47 AA        mov [FileBin+bx], al
138D                
138D                ;-594     BinLen++;
138D                
138D FF 06 58 01     inc  word[BinLen]
1391                
1391                ;-595     PC++;
1391                
1391 FF 06 23 01     inc  word[PC]
1395                
1395                ;-596     if (BinLen >= FILEBINMAX) errorexit("COM file too long");
1395                
1395 A1 58 01        mov ax, [BinLen]
1398 3D 68 42        cmp ax, 17000 ;unsigned : 0
139B 0F 82 00 00   r jb  .genCode8109
139F 68 AA AA      A push genCode8_0
13A2 E8 EB F6        call errorexit
13A5 83 C4 02        add  sp, 2
13A8                
13A8                ;-597     if (OpPrintIndex < OPMAXLEN) {
13A8                
13A8                .genCode8109:
13A8 A1 41 01        mov ax, [OpPrintIndex]
13AB 83 F8 05        cmp ax, 5
13AE 0F 8D 00 00   r jge .genCode8110
13B2                
13B2                ;-598         OpPos[OpPrintIndex]=c;
13B2                
13B2 8A 46 04        mov al, [bp+4]
13B5 8B 1E 41 01     mov bx, [OpPrintIndex]
13B9 88 87 55 77     mov [OpPos+bx], al
13BD                
13BD                ;-599         OpPrintIndex++;
13BD                
13BD FF 06 41 01     inc  word[OpPrintIndex]
13C1                
13C1                ;-600     }
13C1                
13C1                
13C1                ;-601 }
13C1                
13C1                .genCode8110:
13C1                
13C1                ;-602 int gen66h() {genCode8(0x66);
13C1 C9              LEAVE
13C2 C3              ret
13C3 43 4F 4D 20 66 genCode8_0 db "COM file too long",0
leaving: genCode8, loc labels: 3, loc jmp forward: 3
13D5                ENDP
13D5                
entering: gen66h
13D5                gen66h: PROC
13D5 6A 66           push 102
13D7 E8 A5 FF        call genCode8
13DA 83 C4 02        add  sp, 2
13DD                
13DD                ;-603 }
13DD                
13DD                
13DD                ;-604 int genCode2(char c, char d) {
13DD                
13DD C3              ret
leaving: gen66h, loc labels: 0, loc jmp forward: 0
13DE                ENDP
13DE                
entering: genCode2
13DE                genCode2: PROC
13DE                
13DE                ;-605     c = c + d;
13DE                
13DE                ;Function : genCode2, Number of local variables: 2
13DE                ;   # type sign width addr used name   list of local variables
13DE                ;  200 var sign byte   604 NULL c = bp+4
13DE                ;  201 var sign byte   604 NULL d = bp+6;
13DE C8 00 00 00     ENTER  0,0
13E2 8A 46 04        mov al, [bp+4]
13E5 02 46 06        add al, [bp+6]
13E8 88 46 04        mov [bp+4], al
13EB                
13EB                ;-606     genCode8(c);
13EB                
13EB 8A 46 04        mov al, byte [bp+4]
13EE B4 00           mov ah, 0
13F0 50              push ax
13F1 E8 8B FF        call genCode8
13F4 83 C4 02        add  sp, 2
13F7                
13F7                ;-607 }
13F7                
13F7                
13F7                ;-608 int genCodeW(char c) {
13F7 C9              LEAVE
13F8 C3              ret
leaving: genCode2, loc labels: 0, loc jmp forward: 0
13F9                ENDP
13F9                
entering: genCodeW
13F9                genCodeW: PROC
13F9                
13F9                ;-609     c = c + wflag;
13F9                
13F9                ;Function : genCodeW, Number of local variables: 1
13F9                ;   # type sign width addr used name   list of local variables
13F9                ;  200 var sign byte   608 NULL c = bp+4;
13F9 C8 00 00 00     ENTER  0,0
13FD 8A 46 04        mov al, [bp+4]
1400 02 06 38 01     add al, [wflag]
1404 88 46 04        mov [bp+4], al
1407                
1407                ;-610     genCode8(c);
1407                
1407 8A 46 04        mov al, byte [bp+4]
140A B4 00           mov ah, 0
140C 50              push ax
140D E8 6F FF        call genCode8
1410 83 C4 02        add  sp, 2
1413                
1413                ;-611 }
1413                
1413                
1413                ;-612 int genCode16(unsigned int i) {
1413 C9              LEAVE
1414 C3              ret
leaving: genCodeW, loc labels: 0, loc jmp forward: 0
1415                ENDP
1415                
entering: genCode16
1415                genCode16: PROC
1415                
1415                ;-613     genCode8(i); i=i >> 8;
1415                
1415                ;Function : genCode16, Number of local variables: 1
1415                ;   # type sign width addr used name   list of local variables
1415                ;  200 var unsg word   612 NULL i = bp+4;
1415 C8 00 00 00     ENTER  0,0
1419 55              push word [bp+4]
141A E8 62 FF        call genCode8
141D 83 C4 02        add  sp, 2
1420 8B 46 04        mov ax, [bp+4]
1423 C1 E8 08        shr ax, 8
1426 89 46 04        mov [bp+4], ax
1429                
1429                ;-614     genCode8(i);
1429                
1429 55              push word [bp+4]
142A E8 52 FF        call genCode8
142D 83 C4 02        add  sp, 2
1430                
1430                ;-615 }
1430                
1430                
1430                ;-616 int genCode32(unsigned long L) {
1430 C9              LEAVE
1431 C3              ret
leaving: genCode16, loc labels: 0, loc jmp forward: 0
1432                ENDP
1432                
entering: genCode32
1432                genCode32: PROC
1432                
1432                ;-617     genCode16(L); L=L >>16;
1432                
1432                ;Function : genCode32, Number of local variables: 1
1432                ;   # type sign width addr used name   list of local variables
1432                ;  200 var unsg dwrd   616 NULL L = bp+4;
1432 C8 00 00 00     ENTER  0,0
1436 8A 46 04        mov al, byte [bp+4]
1439 B4 00           mov ah, 0
143B 50              push ax
143C E8 D6 FF        call genCode16
143F 83 C4 02        add  sp, 2
1442 66 8B 46 04     mov eax, [bp+4]
1446 66 C1 E8 10     shr eax, 16
144A 66 89 46 04     mov [bp+4], eax
144E                
144E                ;-618     genCode16(L);
144E                
144E 8A 46 04        mov al, byte [bp+4]
1451 B4 00           mov ah, 0
1453 50              push ax
1454 E8 BE FF        call genCode16
1457 83 C4 02        add  sp, 2
145A                
145A                ;-619 }
145A                
145A                
145A                ;-620 int writeEA(char xxx) {//value for reg/operand
145A C9              LEAVE
145B C3              ret
leaving: genCode32, loc labels: 0, loc jmp forward: 0
145C                ENDP
145C                
entering: writeEA
145C                writeEA: PROC
145C                
145C                ;-621 //need: Op, Op2, disp, R1No, R2No, rm, isDirect
145C                
145C                
145C                ;-622 //mod-bits: mode76, reg/opcode543, r/m210
145C                
145C                
145C                ;-623 //Op: 0, IMM, REG, ADR, MEM
145C                
145C                
145C                ;-624     char len;
145C                
145C                
145C                ;-625     len=0;
145C                
145C                ;Function : writeEA, Number of local variables: 2
145C                ;   # type sign width addr used name   list of local variables
145C                ;  200 var sign byte   620 NULL xxx = bp+4
145C                ;  201 var sign byte   624 NULL len = bp-2;
145C C8 02 00 00     ENTER  2,0
1460 B8 00 00        mov ax, 0
1463 88 46 FE        mov [bp-2], al
1466                
1466                ;-626     xxx = xxx << 3;//in reg/opcode field
1466                
1466 8A 46 04        mov al, [bp+4]
1469 C0 E0 03        shl al, 3
146C 88 46 04        mov [bp+4], al
146F                
146F                ;-627     if (Op == REG) {
146F                
146F A0 2D 01        mov al, [Op]
1472 3C 02           cmp al, 2
1474 0F 85 00 00   r jne .writeEA111
1478                
1478                ;-628         xxx |= 0xC0;
1478                
1478 80 4E 04 C0     or  byte[bp+4], 192
147C                
147C                ;-629         if (Op2 <= IMM) xxx = xxx + R1No;//empty or IMM
147C                
147C A0 2E 01        mov al, [Op2]
147F 3C 01           cmp al, 1
1481 0F 8F 00 00   r jg  .writeEA112
1485 8A 46 04        mov al, [bp+4]
1488 02 06 34 01     add al, [R1No]
148C 88 46 04        mov [bp+4], al
148F                
148F                ;-630             else {
148F                
148F E9 00 00      R jmp .writeEA113
1492                .writeEA112:
1492                
1492                ;-631                 if (Op2 == REG) xxx = xxx + R1No;
1492                
1492 A0 2E 01        mov al, [Op2]
1495 3C 02           cmp al, 2
1497 0F 85 00 00   r jne .writeEA114
149B 8A 46 04        mov al, [bp+4]
149E 02 06 34 01     add al, [R1No]
14A2 88 46 04        mov [bp+4], al
14A5                
14A5                ;-632                 else            xxx = xxx + R2No;
14A5                
14A5 E9 00 00      R jmp .writeEA115
14A8                .writeEA114:
14A8 8A 46 04        mov al, [bp+4]
14AB 02 06 33 01     add al, [R2No]
14AF 88 46 04        mov [bp+4], al
14B2                
14B2                ;-633             }
14B2                
14B2                .writeEA115:
14B2                
14B2                ;-634         }
14B2                
14B2                .writeEA113:
14B2                
14B2                ;-635     if (Op == MEM) {
14B2                
14B2                .writeEA111:
14B2 A0 2D 01        mov al, [Op]
14B5 3C 04           cmp al, 4
14B7 0F 85 00 00   r jne .writeEA116
14BB                
14BB                ;-636         if (isDirect) {
14BB                
14BB A0 3C 01        mov al, [isDirect]
14BE 08 C0           or  al, al
14C0 0F 84 00 00   r je .writeEA117
14C4                
14C4                ;-637             xxx |= 6;
14C4                
14C4 80 4E 04 06     or  byte[bp+4], 6
14C8                
14C8                ;-638             len = 2;
14C8                
14C8 B8 02 00        mov ax, 2
14CB 88 46 FE        mov [bp-2], al
14CE                
14CE                ;-639         }
14CE                
14CE                
14CE                ;-640         else {
14CE                
14CE E9 00 00      R jmp .writeEA118
14D1                .writeEA117:
14D1                
14D1                ;-641             xxx = xxx + rm;
14D1                
14D1 8A 46 04        mov al, [bp+4]
14D4 02 06 3B 01     add al, [rm]
14D8 88 46 04        mov [bp+4], al
14DB                
14DB                ;-642             if (rm == 6) {//make [BP+00]
14DB                
14DB A0 3B 01        mov al, [rm]
14DE 3C 06           cmp al, 6
14E0 0F 85 00 00   r jne .writeEA119
14E4                
14E4                ;-643                 len=1;
14E4                
14E4 B8 01 00        mov ax, 1
14E7 88 46 FE        mov [bp-2], al
14EA                
14EA                ;-644                 if (disp == 0) xxx |= 0x40;
14EA                
14EA A1 3D 01        mov ax, [disp]
14ED 83 F8 00        cmp ax, 0
14F0 0F 85 00 00   r jne .writeEA120
14F4 80 4E 04 40     or  byte[bp+4], 64
14F8                
14F8                ;-645             }
14F8                
14F8                .writeEA120:
14F8                
14F8                ;-646 
14F8                
14F8                
14F8                ;-647             if (disp) {
14F8                
14F8                .writeEA119:
14F8 A1 3D 01        mov ax, [disp]
14FB 08 C0           or  al, al
14FD 0F 84 00 00   r je .writeEA121
1501                
1501                ;-648                 ax = disp;
1501                
1501 A1 3D 01        mov  ax, [disp]
1504                
1504                ;-649                 if(ax > 127) len=2;
1504                
1504 83 F8 7F        cmp  ax, 127
1507 0F 8E 00 00   r jle .writeEA122
150B B8 02 00        mov ax, 2
150E 88 46 FE        mov [bp-2], al
1511                
1511                ;-650                 else len=1;
1511                
1511 E9 00 00      R jmp .writeEA123
1514                .writeEA122:
1514 B8 01 00        mov ax, 1
1517 88 46 FE        mov [bp-2], al
151A                
151A                ;-651                 if (len == 1) xxx |= 0x40;
151A                
151A                .writeEA123:
151A 8A 46 FE        mov al, [bp-2]
151D 3C 01           cmp al, 1
151F 0F 85 00 00   r jne .writeEA124
1523 80 4E 04 40     or  byte[bp+4], 64
1527                
1527                ;-652                 else xxx |= 0x80;
1527                
1527 E9 00 00      R jmp .writeEA125
152A                .writeEA124:
152A 80 4E 04 80     or  byte[bp+4], 128
152E                
152E                ;-653             }
152E                
152E                .writeEA125:
152E                
152E                ;-654         }
152E                
152E                .writeEA121:
152E                
152E                ;-655     }
152E                
152E                .writeEA118:
152E                
152E                ;-656 
152E                
152E                
152E                ;-657     genCode8(xxx);// gen second byte
152E                
152E                .writeEA116:
152E 8A 46 04        mov al, byte [bp+4]
1531 B4 00           mov ah, 0
1533 50              push ax
1534 E8 48 FE        call genCode8
1537 83 C4 02        add  sp, 2
153A                
153A                ;-658     if (len == 1) genCode8 (disp);
153A                
153A 8A 46 FE        mov al, [bp-2]
153D 3C 01           cmp al, 1
153F 0F 85 00 00   r jne .writeEA126
1543 FF 36 3D 01     push word [disp]
1547 E8 35 FE        call genCode8
154A 83 C4 02        add  sp, 2
154D                
154D                ;-659     if (len == 2) genCode16(disp);
154D                
154D                .writeEA126:
154D 8A 46 FE        mov al, [bp-2]
1550 3C 02           cmp al, 2
1552 0F 85 00 00   r jne .writeEA127
1556 FF 36 3D 01     push word [disp]
155A E8 B8 FE        call genCode16
155D 83 C4 02        add  sp, 2
1560                
1560                ;-660 }
1560                
1560                .writeEA127:
1560                
1560                ;-661 
1560                
1560                
1560                ;-662 int genImmediate() {
1560 C9              LEAVE
1561 C3              ret
leaving: writeEA, loc labels: 17, loc jmp forward: 17
1562                ENDP
1562                
entering: genImmediate
1562                genImmediate: PROC
1562                
1562                ;-663     if (wflag) if (OpSize == DWORD) genCode32(imme);
1562                
1562 A0 38 01        mov al, [wflag]
1565 08 C0           or  al, al
1567 0F 84 00 00   r je .genImmediate128
156B A0 37 01        mov al, [OpSize]
156E 3C 03           cmp al, 3
1570 0F 85 00 00   r jne .genImmediate129
1574 FF 36 3F 01     push word [imme]
1578 E8 B7 FE        call genCode32
157B 83 C4 02        add  sp, 2
157E                
157E                ;-664         //todo imme long
157E                
157E                
157E                ;-665         else genCode16(imme);
157E                
157E E9 00 00      R jmp .genImmediate130
1581                .genImmediate129:
1581 FF 36 3F 01     push word [imme]
1585 E8 8D FE        call genCode16
1588 83 C4 02        add  sp, 2
158B                
158B                ;-666     else       genCode8 (imme);
158B                
158B                .genImmediate130:
158B E9 00 00      R jmp .genImmediate131
158E                .genImmediate128:
158E FF 36 3F 01     push word [imme]
1592 E8 EA FD        call genCode8
1595 83 C4 02        add  sp, 2
1598                
1598                ;-667 }
1598                
1598                .genImmediate131:
1598                
1598                ;-668 
1598                
1598                
1598                ;-669 int setwflag() {//word size, bit 0
1598                
1598 C3              ret
leaving: genImmediate, loc labels: 4, loc jmp forward: 4
1599                ENDP
1599                
entering: setwflag
1599                setwflag: PROC
1599                
1599                ;-670     wflag=0;
1599                
1599 B8 00 00        mov ax, 0
159C A2 38 01        mov byte [wflag], al
159F                
159F                ;-671     if (OpSize == 0) {//do not override OpSize
159F                
159F A0 37 01        mov al, [OpSize]
15A2 3C 00           cmp al, 0
15A4 0F 85 00 00   r jne .setwflag132
15A8                
15A8                ;-672         if (Op == REG) OpSize=R1Type;
15A8                
15A8 A0 2D 01        mov al, [Op]
15AB 3C 02           cmp al, 2
15AD 0F 85 00 00   r jne .setwflag133
15B1 A0 36 01        mov al, [R1Type]
15B4 A2 37 01        mov byte [OpSize], al
15B7                
15B7                ;-673         if (Op2== REG) OpSize=R2Type;
15B7                
15B7                .setwflag133:
15B7 A0 2E 01        mov al, [Op2]
15BA 3C 02           cmp al, 2
15BC 0F 85 00 00   r jne .setwflag134
15C0 A0 35 01        mov al, [R2Type]
15C3 A2 37 01        mov byte [OpSize], al
15C6                
15C6                ;-674         if (R2Type== SEGREG) OpSize=WORD;
15C6                
15C6                .setwflag134:
15C6 A0 35 01        mov al, [R2Type]
15C9 3C 04           cmp al, 4
15CB 0F 85 00 00   r jne .setwflag135
15CF B8 02 00        mov ax, 2
15D2 A2 37 01        mov byte [OpSize], al
15D5                
15D5                ;-675         if (R1Type == SEGREG) OpSize=WORD;
15D5                
15D5                .setwflag135:
15D5 A0 36 01        mov al, [R1Type]
15D8 3C 04           cmp al, 4
15DA 0F 85 00 00   r jne .setwflag136
15DE B8 02 00        mov ax, 2
15E1 A2 37 01        mov byte [OpSize], al
15E4                
15E4                ;-676     }
15E4                
15E4                .setwflag136:
15E4                
15E4                ;-677     if (OpSize  == DWORD) {gen66h(); wflag=1;}
15E4                
15E4                .setwflag132:
15E4 A0 37 01        mov al, [OpSize]
15E7 3C 03           cmp al, 3
15E9 0F 85 00 00   r jne .setwflag137
15ED E8 E5 FD        call gen66h
15F0 B8 01 00        mov ax, 1
15F3 A2 38 01        mov byte [wflag], al
15F6                
15F6                ;-678     if (OpSize  ==  WORD) wflag=1;
15F6                
15F6                .setwflag137:
15F6 A0 37 01        mov al, [OpSize]
15F9 3C 02           cmp al, 2
15FB 0F 85 00 00   r jne .setwflag138
15FF B8 01 00        mov ax, 1
1602 A2 38 01        mov byte [wflag], al
1605                
1605                ;-679 }
1605                
1605                .setwflag138:
1605                
1605                ;-680 int setsflag() {//sign-extend, bit 1, only PUSH, ALU, IMUL3
1605                
1605 C3              ret
leaving: setwflag, loc labels: 7, loc jmp forward: 7
1606                ENDP
1606                
entering: setsflag
1606                setsflag: PROC
1606                
1606                ;-681     unsigned int ui;
1606                
1606                
1606                ;-682     sflag=2;
1606                
1606                ;Function : setsflag, Number of local variables: 1
1606                ;   # type sign width addr used name   list of local variables
1606                ;  200 var unsg word   681 NULL ui = bp-2;
1606 C8 02 00 00     ENTER  2,0
160A B8 02 00        mov ax, 2
160D A2 3A 01        mov byte [sflag], al
1610                
1610                ;-683     ui = imme & 0xFF80;//is greater than signed 127?
1610                
1610 A1 3F 01        mov ax, [imme]
1613 25 80 FF        and ax, 65408
1616 89 46 FE        mov [bp-2], ax
1619                
1619                ;-684     if(ui != 0) sflag = 0;
1619                
1619 8B 46 FE        mov ax, [bp-2]
161C 83 F8 00        cmp ax, 0
161F 0F 84 00 00   r je  .setsflag139
1623 B8 00 00        mov ax, 0
1626 A2 3A 01        mov byte [sflag], al
1629                
1629                ;-685     if (OpSize == BYTE) {
1629                
1629                .setsflag139:
1629 A0 37 01        mov al, [OpSize]
162C 3C 01           cmp al, 1
162E 0F 85 00 00   r jne .setsflag140
1632                
1632                ;-686         if (imme > 255) error1("too big for byte r/m");
1632                
1632 A1 3F 01        mov ax, [imme]
1635 3D FF 00        cmp ax, 255
1638 0F 8E 00 00   r jle .setsflag141
163C 68 AA AA      A push setsflag_0
163F E8 F9 F3        call error1
1642 83 C4 02        add  sp, 2
1645                
1645                ;-687         sflag=0;//byte reg does not need sign extended
1645                
1645                .setsflag141:
1645 B8 00 00        mov ax, 0
1648 A2 3A 01        mov byte [sflag], al
164B                
164B                ;-688     }
164B                
164B                
164B                ;-689 }
164B                
164B                .setsflag140:
164B                
164B                ;-690 int checkConstSize(unsigned int ui) {
164B C9              LEAVE
164C C3              ret
164D 74 6F 6F 20 62 setsflag_0 db "too big for byte r/m",0
leaving: setsflag, loc labels: 4, loc jmp forward: 4
1662                ENDP
1662                
entering: checkConstSize
1662                checkConstSize: PROC
1662                
1662                ;-691     if (ui > 127   ) return 0;//is near; return sflag
1662                
1662                ;Function : checkConstSize, Number of local variables: 1
1662                ;   # type sign width addr used name   list of local variables
1662                ;  200 var unsg word   690 NULL ui = bp+4;
1662 C8 00 00 00     ENTER  0,0
1666 8B 46 04        mov ax, [bp+4]
1669 83 F8 7F        cmp ax, 127
166C 0F 8E 00 00   r jle .checkConstSize142
1670 B8 00 00        mov ax, 0
1673 E9 00 00      R jmp .retncheckConstSize
1676                
1676                ;-692     if (ui < 0xFF80) return 0;//-128dez
1676                
1676                .checkConstSize142:
1676 8B 46 04        mov ax, [bp+4]
1679 3D 80 FF        cmp ax, 65408
167C 0F 8D 00 00   r jge .checkConstSize143
1680 B8 00 00        mov ax, 0
1683 E9 00 00      R jmp .retncheckConstSize
1686                
1686                ;-693     return 2;// is short
1686                
1686                .checkConstSize143:
1686 B8 02 00        mov ax, 2
1689 E9 00 00      R jmp .retncheckConstSize
168C                
168C                ;-694 }
168C                
168C                
168C                ;-695 
168C                
168C                
168C                ;-696 
168C                
168C                
168C                ;-697 int ChangeDirection() {
168C                
168C C9              .retncheckConstSize: LEAVE
168D C3              ret
leaving: checkConstSize, loc labels: 3, loc jmp forward: 5
168E                ENDP
168E                
entering: ChangeDirection
168E                ChangeDirection: PROC
168E                
168E                ;-698     char c;
168E                
168E                
168E                ;-699     c=Op;     Op    =Op2;    Op2   =c;
168E                
168E                ;Function : ChangeDirection, Number of local variables: 1
168E                ;   # type sign width addr used name   list of local variables
168E                ;  200 var sign byte   698 NULL c = bp-2;
168E C8 02 00 00     ENTER  2,0
1692 A0 2D 01        mov al, [Op]
1695 88 46 FE        mov [bp-2], al
1698 A0 2E 01        mov al, [Op2]
169B A2 2D 01        mov byte [Op], al
169E 8A 46 FE        mov al, [bp-2]
16A1 A2 2E 01        mov byte [Op2], al
16A4                
16A4                ;-700     c=R1Type; R1Type=R2Type; R2Type=c;
16A4                
16A4 A0 36 01        mov al, [R1Type]
16A7 88 46 FE        mov [bp-2], al
16AA A0 35 01        mov al, [R2Type]
16AD A2 36 01        mov byte [R1Type], al
16B0 8A 46 FE        mov al, [bp-2]
16B3 A2 35 01        mov byte [R2Type], al
16B6                
16B6                ;-701     c=R1No;   R1No  =R2No;   R2No  =c;
16B6                
16B6 A0 34 01        mov al, [R1No]
16B9 88 46 FE        mov [bp-2], al
16BC A0 33 01        mov al, [R2No]
16BF A2 34 01        mov byte [R1No], al
16C2 8A 46 FE        mov al, [bp-2]
16C5 A2 33 01        mov byte [R2No], al
16C8                
16C8                ;-702     dflag=2;
16C8                
16C8 B8 02 00        mov ax, 2
16CB A2 39 01        mov byte [dflag], al
16CE                
16CE                ;-703 }
16CE                
16CE                
16CE                ;-704 
16CE                
16CE                
16CE                ;-705 int getTokeType() {
16CE C9              LEAVE
16CF C3              ret
leaving: ChangeDirection, loc labels: 0, loc jmp forward: 0
16D0                ENDP
16D0                
entering: getTokeType
16D0                getTokeType: PROC
16D0                
16D0                ;-706     char c;
16D0                
16D0                
16D0                ;-707     skipBlank();
16D0                
16D0                ;Function : getTokeType, Number of local variables: 1
16D0                ;   # type sign width addr used name   list of local variables
16D0                ;  200 var sign byte   706 NULL c = bp-2;
16D0 C8 02 00 00     ENTER  2,0
16D4 E8 F5 F6        call skipBlank
16D7                
16D7                ;-708     c = *InputPtr;
16D7                
16D7 8B 1E 14 01     mov bx, [InputPtr]
16DB 8A 07           mov al, [bx]
16DD B4 00           mov ah, 0
16DF 88 46 FE        mov [bp-2], al
16E2                
16E2                ;-709     if (c == 0)   {TokeType=0; return; }//last line or empty line
16E2                
16E2 8A 46 FE        mov al, [bp-2]
16E5 3C 00           cmp al, 0
16E7 0F 85 00 00   r jne .getTokeType144
16EB B8 00 00        mov ax, 0
16EE A2 2C 01        mov byte [TokeType], al
16F1 E9 00 00      R jmp .retngetTokeType
16F4                
16F4                ;-710     if (c == ';') {TokeType=0; return; }//comment
16F4                
16F4                .getTokeType144:
16F4 8A 46 FE        mov al, [bp-2]
16F7 3C 3B           cmp al, 59
16F9 0F 85 00 00   r jne .getTokeType145
16FD B8 00 00        mov ax, 0
1700 A2 2C 01        mov byte [TokeType], al
1703 E9 00 00      R jmp .retngetTokeType
1706                
1706                ;-711     if (digit(c)) {getDigit(c); TokeType=DIGIT; return;}//ret:1=SymbolInt
1706                
1706                .getTokeType145:
1706 8A 46 FE        mov al, byte [bp-2]
1709 B4 00           mov ah, 0
170B 50              push ax
170C E8 8D EA        call digit
170F 83 C4 02        add  sp, 2
1712 08 C0           or  al, al
1714 0F 84 00 00   r je .getTokeType146
1718 8A 46 FE        mov al, byte [bp-2]
171B B4 00           mov ah, 0
171D 50              push ax
171E E8 D6 F6        call getDigit
1721 83 C4 02        add  sp, 2
1724 B8 01 00        mov ax, 1
1727 A2 2C 01        mov byte [TokeType], al
172A E9 00 00      R jmp .retngetTokeType
172D                
172D                ;-712     if (letterE (c)) {getName(c); TokeType=ALNUME; return;}//ret:2=Symbol
172D                
172D                .getTokeType146:
172D 8A 46 FE        mov al, byte [bp-2]
1730 B4 00           mov ah, 0
1732 50              push ax
1733 E8 E8 E9        call letterE
1736 83 C4 02        add  sp, 2
1739 08 C0           or  al, al
173B 0F 84 00 00   r je .getTokeType147
173F 8A 46 FE        mov al, byte [bp-2]
1742 B4 00           mov ah, 0
1744 50              push ax
1745 E8 FF F6        call getName
1748 83 C4 02        add  sp, 2
174B B8 03 00        mov ax, 3
174E A2 2C 01        mov byte [TokeType], al
1751 E9 00 00      R jmp .retngetTokeType
1754                
1754                ;-713     TokeType=NOALNUME;
1754                
1754                .getTokeType147:
1754 B8 04 00        mov ax, 4
1757 A2 2C 01        mov byte [TokeType], al
175A                
175A                ;-714 }
175A                
175A                
175A                ;-715 
175A                
175A                
175A                ;-716 int isToken(char c) {
175A                
175A C9              .retngetTokeType: LEAVE
175B C3              ret
leaving: getTokeType, loc labels: 5, loc jmp forward: 8
175C                ENDP
175C                
entering: isToken
175C                isToken: PROC
175C                
175C                ;-717     skipBlank();
175C                
175C                ;Function : isToken, Number of local variables: 1
175C                ;   # type sign width addr used name   list of local variables
175C                ;  200 var sign byte   716 NULL c = bp+4;
175C C8 00 00 00     ENTER  0,0
1760 E8 69 F6        call skipBlank
1763                
1763                ;-718     if (*InputPtr == c) {
1763                
1763 8B 1E 14 01     mov bx, [InputPtr]
1767 8A 07           mov al, [bx]
1769 B4 00           mov ah, 0
176B 3A 46 04        cmp al, [bp+4]
176E 0F 85 00 00   r jne .isToken148
1772                
1772                ;-719         InputPtr++;
1772                
1772 FF 06 14 01     inc  word[InputPtr]
1776                
1776                ;-720         return 1;
1776                
1776 B8 01 00        mov ax, 1
1779 E9 00 00      R jmp .retnisToken
177C                
177C                ;-721         }
177C                
177C                
177C                ;-722     return 0;
177C                
177C                .isToken148:
177C B8 00 00        mov ax, 0
177F E9 00 00      R jmp .retnisToken
1782                
1782                ;-723 }
1782                
1782                
1782                ;-724 
1782                
1782                
1782                ;-725 
1782                
1782                
1782                ;-726 int need(char c) {
1782                
1782 C9              .retnisToken: LEAVE
1783 C3              ret
leaving: isToken, loc labels: 2, loc jmp forward: 3
1784                ENDP
1784                
entering: need
1784                need: PROC
1784                
1784                ;-727     if (isToken(c)) {
1784                
1784                ;Function : need, Number of local variables: 1
1784                ;   # type sign width addr used name   list of local variables
1784                ;  200 var sign byte   726 NULL c = bp+4;
1784 C8 00 00 00     ENTER  0,0
1788 8A 46 04        mov al, byte [bp+4]
178B B4 00           mov ah, 0
178D 50              push ax
178E E8 CB FF        call isToken
1791 83 C4 02        add  sp, 2
1794 08 C0           or  al, al
1796 0F 84 00 00   r je .need149
179A                
179A                ;-728         getTokeType();
179A                
179A E8 33 FF        call getTokeType
179D                
179D                ;-729         return;
179D                
179D E9 00 00      R jmp .retnneed
17A0                
17A0                ;-730         }
17A0                
17A0                
17A0                ;-731     error1();
17A0                
17A0                .need149:
17A0 E8 98 F2        call error1
17A3                
17A3                ;-732     prs(". need: ");
17A3                
17A3 68 AA AA      A push need_0
17A6 E8 86 EF        call prs
17A9 83 C4 02        add  sp, 2
17AC                
17AC                ;-733     prc(c);
17AC                
17AC 8A 46 04        mov al, byte [bp+4]
17AF B4 00           mov ah, 0
17B1 50              push ax
17B2 E8 22 EF        call prc
17B5 83 C4 02        add  sp, 2
17B8                
17B8                ;-734 }
17B8                
17B8                
17B8                ;-735 int skipRest() {
17B8                
17B8 C9              .retnneed: LEAVE
17B9 C3              ret
17BA 2E 20 6E 65 65 need_0 db ". need: ",0
leaving: need, loc labels: 3, loc jmp forward: 3
17C3                ENDP
17C3                
entering: skipRest
17C3                skipRest: PROC
17C3                
17C3                ;-736     getTokeType();
17C3                
17C3 E8 0A FF        call getTokeType
17C6                
17C6                ;-737     if(TokeType)error1("extra char ignored");
17C6                
17C6 A0 2C 01        mov al, [TokeType]
17C9 08 C0           or  al, al
17CB 0F 84 00 00   r je .skipRest150
17CF 68 AA AA      A push skipRest_0
17D2 E8 66 F2        call error1
17D5 83 C4 02        add  sp, 2
17D8                
17D8                ;-738 }
17D8                
17D8                .skipRest150:
17D8                
17D8                ;-739 
17D8                
17D8                
17D8                ;-740 
17D8                
17D8                
17D8                ;-741 int checkOpL() {
17D8                
17D8 C3              ret
17D9 65 78 74 72 61 skipRest_0 db "extra char ignored",0
leaving: skipRest, loc labels: 2, loc jmp forward: 2
17EC                ENDP
17EC                
entering: checkOpL
17EC                checkOpL: PROC
17EC                
17EC                ;-742     if (Op == ADR) implerror();
17EC                
17EC A0 2D 01        mov al, [Op]
17EF 3C 03           cmp al, 3
17F1 0F 85 00 00   r jne .checkOpL151
17F5 E8 51 F3        call implerror
17F8                
17F8                ;-743     if (R1Type==SEGREG) {segregerror();return;}//only move,push,pop
17F8                
17F8                .checkOpL151:
17F8 A0 36 01        mov al, [R1Type]
17FB 3C 04           cmp al, 4
17FD 0F 85 00 00   r jne .checkOpL152
1801 E8 0D F4        call segregerror
1804 E9 00 00      R jmp .retncheckOpL
1807                
1807                ;-744     setwflag();
1807                
1807                .checkOpL152:
1807 E8 8F FD        call setwflag
180A                
180A                ;-745     if (OpSize == 0) error1("no op size declared");
180A                
180A A0 37 01        mov al, [OpSize]
180D 3C 00           cmp al, 0
180F 0F 85 00 00   r jne .checkOpL153
1813 68 AA AA      A push checkOpL_0
1816 E8 22 F2        call error1
1819 83 C4 02        add  sp, 2
181C                
181C                ;-746     if (OpSize == R1Type) return;
181C                
181C                .checkOpL153:
181C A0 37 01        mov al, [OpSize]
181F 3A 06 36 01     cmp al, [R1Type]
1823 0F 85 00 00   r jne .checkOpL154
1827 E9 00 00      R jmp .retncheckOpL
182A                
182A                ;-747     if (Op == REG) if (R1Type==0) error1("no register defined");
182A                
182A                .checkOpL154:
182A A0 2D 01        mov al, [Op]
182D 3C 02           cmp al, 2
182F 0F 85 00 00   r jne .checkOpL155
1833 A0 36 01        mov al, [R1Type]
1836 3C 00           cmp al, 0
1838 0F 85 00 00   r jne .checkOpL156
183C 68 AA AA      A push checkOpL_1
183F E8 F9 F1        call error1
1842 83 C4 02        add  sp, 2
1845                
1845                ;-748 }
1845                
1845                .checkOpL156:
1845                .checkOpL155:
1845                
1845                ;-749 
1845                
1845                
1845                ;-750 int searchLabel() {
1845                
1845                 .retncheckOpL:
1845 C3              ret
1846 6E 6F 20 6F 70 checkOpL_0 db "no op size declared",0
185A 6E 6F 20 72 65 checkOpL_1 db "no register defined",0
leaving: checkOpL, loc labels: 9, loc jmp forward: 10
186E                ENDP
186E                
entering: searchLabel
186E                searchLabel: PROC
186E                
186E                ;-751     int LIx; char *p;
186E                
186E                
186E                ;-752     p = &LabelNames;
186E                
186E                ;Function : searchLabel, Number of local variables: 2
186E                ;   # type sign width addr used name   list of local variables
186E                ;  200 var sign word   751 NULL LIx = bp-2
186E                ;  201 ptr sign byte   751 NULL p = bp-4;
186E C8 04 00 00     ENTER  4,0
1872 B8 5A 77        mov ax, LabelNames
1875 89 46 FC        mov [bp-4], ax
1878                
1878                ;-753     LIx = 1;
1878                
1878 B8 01 00        mov ax, 1
187B 89 46 FE        mov [bp-2], ax
187E                
187E                ;-754     while (LIx <= LabelMaxIx) {
187E                
187E                .searchLabel157:
187E 8B 46 FE        mov ax, [bp-2]
1881 3B 06 4A 01     cmp ax, [LabelMaxIx]
1885 0F 8F 00 00   r jg  .searchLabel158
1889                
1889                ;-755         if (eqstr(p, Symbol)) return LIx;//pos of label
1889                
1889 8D 06 30 75     lea  ax, [Symbol]
188D 50              push ax
188E 55              push word [bp-4]
188F E8 CE E9        call eqstr
1892 83 C4 04        add  sp, 4
1895 08 C0           or  al, al
1897 0F 84 00 00   r je .searchLabel159
189B 8B 46 FE        mov ax, [bp-2]
189E E9 00 00      R jmp .retnsearchLabel
18A1                
18A1                ;-756         p=strlen(p) + p;
18A1                
18A1                .searchLabel159:
18A1 55              push word [bp-4]
18A2 E8 5D E9        call strlen
18A5 83 C4 02        add  sp, 2
18A8 03 46 FC        add ax, [bp-4]
18AB 89 46 FC        mov [bp-4], ax
18AE                
18AE                ;-757         p++;
18AE                
18AE FF 46 FC        inc  word[bp-4]
18B1                
18B1                ;-758         LIx++;
18B1                
18B1 FF 46 FE        inc  word[bp-2]
18B4                
18B4                ;-759     }
18B4                
18B4                
18B4                ;-760     return 0;
18B4                
18B4 EB C8           jmp .searchLabel157
18B6                .searchLabel158:
18B6 B8 00 00        mov ax, 0
18B9 E9 00 00      R jmp .retnsearchLabel
18BC                
18BC                ;-761 }
18BC                
18BC                
18BC                ;-762 
18BC                
18BC                
18BC                ;-763 int getOp1() {//scan for a single operand
18BC                
18BC C9              .retnsearchLabel: LEAVE
18BD C3              ret
leaving: searchLabel, loc labels: 4, loc jmp forward: 4
18BE                ENDP
18BE                
entering: getOp1
18BE                getOp1: PROC
18BE                
18BE                ;-764 //return:0, IMM, REG, ADR (not MEM)
18BE                
18BE                
18BE                ;-765 //set   :R2Type, R2No by testReg
18BE                
18BE                
18BE                ;-766 //set   :LabelIx by searchLabel
18BE                
18BE                
18BE                ;-767     if (TokeType == 0)      return 0;
18BE                
18BE A0 2C 01        mov al, [TokeType]
18C1 3C 00           cmp al, 0
18C3 0F 85 00 00   r jne .getOp1160
18C7 B8 00 00        mov ax, 0
18CA E9 00 00      R jmp .retngetOp1
18CD                
18CD                ;-768     if (TokeType == DIGIT)  return IMM;
18CD                
18CD                .getOp1160:
18CD A0 2C 01        mov al, [TokeType]
18D0 3C 01           cmp al, 1
18D2 0F 85 00 00   r jne .getOp1161
18D6 B8 01 00        mov ax, 1
18D9 E9 00 00      R jmp .retngetOp1
18DC                
18DC                ;-769     if (TokeType == ALNUME) {
18DC                
18DC                .getOp1161:
18DC A0 2C 01        mov al, [TokeType]
18DF 3C 03           cmp al, 3
18E1 0F 85 00 00   r jne .getOp1162
18E5                
18E5                ;-770         R2No=testReg();
18E5                
18E5 E8 28 EA        call testReg
18E8 A2 33 01        mov byte [R2No], al
18EB                
18EB                ;-771         if (R2Type)        return REG;
18EB                
18EB A0 35 01        mov al, [R2Type]
18EE 08 C0           or  al, al
18F0 0F 84 00 00   r je .getOp1163
18F4 B8 02 00        mov ax, 2
18F7 E9 00 00      R jmp .retngetOp1
18FA                
18FA                ;-772         LabelIx=searchLabel();
18FA                
18FA                .getOp1163:
18FA E8 71 FF        call searchLabel
18FD A3 4E 01        mov word [LabelIx], ax
1900                
1900                ;-773         return ADR;
1900                
1900 B8 03 00        mov ax, 3
1903 E9 00 00      R jmp .retngetOp1
1906                
1906                ;-774     }
1906                
1906                
1906                ;-775     return 0;
1906                
1906                .getOp1162:
1906 B8 00 00        mov ax, 0
1909 E9 00 00      R jmp .retngetOp1
190C                
190C                ;-776 }
190C                
190C                
190C                ;-777 
190C                
190C                
190C                ;-778 int getIndReg1() {
190C                
190C                 .retngetOp1:
190C C3              ret
leaving: getOp1, loc labels: 5, loc jmp forward: 9
190D                ENDP
190D                
entering: getIndReg1
190D                getIndReg1: PROC
190D                
190D                ;-779     if (R2Type !=WORD) indexerror();
190D                
190D A0 35 01        mov al, [R2Type]
1910 3C 02           cmp al, 2
1912 0F 84 00 00   r je  .getIndReg1164
1916 E8 4A F2        call indexerror
1919                
1919                ;-780     if (R2No==3) rm=7;//BX
1919                
1919                .getIndReg1164:
1919 A0 33 01        mov al, [R2No]
191C 3C 03           cmp al, 3
191E 0F 85 00 00   r jne .getIndReg1165
1922 B8 07 00        mov ax, 7
1925 A2 3B 01        mov byte [rm], al
1928                
1928                ;-781     if (R2No==5) rm=6;//BP, change to BP+0
1928                
1928                .getIndReg1165:
1928 A0 33 01        mov al, [R2No]
192B 3C 05           cmp al, 5
192D 0F 85 00 00   r jne .getIndReg1166
1931 B8 06 00        mov ax, 6
1934 A2 3B 01        mov byte [rm], al
1937                
1937                ;-782     if (R2No==7) rm=5;//DI
1937                
1937                .getIndReg1166:
1937 A0 33 01        mov al, [R2No]
193A 3C 07           cmp al, 7
193C 0F 85 00 00   r jne .getIndReg1167
1940 B8 05 00        mov ax, 5
1943 A2 3B 01        mov byte [rm], al
1946                
1946                ;-783     if (R2No==6) rm=4;//SI
1946                
1946                .getIndReg1167:
1946 A0 33 01        mov al, [R2No]
1949 3C 06           cmp al, 6
194B 0F 85 00 00   r jne .getIndReg1168
194F B8 04 00        mov ax, 4
1952 A2 3B 01        mov byte [rm], al
1955                
1955                ;-784     if (rm==0) indexerror();
1955                
1955                .getIndReg1168:
1955 A0 3B 01        mov al, [rm]
1958 3C 00           cmp al, 0
195A 0F 85 00 00   r jne .getIndReg1169
195E E8 02 F2        call indexerror
1961                
1961                ;-785 }
1961                
1961                .getIndReg1169:
1961                
1961                ;-786 int getIndReg2() {char m; m=4;//because m=0 is BX+DI
1961                
1961 C3              ret
leaving: getIndReg1, loc labels: 6, loc jmp forward: 6
1962                ENDP
1962                
entering: getIndReg2
1962                getIndReg2: PROC
1962                ;Function : getIndReg2, Number of local variables: 1
1962                ;   # type sign width addr used name   list of local variables
1962                ;  200 var sign byte   786 NULL m = bp-2;
1962 C8 02 00 00     ENTER  2,0
1966 B8 04 00        mov ax, 4
1969 88 46 FE        mov [bp-2], al
196C                
196C                ;-787     if (R2Type !=WORD) indexerror();
196C                
196C A0 35 01        mov al, [R2Type]
196F 3C 02           cmp al, 2
1971 0F 84 00 00   r je  .getIndReg2170
1975 E8 EB F1        call indexerror
1978                
1978                ;-788     if (R2No==7) if (rm==6) m=3;//BP+DI
1978                
1978                .getIndReg2170:
1978 A0 33 01        mov al, [R2No]
197B 3C 07           cmp al, 7
197D 0F 85 00 00   r jne .getIndReg2171
1981 A0 3B 01        mov al, [rm]
1984 3C 06           cmp al, 6
1986 0F 85 00 00   r jne .getIndReg2172
198A B8 03 00        mov ax, 3
198D 88 46 FE        mov [bp-2], al
1990                
1990                ;-789              else if (rm==7) m=1;//BX+DI
1990                
1990 E9 00 00      R jmp .getIndReg2173
1993                .getIndReg2172:
1993 A0 3B 01        mov al, [rm]
1996 3C 07           cmp al, 7
1998 0F 85 00 00   r jne .getIndReg2174
199C B8 01 00        mov ax, 1
199F 88 46 FE        mov [bp-2], al
19A2                
19A2                ;-790     if (R2No==6) if (rm==6) m=2;//BP+SI
19A2                
19A2                .getIndReg2174:
19A2                .getIndReg2173:
19A2                .getIndReg2171:
19A2 A0 33 01        mov al, [R2No]
19A5 3C 06           cmp al, 6
19A7 0F 85 00 00   r jne .getIndReg2175
19AB A0 3B 01        mov al, [rm]
19AE 3C 06           cmp al, 6
19B0 0F 85 00 00   r jne .getIndReg2176
19B4 B8 02 00        mov ax, 2
19B7 88 46 FE        mov [bp-2], al
19BA                
19BA                ;-791              else if (rm==7) m=0;//BX+SI
19BA                
19BA E9 00 00      R jmp .getIndReg2177
19BD                .getIndReg2176:
19BD A0 3B 01        mov al, [rm]
19C0 3C 07           cmp al, 7
19C2 0F 85 00 00   r jne .getIndReg2178
19C6 B8 00 00        mov ax, 0
19C9 88 46 FE        mov [bp-2], al
19CC                
19CC                ;-792     if (m > 3) indexerror();
19CC                
19CC                .getIndReg2178:
19CC                .getIndReg2177:
19CC                .getIndReg2175:
19CC 8A 46 FE        mov al, [bp-2]
19CF 3C 03           cmp al, 3
19D1 0F 8E 00 00   r jle .getIndReg2179
19D5 E8 8B F1        call indexerror
19D8                
19D8                ;-793     return m;
19D8                
19D8                .getIndReg2179:
19D8 8A 46 FE        mov al, [bp-2]
19DB E9 00 00      R jmp .retngetIndReg2
19DE                
19DE                ;-794 }
19DE                
19DE                
19DE                ;-795 int getMEM() {// e.g. [array+bp+si-4]
19DE                
19DE C9              .retngetIndReg2: LEAVE
19DF C3              ret
leaving: getIndReg2, loc labels: 11, loc jmp forward: 11
19E0                ENDP
19E0                
entering: getMEM
19E0                getMEM: PROC
19E0                
19E0                ;-796 //set: disp, rm, R2Type
19E0                
19E0                
19E0                ;-797     char c;
19E0                
19E0                
19E0                ;-798     disp=0; rm=0;
19E0                
19E0                ;Function : getMEM, Number of local variables: 1
19E0                ;   # type sign width addr used name   list of local variables
19E0                ;  200 var sign byte   797 NULL c = bp-2;
19E0 C8 02 00 00     ENTER  2,0
19E4 B8 00 00        mov ax, 0
19E7 A3 3D 01        mov word [disp], ax
19EA B8 00 00        mov ax, 0
19ED A2 3B 01        mov byte [rm], al
19F0                
19F0                ;-799     do {
19F0                
19F0                .getMEM180:
19F0                
19F0                ;-800         getTokeType();
19F0                
19F0 E8 DD FC        call getTokeType
19F3                
19F3                ;-801         c=getOp1();
19F3                
19F3 E8 C8 FE        call getOp1
19F6 88 46 FE        mov [bp-2], al
19F9                
19F9                ;-802         if (c ==   0) syntaxerror();
19F9                
19F9 8A 46 FE        mov al, [bp-2]
19FC 3C 00           cmp al, 0
19FE 0F 85 00 00   r jne .getMEM181
1A02 E8 33 F2        call syntaxerror
1A05                
1A05                ;-803         if (c == REG) {
1A05                
1A05                .getMEM181:
1A05 8A 46 FE        mov al, [bp-2]
1A08 3C 02           cmp al, 2
1A0A 0F 85 00 00   r jne .getMEM182
1A0E                
1A0E                ;-804             isDirect=0;
1A0E                
1A0E B8 00 00        mov ax, 0
1A11 A2 3C 01        mov byte [isDirect], al
1A14                
1A14                ;-805             if (rm) rm=getIndReg2();
1A14                
1A14 A0 3B 01        mov al, [rm]
1A17 08 C0           or  al, al
1A19 0F 84 00 00   r je .getMEM183
1A1D E8 42 FF        call getIndReg2
1A20 A2 3B 01        mov byte [rm], al
1A23                
1A23                ;-806             else getIndReg1();
1A23                
1A23 E9 00 00      R jmp .getMEM184
1A26                .getMEM183:
1A26 E8 E4 FE        call getIndReg1
1A29                
1A29                ;-807         }
1A29                
1A29                .getMEM184:
1A29                
1A29                ;-808         if (c == ADR) {
1A29                
1A29                .getMEM182:
1A29 8A 46 FE        mov al, [bp-2]
1A2C 3C 03           cmp al, 3
1A2E 0F 85 00 00   r jne .getMEM185
1A32                
1A32                ;-809             if (LabelIx)    disp=disp+LabelAddr[LabelIx];
1A32                
1A32 A1 4E 01        mov ax, [LabelIx]
1A35 08 C0           or  al, al
1A37 0F 84 00 00   r je .getMEM186
1A3B A1 3D 01        mov ax, [disp]
1A3E 8B 1E 4E 01     mov bx, [LabelIx]
1A42 D1 E3           shl bx, 1
1A44 03 47 CA        add ax, [LabelAddr + bx]
1A47 A3 3D 01        mov word [disp], ax
1A4A                
1A4A                ;-810             else notfounderror();
1A4A                
1A4A E9 00 00      R jmp .getMEM187
1A4D                .getMEM186:
1A4D E8 58 F0        call notfounderror
1A50                
1A50                ;-811         }
1A50                
1A50                .getMEM187:
1A50                
1A50                ;-812         if (c == IMM) disp=disp+SymbolInt;
1A50                
1A50                .getMEM185:
1A50 8A 46 FE        mov al, [bp-2]
1A53 3C 01           cmp al, 1
1A55 0F 85 00 00   r jne .getMEM188
1A59 A1 3D 01        mov ax, [disp]
1A5C 03 06 0E 01     add ax, [SymbolInt]
1A60 A3 3D 01        mov word [disp], ax
1A63                
1A63                ;-813         if (isToken('-')) {
1A63                
1A63                .getMEM188:
1A63 6A 2D           push 45
1A65 E8 F4 FC        call isToken
1A68 83 C4 02        add  sp, 2
1A6B 08 C0           or  al, al
1A6D 0F 84 00 00   r je .getMEM189
1A71                
1A71                ;-814             getTokeType();
1A71                
1A71 E8 5C FC        call getTokeType
1A74                
1A74                ;-815             if (TokeType != DIGIT) numbererror();
1A74                
1A74 A0 2C 01        mov al, [TokeType]
1A77 3C 01           cmp al, 1
1A79 0F 84 00 00   r je  .getMEM190
1A7D E8 25 F1        call numbererror
1A80                
1A80                ;-816             disp = disp - SymbolInt;
1A80                
1A80                .getMEM190:
1A80 A1 3D 01        mov ax, [disp]
1A83 2B 06 0E 01     sub ax, [SymbolInt]
1A87 A3 3D 01        mov word [disp], ax
1A8A                
1A8A                ;-817         }
1A8A                
1A8A                
1A8A                ;-818     } while (isToken('+'));
1A8A                
1A8A                .getMEM189:
1A8A 6A 2B           push 43
1A8C E8 CD FC        call isToken
1A8F 83 C4 02        add  sp, 2
1A92 08 C0           or  al, al
1A94 0F 84 00 00   r je .getMEM191
1A98 E9 55 FF        jmp .getMEM180
1A9B                .getMEM191:
1A9B                
1A9B                ;-819     if (isToken(']') == 0) errorexit("] expected");
1A9B                
1A9B 6A 5D           push 93
1A9D E8 BC FC        call isToken
1AA0 83 C4 02        add  sp, 2
1AA3 83 F8 00        cmp ax, 0
1AA6 0F 85 00 00   r jne .getMEM192
1AAA 68 AA AA      A push getMEM_0
1AAD E8 E0 EF        call errorexit
1AB0 83 C4 02        add  sp, 2
1AB3                
1AB3                ;-820 }
1AB3                
1AB3                .getMEM192:
1AB3                
1AB3                ;-821 
1AB3                
1AB3                
1AB3                ;-822 int getOpR() {
1AB3 C9              LEAVE
1AB4 C3              ret
1AB5 5D 20 65 78 70 getMEM_0 db "] expected",0
leaving: getMEM, loc labels: 14, loc jmp forward: 13
1AC0                ENDP
1AC0                
entering: getOpR
1AC0                getOpR: PROC
1AC0                
1AC0                ;-823     Op2=getOp1();
1AC0                
1AC0 E8 FB FD        call getOp1
1AC3 A2 2E 01        mov byte [Op2], al
1AC6                
1AC6                ;-824     if (isToken('[')) {Op2 = MEM; getMEM();    return;}
1AC6                
1AC6 6A 5B           push 91
1AC8 E8 91 FC        call isToken
1ACB 83 C4 02        add  sp, 2
1ACE 08 C0           or  al, al
1AD0 0F 84 00 00   r je .getOpR193
1AD4 B8 04 00        mov ax, 4
1AD7 A2 2E 01        mov byte [Op2], al
1ADA E8 03 FF        call getMEM
1ADD E9 00 00      R jmp .retngetOpR
1AE0                
1AE0                ;-825     if (Op2 == 0)     {invaloperror();         return;}
1AE0                
1AE0                .getOpR193:
1AE0 A0 2E 01        mov al, [Op2]
1AE3 3C 00           cmp al, 0
1AE5 0F 85 00 00   r jne .getOpR194
1AE9 E8 98 F0        call invaloperror
1AEC E9 00 00      R jmp .retngetOpR
1AEF                
1AEF                ;-826     if (Op2 == IMM)   {imme=SymbolInt;         return;}
1AEF                
1AEF                .getOpR194:
1AEF A0 2E 01        mov al, [Op2]
1AF2 3C 01           cmp al, 1
1AF4 0F 85 00 00   r jne .getOpR195
1AF8 A1 0E 01        mov ax, [SymbolInt]
1AFB A3 3F 01        mov word [imme], ax
1AFE E9 00 00      R jmp .retngetOpR
1B01                
1B01                ;-827     if (Op2 == REG)                            return;
1B01                
1B01                .getOpR195:
1B01 A0 2E 01        mov al, [Op2]
1B04 3C 02           cmp al, 2
1B06 0F 85 00 00   r jne .getOpR196
1B0A E9 00 00      R jmp .retngetOpR
1B0D                
1B0D                ;-828     if (Op2 == ADR)   {
1B0D                
1B0D                .getOpR196:
1B0D A0 2E 01        mov al, [Op2]
1B10 3C 03           cmp al, 3
1B12 0F 85 00 00   r jne .getOpR197
1B16                
1B16                ;-829         if (LabelIx == 0) disp=0;
1B16                
1B16 A1 4E 01        mov ax, [LabelIx]
1B19 83 F8 00        cmp ax, 0
1B1C 0F 85 00 00   r jne .getOpR198
1B20 B8 00 00        mov ax, 0
1B23 A3 3D 01        mov word [disp], ax
1B26                
1B26                ;-830         else disp=LabelAddr[LabelIx];
1B26                
1B26 E9 00 00      R jmp .getOpR199
1B29                .getOpR198:
1B29 8B 1E 4E 01     mov bx, [LabelIx]
1B2D D1 E3           shl bx, 1
1B2F 8B 47 CA        mov ax, [LabelAddr + bx]
1B32 A3 3D 01        mov word [disp], ax
1B35                
1B35                ;-831         return;}
1B35                
1B35                .getOpR199:
1B35 E9 00 00      R jmp .retngetOpR
1B38                
1B38                ;-832     error1("Name of operand expected");
1B38                
1B38                .getOpR197:
1B38 68 AA AA      A push getOpR_0
1B3B E8 FD EE        call error1
1B3E 83 C4 02        add  sp, 2
1B41                
1B41                ;-833 }
1B41                
1B41                
1B41                ;-834 
1B41                
1B41                
1B41                ;-835 int getOpL() {//set: op=0,IMM,REG,ADR,MEM
1B41                
1B41                 .retngetOpR:
1B41 C3              ret
1B42 4E 61 6D 65 20 getOpR_0 db "Name of operand expected",0
leaving: getOpR, loc labels: 9, loc jmp forward: 13
1B5B                ENDP
1B5B                
entering: getOpL
1B5B                getOpL: PROC
1B5B                
1B5B                ;-836     getOpR();
1B5B                
1B5B E8 62 FF        call getOpR
1B5E                
1B5E                ;-837     Op=Op2;         Op2=0;
1B5E                
1B5E A0 2E 01        mov al, [Op2]
1B61 A2 2D 01        mov byte [Op], al
1B64 B8 00 00        mov ax, 0
1B67 A2 2E 01        mov byte [Op2], al
1B6A                
1B6A                ;-838     R1No=R2No;      R2No=0;
1B6A                
1B6A A0 33 01        mov al, [R2No]
1B6D A2 34 01        mov byte [R1No], al
1B70 B8 00 00        mov ax, 0
1B73 A2 33 01        mov byte [R2No], al
1B76                
1B76                ;-839     R1Type=R2Type;  R2Type=0;
1B76                
1B76 A0 35 01        mov al, [R2Type]
1B79 A2 36 01        mov byte [R1Type], al
1B7C B8 00 00        mov ax, 0
1B7F A2 35 01        mov byte [R2Type], al
1B82                
1B82                ;-840 }
1B82                
1B82                
1B82                ;-841 
1B82                
1B82                
1B82                ;-842 int get2Ops() {
1B82                
1B82 C3              ret
leaving: getOpL, loc labels: 0, loc jmp forward: 0
1B83                ENDP
1B83                
entering: get2Ops
1B83                get2Ops: PROC
1B83                
1B83                ;-843     getOpL();
1B83                
1B83 E8 D5 FF        call getOpL
1B86                
1B86                ;-844     need(',');
1B86                
1B86 6A 2C           push 44
1B88 E8 F9 FB        call need
1B8B 83 C4 02        add  sp, 2
1B8E                
1B8E                ;-845     getOpR();
1B8E                
1B8E E8 2F FF        call getOpR
1B91                
1B91                ;-846 }
1B91                
1B91                
1B91                ;-847 int check2Ops() {
1B91                
1B91 C3              ret
leaving: get2Ops, loc labels: 0, loc jmp forward: 0
1B92                ENDP
1B92                
entering: check2Ops
1B92                check2Ops: PROC
1B92                
1B92                ;-848     get2Ops();
1B92                
1B92 E8 EE FF        call get2Ops
1B95                
1B95                ;-849     if (Op ==   0) addrerror();
1B95                
1B95 A0 2D 01        mov al, [Op]
1B98 3C 00           cmp al, 0
1B9A 0F 85 00 00   r jne .check2Ops200
1B9E E8 69 EF        call addrerror
1BA1                
1BA1                ;-850     if (Op == ADR) invaloperror();
1BA1                
1BA1                .check2Ops200:
1BA1 A0 2D 01        mov al, [Op]
1BA4 3C 03           cmp al, 3
1BA6 0F 85 00 00   r jne .check2Ops201
1BAA E8 D7 EF        call invaloperror
1BAD                
1BAD                ;-851     if (Op == IMM) immeerror();
1BAD                
1BAD                .check2Ops201:
1BAD A0 2D 01        mov al, [Op]
1BB0 3C 01           cmp al, 1
1BB2 0F 85 00 00   r jne .check2Ops202
1BB6 E8 6B EF        call immeerror
1BB9                
1BB9                ;-852     if (Op2==   0) addrerror();
1BB9                
1BB9                .check2Ops202:
1BB9 A0 2E 01        mov al, [Op2]
1BBC 3C 00           cmp al, 0
1BBE 0F 85 00 00   r jne .check2Ops203
1BC2 E8 45 EF        call addrerror
1BC5                
1BC5                ;-853 //if (CodeType != 5) if (Op2==ADR) invaloperror();//only mov,add
1BC5                
1BC5                
1BC5                ;-854     setwflag();
1BC5                
1BC5                .check2Ops203:
1BC5 E8 D1 F9        call setwflag
1BC8                
1BC8                ;-855 }
1BC8                
1BC8                
1BC8                ;-856 
1BC8                
1BC8                
1BC8                ;-857 int storeJmp() {
1BC8                
1BC8 C3              ret
leaving: check2Ops, loc labels: 4, loc jmp forward: 4
1BC9                ENDP
1BC9                
entering: storeJmp
1BC9                storeJmp: PROC
1BC9                
1BC9                ;-858     unsigned int i;
1BC9                
1BC9                
1BC9                ;-859     JmpMaxIx++;
1BC9                
1BC9                ;Function : storeJmp, Number of local variables: 1
1BC9                ;   # type sign width addr used name   list of local variables
1BC9                ;  200 var unsg word   858 NULL i = bp-2;
1BC9 C8 02 00 00     ENTER  2,0
1BCD FF 06 54 01     inc  word[JmpMaxIx]
1BD1                
1BD1                ;-860     if (JmpMaxIx >= JMPMAX) errorexit("too many Jmp");
1BD1                
1BD1 A1 54 01        mov ax, [JmpMaxIx]
1BD4 3D C8 00        cmp ax, 200 ;unsigned : 1
1BD7 0F 8C 00 00   r jl  .storeJmp204
1BDB 68 AA AA      A push storeJmp_0
1BDE E8 AF EE        call errorexit
1BE1 83 C4 02        add  sp, 2
1BE4                
1BE4                ;-861     JmpNamePtr=strcpy(JmpNamePtr, Symbol);
1BE4                
1BE4                .storeJmp204:
1BE4 8D 06 30 75     lea  ax, [Symbol]
1BE8 50              push ax
1BE9 FF 36 50 01     push word [JmpNamePtr]
1BED E8 3A E6        call strcpy
1BF0 83 C4 04        add  sp, 4
1BF3 A3 50 01        mov word [JmpNamePtr], ax
1BF6                
1BF6                ;-862     JmpNamePtr++;
1BF6                
1BF6 FF 06 50 01     inc  word[JmpNamePtr]
1BFA                
1BFA                ;-863     i = JmpNamePtr - &JmpNames;
1BFA                
1BFA A1 50 01        mov ax, [JmpNamePtr]
1BFD 2D 7A 93        sub ax, JmpNames
1C00 89 46 FE        mov [bp-2], ax
1C03                
1C03                ;-864     if ( i >= JMPNAMESMAX) errorexit("too many Jmp names");
1C03                
1C03 8B 46 FE        mov ax, [bp-2]
1C06 3D 81 0F        cmp ax, 3969 ;unsigned : 0
1C09 0F 82 00 00   r jb  .storeJmp205
1C0D 68 AA AA      A push storeJmp_1
1C10 E8 7D EE        call errorexit
1C13 83 C4 02        add  sp, 2
1C16                
1C16                ;-865     JmpAddr[JmpMaxIx] = PC;
1C16                
1C16                .storeJmp205:
1C16 A1 23 01        mov ax, [PC]
1C19 8B 1E 54 01     mov bx, [JmpMaxIx]
1C1D D1 E3           shl bx, 1
1C1F 89 47 1A        mov [JmpAddr+bx], ax
1C22                
1C22                ;-866 }
1C22                
1C22                
1C22                ;-867 
1C22                
1C22                
1C22                ;-868 int storeLabel() {
1C22 C9              LEAVE
1C23 C3              ret
1C24 74 6F 6F 20 6D storeJmp_0 db "too many Jmp",0
1C31 74 6F 6F 20 6D storeJmp_1 db "too many Jmp names",0
leaving: storeJmp, loc labels: 4, loc jmp forward: 4
1C44                ENDP
1C44                
entering: storeLabel
1C44                storeLabel: PROC
1C44                
1C44                ;-869     unsigned int i;
1C44                
1C44                
1C44                ;-870     if(searchLabel()) error1("duplicate label");
1C44                
1C44                ;Function : storeLabel, Number of local variables: 1
1C44                ;   # type sign width addr used name   list of local variables
1C44                ;  200 var unsg word   869 NULL i = bp-2;
1C44 C8 02 00 00     ENTER  2,0
1C48 E8 23 FC        call searchLabel
1C4B 08 C0           or  al, al
1C4D 0F 84 00 00   r je .storeLabel206
1C51 68 AA AA      A push storeLabel_0
1C54 E8 E4 ED        call error1
1C57 83 C4 02        add  sp, 2
1C5A                
1C5A                ;-871     LabelMaxIx++;
1C5A                
1C5A                .storeLabel206:
1C5A FF 06 4A 01     inc  word[LabelMaxIx]
1C5E                
1C5E                ;-872     if (LabelMaxIx >= LABELADRMAX) errorexit("too many labels");
1C5E                
1C5E A1 4A 01        mov ax, [LabelMaxIx]
1C61 3D 58 02        cmp ax, 600 ;unsigned : 1
1C64 0F 8C 00 00   r jl  .storeLabel207
1C68 68 AA AA      A push storeLabel_1
1C6B E8 22 EE        call errorexit
1C6E 83 C4 02        add  sp, 2
1C71                
1C71                ;-873     LabelNamePtr=strcpy(LabelNamePtr, Symbol);
1C71                
1C71                .storeLabel207:
1C71 8D 06 30 75     lea  ax, [Symbol]
1C75 50              push ax
1C76 FF 36 46 01     push word [LabelNamePtr]
1C7A E8 AD E5        call strcpy
1C7D 83 C4 04        add  sp, 4
1C80 A3 46 01        mov word [LabelNamePtr], ax
1C83                
1C83                ;-874     LabelNamePtr++;
1C83                
1C83 FF 06 46 01     inc  word[LabelNamePtr]
1C87                
1C87                ;-875     i = LabelNamePtr - &LabelNames;
1C87                
1C87 A1 46 01        mov ax, [LabelNamePtr]
1C8A 2D 5A 77        sub ax, LabelNames
1C8D 89 46 FE        mov [bp-2], ax
1C90                
1C90                ;-876     if (i >= LABELNAMESMAX) errorexit("too many label names");
1C90                
1C90 8B 46 FE        mov ax, [bp-2]
1C93 3D 51 17        cmp ax, 5969 ;unsigned : 0
1C96 0F 82 00 00   r jb  .storeLabel208
1C9A 68 AA AA      A push storeLabel_2
1C9D E8 F0 ED        call errorexit
1CA0 83 C4 02        add  sp, 2
1CA3                
1CA3                ;-877     LabelAddr[LabelMaxIx] = PC + Origin;
1CA3                
1CA3                .storeLabel208:
1CA3 A1 23 01        mov ax, [PC]
1CA6 03 06 25 01     add ax, [Origin]
1CAA 8B 1E 4A 01     mov bx, [LabelMaxIx]
1CAE D1 E3           shl bx, 1
1CB0 89 47 CA        mov [LabelAddr+bx], ax
1CB3                
1CB3                ;-878 }
1CB3                
1CB3                
1CB3                ;-879 
1CB3                
1CB3                
1CB3                ;-880 
1CB3                
1CB3                
1CB3                ;-881 int genDB() {
1CB3 C9              LEAVE
1CB4 C3              ret
1CB5 64 75 70 6C 69 storeLabel_0 db "duplicate label",0
1CC5 74 6F 6F 20 6D storeLabel_1 db "too many labels",0
1CD5 74 6F 6F 20 6D storeLabel_2 db "too many label names",0
leaving: storeLabel, loc labels: 6, loc jmp forward: 6
1CEA                ENDP
1CEA                
entering: genDB
1CEA                genDB: PROC
1CEA                
1CEA                ;-882     char c;  char isloop;
1CEA                
1CEA                
1CEA                ;-883         isloop = 0;
1CEA                
1CEA                ;Function : genDB, Number of local variables: 2
1CEA                ;   # type sign width addr used name   list of local variables
1CEA                ;  200 var sign byte   882 NULL c = bp-2
1CEA                ;  201 var sign byte   882 NULL isloop = bp-4;
1CEA C8 04 00 00     ENTER  4,0
1CEE B8 00 00        mov ax, 0
1CF1 88 46 FC        mov [bp-4], al
1CF4                
1CF4                ;-884             do {
1CF4                
1CF4                .genDB209:
1CF4                
1CF4                ;-885                 if (isloop) getTokeType();//omit ,  
1CF4                
1CF4 8A 46 FC        mov al, [bp-4]
1CF7 08 C0           or  al, al
1CF9 0F 84 00 00   r je .genDB210
1CFD E8 D0 F9        call getTokeType
1D00                
1D00                ;-886                 if (TokeType == DIGIT) genCode8(SymbolInt);
1D00                
1D00                .genDB210:
1D00 A0 2C 01        mov al, [TokeType]
1D03 3C 01           cmp al, 1
1D05 0F 85 00 00   r jne .genDB211
1D09 FF 36 0E 01     push word [SymbolInt]
1D0D E8 6F F6        call genCode8
1D10 83 C4 02        add  sp, 2
1D13                
1D13                ;-887                 else {
1D13                
1D13 E9 00 00      R jmp .genDB212
1D16                .genDB211:
1D16                
1D16                ;-888                     skipBlank();
1D16                
1D16 E8 B3 F0        call skipBlank
1D19                
1D19                ;-889                     if (isToken('"')) {
1D19                
1D19 6A 22           push 34
1D1B E8 3E FA        call isToken
1D1E 83 C4 02        add  sp, 2
1D21 08 C0           or  al, al
1D23 0F 84 00 00   r je .genDB213
1D27                
1D27                ;-890                         do {
1D27                
1D27                .genDB214:
1D27                
1D27                ;-891                             c= *InputPtr;
1D27                
1D27 8B 1E 14 01     mov bx, [InputPtr]
1D2B 8A 07           mov al, [bx]
1D2D B4 00           mov ah, 0
1D2F 88 46 FE        mov [bp-2], al
1D32                
1D32                ;-892                             genCode8(c);
1D32                
1D32 8A 46 FE        mov al, byte [bp-2]
1D35 B4 00           mov ah, 0
1D37 50              push ax
1D38 E8 44 F6        call genCode8
1D3B 83 C4 02        add  sp, 2
1D3E                
1D3E                ;-893                             InputPtr++;
1D3E                
1D3E FF 06 14 01     inc  word[InputPtr]
1D42                
1D42                ;-894                         } while (*InputPtr != '"' );
1D42                
1D42 8B 1E 14 01     mov bx, [InputPtr]
1D46 8A 07           mov al, [bx]
1D48 B4 00           mov ah, 0
1D4A 83 F8 22        cmp ax, 34
1D4D 0F 84 00 00   r je  .genDB215
1D51 EB D4           jmp .genDB214
1D53                .genDB215:
1D53                
1D53                ;-895                         InputPtr++;
1D53                
1D53 FF 06 14 01     inc  word[InputPtr]
1D57                
1D57                ;-896                     }
1D57                
1D57                
1D57                ;-897                 } 
1D57                
1D57                .genDB213:
1D57                
1D57                ;-898                 isloop = 1;
1D57                
1D57                .genDB212:
1D57 B8 01 00        mov ax, 1
1D5A 88 46 FC        mov [bp-4], al
1D5D                
1D5D                ;-899             } while (isToken(','));
1D5D                
1D5D 6A 2C           push 44
1D5F E8 FA F9        call isToken
1D62 83 C4 02        add  sp, 2
1D65 08 C0           or  al, al
1D67 0F 84 00 00   r je .genDB216
1D6B EB 87           jmp .genDB209
1D6D                .genDB216:
1D6D                
1D6D                ;-900 }
1D6D                
1D6D                
1D6D                ;-901 
1D6D                
1D6D                
1D6D                ;-902 int getVariable() {
1D6D C9              LEAVE
1D6E C3              ret
leaving: genDB, loc labels: 8, loc jmp forward: 6
1D6F                ENDP
1D6F                
entering: getVariable
1D6F                getVariable: PROC
1D6F                
1D6F                ;-903     char c;
1D6F                
1D6F                
1D6F                ;-904     storeLabel();
1D6F                
1D6F                ;Function : getVariable, Number of local variables: 1
1D6F                ;   # type sign width addr used name   list of local variables
1D6F                ;  200 var sign byte   903 NULL c = bp-2;
1D6F C8 02 00 00     ENTER  2,0
1D73 E8 CE FE        call storeLabel
1D76                
1D76                ;-905     getTokeType();
1D76                
1D76 E8 57 F9        call getTokeType
1D79                
1D79                ;-906     if(TokeType==ALNUME) {//getName
1D79                
1D79 A0 2C 01        mov al, [TokeType]
1D7C 3C 03           cmp al, 3
1D7E 0F 85 00 00   r jne .getVariable217
1D82                
1D82                ;-907         lookCode();
1D82                
1D82 E8 83 F5        call lookCode
1D85                
1D85                ;-908         if (CodeType < 200) dataexit();
1D85                
1D85 A0 2F 01        mov al, [CodeType]
1D88 3C C8           cmp al, 200
1D8A 0F 8D 00 00   r jge .getVariable218
1D8E E8 D2 EE        call dataexit
1D91                
1D91                ;-909         if (CodeType > 205) dataexit();
1D91                
1D91                .getVariable218:
1D91 A0 2F 01        mov al, [CodeType]
1D94 3C CD           cmp al, 205
1D96 0F 8E 00 00   r jle .getVariable219
1D9A E8 C6 EE        call dataexit
1D9D                
1D9D                ;-910         if (CodeType== 200) {//DB
1D9D                
1D9D                .getVariable219:
1D9D A0 2F 01        mov al, [CodeType]
1DA0 3C C8           cmp al, 200
1DA2 0F 85 00 00   r jne .getVariable220
1DA6                
1DA6                ;-911             do {
1DA6                
1DA6                .getVariable221:
1DA6                
1DA6                ;-912                 getTokeType();
1DA6                
1DA6 E8 27 F9        call getTokeType
1DA9                
1DA9                ;-913                 if (TokeType == DIGIT) genCode8(SymbolInt);
1DA9                
1DA9 A0 2C 01        mov al, [TokeType]
1DAC 3C 01           cmp al, 1
1DAE 0F 85 00 00   r jne .getVariable222
1DB2 FF 36 0E 01     push word [SymbolInt]
1DB6 E8 C6 F5        call genCode8
1DB9 83 C4 02        add  sp, 2
1DBC                
1DBC                ;-914                 else {
1DBC                
1DBC E9 00 00      R jmp .getVariable223
1DBF                .getVariable222:
1DBF                
1DBF                ;-915                     skipBlank();
1DBF                
1DBF E8 0A F0        call skipBlank
1DC2                
1DC2                ;-916                     if (isToken('"')) {
1DC2                
1DC2 6A 22           push 34
1DC4 E8 95 F9        call isToken
1DC7 83 C4 02        add  sp, 2
1DCA 08 C0           or  al, al
1DCC 0F 84 00 00   r je .getVariable224
1DD0                
1DD0                ;-917                         do {
1DD0                
1DD0                .getVariable225:
1DD0                
1DD0                ;-918                             c= *InputPtr;
1DD0                
1DD0 8B 1E 14 01     mov bx, [InputPtr]
1DD4 8A 07           mov al, [bx]
1DD6 B4 00           mov ah, 0
1DD8 88 46 FE        mov [bp-2], al
1DDB                
1DDB                ;-919                             genCode8(c);
1DDB                
1DDB 8A 46 FE        mov al, byte [bp-2]
1DDE B4 00           mov ah, 0
1DE0 50              push ax
1DE1 E8 9B F5        call genCode8
1DE4 83 C4 02        add  sp, 2
1DE7                
1DE7                ;-920                             InputPtr++;
1DE7                
1DE7 FF 06 14 01     inc  word[InputPtr]
1DEB                
1DEB                ;-921                         } while (*InputPtr != '"' );
1DEB                
1DEB 8B 1E 14 01     mov bx, [InputPtr]
1DEF 8A 07           mov al, [bx]
1DF1 B4 00           mov ah, 0
1DF3 83 F8 22        cmp ax, 34
1DF6 0F 84 00 00   r je  .getVariable226
1DFA EB D4           jmp .getVariable225
1DFC                .getVariable226:
1DFC                
1DFC                ;-922                         InputPtr++;
1DFC                
1DFC FF 06 14 01     inc  word[InputPtr]
1E00                
1E00                ;-923                     }
1E00                
1E00                
1E00                ;-924                 }
1E00                
1E00                .getVariable224:
1E00                
1E00                ;-925             } while (isToken(','));
1E00                
1E00                .getVariable223:
1E00 6A 2C           push 44
1E02 E8 57 F9        call isToken
1E05 83 C4 02        add  sp, 2
1E08 08 C0           or  al, al
1E0A 0F 84 00 00   r je .getVariable227
1E0E EB 96           jmp .getVariable221
1E10                .getVariable227:
1E10                
1E10                ;-926         }
1E10                
1E10                
1E10                ;-927         if (CodeType == 201) {//DW
1E10                
1E10                .getVariable220:
1E10 A0 2F 01        mov al, [CodeType]
1E13 3C C9           cmp al, 201
1E15 0F 85 00 00   r jne .getVariable228
1E19                
1E19                ;-928             do {
1E19                
1E19                .getVariable229:
1E19                
1E19                ;-929                 getTokeType();
1E19                
1E19 E8 B4 F8        call getTokeType
1E1C                
1E1C                ;-930                 if (TokeType ==DIGIT) genCode16(SymbolInt);
1E1C                
1E1C A0 2C 01        mov al, [TokeType]
1E1F 3C 01           cmp al, 1
1E21 0F 85 00 00   r jne .getVariable230
1E25 FF 36 0E 01     push word [SymbolInt]
1E29 E8 E9 F5        call genCode16
1E2C 83 C4 02        add  sp, 2
1E2F                
1E2F                ;-931             } while (isToken(','));
1E2F                
1E2F                .getVariable230:
1E2F 6A 2C           push 44
1E31 E8 28 F9        call isToken
1E34 83 C4 02        add  sp, 2
1E37 08 C0           or  al, al
1E39 0F 84 00 00   r je .getVariable231
1E3D EB DA           jmp .getVariable229
1E3F                .getVariable231:
1E3F                
1E3F                ;-932         }
1E3F                
1E3F                
1E3F                ;-933         if (CodeType == 202) {//DD
1E3F                
1E3F                .getVariable228:
1E3F A0 2F 01        mov al, [CodeType]
1E42 3C CA           cmp al, 202
1E44 0F 85 00 00   r jne .getVariable232
1E48                
1E48                ;-934             do {
1E48                
1E48                .getVariable233:
1E48                
1E48                ;-935                 getTokeType();
1E48                
1E48 E8 85 F8        call getTokeType
1E4B                
1E4B                ;-936                 if (TokeType ==DIGIT) { genCode16(SymbolInt);
1E4B                
1E4B A0 2C 01        mov al, [TokeType]
1E4E 3C 01           cmp al, 1
1E50 0F 85 00 00   r jne .getVariable234
1E54 FF 36 0E 01     push word [SymbolInt]
1E58 E8 BA F5        call genCode16
1E5B 83 C4 02        add  sp, 2
1E5E                
1E5E                ;-937                                     genCode16(0);}//todo genCode32(SymbolLong);
1E5E                
1E5E 6A 00           push 0
1E60 E8 B2 F5        call genCode16
1E63 83 C4 02        add  sp, 2
1E66                
1E66                ;-938             } while (isToken(','));
1E66                
1E66                .getVariable234:
1E66 6A 2C           push 44
1E68 E8 F1 F8        call isToken
1E6B 83 C4 02        add  sp, 2
1E6E 08 C0           or  al, al
1E70 0F 84 00 00   r je .getVariable235
1E74 EB D2           jmp .getVariable233
1E76                .getVariable235:
1E76                
1E76                ;-939         }
1E76                
1E76                
1E76                ;-940         if (CodeType >= 203) {//resb, resw, resd
1E76                
1E76                .getVariable232:
1E76 A0 2F 01        mov al, [CodeType]
1E79 3C CB           cmp al, 203 ;unsigned : 1
1E7B 0F 8C 00 00   r jl  .getVariable236
1E7F                
1E7F                ;-941             getTokeType();
1E7F                
1E7F E8 4E F8        call getTokeType
1E82                
1E82                ;-942             if (TokeType == DIGIT) {
1E82                
1E82 A0 2C 01        mov al, [TokeType]
1E85 3C 01           cmp al, 1
1E87 0F 85 00 00   r jne .getVariable237
1E8B                
1E8B                ;-943                 if (SymbolInt <= 0) syntaxerror();
1E8B                
1E8B A1 0E 01        mov ax, [SymbolInt]
1E8E 83 F8 00        cmp ax, 0
1E91 0F 87 00 00   r ja  .getVariable238
1E95 E8 A0 ED        call syntaxerror
1E98                
1E98                ;-944                 if (AbsoluteLab == 0) error1("Absolute is null");
1E98                
1E98                .getVariable238:
1E98 A1 27 01        mov ax, [AbsoluteLab]
1E9B 83 F8 00        cmp ax, 0
1E9E 0F 85 00 00   r jne .getVariable239
1EA2 68 AA AA      A push getVariable_0
1EA5 E8 93 EB        call error1
1EA8 83 C4 02        add  sp, 2
1EAB                
1EAB                ;-945                 LabelAddr[LabelMaxIx] = AbsoluteLab;
1EAB                
1EAB                .getVariable239:
1EAB A1 27 01        mov ax, [AbsoluteLab]
1EAE 8B 1E 4A 01     mov bx, [LabelMaxIx]
1EB2 D1 E3           shl bx, 1
1EB4 89 47 CA        mov [LabelAddr+bx], ax
1EB7                
1EB7                ;-946                 if (CodeType == 204) SymbolInt=SymbolInt+SymbolInt;//resw
1EB7                
1EB7 A0 2F 01        mov al, [CodeType]
1EBA 3C CC           cmp al, 204
1EBC 0F 85 00 00   r jne .getVariable240
1EC0 A1 0E 01        mov ax, [SymbolInt]
1EC3 03 06 0E 01     add ax, [SymbolInt]
1EC7 A3 0E 01        mov word [SymbolInt], ax
1ECA                
1ECA                ;-947                 if (CodeType == 205) SymbolInt=SymbolInt * 4;//resd
1ECA                
1ECA                .getVariable240:
1ECA A0 2F 01        mov al, [CodeType]
1ECD 3C CD           cmp al, 205
1ECF 0F 85 00 00   r jne .getVariable241
1ED3 A1 0E 01        mov ax, [SymbolInt]
1ED6 BB 04 00        mov bx, 4
1ED9 F7 E3           mul bx
1EDB A3 0E 01        mov word [SymbolInt], ax
1EDE                
1EDE                ;-948                 AbsoluteLab = AbsoluteLab + SymbolInt;
1EDE                
1EDE                .getVariable241:
1EDE A1 27 01        mov ax, [AbsoluteLab]
1EE1 03 06 0E 01     add ax, [SymbolInt]
1EE5 A3 27 01        mov word [AbsoluteLab], ax
1EE8                
1EE8                ;-949             } else numbererror();
1EE8                
1EE8 E9 00 00      R jmp .getVariable242
1EEB                .getVariable237:
1EEB E8 B7 EC        call numbererror
1EEE                
1EEE                ;-950         }
1EEE                
1EEE                .getVariable242:
1EEE                
1EEE                ;-951     }
1EEE                
1EEE                .getVariable236:
1EEE                
1EEE                ;-952     else dataexit();
1EEE                
1EEE E9 00 00      R jmp .getVariable243
1EF1                .getVariable217:
1EF1 E8 6F ED        call dataexit
1EF4                
1EF4                ;-953 }
1EF4                
1EF4                .getVariable243:
1EF4                
1EF4                ;-954 
1EF4                
1EF4                
1EF4                ;-955 int getCodeSize() {
1EF4 C9              LEAVE
1EF5 C3              ret
1EF6 41 62 73 6F 6C getVariable_0 db "Absolute is null",0
leaving: getVariable, loc labels: 28, loc jmp forward: 24
1F07                ENDP
1F07                
entering: getCodeSize
1F07                getCodeSize: PROC
1F07                
1F07                ;-956     if (TokeType ==ALNUME) {
1F07                
1F07 A0 2C 01        mov al, [TokeType]
1F0A 3C 03           cmp al, 3
1F0C 0F 85 00 00   r jne .getCodeSize244
1F10                
1F10                ;-957         if (eqstr(SymbolUpper,"BYTE")) {getTokeType(); return BYTE;}
1F10                
1F10 68 AA AA      A push getCodeSize_0
1F13 8D 06 4F 75     lea  ax, [SymbolUpper]
1F17 50              push ax
1F18 E8 45 E3        call eqstr
1F1B 83 C4 04        add  sp, 4
1F1E 08 C0           or  al, al
1F20 0F 84 00 00   r je .getCodeSize245
1F24 E8 A9 F7        call getTokeType
1F27 B8 01 00        mov ax, 1
1F2A E9 00 00      R jmp .retngetCodeSize
1F2D                
1F2D                ;-958         if (eqstr(SymbolUpper,"WORD")) {getTokeType(); return WORD;}
1F2D                
1F2D                .getCodeSize245:
1F2D 68 AA AA      A push getCodeSize_1
1F30 8D 06 4F 75     lea  ax, [SymbolUpper]
1F34 50              push ax
1F35 E8 28 E3        call eqstr
1F38 83 C4 04        add  sp, 4
1F3B 08 C0           or  al, al
1F3D 0F 84 00 00   r je .getCodeSize246
1F41 E8 8C F7        call getTokeType
1F44 B8 02 00        mov ax, 2
1F47 E9 00 00      R jmp .retngetCodeSize
1F4A                
1F4A                ;-959         if (eqstr(SymbolUpper,"DWORD")){getTokeType(); return DWORD;}
1F4A                
1F4A                .getCodeSize246:
1F4A 68 AA AA      A push getCodeSize_2
1F4D 8D 06 4F 75     lea  ax, [SymbolUpper]
1F51 50              push ax
1F52 E8 0B E3        call eqstr
1F55 83 C4 04        add  sp, 4
1F58 08 C0           or  al, al
1F5A 0F 84 00 00   r je .getCodeSize247
1F5E E8 6F F7        call getTokeType
1F61 B8 03 00        mov ax, 3
1F64 E9 00 00      R jmp .retngetCodeSize
1F67                
1F67                ;-960     }
1F67                
1F67                .getCodeSize247:
1F67                
1F67                ;-961     return 0;
1F67                
1F67                .getCodeSize244:
1F67 B8 00 00        mov ax, 0
1F6A E9 00 00      R jmp .retngetCodeSize
1F6D                
1F6D                ;-962 }
1F6D                
1F6D                
1F6D                ;-963 
1F6D                
1F6D                
1F6D                ;-964 
1F6D                
1F6D                
1F6D                ;-965 int getarg() {
1F6D                
1F6D                 .retngetCodeSize:
1F6D C3              ret
1F6E 42 59 54 45 00 getCodeSize_0 db "BYTE",0
1F73 57 4F 52 44 00 getCodeSize_1 db "WORD",0
1F78 44 57 4F 52 44 getCodeSize_2 db "DWORD",0
leaving: getCodeSize, loc labels: 8, loc jmp forward: 11
1F7E                ENDP
1F7E                
entering: getarg
1F7E                getarg: PROC
1F7E                
1F7E                ;-966     int arglen1; int i; char *c;
1F7E                
1F7E                
1F7E                ;-967     arglen1=*arglen;
1F7E                
1F7E                ;Function : getarg, Number of local variables: 3
1F7E                ;   # type sign width addr used name   list of local variables
1F7E                ;  200 var sign word   966 NULL arglen1 = bp-2
1F7E                ;  201 var sign word   966 NULL i = bp-4
1F7E                ;  202 ptr sign byte   966 NULL c = bp-6;
1F7E C8 06 00 00     ENTER  6,0
1F82 8B 1E 5A 01     mov bx, [arglen]
1F86 8A 07           mov al, [bx]
1F88 B4 00           mov ah, 0
1F8A 89 46 FE        mov [bp-2], ax
1F8D                
1F8D                ;-968     if (arglen1==0) {
1F8D                
1F8D 8B 46 FE        mov ax, [bp-2]
1F90 83 F8 00        cmp ax, 0
1F93 0F 85 00 00   r jne .getarg248
1F97                
1F97                ;-969         cputs(Version1);
1F97                
1F97 8D 06 03 01     lea  ax, [Version1]
1F9B 50              push ax
1F9C E8 E0 E0        call cputs
1F9F 83 C4 02        add  sp, 2
1FA2                
1FA2                ;-970         cputs(", Usage: AS.COM filename [w/o .S] : ");
1FA2                
1FA2 68 AA AA      A push getarg_0
1FA5 E8 D7 E0        call cputs
1FA8 83 C4 02        add  sp, 2
1FAB                
1FAB                ;-971         exitR(3);
1FAB                
1FAB 6A 03           push 3
1FAD E8 36 E1        call exitR
1FB0 83 C4 02        add  sp, 2
1FB3                
1FB3                ;-972     }
1FB3                
1FB3                
1FB3                ;-973     i=arglen1+129;
1FB3                
1FB3                .getarg248:
1FB3 8B 46 FE        mov ax, [bp-2]
1FB6 05 81 00        add ax, 129
1FB9 89 46 FC        mov [bp-4], ax
1FBC                
1FBC                ;-974     *i=0;
1FBC                
1FBC B8 00 00        mov ax, 0
1FBF 8B 5E FC        mov  bx, [bp-4]
1FC2 89 07           mov  [bx], ax
1FC4                
1FC4                ;-975     arglen1--;
1FC4                
1FC4 FF 4E FE        dec  word[bp-2]
1FC7                
1FC7                ;-976     toupper(argv);
1FC7                
1FC7 FF 36 5C 01     push word [argv]
1FCB E8 FF E2        call toupper
1FCE 83 C4 02        add  sp, 2
1FD1                
1FD1                ;-977 
1FD1                
1FD1                
1FD1                ;-978     strcpy(namein, argv); strcat1(namein, ".S");
1FD1                
1FD1 FF 36 5C 01     push word [argv]
1FD5 8D 06 8C 76     lea  ax, [namein]
1FD9 50              push ax
1FDA E8 4D E2        call strcpy
1FDD 83 C4 04        add  sp, 4
1FE0 68 AA AA      A push getarg_1
1FE3 8D 06 8C 76     lea  ax, [namein]
1FE7 50              push ax
1FE8 E8 C1 E2        call strcat1
1FEB 83 C4 04        add  sp, 4
1FEE                
1FEE                ;-979     strcpy(namelst,argv); strcat1(namelst,".LST");
1FEE                
1FEE FF 36 5C 01     push word [argv]
1FF2 8D 06 CF 76     lea  ax, [namelst]
1FF6 50              push ax
1FF7 E8 30 E2        call strcpy
1FFA 83 C4 04        add  sp, 4
1FFD 68 AA AA      A push getarg_2
2000 8D 06 CF 76     lea  ax, [namelst]
2004 50              push ax
2005 E8 A4 E2        call strcat1
2008 83 C4 04        add  sp, 4
200B                
200B                ;-980     strcpy(namebin,argv); strcat1(namebin,".COM");
200B                
200B FF 36 5C 01     push word [argv]
200F 8D 06 12 77     lea  ax, [namebin]
2013 50              push ax
2014 E8 13 E2        call strcpy
2017 83 C4 04        add  sp, 4
201A 68 AA AA      A push getarg_3
201D 8D 06 12 77     lea  ax, [namebin]
2021 50              push ax
2022 E8 87 E2        call strcat1
2025 83 C4 04        add  sp, 4
2028                
2028                ;-981 
2028                
2028                
2028                ;-982   DOS_ERR=0; PC=0; ErrorCount=0;
2028                
2028 B8 00 00        mov ax, 0
202B A3 1C 01        mov word [DOS_ERR], ax
202E B8 00 00        mov ax, 0
2031 A3 23 01        mov word [PC], ax
2034 B8 00 00        mov ax, 0
2037 A3 1E 01        mov word [ErrorCount], ax
203A                
203A                ;-983 
203A                
203A                
203A                ;-984     asm_fd=openR (namein);
203A                
203A 8D 06 8C 76     lea  ax, [namein]
203E 50              push ax
203F E8 74 E0        call openR
2042 83 C4 02        add  sp, 2
2045 A3 16 01        mov word [asm_fd], ax
2048                
2048                ;-985     if(DOS_ERR){cputs("Source file missing: ") ;cputs(namein );exitR(1);}
2048                
2048 A1 1C 01        mov ax, [DOS_ERR]
204B 08 C0           or  al, al
204D 0F 84 00 00   r je .getarg249
2051 68 AA AA      A push getarg_4
2054 E8 28 E0        call cputs
2057 83 C4 02        add  sp, 2
205A 8D 06 8C 76     lea  ax, [namein]
205E 50              push ax
205F E8 1D E0        call cputs
2062 83 C4 02        add  sp, 2
2065 6A 01           push 1
2067 E8 7C E0        call exitR
206A 83 C4 02        add  sp, 2
206D                
206D                ;-986     lst_fd=creatR(namelst);
206D                
206D                .getarg249:
206D 8D 06 CF 76     lea  ax, [namelst]
2071 50              push ax
2072 E8 50 E0        call creatR
2075 83 C4 02        add  sp, 2
2078 A3 18 01        mov word [lst_fd], ax
207B                
207B                ;-987     if(DOS_ERR){cputs("List file not create: ");cputs(namelst);exitR(2);}
207B                
207B A1 1C 01        mov ax, [DOS_ERR]
207E 08 C0           or  al, al
2080 0F 84 00 00   r je .getarg250
2084 68 AA AA      A push getarg_5
2087 E8 F5 DF        call cputs
208A 83 C4 02        add  sp, 2
208D 8D 06 CF 76     lea  ax, [namelst]
2091 50              push ax
2092 E8 EA DF        call cputs
2095 83 C4 02        add  sp, 2
2098 6A 02           push 2
209A E8 49 E0        call exitR
209D 83 C4 02        add  sp, 2
20A0                
20A0                ;-988     bin_fd=creatR(namebin);
20A0                
20A0                .getarg250:
20A0 8D 06 12 77     lea  ax, [namebin]
20A4 50              push ax
20A5 E8 1D E0        call creatR
20A8 83 C4 02        add  sp, 2
20AB A3 1A 01        mov word [bin_fd], ax
20AE                
20AE                ;-989     if(DOS_ERR){cputs("COM file not create: ") ;cputs(namebin);exitR(2);}
20AE                
20AE A1 1C 01        mov ax, [DOS_ERR]
20B1 08 C0           or  al, al
20B3 0F 84 00 00   r je .getarg251
20B7 68 AA AA      A push getarg_6
20BA E8 C2 DF        call cputs
20BD 83 C4 02        add  sp, 2
20C0 8D 06 12 77     lea  ax, [namebin]
20C4 50              push ax
20C5 E8 B7 DF        call cputs
20C8 83 C4 02        add  sp, 2
20CB 6A 02           push 2
20CD E8 16 E0        call exitR
20D0 83 C4 02        add  sp, 2
20D3                
20D3                ;-990 
20D3                
20D3                
20D3                ;-991     prs(";");
20D3                
20D3                .getarg251:
20D3 68 AA AA      A push getarg_7
20D6 E8 56 E6        call prs
20D9 83 C4 02        add  sp, 2
20DC                
20DC                ;-992     prs(Version1);
20DC                
20DC 8D 06 03 01     lea  ax, [Version1]
20E0 50              push ax
20E1 E8 4B E6        call prs
20E4 83 C4 02        add  sp, 2
20E7                
20E7                ;-993     prs(", Source: "); prs(namein);
20E7                
20E7 68 AA AA      A push getarg_8
20EA E8 42 E6        call prs
20ED 83 C4 02        add  sp, 2
20F0 8D 06 8C 76     lea  ax, [namein]
20F4 50              push ax
20F5 E8 37 E6        call prs
20F8 83 C4 02        add  sp, 2
20FB                
20FB                ;-994     prs(", Output: "); prs(namelst);
20FB                
20FB 68 AA AA      A push getarg_9
20FE E8 2E E6        call prs
2101 83 C4 02        add  sp, 2
2104 8D 06 CF 76     lea  ax, [namelst]
2108 50              push ax
2109 E8 23 E6        call prs
210C 83 C4 02        add  sp, 2
210F                
210F                ;-995     prs(", "); prs(namebin);
210F                
210F 68 AA AA      A push getarg_10
2112 E8 1A E6        call prs
2115 83 C4 02        add  sp, 2
2118 8D 06 12 77     lea  ax, [namebin]
211C 50              push ax
211D E8 0F E6        call prs
2120 83 C4 02        add  sp, 2
2123                
2123                ;-996     prs("\n");
2123                
2123 68 AA AA      A push getarg_11
2126 E8 06 E6        call prs
2129 83 C4 02        add  sp, 2
212C                
212C                ;-997 }
212C                
212C                
212C                ;-998 
212C                
212C                
212C                ;-999 int fixJmp() {   
212C C9              LEAVE
212D C3              ret
212E 2C 20 55 73 61 getarg_0 db ", Usage: AS.COM filename [w/o .S] : ",0
2153 2E 53 00       getarg_1 db ".S",0
2156 2E 4C 53 54 00 getarg_2 db ".LST",0
215B 2E 43 4F 4D 00 getarg_3 db ".COM",0
2160 53 6F 75 72 63 getarg_4 db "Source file missing: ",0
2176 4C 69 73 74 20 getarg_5 db "List file not create: ",0
218D 43 4F 4D 20 66 getarg_6 db "COM file not create: ",0
21A3 3B 00          getarg_7 db ";",0
21A5 2C 20 53 6F 75 getarg_8 db ", Source: ",0
21B0 2C 20 4F 75 74 getarg_9 db ", Output: ",0
21BB 2C 20 00       getarg_10 db ", ",0
21BE 5C 6E 00       getarg_11 db "\n",0
leaving: getarg, loc labels: 16, loc jmp forward: 16
21C1                ENDP
21C1                
entering: fixJmp
21C1                fixJmp: PROC
21C1                
21C1                ;-1000     unsigned int hex; int i;
21C1                
21C1                
21C1                ;-1001     char *p; int Ix; char c;
21C1                
21C1                
21C1                ;-1002 //    prs("\, jmp to fix:"); printIntU(JmpMaxIx);
21C1                
21C1                
21C1                ;-1003     p = &JmpNames;
21C1                
21C1                ;Function : fixJmp, Number of local variables: 5
21C1                ;   # type sign width addr used name   list of local variables
21C1                ;  200 var unsg word  1000 NULL hex = bp-2
21C1                ;  201 var sign word  1000 NULL i = bp-4
21C1                ;  202 ptr sign byte  1001 NULL p = bp-6
21C1                ;  203 var sign word  1001 NULL Ix = bp-8
21C1                ;  204 var sign byte  1001 NULL c = bp-10;
21C1 C8 0A 00 00     ENTER  10,0
21C5 B8 7A 93        mov ax, JmpNames
21C8 89 46 FA        mov [bp-6], ax
21CB                
21CB                ;-1004     i = 1;
21CB                
21CB B8 01 00        mov ax, 1
21CE 89 46 FC        mov [bp-4], ax
21D1                
21D1                ;-1005     while (i <= JmpMaxIx) {
21D1                
21D1                .fixJmp252:
21D1 8B 46 FC        mov ax, [bp-4]
21D4 3B 06 54 01     cmp ax, [JmpMaxIx]
21D8 0F 8F 00 00   r jg  .fixJmp253
21DC                
21DC                ;-1006         strcpy(Symbol, p);
21DC                
21DC 55              push word [bp-6]
21DD 8D 06 30 75     lea  ax, [Symbol]
21E1 50              push ax
21E2 E8 45 E0        call strcpy
21E5 83 C4 04        add  sp, 4
21E8                
21E8                ;-1007         p = strlen(Symbol) + p;
21E8                
21E8 8D 06 30 75     lea  ax, [Symbol]
21EC 50              push ax
21ED E8 12 E0        call strlen
21F0 83 C4 02        add  sp, 2
21F3 03 46 FA        add ax, [bp-6]
21F6 89 46 FA        mov [bp-6], ax
21F9                
21F9                ;-1008         p++;
21F9                
21F9 FF 46 FA        inc  word[bp-6]
21FC                
21FC                ;-1009         hex = JmpAddr[i];
21FC                
21FC 8B 5E FC        mov bx, [bp-4]
21FF D1 E3           shl bx, 1
2201 8B 47 1A        mov ax, [JmpAddr + bx]
2204 89 46 FE        mov [bp-2], ax
2207                
2207                ;-1010 //        prs("\n"); printIntU(i);
2207                
2207                
2207                ;-1011 //        prs("  "); prs(Symbol); prs(", from:");
2207                
2207                
2207                ;-1012 //        printhex16(hex);
2207                
2207                
2207                ;-1013         
2207                
2207                
2207                ;-1014         Ix=searchLabel();
2207                
2207 E8 64 F6        call searchLabel
220A 89 46 F8        mov [bp-8], ax
220D                
220D                ;-1015         if (Ix == 0) notfounderror();
220D                
220D 8B 46 F8        mov ax, [bp-8]
2210 83 F8 00        cmp ax, 0
2213 0F 85 00 00   r jne .fixJmp254
2217 E8 8E E8        call notfounderror
221A                
221A                ;-1016         disp = LabelAddr[Ix];   
221A                
221A                .fixJmp254:
221A 8B 5E F8        mov bx, [bp-8]
221D D1 E3           shl bx, 1
221F 8B 47 CA        mov ax, [LabelAddr + bx]
2222 A3 3D 01        mov word [disp], ax
2225                
2225                ;-1017         c = FileBin[hex];//look for 'A' push Absolute 
2225                
2225 8B 5E FE        mov bx, [bp-2]
2228 8A 47 AA        mov al, [FileBin + bx]
222B 88 46 F6        mov [bp-10], al
222E                
222E                ;-1018 //        prs(", Label+ORG:"); printhex16(disp);
222E                
222E                
222E                ;-1019         if (c != 0xAA) {
222E                
222E 8A 46 F6        mov al, [bp-10]
2231 3C AA           cmp al, 170
2233 0F 84 00 00   r je  .fixJmp255
2237                
2237                ;-1020             disp = disp - hex;
2237                
2237 A1 3D 01        mov ax, [disp]
223A 2B 46 FE        sub ax, [bp-2]
223D A3 3D 01        mov word [disp], ax
2240                
2240                ;-1021             disp = disp -2;//PC points to next instruction
2240                
2240 A1 3D 01        mov ax, [disp]
2243 83 E8 02        sub ax, 2
2246 A3 3D 01        mov word [disp], ax
2249                
2249                ;-1022             disp = disp - Origin; 
2249                
2249 A1 3D 01        mov ax, [disp]
224C 2B 06 25 01     sub ax, [Origin]
2250 A3 3D 01        mov word [disp], ax
2253                
2253                ;-1023 //            prs(", rel:"); printhex16(disp);
2253                
2253                
2253                ;-1024         }
2253                
2253                
2253                ;-1025             FileBin[hex] = disp;//fix low byte
2253                
2253                .fixJmp255:
2253 A1 3D 01        mov ax, [disp]
2256 8B 5E FE        mov bx, [bp-2]
2259 88 47 AA        mov [FileBin+bx], al
225C                
225C                ;-1026             hex++;
225C                
225C FF 46 FE        inc  word[bp-2]
225F                
225F                ;-1027             disp = disp >> 8;
225F                
225F A1 3D 01        mov ax, [disp]
2262 C1 E8 08        shr ax, 8
2265 A3 3D 01        mov word [disp], ax
2268                
2268                ;-1028             FileBin[hex] = disp; 
2268                
2268 A1 3D 01        mov ax, [disp]
226B 8B 5E FE        mov bx, [bp-2]
226E 88 47 AA        mov [FileBin+bx], al
2271                
2271                ;-1029         i++;  
2271                
2271 FF 46 FC        inc  word[bp-4]
2274                
2274                ;-1030     }
2274                
2274                
2274                ;-1031 }
2274                
2274 E9 5A FF        jmp .fixJmp252
2277                .fixJmp253:
2277                
2277                ;-1032 int fixJmpMain() {   
2277 C9              LEAVE
2278 C3              ret
leaving: fixJmp, loc labels: 4, loc jmp forward: 3
2279                ENDP
2279                
entering: fixJmpMain
2279                fixJmpMain: PROC
2279                
2279                ;-1033     unsigned int hex; 
2279                
2279                
2279                ;-1034     int Ix; char c;
2279                
2279                
2279                ;-1035     prs("\nfix jmp to main. resting global jmp: ");
2279                
2279                ;Function : fixJmpMain, Number of local variables: 3
2279                ;   # type sign width addr used name   list of local variables
2279                ;  200 var unsg word  1033 NULL hex = bp-2
2279                ;  201 var sign word  1034 NULL Ix = bp-4
2279                ;  202 var sign byte  1034 NULL c = bp-6;
2279 C8 06 00 00     ENTER  6,0
227D 68 AA AA      A push fixJmpMain_0
2280 E8 AC E4        call prs
2283 83 C4 02        add  sp, 2
2286                
2286                ;-1036     printIntU(JmpMaxIx);  
2286                
2286 FF 36 54 01     push word [JmpMaxIx]
228A E8 AE E5        call printIntU
228D 83 C4 02        add  sp, 2
2290                
2290                ;-1037     if (JmpMaxIx ) error1("resting global jmp");
2290                
2290 A1 54 01        mov ax, [JmpMaxIx]
2293 08 C0           or  al, al
2295 0F 84 00 00   r je .fixJmpMain256
2299 68 AA AA      A push fixJmpMain_1
229C E8 9C E7        call error1
229F 83 C4 02        add  sp, 2
22A2                
22A2                ;-1038         strcpy(Symbol, "main");
22A2                
22A2                .fixJmpMain256:
22A2 68 AA AA      A push fixJmpMain_2
22A5 8D 06 30 75     lea  ax, [Symbol]
22A9 50              push ax
22AA E8 7D DF        call strcpy
22AD 83 C4 04        add  sp, 4
22B0                
22B0                ;-1039         hex = 1;//first instruction, PC=1
22B0                
22B0 B8 01 00        mov ax, 1
22B3 89 46 FE        mov [bp-2], ax
22B6                
22B6                ;-1040         Ix=searchLabel();
22B6                
22B6 E8 B5 F5        call searchLabel
22B9 89 46 FC        mov [bp-4], ax
22BC                
22BC                ;-1041         if (Ix == 0) notfounderror();
22BC                
22BC 8B 46 FC        mov ax, [bp-4]
22BF 83 F8 00        cmp ax, 0
22C2 0F 85 00 00   r jne .fixJmpMain257
22C6 E8 DF E7        call notfounderror
22C9                
22C9                ;-1042         disp = LabelAddr[Ix];   
22C9                
22C9                .fixJmpMain257:
22C9 8B 5E FC        mov bx, [bp-4]
22CC D1 E3           shl bx, 1
22CE 8B 47 CA        mov ax, [LabelAddr + bx]
22D1 A3 3D 01        mov word [disp], ax
22D4                
22D4                ;-1043         c = FileBin[hex];//look for 'A' push Absolute 
22D4                
22D4 8B 5E FE        mov bx, [bp-2]
22D7 8A 47 AA        mov al, [FileBin + bx]
22DA 88 46 FA        mov [bp-6], al
22DD                
22DD                ;-1044         prs("\nmain ,Label+ORG:"); printhex16(disp);
22DD                
22DD 68 AA AA      A push fixJmpMain_3
22E0 E8 4C E4        call prs
22E3 83 C4 02        add  sp, 2
22E6 FF 36 3D 01     push word [disp]
22EA E8 28 E5        call printhex16
22ED 83 C4 02        add  sp, 2
22F0                
22F0                ;-1045         if (c != 0xAA) {
22F0                
22F0 8A 46 FA        mov al, [bp-6]
22F3 3C AA           cmp al, 170
22F5 0F 84 00 00   r je  .fixJmpMain258
22F9                
22F9                ;-1046             disp = disp - hex;
22F9                
22F9 A1 3D 01        mov ax, [disp]
22FC 2B 46 FE        sub ax, [bp-2]
22FF A3 3D 01        mov word [disp], ax
2302                
2302                ;-1047             disp = disp -2;//PC points to next instruction
2302                
2302 A1 3D 01        mov ax, [disp]
2305 83 E8 02        sub ax, 2
2308 A3 3D 01        mov word [disp], ax
230B                
230B                ;-1048             disp = disp - Origin; 
230B                
230B A1 3D 01        mov ax, [disp]
230E 2B 06 25 01     sub ax, [Origin]
2312 A3 3D 01        mov word [disp], ax
2315                
2315                ;-1049             prs(",rel:"); printhex16(disp);
2315                
2315 68 AA AA      A push fixJmpMain_4
2318 E8 14 E4        call prs
231B 83 C4 02        add  sp, 2
231E FF 36 3D 01     push word [disp]
2322 E8 F0 E4        call printhex16
2325 83 C4 02        add  sp, 2
2328                
2328                ;-1050         }
2328                
2328                
2328                ;-1051             FileBin[hex] = disp;//fix low byte
2328                
2328                .fixJmpMain258:
2328 A1 3D 01        mov ax, [disp]
232B 8B 5E FE        mov bx, [bp-2]
232E 88 47 AA        mov [FileBin+bx], al
2331                
2331                ;-1052             hex++;
2331                
2331 FF 46 FE        inc  word[bp-2]
2334                
2334                ;-1053             disp = disp >> 8;
2334                
2334 A1 3D 01        mov ax, [disp]
2337 C1 E8 08        shr ax, 8
233A A3 3D 01        mov word [disp], ax
233D                
233D                ;-1054             FileBin[hex] = disp; 
233D                
233D A1 3D 01        mov ax, [disp]
2340 8B 5E FE        mov bx, [bp-2]
2343 88 47 AA        mov [FileBin+bx], al
2346                
2346                ;-1055 }
2346                
2346                
2346                ;-1056 
2346                
2346                
2346                ;-1057 
2346                
2346                
2346                ;-1058 int getCodes() {
2346 C9              LEAVE
2347 C3              ret
2348 5C 6E 66 69 78 fixJmpMain_0 db "\nfix jmp to main. resting global jmp: ",0
2370 72 65 73 74 69 fixJmpMain_1 db "resting global jmp",0
2383 6D 61 69 6E 00 fixJmpMain_2 db "main",0
2388 5C 6E 6D 61 69 fixJmpMain_3 db "\nmain ,Label+ORG:",0
239B 2C 72 65 6C 3A fixJmpMain_4 db ",rel:",0
leaving: fixJmpMain, loc labels: 8, loc jmp forward: 8
23A1                ENDP
23A1                
entering: getCodes
23A1                getCodes: PROC
23A1                
23A1                ;-1059     OpCodePtr ++; Code1 = *OpCodePtr;
23A1                
23A1 FF 06 43 01     inc  word[OpCodePtr]
23A5 8B 1E 43 01     mov bx, [OpCodePtr]
23A9 8A 07           mov al, [bx]
23AB B4 00           mov ah, 0
23AD A2 30 01        mov byte [Code1], al
23B0                
23B0                ;-1060     OpCodePtr ++; Code2 = *OpCodePtr;
23B0                
23B0 FF 06 43 01     inc  word[OpCodePtr]
23B4 8B 1E 43 01     mov bx, [OpCodePtr]
23B8 8A 07           mov al, [bx]
23BA B4 00           mov ah, 0
23BC A2 31 01        mov byte [Code2], al
23BF                
23BF                ;-1061     OpCodePtr ++; Code3 = *OpCodePtr;
23BF                
23BF FF 06 43 01     inc  word[OpCodePtr]
23C3 8B 1E 43 01     mov bx, [OpCodePtr]
23C7 8A 07           mov al, [bx]
23C9 B4 00           mov ah, 0
23CB A2 32 01        mov byte [Code3], al
23CE                
23CE                ;-1062 }
23CE                
23CE                
23CE                ;-1063 
23CE                
23CE                
23CE                ;-1064 int process() {
23CE                
23CE C3              ret
leaving: getCodes, loc labels: 0, loc jmp forward: 0
23CF                ENDP
23CF                
entering: process
23CF                process: PROC
23CF                
23CF                ;-1065     char c;
23CF                
23CF                
23CF                ;-1066     int i;
23CF                
23CF                
23CF                ;-1067     Op=Op2=R1Type=R2Type=R1No=R2No=dflag=wflag=rm=0;//char
23CF                
23CF                ;Function : process, Number of local variables: 2
23CF                ;   # type sign width addr used name   list of local variables
23CF                ;  200 var sign byte  1065 NULL c = bp-2
23CF                ;  201 var sign word  1066 NULL i = bp-4;
23CF C8 04 00 00     ENTER  4,0
23D3 B8 00 00        mov ax, 0
23D6 A2 3B 01        mov byte [rm], al
23D9 A2 38 01        mov byte [wflag], al
23DC A2 39 01        mov byte [dflag], al
23DF A2 33 01        mov byte [R2No], al
23E2 A2 34 01        mov byte [R1No], al
23E5 A2 35 01        mov byte [R2Type], al
23E8 A2 36 01        mov byte [R1Type], al
23EB A2 2E 01        mov byte [Op2], al
23EE A2 2D 01        mov byte [Op], al
23F1                
23F1                ;-1068     disp=imme=0;//int
23F1                
23F1 B8 00 00        mov ax, 0
23F4 A3 3F 01        mov word [imme], ax
23F7 A3 3D 01        mov word [disp], ax
23FA                
23FA                ;-1069     isDirect=1; //set in getMeM=0, need in WriteEA
23FA                
23FA B8 01 00        mov ax, 1
23FD A2 3C 01        mov byte [isDirect], al
2400                
2400                ;-1070     getTokeType();//0, DIGIT, ALNUME, NOALNUME
2400                
2400 E8 CD F2        call getTokeType
2403                
2403                ;-1071     OpSize=getCodeSize();//0, BYTE, WORD, DWORD
2403                
2403 E8 01 FB        call getCodeSize
2406 A2 37 01        mov byte [OpSize], al
2409                
2409                ;-1072     getCodes();//set: Code1, Code2, Code3
2409                
2409 E8 95 FF        call getCodes
240C                
240C                ;-1073 
240C                
240C                
240C                ;-1074     if (CodeType ==  1) {//1 byte opcode
240C                
240C A0 2F 01        mov al, [CodeType]
240F 3C 01           cmp al, 1
2411 0F 85 00 00   r jne .process259
2415                
2415                ;-1075         genCode8(Code1);
2415                
2415 A0 30 01        mov al, byte [Code1]
2418 B4 00           mov ah, 0
241A 50              push ax
241B E8 61 EF        call genCode8
241E 83 C4 02        add  sp, 2
2421                
2421                ;-1076         return;
2421                
2421 E9 00 00      R jmp .retnprocess
2424                
2424                ;-1077     }
2424                
2424                
2424                ;-1078 
2424                
2424                
2424                ;-1079     if (CodeType ==  2) {//inc,dec,not,neg,mul,imul,div,idiv
2424                
2424                .process259:
2424 A0 2F 01        mov al, [CodeType]
2427 3C 02           cmp al, 2
2429 0F 85 00 00   r jne .process260
242D                
242D                ;-1080         getOpL();
242D                
242D E8 2B F7        call getOpL
2430                
2430                ;-1081         checkOpL();
2430                
2430 E8 B9 F3        call checkOpL
2433                
2433                ;-1082         if (Code2 <= 1) {//inc,dec
2433                
2433 A0 31 01        mov al, [Code2]
2436 3C 01           cmp al, 1
2438 0F 8F 00 00   r jg  .process261
243C                
243C                ;-1083   	        if (Op == REG) {//short
243C                
243C A0 2D 01        mov al, [Op]
243F 3C 02           cmp al, 2
2441 0F 85 00 00   r jne .process262
2445                
2445                ;-1084                 if (wflag) {genCode2(Code3, R1No); return; }
2445                
2445 A0 38 01        mov al, [wflag]
2448 08 C0           or  al, al
244A 0F 84 00 00   r je .process263
244E A0 34 01        mov al, byte [R1No]
2451 B4 00           mov ah, 0
2453 50              push ax
2454 A0 32 01        mov al, byte [Code3]
2457 B4 00           mov ah, 0
2459 50              push ax
245A E8 81 EF        call genCode2
245D 83 C4 04        add  sp, 4
2460 E9 00 00      R jmp .retnprocess
2463                
2463                ;-1085             }
2463                
2463                .process263:
2463                
2463                ;-1086         }
2463                
2463                .process262:
2463                
2463                ;-1087         if (Code2 == 5) {//imul extension?
2463                
2463                .process261:
2463 A0 31 01        mov al, [Code2]
2466 3C 05           cmp al, 5
2468 0F 85 00 00   r jne .process264
246C                
246C                ;-1088             getTokeType();
246C                
246C E8 61 F2        call getTokeType
246F                
246F                ;-1089             if (TokeType) implerror();
246F                
246F A0 2C 01        mov al, [TokeType]
2472 08 C0           or  al, al
2474 0F 84 00 00   r je .process265
2478 E8 CE E6        call implerror
247B                
247B                ;-1090         }
247B                
247B                .process265:
247B                
247B                ;-1091         genCodeW(Code1);
247B                
247B                .process264:
247B A0 30 01        mov al, byte [Code1]
247E B4 00           mov ah, 0
2480 50              push ax
2481 E8 75 EF        call genCodeW
2484 83 C4 02        add  sp, 2
2487                
2487                ;-1092         writeEA(Code2);
2487                
2487 A0 31 01        mov al, byte [Code2]
248A B4 00           mov ah, 0
248C 50              push ax
248D E8 CC EF        call writeEA
2490 83 C4 02        add  sp, 2
2493                
2493                ;-1093         return;
2493                
2493 E9 00 00      R jmp .retnprocess
2496                
2496                ;-1094     }
2496                
2496                
2496                ;-1095 
2496                
2496                
2496                ;-1096     if (CodeType == 3) {//les,lds,lea,lss,lfs,lgs
2496                
2496                .process260:
2496 A0 2F 01        mov al, [CodeType]
2499 3C 03           cmp al, 3
249B 0F 85 00 00   r jne .process266
249F                
249F                ;-1097         check2Ops();    //setwflag not applicable
249F                
249F E8 F0 F6        call check2Ops
24A2                
24A2                ;-1098         if (R1Type != WORD) reg16error();//only r16
24A2                
24A2 A0 36 01        mov al, [R1Type]
24A5 3C 02           cmp al, 2
24A7 0F 84 00 00   r je  .process267
24AB E8 3B E7        call reg16error
24AE                
24AE                ;-1099         if (Op2 != MEM) addrerror();//only m16
24AE                
24AE                .process267:
24AE A0 2E 01        mov al, [Op2]
24B1 3C 04           cmp al, 4
24B3 0F 84 00 00   r je  .process268
24B7 E8 50 E6        call addrerror
24BA                
24BA                ;-1100 
24BA                
24BA                
24BA                ;-1101         genCode8(Code1);//les,lds,lea
24BA                
24BA                .process268:
24BA A0 30 01        mov al, byte [Code1]
24BD B4 00           mov ah, 0
24BF 50              push ax
24C0 E8 BC EE        call genCode8
24C3 83 C4 02        add  sp, 2
24C6                
24C6                ;-1102         if (Code1 == 0x0F) genCode8(Code2);//lss,lfs,lgs
24C6                
24C6 A0 30 01        mov al, [Code1]
24C9 3C 0F           cmp al, 15
24CB 0F 85 00 00   r jne .process269
24CF A0 31 01        mov al, byte [Code2]
24D2 B4 00           mov ah, 0
24D4 50              push ax
24D5 E8 A7 EE        call genCode8
24D8 83 C4 02        add  sp, 2
24DB                
24DB                ;-1103         Op=Op2;//set MEM for writeEA
24DB                
24DB                .process269:
24DB A0 2E 01        mov al, [Op2]
24DE A2 2D 01        mov byte [Op], al
24E1                
24E1                ;-1104         writeEA(R1No);
24E1                
24E1 A0 34 01        mov al, byte [R1No]
24E4 B4 00           mov ah, 0
24E6 50              push ax
24E7 E8 72 EF        call writeEA
24EA 83 C4 02        add  sp, 2
24ED                
24ED                ;-1105         return;
24ED                
24ED E9 00 00      R jmp .retnprocess
24F0                
24F0                ;-1106     }
24F0                
24F0                
24F0                ;-1107 
24F0                
24F0                
24F0                ;-1108     if (CodeType == 4) {//add,or,adc,sbb,and,sub,xor,cmp,->test
24F0                
24F0                .process266:
24F0 A0 2F 01        mov al, [CodeType]
24F3 3C 04           cmp al, 4
24F5 0F 85 00 00   r jne .process270
24F9                
24F9                ;-1109         check2Ops();  
24F9                
24F9 E8 96 F6        call check2Ops
24FC                
24FC                ;-1110         if (Op2 == ADR) {  
24FC                
24FC A0 2E 01        mov al, [Op2]
24FF 3C 03           cmp al, 3
2501 0F 85 00 00   r jne .process271
2505                
2505                ;-1111             if (LabelIx == 0) notfounderror();
2505                
2505 A1 4E 01        mov ax, [LabelIx]
2508 83 F8 00        cmp ax, 0
250B 0F 85 00 00   r jne .process272
250F E8 96 E5        call notfounderror
2512                
2512                ;-1112             imme=LabelAddr[LabelIx];
2512                
2512                .process272:
2512 8B 1E 4E 01     mov bx, [LabelIx]
2516 D1 E3           shl bx, 1
2518 8B 47 CA        mov ax, [LabelAddr + bx]
251B A3 3F 01        mov word [imme], ax
251E                
251E                ;-1113             Op2=IMM;//got the addr and fall through
251E                
251E B8 01 00        mov ax, 1
2521 A2 2E 01        mov byte [Op2], al
2524                
2524                ;-1114         }
2524                
2524                
2524                ;-1115         if (Op2 == IMM) {//second operand is imm
2524                
2524                .process271:
2524 A0 2E 01        mov al, [Op2]
2527 3C 01           cmp al, 1
2529 0F 85 00 00   r jne .process273
252D                
252D                ;-1116             setsflag();
252D                
252D E8 D6 F0        call setsflag
2530                
2530                ;-1117             if (Op == REG) {
2530                
2530 A0 2D 01        mov al, [Op]
2533 3C 02           cmp al, 2
2535 0F 85 00 00   r jne .process274
2539                
2539                ;-1118                 if (R1No == 0) {// acc,imm
2539                
2539 A0 34 01        mov al, [R1No]
253C 3C 00           cmp al, 0
253E 0F 85 00 00   r jne .process275
2542                
2542                ;-1119                     if (sflag == 0) {
2542                
2542 A0 3A 01        mov al, [sflag]
2545 3C 00           cmp al, 0
2547 0F 85 00 00   r jne .process276
254B                
254B                ;-1120                         c = Code1 << 3;
254B                
254B A0 30 01        mov al, [Code1]
254E C0 E0 03        shl al, 3
2551 88 46 FE        mov [bp-2], al
2554                
2554                ;-1121                         c += 4;
2554                
2554 80 46 FE 04     add  byte[bp-2], 4
2558                
2558                ;-1122                         genCodeW(c);
2558                
2558 8A 46 FE        mov al, byte [bp-2]
255B B4 00           mov ah, 0
255D 50              push ax
255E E8 98 EE        call genCodeW
2561 83 C4 02        add  sp, 2
2564                
2564                ;-1123                         genImmediate();
2564                
2564 E8 FB EF        call genImmediate
2567                
2567                ;-1124                         return;
2567                
2567 E9 00 00      R jmp .retnprocess
256A                
256A                ;-1125                     }
256A                
256A                
256A                ;-1126                 }
256A                
256A                .process276:
256A                
256A                ;-1127             }
256A                
256A                .process275:
256A                
256A                ;-1128             //r/m, imm: 80 sign-extended,TTT,imm
256A                
256A                
256A                ;-1129             c = sflag + 0x80;
256A                
256A                .process274:
256A A0 3A 01        mov al, [sflag]
256D 04 80           add al, 128
256F 88 46 FE        mov [bp-2], al
2572                
2572                ;-1130             genCodeW(c);
2572                
2572 8A 46 FE        mov al, byte [bp-2]
2575 B4 00           mov ah, 0
2577 50              push ax
2578 E8 7E EE        call genCodeW
257B 83 C4 02        add  sp, 2
257E                
257E                ;-1131             writeEA(Code1);
257E                
257E A0 30 01        mov al, byte [Code1]
2581 B4 00           mov ah, 0
2583 50              push ax
2584 E8 D5 EE        call writeEA
2587 83 C4 02        add  sp, 2
258A                
258A                ;-1132             if (sflag) genCode8(imme);
258A                
258A A0 3A 01        mov al, [sflag]
258D 08 C0           or  al, al
258F 0F 84 00 00   r je .process277
2593 FF 36 3F 01     push word [imme]
2597 E8 E5 ED        call genCode8
259A 83 C4 02        add  sp, 2
259D                
259D                ;-1133             else genImmediate();
259D                
259D E9 00 00      R jmp .process278
25A0                .process277:
25A0 E8 BF EF        call genImmediate
25A3                
25A3                ;-1134             return;
25A3                
25A3                .process278:
25A3 E9 00 00      R jmp .retnprocess
25A6                
25A6                ;-1135         }
25A6                
25A6                
25A6                ;-1136         c = Code1 << 3;//r/m, r/r
25A6                
25A6                .process273:
25A6 A0 30 01        mov al, [Code1]
25A9 C0 E0 03        shl al, 3
25AC 88 46 FE        mov [bp-2], al
25AF                
25AF                ;-1137         if (Op == REG) {
25AF                
25AF A0 2D 01        mov al, [Op]
25B2 3C 02           cmp al, 2
25B4 0F 85 00 00   r jne .process279
25B8                
25B8                ;-1138             if (Op2 == MEM) {//reg, mem
25B8                
25B8 A0 2E 01        mov al, [Op2]
25BB 3C 04           cmp al, 4
25BD 0F 85 00 00   r jne .process280
25C1                
25C1                ;-1139                 c += 2;//add direction flag
25C1                
25C1 80 46 FE 02     add  byte[bp-2], 2
25C5                
25C5                ;-1140                 genCodeW(c);
25C5                
25C5 8A 46 FE        mov al, byte [bp-2]
25C8 B4 00           mov ah, 0
25CA 50              push ax
25CB E8 2B EE        call genCodeW
25CE 83 C4 02        add  sp, 2
25D1                
25D1                ;-1141                 Op=Op2;//set MEM for writeEA
25D1                
25D1 A0 2E 01        mov al, [Op2]
25D4 A2 2D 01        mov byte [Op], al
25D7                
25D7                ;-1142                 writeEA(R1No);
25D7                
25D7 A0 34 01        mov al, byte [R1No]
25DA B4 00           mov ah, 0
25DC 50              push ax
25DD E8 7C EE        call writeEA
25E0 83 C4 02        add  sp, 2
25E3                
25E3                ;-1143                 return;
25E3                
25E3 E9 00 00      R jmp .retnprocess
25E6                
25E6                ;-1144             }
25E6                
25E6                
25E6                ;-1145         }
25E6                
25E6                .process280:
25E6                
25E6                ;-1146         if (Op2 == REG) {//mem,reg    reg,reg
25E6                
25E6                .process279:
25E6 A0 2E 01        mov al, [Op2]
25E9 3C 02           cmp al, 2
25EB 0F 85 00 00   r jne .process281
25EF                
25EF                ;-1147             genCodeW(c);
25EF                
25EF 8A 46 FE        mov al, byte [bp-2]
25F2 B4 00           mov ah, 0
25F4 50              push ax
25F5 E8 01 EE        call genCodeW
25F8 83 C4 02        add  sp, 2
25FB                
25FB                ;-1148             writeEA(R2No);//2. Op in reg-field
25FB                
25FB A0 33 01        mov al, byte [R2No]
25FE B4 00           mov ah, 0
2600 50              push ax
2601 E8 58 EE        call writeEA
2604 83 C4 02        add  sp, 2
2607                
2607                ;-1149             return;
2607                
2607 E9 00 00      R jmp .retnprocess
260A                
260A                ;-1150         }
260A                
260A                
260A                ;-1151         syntaxerror();
260A                
260A                .process281:
260A E8 2B E6        call syntaxerror
260D                
260D                ;-1152         return;
260D                
260D E9 00 00      R jmp .retnprocess
2610                
2610                ;-1153     }
2610                
2610                
2610                ;-1154 
2610                
2610                
2610                ;-1155     if (CodeType == 5) {//mov (movsx, movzx=51)
2610                
2610                .process270:
2610 A0 2F 01        mov al, [CodeType]
2613 3C 05           cmp al, 5
2615 0F 85 00 00   r jne .process282
2619                
2619                ;-1156         check2Ops();
2619                
2619 E8 76 F5        call check2Ops
261C                
261C                ;-1157         if (Op2 == ADR) {
261C                
261C A0 2E 01        mov al, [Op2]
261F 3C 03           cmp al, 3
2621 0F 85 00 00   r jne .process283
2625                
2625                ;-1158             if (disp) imme=disp;
2625                
2625 A1 3D 01        mov ax, [disp]
2628 08 C0           or  al, al
262A 0F 84 00 00   r je .process284
262E A1 3D 01        mov ax, [disp]
2631 A3 3F 01        mov word [imme], ax
2634                
2634                ;-1159             else notfounderror();
2634                
2634 E9 00 00      R jmp .process285
2637                .process284:
2637 E8 6E E4        call notfounderror
263A                
263A                ;-1160             Op2=IMM;//continue with IMM
263A                
263A                .process285:
263A B8 01 00        mov ax, 1
263D A2 2E 01        mov byte [Op2], al
2640                
2640                ;-1161         }
2640                
2640                
2640                ;-1162         if (Op2 == IMM) {// r,i
2640                
2640                .process283:
2640 A0 2E 01        mov al, [Op2]
2643 3C 01           cmp al, 1
2645 0F 85 00 00   r jne .process286
2649                
2649                ;-1163             if (Op == REG) {
2649                
2649 A0 2D 01        mov al, [Op]
264C 3C 02           cmp al, 2
264E 0F 85 00 00   r jne .process287
2652                
2652                ;-1164                 c = wflag << 3;
2652                
2652 A0 38 01        mov al, [wflag]
2655 C0 E0 03        shl al, 3
2658 88 46 FE        mov [bp-2], al
265B                
265B                ;-1165                 c += 0xB0;
265B                
265B 80 46 FE B0     add  byte[bp-2], 176
265F                
265F                ;-1166                 genCode2(c, R1No);
265F                
265F A0 34 01        mov al, byte [R1No]
2662 B4 00           mov ah, 0
2664 50              push ax
2665 8A 46 FE        mov al, byte [bp-2]
2668 B4 00           mov ah, 0
266A 50              push ax
266B E8 70 ED        call genCode2
266E 83 C4 04        add  sp, 4
2671                
2671                ;-1167                 genImmediate();
2671                
2671 E8 EE EE        call genImmediate
2674                
2674                ;-1168                 return;
2674                
2674 E9 00 00      R jmp .retnprocess
2677                
2677                ;-1169             }
2677                
2677                
2677                ;-1170             if (Op == MEM) {// m,i
2677                
2677                .process287:
2677 A0 2D 01        mov al, [Op]
267A 3C 04           cmp al, 4
267C 0F 85 00 00   r jne .process288
2680                
2680                ;-1171                 genCodeW(0xC6);
2680                
2680 68 C6 00        push 198
2683 E8 73 ED        call genCodeW
2686 83 C4 02        add  sp, 2
2689                
2689                ;-1172                 writeEA( 0 );
2689                
2689 6A 00           push 0
268B E8 CE ED        call writeEA
268E 83 C4 02        add  sp, 2
2691                
2691                ;-1173                 genImmediate();
2691                
2691 E8 CE EE        call genImmediate
2694                
2694                ;-1174                 return;
2694                
2694 E9 00 00      R jmp .retnprocess
2697                
2697                ;-1175             }
2697                
2697                
2697                ;-1176             regmemerror();
2697                
2697                .process288:
2697 E8 25 E5        call regmemerror
269A                
269A                ;-1177             return;
269A                
269A E9 00 00      R jmp .retnprocess
269D                
269D                ;-1178         }
269D                
269D                
269D                ;-1179         if (R1Type == SEGREG) ChangeDirection();//sreg,rm
269D                
269D                .process286:
269D A0 36 01        mov al, [R1Type]
26A0 3C 04           cmp al, 4
26A2 0F 85 00 00   r jne .process289
26A6 E8 E5 EF        call ChangeDirection
26A9                
26A9                ;-1180         if (R2Type == SEGREG) {//rm,sreg
26A9                
26A9                .process289:
26A9 A0 35 01        mov al, [R2Type]
26AC 3C 04           cmp al, 4
26AE 0F 85 00 00   r jne .process290
26B2                
26B2                ;-1181             if (OpSize != WORD) reg16error();
26B2                
26B2 A0 37 01        mov al, [OpSize]
26B5 3C 02           cmp al, 2
26B7 0F 84 00 00   r je  .process291
26BB E8 2B E5        call reg16error
26BE                
26BE                ;-1182                 genCode2(0x8C, dflag);
26BE                
26BE                .process291:
26BE A0 39 01        mov al, byte [dflag]
26C1 B4 00           mov ah, 0
26C3 50              push ax
26C4 68 8C 00        push 140
26C7 E8 14 ED        call genCode2
26CA 83 C4 04        add  sp, 4
26CD                
26CD                ;-1183                 writeEA(R2No);
26CD                
26CD A0 33 01        mov al, byte [R2No]
26D0 B4 00           mov ah, 0
26D2 50              push ax
26D3 E8 86 ED        call writeEA
26D6 83 C4 02        add  sp, 2
26D9                
26D9                ;-1184                 return;
26D9                
26D9 E9 00 00      R jmp .retnprocess
26DC                
26DC                ;-1185         }
26DC                
26DC                
26DC                ;-1186         if (Op2 == MEM) {//acc, moffs16
26DC                
26DC                .process290:
26DC A0 2E 01        mov al, [Op2]
26DF 3C 04           cmp al, 4
26E1 0F 85 00 00   r jne .process292
26E5                
26E5                ;-1187             if (Op == REG) {
26E5                
26E5 A0 2D 01        mov al, [Op]
26E8 3C 02           cmp al, 2
26EA 0F 85 00 00   r jne .process293
26EE                
26EE                ;-1188                 if (R1No == 0) {
26EE                
26EE A0 34 01        mov al, [R1No]
26F1 3C 00           cmp al, 0
26F3 0F 85 00 00   r jne .process294
26F7                
26F7                ;-1189                     if (isDirect) {
26F7                
26F7 A0 3C 01        mov al, [isDirect]
26FA 08 C0           or  al, al
26FC 0F 84 00 00   r je .process295
2700                
2700                ;-1190                         genCodeW(0xA0);
2700                
2700 68 A0 00        push 160
2703 E8 F3 EC        call genCodeW
2706 83 C4 02        add  sp, 2
2709                
2709                ;-1191                         genCode16(disp);
2709                
2709 FF 36 3D 01     push word [disp]
270D E8 05 ED        call genCode16
2710 83 C4 02        add  sp, 2
2713                
2713                ;-1192                         return;
2713                
2713 E9 00 00      R jmp .retnprocess
2716                
2716                ;-1193                     }
2716                
2716                
2716                ;-1194                 }
2716                
2716                .process295:
2716                
2716                ;-1195             }
2716                
2716                .process294:
2716                
2716                ;-1196         }
2716                
2716                .process293:
2716                
2716                ;-1197         if (Op == MEM) {//moffs16, acc
2716                
2716                .process292:
2716 A0 2D 01        mov al, [Op]
2719 3C 04           cmp al, 4
271B 0F 85 00 00   r jne .process296
271F                
271F                ;-1198             if (Op2 == REG) {
271F                
271F A0 2E 01        mov al, [Op2]
2722 3C 02           cmp al, 2
2724 0F 85 00 00   r jne .process297
2728                
2728                ;-1199                 if (R2No == 0) {
2728                
2728 A0 33 01        mov al, [R2No]
272B 3C 00           cmp al, 0
272D 0F 85 00 00   r jne .process298
2731                
2731                ;-1200                     if (isDirect) {
2731                
2731 A0 3C 01        mov al, [isDirect]
2734 08 C0           or  al, al
2736 0F 84 00 00   r je .process299
273A                
273A                ;-1201                         genCodeW(0xA2);
273A                
273A 68 A2 00        push 162
273D E8 B9 EC        call genCodeW
2740 83 C4 02        add  sp, 2
2743                
2743                ;-1202                         genCode16(disp);
2743                
2743 FF 36 3D 01     push word [disp]
2747 E8 CB EC        call genCode16
274A 83 C4 02        add  sp, 2
274D                
274D                ;-1203                         return;
274D                
274D E9 00 00      R jmp .retnprocess
2750                
2750                ;-1204                     }
2750                
2750                
2750                ;-1205                 }
2750                
2750                .process299:
2750                
2750                ;-1206             }
2750                
2750                .process298:
2750                
2750                ;-1207 
2750                
2750                
2750                ;-1208         }
2750                
2750                .process297:
2750                
2750                ;-1209         if (Op2 == REG) {//rm, r
2750                
2750                .process296:
2750 A0 2E 01        mov al, [Op2]
2753 3C 02           cmp al, 2
2755 0F 85 00 00   r jne .process300
2759                
2759                ;-1210             genCodeW(0x88);
2759                
2759 68 88 00        push 136
275C E8 9A EC        call genCodeW
275F 83 C4 02        add  sp, 2
2762                
2762                ;-1211             writeEA(R2No);
2762                
2762 A0 33 01        mov al, byte [R2No]
2765 B4 00           mov ah, 0
2767 50              push ax
2768 E8 F1 EC        call writeEA
276B 83 C4 02        add  sp, 2
276E                
276E                ;-1212             return;
276E                
276E E9 00 00      R jmp .retnprocess
2771                
2771                ;-1213         }
2771                
2771                
2771                ;-1214         if (Op2 == MEM) {//r, m
2771                
2771                .process300:
2771 A0 2E 01        mov al, [Op2]
2774 3C 04           cmp al, 4
2776 0F 85 00 00   r jne .process301
277A                
277A                ;-1215             if (Op == REG) {
277A                
277A A0 2D 01        mov al, [Op]
277D 3C 02           cmp al, 2
277F 0F 85 00 00   r jne .process302
2783                
2783                ;-1216                 ChangeDirection();
2783                
2783 E8 08 EF        call ChangeDirection
2786                
2786                ;-1217                 genCodeW(0x8A);
2786                
2786 68 8A 00        push 138
2789 E8 6D EC        call genCodeW
278C 83 C4 02        add  sp, 2
278F                
278F                ;-1218                 writeEA(R2No);
278F                
278F A0 33 01        mov al, byte [R2No]
2792 B4 00           mov ah, 0
2794 50              push ax
2795 E8 C4 EC        call writeEA
2798 83 C4 02        add  sp, 2
279B                
279B                ;-1219                 return;
279B                
279B E9 00 00      R jmp .retnprocess
279E                
279E                ;-1220             }
279E                
279E                
279E                ;-1221         }
279E                
279E                .process302:
279E                
279E                ;-1222         syntaxerror();
279E                
279E                .process301:
279E E8 97 E4        call syntaxerror
27A1                
27A1                ;-1223         return;
27A1                
27A1 E9 00 00      R jmp .retnprocess
27A4                
27A4                ;-1224     }
27A4                
27A4                
27A4                ;-1225 
27A4                
27A4                
27A4                ;-1226     if (CodeType == 6) {//Jcc
27A4                
27A4                .process282:
27A4 A0 2F 01        mov al, [CodeType]
27A7 3C 06           cmp al, 6
27A9 0F 85 00 00   r jne .process303
27AD                
27AD                ;-1227         if (TokeType == ALNUME) {
27AD                
27AD A0 2C 01        mov al, [TokeType]
27B0 3C 03           cmp al, 3
27B2 0F 85 00 00   r jne .process304
27B6                
27B6                ;-1228             LabelIx=searchLabel();
27B6                
27B6 E8 B5 F0        call searchLabel
27B9 A3 4E 01        mov word [LabelIx], ax
27BC                
27BC                ;-1229             if (LabelIx > 0) {
27BC                
27BC A1 4E 01        mov ax, [LabelIx]
27BF 83 F8 00        cmp ax, 0
27C2 0F 8E 00 00   r jle .process305
27C6                
27C6                ;-1230                 disp=LabelAddr[LabelIx];
27C6                
27C6 8B 1E 4E 01     mov bx, [LabelIx]
27CA D1 E3           shl bx, 1
27CC 8B 47 CA        mov ax, [LabelAddr + bx]
27CF A3 3D 01        mov word [disp], ax
27D2                
27D2                ;-1231                 disp = disp - PC;
27D2                
27D2 A1 3D 01        mov ax, [disp]
27D5 2B 06 23 01     sub ax, [PC]
27D9 A3 3D 01        mov word [disp], ax
27DC                
27DC                ;-1232                 disp = disp - Origin;
27DC                
27DC A1 3D 01        mov ax, [disp]
27DF 2B 06 25 01     sub ax, [Origin]
27E3 A3 3D 01        mov word [disp], ax
27E6                
27E6                ;-1233                 if (checkConstSize(disp) ) {
27E6                
27E6 FF 36 3D 01     push word [disp]
27EA E8 75 EE        call checkConstSize
27ED 83 C4 02        add  sp, 2
27F0 08 C0           or  al, al
27F2 0F 84 00 00   r je .process306
27F6                
27F6                ;-1234                     genCode2(Code1, 0x70);//short
27F6                
27F6 6A 70           push 112
27F8 A0 30 01        mov al, byte [Code1]
27FB B4 00           mov ah, 0
27FD 50              push ax
27FE E8 DD EB        call genCode2
2801 83 C4 04        add  sp, 4
2804                
2804                ;-1235                     disp -= 2;
2804                
2804 83 2E 3D 01 02  sub  word[disp], 2
2809                
2809                ;-1236                     genCode8(disp);
2809                
2809 FF 36 3D 01     push word [disp]
280D E8 6F EB        call genCode8
2810 83 C4 02        add  sp, 2
2813                
2813                ;-1237                 } else {
2813                
2813 E9 00 00      R jmp .process307
2816                .process306:
2816                
2816                ;-1238                     genCode8(0x0F);
2816                
2816 6A 0F           push 15
2818 E8 64 EB        call genCode8
281B 83 C4 02        add  sp, 2
281E                
281E                ;-1239                     genCode2(Code1, 0x80);//near
281E                
281E 68 80 00        push 128
2821 A0 30 01        mov al, byte [Code1]
2824 B4 00           mov ah, 0
2826 50              push ax
2827 E8 B4 EB        call genCode2
282A 83 C4 04        add  sp, 4
282D                
282D                ;-1240                     disp -= 4;
282D                
282D 83 2E 3D 01 04  sub  word[disp], 4
2832                
2832                ;-1241                     genCode16(disp);
2832                
2832 FF 36 3D 01     push word [disp]
2836 E8 DC EB        call genCode16
2839 83 C4 02        add  sp, 2
283C                
283C                ;-1242                 }
283C                
283C                
283C                ;-1243             }
283C                
283C                .process307:
283C                
283C                ;-1244             else {//jump forward, near only
283C                
283C E9 00 00      R jmp .process308
283F                .process305:
283F                
283F                ;-1245                 genCode8(0x0F);
283F                
283F 6A 0F           push 15
2841 E8 3B EB        call genCode8
2844 83 C4 02        add  sp, 2
2847                
2847                ;-1246                 genCode2(Code1, 0x80);
2847                
2847 68 80 00        push 128
284A A0 30 01        mov al, byte [Code1]
284D B4 00           mov ah, 0
284F 50              push ax
2850 E8 8B EB        call genCode2
2853 83 C4 04        add  sp, 4
2856                
2856                ;-1247                 storeJmp();
2856                
2856 E8 70 F3        call storeJmp
2859                
2859                ;-1248                 genCode16(0);
2859                
2859 6A 00           push 0
285B E8 B7 EB        call genCode16
285E 83 C4 02        add  sp, 2
2861                
2861                ;-1249                 PrintRA='r';
2861                
2861 B8 72 00        mov ax, 114
2864 A2 45 01        mov byte [PrintRA], al
2867                
2867                ;-1250             }
2867                
2867                
2867                ;-1251         return;
2867                
2867                .process308:
2867 E9 00 00      R jmp .retnprocess
286A                
286A                ;-1252         }
286A                
286A                
286A                ;-1253     }
286A                
286A                .process304:
286A                
286A                ;-1254 
286A                
286A                
286A                ;-1255     if (CodeType == 7) {//jmp, call
286A                
286A                .process303:
286A A0 2F 01        mov al, [CodeType]
286D 3C 07           cmp al, 7
286F 0F 85 00 00   r jne .process309
2873                
2873                ;-1256         if (TokeType == ALNUME) {
2873                
2873 A0 2C 01        mov al, [TokeType]
2876 3C 03           cmp al, 3
2878 0F 85 00 00   r jne .process310
287C                
287C                ;-1257             LabelIx=searchLabel();
287C                
287C E8 EF EF        call searchLabel
287F A3 4E 01        mov word [LabelIx], ax
2882                
2882                ;-1258             if (LabelIx > 0) {
2882                
2882 A1 4E 01        mov ax, [LabelIx]
2885 83 F8 00        cmp ax, 0
2888 0F 8E 00 00   r jle .process311
288C                
288C                ;-1259                 disp=LabelAddr[LabelIx];
288C                
288C 8B 1E 4E 01     mov bx, [LabelIx]
2890 D1 E3           shl bx, 1
2892 8B 47 CA        mov ax, [LabelAddr + bx]
2895 A3 3D 01        mov word [disp], ax
2898                
2898                ;-1260                 disp = disp - PC;
2898                
2898 A1 3D 01        mov ax, [disp]
289B 2B 06 23 01     sub ax, [PC]
289F A3 3D 01        mov word [disp], ax
28A2                
28A2                ;-1261                 disp = disp - Origin;
28A2                
28A2 A1 3D 01        mov ax, [disp]
28A5 2B 06 25 01     sub ax, [Origin]
28A9 A3 3D 01        mov word [disp], ax
28AC                
28AC                ;-1262                 if (checkConstSize(disp) ) {
28AC                
28AC FF 36 3D 01     push word [disp]
28B0 E8 AF ED        call checkConstSize
28B3 83 C4 02        add  sp, 2
28B6 08 C0           or  al, al
28B8 0F 84 00 00   r je .process312
28BC                
28BC                ;-1263                     if (Code1 == 0xE9) {//jmp only
28BC                
28BC A0 30 01        mov al, [Code1]
28BF 3C E9           cmp al, 233
28C1 0F 85 00 00   r jne .process313
28C5                
28C5                ;-1264                         genCode8(0xEB);//short
28C5                
28C5 68 EB 00        push 235
28C8 E8 B4 EA        call genCode8
28CB 83 C4 02        add  sp, 2
28CE                
28CE                ;-1265                         disp -= 2;
28CE                
28CE 83 2E 3D 01 02  sub  word[disp], 2
28D3                
28D3                ;-1266                         genCode8(disp);
28D3                
28D3 FF 36 3D 01     push word [disp]
28D7 E8 A5 EA        call genCode8
28DA 83 C4 02        add  sp, 2
28DD                
28DD                ;-1267                     }
28DD                
28DD                
28DD                ;-1268                     else {
28DD                
28DD E9 00 00      R jmp .process314
28E0                .process313:
28E0                
28E0                ;-1269                         genCode8(Code1);//near
28E0                
28E0 A0 30 01        mov al, byte [Code1]
28E3 B4 00           mov ah, 0
28E5 50              push ax
28E6 E8 96 EA        call genCode8
28E9 83 C4 02        add  sp, 2
28EC                
28EC                ;-1270                         disp -= 3;
28EC                
28EC 83 2E 3D 01 03  sub  word[disp], 3
28F1                
28F1                ;-1271                         genCode16(disp);
28F1                
28F1 FF 36 3D 01     push word [disp]
28F5 E8 1D EB        call genCode16
28F8 83 C4 02        add  sp, 2
28FB                
28FB                ;-1272                     }
28FB                
28FB                
28FB                ;-1273                 }
28FB                
28FB                .process314:
28FB                
28FB                ;-1274                 else {
28FB                
28FB E9 00 00      R jmp .process315
28FE                .process312:
28FE                
28FE                ;-1275                     genCode8(Code1);//near
28FE                
28FE A0 30 01        mov al, byte [Code1]
2901 B4 00           mov ah, 0
2903 50              push ax
2904 E8 78 EA        call genCode8
2907 83 C4 02        add  sp, 2
290A                
290A                ;-1276                     disp -= 3;
290A                
290A 83 2E 3D 01 03  sub  word[disp], 3
290F                
290F                ;-1277                     genCode16(disp);
290F                
290F FF 36 3D 01     push word [disp]
2913 E8 FF EA        call genCode16
2916 83 C4 02        add  sp, 2
2919                
2919                ;-1278                 }
2919                
2919                
2919                ;-1279             }
2919                
2919                .process315:
2919                
2919                ;-1280             else {//jump forward, near only
2919                
2919 E9 00 00      R jmp .process316
291C                .process311:
291C                
291C                ;-1281                 genCode8(Code1);  
291C                
291C A0 30 01        mov al, byte [Code1]
291F B4 00           mov ah, 0
2921 50              push ax
2922 E8 5A EA        call genCode8
2925 83 C4 02        add  sp, 2
2928                
2928                ;-1282                 if (PC != 1) storeJmp();//omit jmp main
2928                
2928 A1 23 01        mov ax, [PC]
292B 83 F8 01        cmp ax, 1
292E 0F 84 00 00   r je  .process317
2932 E8 94 F2        call storeJmp
2935                
2935                ;-1283                 genCode16(0);
2935                
2935                .process317:
2935 6A 00           push 0
2937 E8 DB EA        call genCode16
293A 83 C4 02        add  sp, 2
293D                
293D                ;-1284                 PrintRA='R';
293D                
293D B8 52 00        mov ax, 82
2940 A2 45 01        mov byte [PrintRA], al
2943                
2943                ;-1285             }
2943                
2943                
2943                ;-1286         return;
2943                
2943                .process316:
2943 E9 00 00      R jmp .retnprocess
2946                
2946                ;-1287         }
2946                
2946                
2946                ;-1288     }
2946                
2946                .process310:
2946                
2946                ;-1289 
2946                
2946                
2946                ;-1290     if (CodeType ==  8) {//ret,retf
2946                
2946                .process309:
2946 A0 2F 01        mov al, [CodeType]
2949 3C 08           cmp al, 8
294B 0F 85 00 00   r jne .process318
294F                
294F                ;-1291         if (TokeType == DIGIT) {
294F                
294F A0 2C 01        mov al, [TokeType]
2952 3C 01           cmp al, 1
2954 0F 85 00 00   r jne .process319
2958                
2958                ;-1292             genCode8(Code2);
2958                
2958 A0 31 01        mov al, byte [Code2]
295B B4 00           mov ah, 0
295D 50              push ax
295E E8 1E EA        call genCode8
2961 83 C4 02        add  sp, 2
2964                
2964                ;-1293             genCode16(SymbolInt);
2964                
2964 FF 36 0E 01     push word [SymbolInt]
2968 E8 AA EA        call genCode16
296B 83 C4 02        add  sp, 2
296E                
296E                ;-1294             return;
296E                
296E E9 00 00      R jmp .retnprocess
2971                
2971                ;-1295         }
2971                
2971                
2971                ;-1296         genCode8(Code1);
2971                
2971                .process319:
2971 A0 30 01        mov al, byte [Code1]
2974 B4 00           mov ah, 0
2976 50              push ax
2977 E8 05 EA        call genCode8
297A 83 C4 02        add  sp, 2
297D                
297D                ;-1297         return;
297D                
297D E9 00 00      R jmp .retnprocess
2980                
2980                ;-1298     }
2980                
2980                
2980                ;-1299 
2980                
2980                
2980                ;-1300     if (CodeType == 9) {//push, pop
2980                
2980                .process318:
2980 A0 2F 01        mov al, [CodeType]
2983 3C 09           cmp al, 9
2985 0F 85 00 00   r jne .process320
2989                
2989                ;-1301         getOpL();
2989                
2989 E8 CF F1        call getOpL
298C                
298C                ;-1302         if (Code1 == 0x50) {//push only
298C                
298C A0 30 01        mov al, [Code1]
298F 3C 50           cmp al, 80
2991 0F 85 00 00   r jne .process321
2995                
2995                ;-1303             if (Op == IMM) {//push imm8,16
2995                
2995 A0 2D 01        mov al, [Op]
2998 3C 01           cmp al, 1
299A 0F 85 00 00   r jne .process322
299E                
299E                ;-1304                 setsflag();
299E                
299E E8 65 EC        call setsflag
29A1                
29A1                ;-1305                 genCode2(0x68, sflag);
29A1                
29A1 A0 3A 01        mov al, byte [sflag]
29A4 B4 00           mov ah, 0
29A6 50              push ax
29A7 6A 68           push 104
29A9 E8 32 EA        call genCode2
29AC 83 C4 04        add  sp, 4
29AF                
29AF                ;-1306                 if (sflag) genCode8 (imme);
29AF                
29AF A0 3A 01        mov al, [sflag]
29B2 08 C0           or  al, al
29B4 0F 84 00 00   r je .process323
29B8 FF 36 3F 01     push word [imme]
29BC E8 C0 E9        call genCode8
29BF 83 C4 02        add  sp, 2
29C2                
29C2                ;-1307                 else       genCode16(imme);
29C2                
29C2 E9 00 00      R jmp .process324
29C5                .process323:
29C5 FF 36 3F 01     push word [imme]
29C9 E8 49 EA        call genCode16
29CC 83 C4 02        add  sp, 2
29CF                
29CF                ;-1308                 return;
29CF                
29CF                .process324:
29CF E9 00 00      R jmp .retnprocess
29D2                
29D2                ;-1309             }
29D2                
29D2                
29D2                ;-1310             if (Op == ADR) {//push string ABSOLUTE i16 
29D2                
29D2                .process322:
29D2 A0 2D 01        mov al, [Op]
29D5 3C 03           cmp al, 3
29D7 0F 85 00 00   r jne .process325
29DB                
29DB                ;-1311 //prscomment("\n push disp: "); printhex16 (disp);
29DB                
29DB                
29DB                ;-1312                 if (disp) {
29DB                
29DB A1 3D 01        mov ax, [disp]
29DE 08 C0           or  al, al
29E0 0F 84 00 00   r je .process326
29E4                
29E4                ;-1313                     genCode8(0x68);
29E4                
29E4 6A 68           push 104
29E6 E8 96 E9        call genCode8
29E9 83 C4 02        add  sp, 2
29EC                
29EC                ;-1314                     genCode16(disp);
29EC                
29EC FF 36 3D 01     push word [disp]
29F0 E8 22 EA        call genCode16
29F3 83 C4 02        add  sp, 2
29F6                
29F6                ;-1315                     return;
29F6                
29F6 E9 00 00      R jmp .retnprocess
29F9                
29F9                ;-1316                 }
29F9                
29F9                
29F9                ;-1317                 else {
29F9                
29F9 E9 00 00      R jmp .process327
29FC                .process326:
29FC                
29FC                ;-1318                     genCode8(0x68);
29FC                
29FC 6A 68           push 104
29FE E8 7E E9        call genCode8
2A01 83 C4 02        add  sp, 2
2A04                
2A04                ;-1319                     storeJmp();
2A04                
2A04 E8 C2 F1        call storeJmp
2A07                
2A07                ;-1320                     genCode16(0xAAAA);//magic for abs ADR
2A07                
2A07 68 AA AA        push 43690
2A0A E8 08 EA        call genCode16
2A0D 83 C4 02        add  sp, 2
2A10                
2A10                ;-1321                     PrintRA='A';
2A10                
2A10 B8 41 00        mov ax, 65
2A13 A2 45 01        mov byte [PrintRA], al
2A16                
2A16                ;-1322                     return;
2A16                
2A16 E9 00 00      R jmp .retnprocess
2A19                
2A19                ;-1323                 }
2A19                
2A19                
2A19                ;-1324             }
2A19                
2A19                .process327:
2A19                
2A19                ;-1325         }
2A19                
2A19                .process325:
2A19                
2A19                ;-1326         if (R1Type == SEGREG) {
2A19                
2A19                .process321:
2A19 A0 36 01        mov al, [R1Type]
2A1C 3C 04           cmp al, 4
2A1E 0F 85 00 00   r jne .process328
2A22                
2A22                ;-1327             if (Code1 == 0x58) {//pop only
2A22                
2A22 A0 30 01        mov al, [Code1]
2A25 3C 58           cmp al, 88
2A27 0F 85 00 00   r jne .process329
2A2B                
2A2B                ;-1328                 if (R1No == 1) error1("pop cs not allowed");
2A2B                
2A2B A0 34 01        mov al, [R1No]
2A2E 3C 01           cmp al, 1
2A30 0F 85 00 00   r jne .process330
2A34 68 AA AA      A push process_0
2A37 E8 01 E0        call error1
2A3A 83 C4 02        add  sp, 2
2A3D                
2A3D                ;-1329             }
2A3D                
2A3D                .process330:
2A3D                
2A3D                ;-1330             c = R1No <<3;
2A3D                
2A3D                .process329:
2A3D A0 34 01        mov al, [R1No]
2A40 C0 E0 03        shl al, 3
2A43 88 46 FE        mov [bp-2], al
2A46                
2A46                ;-1331             if (R1No > 3) {//FS, GS
2A46                
2A46 A0 34 01        mov al, [R1No]
2A49 3C 03           cmp al, 3
2A4B 0F 8E 00 00   r jle .process331
2A4F                
2A4F                ;-1332                 c += 122;
2A4F                
2A4F 80 46 FE 7A     add  byte[bp-2], 122
2A53                
2A53                ;-1333                 genCode8(0x0F);
2A53                
2A53 6A 0F           push 15
2A55 E8 27 E9        call genCode8
2A58 83 C4 02        add  sp, 2
2A5B                
2A5B                ;-1334             }
2A5B                
2A5B                
2A5B                ;-1335             OpCodePtr++;
2A5B                
2A5B                .process331:
2A5B FF 06 43 01     inc  word[OpCodePtr]
2A5F                
2A5F                ;-1336             c = c + *OpCodePtr;////////////////is Code4
2A5F                
2A5F 8A 46 FE        mov al, [bp-2]
2A62 8B 1E 43 01     mov bx, [OpCodePtr]
2A66 02 07           add al, [bx]
2A68 B4 00           mov ah, 0
2A6A 88 46 FE        mov [bp-2], al
2A6D                
2A6D                ;-1337             genCode8(c);
2A6D                
2A6D 8A 46 FE        mov al, byte [bp-2]
2A70 B4 00           mov ah, 0
2A72 50              push ax
2A73 E8 09 E9        call genCode8
2A76 83 C4 02        add  sp, 2
2A79                
2A79                ;-1338             return;
2A79                
2A79 E9 00 00      R jmp .retnprocess
2A7C                
2A7C                ;-1339         }
2A7C                
2A7C                
2A7C                ;-1340         checkOpL();//no ADR, SEGREG
2A7C                
2A7C                .process328:
2A7C E8 6D ED        call checkOpL
2A7F                
2A7F                ;-1341         if (R1Type == BYTE) reg16error();
2A7F                
2A7F A0 36 01        mov al, [R1Type]
2A82 3C 01           cmp al, 1
2A84 0F 85 00 00   r jne .process332
2A88 E8 5E E1        call reg16error
2A8B                
2A8B                ;-1342         if (R1Type == WORD) {
2A8B                
2A8B                .process332:
2A8B A0 36 01        mov al, [R1Type]
2A8E 3C 02           cmp al, 2
2A90 0F 85 00 00   r jne .process333
2A94                
2A94                ;-1343             genCode2(Code1, R1No);
2A94                
2A94 A0 34 01        mov al, byte [R1No]
2A97 B4 00           mov ah, 0
2A99 50              push ax
2A9A A0 30 01        mov al, byte [Code1]
2A9D B4 00           mov ah, 0
2A9F 50              push ax
2AA0 E8 3B E9        call genCode2
2AA3 83 C4 04        add  sp, 4
2AA6                
2AA6                ;-1344             return;
2AA6                
2AA6 E9 00 00      R jmp .retnprocess
2AA9                
2AA9                ;-1345         }
2AA9                
2AA9                
2AA9                ;-1346         if (Op == MEM) {
2AA9                
2AA9                .process333:
2AA9 A0 2D 01        mov al, [Op]
2AAC 3C 04           cmp al, 4
2AAE 0F 85 00 00   r jne .process334
2AB2                
2AB2                ;-1347             genCode8(Code2);
2AB2                
2AB2 A0 31 01        mov al, byte [Code2]
2AB5 B4 00           mov ah, 0
2AB7 50              push ax
2AB8 E8 C4 E8        call genCode8
2ABB 83 C4 02        add  sp, 2
2ABE                
2ABE                ;-1348             writeEA(Code3);//////////////////Code3
2ABE                
2ABE A0 32 01        mov al, byte [Code3]
2AC1 B4 00           mov ah, 0
2AC3 50              push ax
2AC4 E8 95 E9        call writeEA
2AC7 83 C4 02        add  sp, 2
2ACA                
2ACA                ;-1349             return;
2ACA                
2ACA E9 00 00      R jmp .retnprocess
2ACD                
2ACD                ;-1350         }
2ACD                
2ACD                
2ACD                ;-1351         syntaxerror();
2ACD                
2ACD                .process334:
2ACD E8 68 E1        call syntaxerror
2AD0                
2AD0                ;-1352         return;
2AD0                
2AD0 E9 00 00      R jmp .retnprocess
2AD3                
2AD3                ;-1353     }
2AD3                
2AD3                
2AD3                ;-1354 
2AD3                
2AD3                
2AD3                ;-1355     if (CodeType == 11) {//shift, rotate
2AD3                
2AD3                .process320:
2AD3 A0 2F 01        mov al, [CodeType]
2AD6 3C 0B           cmp al, 11
2AD8 0F 85 00 00   r jne .process335
2ADC                
2ADC                ;-1356         check2Ops();
2ADC                
2ADC E8 B3 F0        call check2Ops
2ADF                
2ADF                ;-1357         if (Op2 == IMM) {
2ADF                
2ADF A0 2E 01        mov al, [Op2]
2AE2 3C 01           cmp al, 1
2AE4 0F 85 00 00   r jne .process336
2AE8                
2AE8                ;-1358             if (imme == 1) {
2AE8                
2AE8 A1 3F 01        mov ax, [imme]
2AEB 83 F8 01        cmp ax, 1
2AEE 0F 85 00 00   r jne .process337
2AF2                
2AF2                ;-1359                 genCodeW(0xD0);
2AF2                
2AF2 68 D0 00        push 208
2AF5 E8 01 E9        call genCodeW
2AF8 83 C4 02        add  sp, 2
2AFB                
2AFB                ;-1360                 writeEA(Code1);
2AFB                
2AFB A0 30 01        mov al, byte [Code1]
2AFE B4 00           mov ah, 0
2B00 50              push ax
2B01 E8 58 E9        call writeEA
2B04 83 C4 02        add  sp, 2
2B07                
2B07                ;-1361                 return;
2B07                
2B07 E9 00 00      R jmp .retnprocess
2B0A                
2B0A                ;-1362             }
2B0A                
2B0A                
2B0A                ;-1363             genCodeW(0xC0);//80186
2B0A                
2B0A                .process337:
2B0A 68 C0 00        push 192
2B0D E8 E9 E8        call genCodeW
2B10 83 C4 02        add  sp, 2
2B13                
2B13                ;-1364             writeEA(Code1);
2B13                
2B13 A0 30 01        mov al, byte [Code1]
2B16 B4 00           mov ah, 0
2B18 50              push ax
2B19 E8 40 E9        call writeEA
2B1C 83 C4 02        add  sp, 2
2B1F                
2B1F                ;-1365             genCode8(imme);
2B1F                
2B1F FF 36 3F 01     push word [imme]
2B23 E8 59 E8        call genCode8
2B26 83 C4 02        add  sp, 2
2B29                
2B29                ;-1366             return;
2B29                
2B29 E9 00 00      R jmp .retnprocess
2B2C                
2B2C                ;-1367         }
2B2C                
2B2C                
2B2C                ;-1368         if (Op2 == REG) {
2B2C                
2B2C                .process336:
2B2C A0 2E 01        mov al, [Op2]
2B2F 3C 02           cmp al, 2
2B31 0F 85 00 00   r jne .process338
2B35                
2B35                ;-1369             if (R2Type == BYTE) {
2B35                
2B35 A0 35 01        mov al, [R2Type]
2B38 3C 01           cmp al, 1
2B3A 0F 85 00 00   r jne .process339
2B3E                
2B3E                ;-1370                 if (R2No == 1) {//CL-REG
2B3E                
2B3E A0 33 01        mov al, [R2No]
2B41 3C 01           cmp al, 1
2B43 0F 85 00 00   r jne .process340
2B47                
2B47                ;-1371                     if (R1Type == WORD) wflag=1;//hack
2B47                
2B47 A0 36 01        mov al, [R1Type]
2B4A 3C 02           cmp al, 2
2B4C 0F 85 00 00   r jne .process341
2B50 B8 01 00        mov ax, 1
2B53 A2 38 01        mov byte [wflag], al
2B56                
2B56                ;-1372                     genCodeW(0xD2);
2B56                
2B56                .process341:
2B56 68 D2 00        push 210
2B59 E8 9D E8        call genCodeW
2B5C 83 C4 02        add  sp, 2
2B5F                
2B5F                ;-1373                     writeEA(Code1);
2B5F                
2B5F A0 30 01        mov al, byte [Code1]
2B62 B4 00           mov ah, 0
2B64 50              push ax
2B65 E8 F4 E8        call writeEA
2B68 83 C4 02        add  sp, 2
2B6B                
2B6B                ;-1374                     return;
2B6B                
2B6B E9 00 00      R jmp .retnprocess
2B6E                
2B6E                ;-1375                 }
2B6E                
2B6E                
2B6E                ;-1376             }
2B6E                
2B6E                .process340:
2B6E                
2B6E                ;-1377         }
2B6E                
2B6E                .process339:
2B6E                
2B6E                ;-1378     }
2B6E                
2B6E                .process338:
2B6E                
2B6E                ;-1379 
2B6E                
2B6E                
2B6E                ;-1380     if (CodeType == 12) {//int
2B6E                
2B6E                .process335:
2B6E A0 2F 01        mov al, [CodeType]
2B71 3C 0C           cmp al, 12
2B73 0F 85 00 00   r jne .process342
2B77                
2B77                ;-1381         if (TokeType == DIGIT) {
2B77                
2B77 A0 2C 01        mov al, [TokeType]
2B7A 3C 01           cmp al, 1
2B7C 0F 85 00 00   r jne .process343
2B80                
2B80                ;-1382             genCode8(Code1);
2B80                
2B80 A0 30 01        mov al, byte [Code1]
2B83 B4 00           mov ah, 0
2B85 50              push ax
2B86 E8 F6 E7        call genCode8
2B89 83 C4 02        add  sp, 2
2B8C                
2B8C                ;-1383             genCode8(SymbolInt);
2B8C                
2B8C FF 36 0E 01     push word [SymbolInt]
2B90 E8 EC E7        call genCode8
2B93 83 C4 02        add  sp, 2
2B96                
2B96                ;-1384             return;
2B96                
2B96 E9 00 00      R jmp .retnprocess
2B99                
2B99                ;-1385         }
2B99                
2B99                
2B99                ;-1386     }
2B99                
2B99                .process343:
2B99                
2B99                ;-1387 
2B99                
2B99                
2B99                ;-1388     if (CodeType == 30) {//enter i18,i8
2B99                
2B99                .process342:
2B99 A0 2F 01        mov al, [CodeType]
2B9C 3C 1E           cmp al, 30
2B9E 0F 85 00 00   r jne .process344
2BA2                
2BA2                ;-1389         genCode8(0xC8);
2BA2                
2BA2 68 C8 00        push 200
2BA5 E8 D7 E7        call genCode8
2BA8 83 C4 02        add  sp, 2
2BAB                
2BAB                ;-1390         Op=getOp1();
2BAB                
2BAB E8 10 ED        call getOp1
2BAE A2 2D 01        mov byte [Op], al
2BB1                
2BB1                ;-1391         if (Op == IMM) genCode16(SymbolInt);
2BB1                
2BB1 A0 2D 01        mov al, [Op]
2BB4 3C 01           cmp al, 1
2BB6 0F 85 00 00   r jne .process345
2BBA FF 36 0E 01     push word [SymbolInt]
2BBE E8 54 E8        call genCode16
2BC1 83 C4 02        add  sp, 2
2BC4                
2BC4                ;-1392         else numbererror();
2BC4                
2BC4 E9 00 00      R jmp .process346
2BC7                .process345:
2BC7 E8 DB DF        call numbererror
2BCA                
2BCA                ;-1393         need(',');
2BCA                
2BCA                .process346:
2BCA 6A 2C           push 44
2BCC E8 B5 EB        call need
2BCF 83 C4 02        add  sp, 2
2BD2                
2BD2                ;-1394         Op=getOp1();
2BD2                
2BD2 E8 E9 EC        call getOp1
2BD5 A2 2D 01        mov byte [Op], al
2BD8                
2BD8                ;-1395         if (Op == IMM) genCode8 (SymbolInt);
2BD8                
2BD8 A0 2D 01        mov al, [Op]
2BDB 3C 01           cmp al, 1
2BDD 0F 85 00 00   r jne .process347
2BE1 FF 36 0E 01     push word [SymbolInt]
2BE5 E8 97 E7        call genCode8
2BE8 83 C4 02        add  sp, 2
2BEB                
2BEB                ;-1396         else numbererror();
2BEB                
2BEB E9 00 00      R jmp .process348
2BEE                .process347:
2BEE E8 B4 DF        call numbererror
2BF1                
2BF1                ;-1397         return;
2BF1                
2BF1                .process348:
2BF1 E9 00 00      R jmp .retnprocess
2BF4                
2BF4                ;-1398     }
2BF4                
2BF4                
2BF4                ;-1399 
2BF4                
2BF4                
2BF4                ;-1400     if (CodeType==101) {//ORG nn
2BF4                
2BF4                .process344:
2BF4 A0 2F 01        mov al, [CodeType]
2BF7 3C 65           cmp al, 101
2BF9 0F 85 00 00   r jne .process349
2BFD                
2BFD                ;-1401         if (TokeType != DIGIT) numbererror();
2BFD                
2BFD A0 2C 01        mov al, [TokeType]
2C00 3C 01           cmp al, 1
2C02 0F 84 00 00   r je  .process350
2C06 E8 9C DF        call numbererror
2C09                
2C09                ;-1402         Origin=SymbolInt;
2C09                
2C09                .process350:
2C09 A1 0E 01        mov ax, [SymbolInt]
2C0C A3 25 01        mov word [Origin], ax
2C0F                
2C0F                ;-1403         return;
2C0F                
2C0F E9 00 00      R jmp .retnprocess
2C12                
2C12                ;-1404     }
2C12                
2C12                
2C12                ;-1405 
2C12                
2C12                
2C12                ;-1406     if (CodeType == 102) {//section, segment
2C12                
2C12                .process349:
2C12 A0 2F 01        mov al, [CodeType]
2C15 3C 66           cmp al, 102
2C17 0F 85 00 00   r jne .process351
2C1B                
2C1B                ;-1407         //getTokeType();//ignore .bss .text .data
2C1B                
2C1B                
2C1B                ;-1408         AbsoluteLab=0;//nasm resets erevy time
2C1B                
2C1B B8 00 00        mov ax, 0
2C1E A3 27 01        mov word [AbsoluteLab], ax
2C21                
2C21                ;-1409         return;
2C21                
2C21 E9 00 00      R jmp .retnprocess
2C24                
2C24                ;-1410     }
2C24                
2C24                
2C24                ;-1411 
2C24                
2C24                
2C24                ;-1412     if (CodeType == 110) {//absolute
2C24                
2C24                .process351:
2C24 A0 2F 01        mov al, [CodeType]
2C27 3C 6E           cmp al, 110
2C29 0F 85 00 00   r jne .process352
2C2D                
2C2D                ;-1413         if (TokeType != DIGIT) numbererror();
2C2D                
2C2D A0 2C 01        mov al, [TokeType]
2C30 3C 01           cmp al, 1
2C32 0F 84 00 00   r je  .process353
2C36 E8 6C DF        call numbererror
2C39                
2C39                ;-1414         AbsoluteLab=SymbolInt;
2C39                
2C39                .process353:
2C39 A1 0E 01        mov ax, [SymbolInt]
2C3C A3 27 01        mov word [AbsoluteLab], ax
2C3F                
2C3F                ;-1415         return;
2C3F                
2C3F E9 00 00      R jmp .retnprocess
2C42                
2C42                ;-1416     }
2C42                
2C42                
2C42                ;-1417     if (CodeType == 111) {//name: PROC
2C42                
2C42                .process352:
2C42 A0 2F 01        mov al, [CodeType]
2C45 3C 6F           cmp al, 111
2C47 0F 85 00 00   r jne .process354
2C4B                
2C4B                ;-1418         if (isInProc == 0)  {
2C4B                
2C4B A0 0D 01        mov al, [isInProc]
2C4E 3C 00           cmp al, 0
2C50 0F 85 00 00   r jne .process355
2C54                
2C54                ;-1419             prs("\nentering: ");
2C54                
2C54 68 AA AA      A push process_1
2C57 E8 D5 DA        call prs
2C5A 83 C4 02        add  sp, 2
2C5D                
2C5D                ;-1420             prs(ProcName);
2C5D                
2C5D 8D 06 6E 75     lea  ax, [ProcName]
2C61 50              push ax
2C62 E8 CA DA        call prs
2C65 83 C4 02        add  sp, 2
2C68                
2C68                ;-1421             isInProc=1;
2C68                
2C68 B8 01 00        mov ax, 1
2C6B A2 0D 01        mov byte [isInProc], al
2C6E                
2C6E                ;-1422             tmpLabelNamePtr = LabelNamePtr;
2C6E                
2C6E A1 46 01        mov ax, [LabelNamePtr]
2C71 A3 48 01        mov word [tmpLabelNamePtr], ax
2C74                
2C74                ;-1423             tmpLabelMaxIx   = LabelMaxIx;
2C74                
2C74 A1 4A 01        mov ax, [LabelMaxIx]
2C77 A3 4C 01        mov word [tmpLabelMaxIx], ax
2C7A                
2C7A                ;-1424             tmpJmpNamePtr   = JmpNamePtr;
2C7A                
2C7A A1 50 01        mov ax, [JmpNamePtr]
2C7D A3 52 01        mov word [tmpJmpNamePtr], ax
2C80                
2C80                ;-1425             tmpJmpMaxIx     = JmpMaxIx;
2C80                
2C80 A1 54 01        mov ax, [JmpMaxIx]
2C83 A3 56 01        mov word [tmpJmpMaxIx], ax
2C86                
2C86                ;-1426         } else error1("already in PROC");
2C86                
2C86 E9 00 00      R jmp .process356
2C89                .process355:
2C89 68 AA AA      A push process_2
2C8C E8 AC DD        call error1
2C8F 83 C4 02        add  sp, 2
2C92                
2C92                ;-1427         return;
2C92                
2C92                .process356:
2C92 E9 00 00      R jmp .retnprocess
2C95                
2C95                ;-1428     }
2C95                
2C95                
2C95                ;-1429     if (CodeType == 112) {//ENDP 
2C95                
2C95                .process354:
2C95 A0 2F 01        mov al, [CodeType]
2C98 3C 70           cmp al, 112
2C9A 0F 85 00 00   r jne .process357
2C9E                
2C9E                ;-1430         if (isInProc == 0) error1("not in PROC");
2C9E                
2C9E A0 0D 01        mov al, [isInProc]
2CA1 3C 00           cmp al, 0
2CA3 0F 85 00 00   r jne .process358
2CA7 68 AA AA      A push process_3
2CAA E8 8E DD        call error1
2CAD 83 C4 02        add  sp, 2
2CB0                
2CB0                ;-1431         prs("\nleaving: ");
2CB0                
2CB0                .process358:
2CB0 68 AA AA      A push process_4
2CB3 E8 79 DA        call prs
2CB6 83 C4 02        add  sp, 2
2CB9                
2CB9                ;-1432         prs(ProcName);
2CB9                
2CB9 8D 06 6E 75     lea  ax, [ProcName]
2CBD 50              push ax
2CBE E8 6E DA        call prs
2CC1 83 C4 02        add  sp, 2
2CC4                
2CC4                ;-1433         prs(", loc labels: ");
2CC4                
2CC4 68 AA AA      A push process_5
2CC7 E8 65 DA        call prs
2CCA 83 C4 02        add  sp, 2
2CCD                
2CCD                ;-1434         i = LabelMaxIx - tmpLabelMaxIx;
2CCD                
2CCD A1 4A 01        mov ax, [LabelMaxIx]
2CD0 2B 06 4C 01     sub ax, [tmpLabelMaxIx]
2CD4 89 46 FC        mov [bp-4], ax
2CD7                
2CD7                ;-1435         printIntU(i);
2CD7                
2CD7 55              push word [bp-4]
2CD8 E8 60 DB        call printIntU
2CDB 83 C4 02        add  sp, 2
2CDE                
2CDE                ;-1436         prs(", loc jmp forward: ");
2CDE                
2CDE 68 AA AA      A push process_6
2CE1 E8 4B DA        call prs
2CE4 83 C4 02        add  sp, 2
2CE7                
2CE7                ;-1437         i = JmpMaxIx - tmpJmpMaxIx;
2CE7                
2CE7 A1 54 01        mov ax, [JmpMaxIx]
2CEA 2B 06 56 01     sub ax, [tmpJmpMaxIx]
2CEE 89 46 FC        mov [bp-4], ax
2CF1                
2CF1                ;-1438         printIntU(i);        
2CF1                
2CF1 55              push word [bp-4]
2CF2 E8 46 DB        call printIntU
2CF5 83 C4 02        add  sp, 2
2CF8                
2CF8                ;-1439         fixJmp();
2CF8                
2CF8 E8 C6 F4        call fixJmp
2CFB                
2CFB                ;-1440         isInProc=0;
2CFB                
2CFB B8 00 00        mov ax, 0
2CFE A2 0D 01        mov byte [isInProc], al
2D01                
2D01                ;-1441         LabelNamePtr = tmpLabelNamePtr;//delete local Labels
2D01                
2D01 A1 48 01        mov ax, [tmpLabelNamePtr]
2D04 A3 46 01        mov word [LabelNamePtr], ax
2D07                
2D07                ;-1442         LabelMaxIx   = tmpLabelMaxIx;                       
2D07                
2D07 A1 4C 01        mov ax, [tmpLabelMaxIx]
2D0A A3 4A 01        mov word [LabelMaxIx], ax
2D0D                
2D0D                ;-1443         JmpNamePtr   = tmpJmpNamePtr;//delete local Jmp
2D0D                
2D0D A1 52 01        mov ax, [tmpJmpNamePtr]
2D10 A3 50 01        mov word [JmpNamePtr], ax
2D13                
2D13                ;-1444         JmpMaxIx     = tmpJmpMaxIx;
2D13                
2D13 A1 56 01        mov ax, [tmpJmpMaxIx]
2D16 A3 54 01        mov word [JmpMaxIx], ax
2D19                
2D19                ;-1445         return;
2D19                
2D19 E9 00 00      R jmp .retnprocess
2D1C                
2D1C                ;-1446     } 
2D1C                
2D1C                
2D1C                ;-1447     if (CodeType == 200) {//db  
2D1C                
2D1C                .process357:
2D1C A0 2F 01        mov al, [CodeType]
2D1F 3C C8           cmp al, 200
2D21 0F 85 00 00   r jne .process359
2D25                
2D25                ;-1448         genDB();
2D25                
2D25 E8 C2 EF        call genDB
2D28                
2D28                ;-1449         return;
2D28                
2D28 E9 00 00      R jmp .retnprocess
2D2B                
2D2B                ;-1450     }
2D2B                
2D2B                
2D2B                ;-1451     
2D2B                
2D2B                
2D2B                ;-1452     error1("Command not implemented or syntax error");
2D2B                
2D2B                .process359:
2D2B 68 AA AA      A push process_7
2D2E E8 0A DD        call error1
2D31 83 C4 02        add  sp, 2
2D34                
2D34                ;-1453 }
2D34                
2D34                
2D34                ;-1454 
2D34                
2D34                
2D34                ;-1455 int parse() {
2D34                
2D34 C9              .retnprocess: LEAVE
2D35 C3              ret
2D36 70 6F 70 20 63 process_0 db "pop cs not allowed",0
2D49 5C 6E 65 6E 74 process_1 db "\nentering: ",0
2D56 61 6C 72 65 61 process_2 db "already in PROC",0
2D66 6E 6F 74 20 69 process_3 db "not in PROC",0
2D72 5C 6E 6C 65 61 process_4 db "\nleaving: ",0
2D7E 2C 20 6C 6F 63 process_5 db ", loc labels: ",0
2D8D 2C 20 6C 6F 63 process_6 db ", loc jmp forward: ",0
2DA1 43 6F 6D 6D 61 process_7 db "Command not implemented or syntax error",0
leaving: process, loc labels: 110, loc jmp forward: 149
2DC9                ENDP
2DC9                
entering: parse
2DC9                parse: PROC
2DC9                
2DC9                ;-1456     LabelNamePtr  = &LabelNames;
2DC9                
2DC9 B8 5A 77        mov ax, LabelNames
2DCC A3 46 01        mov word [LabelNamePtr], ax
2DCF                
2DCF                ;-1457     JmpNamePtr= &JmpNames;
2DCF                
2DCF B8 7A 93        mov ax, JmpNames
2DD2 A3 50 01        mov word [JmpNamePtr], ax
2DD5                
2DD5                ;-1458     LabelMaxIx=0;
2DD5                
2DD5 B8 00 00        mov ax, 0
2DD8 A3 4A 01        mov word [LabelMaxIx], ax
2DDB                
2DDB                ;-1459     JmpMaxIx=0;
2DDB                
2DDB B8 00 00        mov ax, 0
2DDE A3 54 01        mov word [JmpMaxIx], ax
2DE1                
2DE1                ;-1460     BinLen=0;
2DE1                
2DE1 B8 00 00        mov ax, 0
2DE4 A3 58 01        mov word [BinLen], ax
2DE7                
2DE7                ;-1461     isInProc=0;
2DE7                
2DE7 B8 00 00        mov ax, 0
2DEA A2 0D 01        mov byte [isInProc], al
2DED                
2DED                ;-1462 
2DED                
2DED                
2DED                ;-1463     do {//process a new line
2DED                
2DED                .parse360:
2DED                
2DED                ;-1464         PCStart=PC;
2DED                
2DED A1 23 01        mov ax, [PC]
2DF0 A3 29 01        mov word [PCStart], ax
2DF3                
2DF3                ;-1465         OpSize=0;
2DF3                
2DF3 B8 00 00        mov ax, 0
2DF6 A2 37 01        mov byte [OpSize], al
2DF9                
2DF9                ;-1466         OpPrintIndex=0;
2DF9                
2DF9 B8 00 00        mov ax, 0
2DFC A3 41 01        mov word [OpPrintIndex], ax
2DFF                
2DFF                ;-1467         PrintRA=' ';
2DFF                
2DFF B8 20 00        mov ax, 32
2E02 A2 45 01        mov byte [PrintRA], al
2E05                
2E05                ;-1468         getLine();
2E05                
2E05 E8 0F DF        call getLine
2E08                
2E08                ;-1469         InputPtr = &InputBuf;
2E08                
2E08 B8 8D 75        mov ax, InputBuf
2E0B A3 14 01        mov word [InputPtr], ax
2E0E                
2E0E                ;-1470         getTokeType();//getCode in SymbolUpper,
2E0E                
2E0E E8 BF E8        call getTokeType
2E11                
2E11                ;-1471                       //set TokeType,isLabel by getName
2E11                
2E11                
2E11                ;-1472         if (TokeType == ALNUME) {
2E11                
2E11 A0 2C 01        mov al, [TokeType]
2E14 3C 03           cmp al, 3
2E16 0F 85 00 00   r jne .parse361
2E1A                
2E1A                ;-1473             if (isLabel) {//set in getName
2E1A                
2E1A A0 2B 01        mov al, [isLabel]
2E1D 08 C0           or  al, al
2E1F 0F 84 00 00   r je .parse362
2E23                
2E23                ;-1474               if (isInProc == 0)  strcpy(ProcName, Symbol);
2E23                
2E23 A0 0D 01        mov al, [isInProc]
2E26 3C 00           cmp al, 0
2E28 0F 85 00 00   r jne .parse363
2E2C 8D 06 30 75     lea  ax, [Symbol]
2E30 50              push ax
2E31 8D 06 6E 75     lea  ax, [ProcName]
2E35 50              push ax
2E36 E8 F1 D3        call strcpy
2E39 83 C4 04        add  sp, 4
2E3C                
2E3C                ;-1475                 storeLabel();
2E3C                
2E3C                .parse363:
2E3C E8 05 EE        call storeLabel
2E3F                
2E3F                ;-1476                 InputPtr++;//remove :
2E3F                
2E3F FF 06 14 01     inc  word[InputPtr]
2E43                
2E43                ;-1477                 getTokeType();
2E43                
2E43 E8 8A E8        call getTokeType
2E46                
2E46                ;-1478             }
2E46                
2E46                
2E46                ;-1479         }
2E46                
2E46                .parse362:
2E46                
2E46                ;-1480         if (TokeType == ALNUME) {
2E46                
2E46                .parse361:
2E46 A0 2C 01        mov al, [TokeType]
2E49 3C 03           cmp al, 3
2E4B 0F 85 00 00   r jne .parse364
2E4F                
2E4F                ;-1481             lookCode();// and OpCodePtr
2E4F                
2E4F E8 B6 E4        call lookCode
2E52                
2E52                ;-1482             if(CodeType) process();
2E52                
2E52 A0 2F 01        mov al, [CodeType]
2E55 08 C0           or  al, al
2E57 0F 84 00 00   r je .parse365
2E5B E8 71 F5        call process
2E5E                
2E5E                ;-1483             else getVariable();
2E5E                
2E5E E9 00 00      R jmp .parse366
2E61                .parse365:
2E61 E8 0B EF        call getVariable
2E64                
2E64                ;-1484             skipRest();
2E64                
2E64                .parse366:
2E64 E8 5C E9        call skipRest
2E67                
2E67                ;-1485         }
2E67                
2E67                
2E67                ;-1486         else if (TokeType >ALNUME) error1("Label or instruction expected");
2E67                
2E67 E9 00 00      R jmp .parse367
2E6A                .parse364:
2E6A A0 2C 01        mov al, [TokeType]
2E6D 3C 03           cmp al, 3
2E6F 0F 8E 00 00   r jle .parse368
2E73 68 AA AA      A push parse_0
2E76 E8 C2 DB        call error1
2E79 83 C4 02        add  sp, 2
2E7C                
2E7C                ;-1487         else if (TokeType==DIGIT ) error1("No digit allowed at start of line");
2E7C                
2E7C E9 00 00      R jmp .parse369
2E7F                .parse368:
2E7F A0 2C 01        mov al, [TokeType]
2E82 3C 01           cmp al, 1
2E84 0F 85 00 00   r jne .parse370
2E88 68 AA AA      A push parse_1
2E8B E8 AD DB        call error1
2E8E 83 C4 02        add  sp, 2
2E91                
2E91                ;-1488         printLine();
2E91                
2E91                .parse370:
2E91                .parse369:
2E91                .parse367:
2E91 E8 E5 D9        call printLine
2E94                
2E94                ;-1489     } while (DOS_NoBytes != 0 );
2E94                
2E94 A1 20 01        mov ax, [DOS_NoBytes]
2E97 83 F8 00        cmp ax, 0
2E9A 0F 84 00 00   r je  .parse371
2E9E E9 4C FF        jmp .parse360
2EA1                .parse371:
2EA1                
2EA1                ;-1490 }
2EA1                
2EA1                
2EA1                ;-1491 
2EA1                
2EA1                
2EA1                ;-1492 int main() {
2EA1                
2EA1 C3              ret
2EA2 4C 61 62 65 6C parse_0 db "Label or instruction expected",0
2EC0 4E 6F 20 64 69 parse_1 db "No digit allowed at start of line",0
leaving: parse, loc labels: 14, loc jmp forward: 13
2EE2                ENDP
2EE2                
entering: main
2EE2                main: PROC
2EE2                
2EE2                ;-1493     getarg();
2EE2                
2EE2 E8 99 F0        call getarg
2EE5                
2EE5                ;-1494     parse();
2EE5                
2EE5 E8 E1 FE        call parse
2EE8                
2EE8                ;-1495     fixJmpMain();
2EE8                
2EE8 E8 8E F3        call fixJmpMain
2EEB                
2EEB                ;-1496     epilog();
2EEB                
2EEB E8 34 DA        call epilog
2EEE                
2EEE                ;-1497     end1();
2EEE                
2EEE E8 1F DB        call end1
2EF1                
2EF1                ;-1498 }
2EF1                
2EF1 C3              ret
leaving: main, loc labels: 0, loc jmp forward: 0
2EF2                ENDP
2EF2                 
2EF2                ; missing functions: 
2EF2                ; Number of unresolved CALLs :    0 All FUNCTIONs in place
******* next line ERROR: extra char ignored, Symbol: E8h
2EF2 00             LastFunctionByt:db 0E8h, 0, 0
2EF3 58             pop ax
2EF4 C3             ret
2EF5                 
2EF5                ;   # type sign width  adr used name   list of global variables
2EF5                
2EF5                ;    1 arr sign byte     1    2 Version1[9]
2EF5                ;    2 def unsg byte     3    - SYMBOLMAX=31
2EF5                ;    3 arr sign byte     4   14 Symbol[31]
2EF5                ;    4 arr sign byte     5   36 SymbolUpper[31]
2EF5                ;    5 arr sign byte     6    3 ProcName[31]
2EF5                ;    6 var sign byte     7    6 isInProc
2EF5                ;    7 var unsg word     8   25 SymbolInt
2EF5                ;    8 var unsg dwrd     9 NULL SymbolLong
2EF5                ;    9 def unsg byte    10    - INPUTBUFMAX=255
2EF5                ;   10 arr sign byte    11    4 InputBuf[255]
2EF5                ;   11 ptr unsg byte    12   28 InputPtr
2EF5                ;   12 arr sign byte    13    5 namein[67]
2EF5                ;   13 arr sign byte    14    6 namelst[67]
2EF5                ;   14 arr sign byte    15    6 namebin[67]
2EF5                ;   15 var sign word    16    4 asm_fd
2EF5                ;   16 var sign word    17    3 lst_fd
2EF5                ;   17 var sign word    18    3 bin_fd
2EF5                ;   18 var sign word    19    6 DOS_ERR
2EF5                ;   19 var sign word    20    5 ErrorCount
2EF5                ;   20 var sign word    21    4 DOS_NoBytes
2EF5                ;   21 var sign byte    22    5 DOS_ByteRead
2EF5                ;   22 var unsg word    24    8 PC
2EF5                ;   23 var unsg word    25    6 Origin
2EF5                ;   24 var unsg word    26    6 AbsoluteLab
2EF5                ;   25 var unsg word    27    2 PCStart
2EF5                ;   26 var sign byte    28    3 isLabel
2EF5                ;   27 def unsg byte    29    - DIGIT=1
2EF5                ;   28 def unsg byte    30    - LETTERE=2
2EF5                ;   29 def unsg byte    31    - ALNUME=3
2EF5                ;   30 def unsg byte    32    - NOALNUME=4
2EF5                ;   31 var sign byte    33   28 TokeType
2EF5                ;   32 def unsg byte    34    - BYTE=1
2EF5                ;   33 def unsg byte    35    - WORD=2
2EF5                ;   34 def unsg byte    36    - DWORD=3
2EF5                ;   35 def unsg byte    37    - SEGREG=4
2EF5                ;   36 def unsg byte    38    - IMM=1
2EF5                ;   37 def unsg byte    39    - REG=2
2EF5                ;   38 def unsg byte    40    - ADR=3
2EF5                ;   39 def unsg byte    41    - MEM=4
2EF5                ;   40 var sign byte    42   29 Op
2EF5                ;   41 var sign byte    43   32 Op2
2EF5                ;   42 var sign byte    44   29 CodeType
2EF5                ;   43 var sign byte    45   23 Code1
2EF5                ;   44 var sign byte    46    7 Code2
2EF5                ;   45 var sign byte    47    3 Code3
2EF5                ;   46 var sign byte    48   19 R2No
2EF5                ;   47 var sign byte    49   16 R1No
2EF5                ;   48 var sign byte    50   18 R2Type
2EF5                ;   49 var sign byte    51   15 R1Type
2EF5                ;   50 var sign byte    52   14 OpSize
2EF5                ;   51 var sign byte    53    9 wflag
2EF5                ;   52 var sign byte    54    3 dflag
2EF5                ;   53 var sign byte    55    8 sflag
2EF5                ;   54 var sign byte    56   15 rm
2EF5                ;   55 var sign byte    57    5 isDirect
2EF5                ;   56 var sign word    58   67 disp
2EF5                ;   57 var unsg word    59   14 imme
2EF5                ;   58 def unsg byte    61    - OPMAXLEN=5
2EF5                ;   59 arr sign byte    62    2 OpPos[5]
2EF5                ;   60 var sign word    63    6 OpPrintIndex
2EF5                ;   61 ptr sign byte    64   19 OpCodePtr
2EF5                ;   62 var sign byte    65    5 PrintRA
2EF5                ;   63 def unsg byte    67    - LABELNAMESMAX=5969
2EF5                ;   64 arr sign byte    68    3 LabelNames[6000]
2EF5                ;   65 ptr sign byte    69    7 LabelNamePtr
2EF5                ;   66 ptr sign byte    70    2 tmpLabelNamePtr
2EF5                ;   67 def unsg byte    72    - LABELADRMAX=600
2EF5                ;   68 arr unsg word    73    9 LabelAddr[600]
2EF5                ;   69 var sign word    74   10 LabelMaxIx
2EF5                ;   70 var sign word    75    3 tmpLabelMaxIx
2EF5                ;   71 var sign word    76   13 LabelIx
2EF5                ;   72 def unsg byte    78    - JMPNAMESMAX=3969
2EF5                ;   73 arr sign byte    79    3 JmpNames[4000]
2EF5                ;   74 ptr sign byte    80    7 JmpNamePtr
2EF5                ;   75 ptr sign byte    81    2 tmpJmpNamePtr
2EF5                ;   76 def unsg byte    83    - JMPMAX=200
2EF5                ;   77 arr unsg word    84    2 JmpAddr[200]
2EF5                ;   78 var sign word    85   10 JmpMaxIx
2EF5                ;   79 var sign word    86    3 tmpJmpMaxIx
2EF5                ;   80 def unsg byte    88    - FILEBINMAX=17000
2EF5                ;   81 arr sign byte    89    8 FileBin[17000]
2EF5                ;   82 var unsg word    90    6 BinLen
2EF5                ;   83 ptr sign byte    92    1 arglen
2EF5                ;   84 ptr sign byte    93    4 argv
2EF5                ;   85 var sign byte   451    1 I_START
2EF5                ;   86 arr sign byte   454 NULL I_PUSHA[8125]
2EF5                ;   87 arr sign byte   455 NULL I_NOP[24260]
2EF5                ;   88 arr sign byte   456 NULL I_CWDE[9734]
2EF5                ;   89 arr sign byte   457 NULL I_CDQ[1931]
2EF5                ;   90 arr sign byte   458 NULL I_PUSHF[35622]
2EF5                ;   91 arr sign byte   459 NULL I_SAHF[599]
2EF5                ;   92 arr sign byte   460 NULL I_MOVSB[53495]
2EF5                ;   93 arr sign byte   461 NULL I_CMPSB[54007]
2EF5                ;   94 arr sign byte   462 NULL I_STOSB[37]
2EF5                ;   95 arr sign byte   463 NULL I_LODSB[33600]
2EF5                ;   96 arr sign byte   464 NULL I_SCASB[8418]
2EF5                ;   97 arr sign byte   465 NULL I_LEAVE[53259]
2EF5                ;   98 arr sign byte   466 NULL I_INTO[12917]
2EF5                ;   99 arr sign byte   467 NULL I_XLAT[35622]
2EF5                ;  100 arr sign byte   468 NULL I_REPNE[2119]
2EF5                ;  101 arr sign byte   469 NULL I_REPE[18057]
2EF5                ;  102 arr sign byte   470 NULL I_HLT[9982]
2EF5                ;  103 arr sign byte   471 NULL I_STC[18315]
2EF5                ;  104 arr sign byte   472 NULL I_STI[9734]
2EF5                ;  105 arr sign byte   473 NULL I_STD[32643]
2EF5                ;  106 arr sign byte   475 NULL I_INC[10]
2EF5                ;  107 arr sign byte   476 NULL I_DEC[1397]
2EF5                ;  108 arr sign byte   477 NULL I_NOT[18119]
2EF5                ;  109 arr sign byte   478 NULL I_NEG[65534]
2EF5                ;  110 arr sign byte   479 NULL I_MUL[33791]
2EF5                ;  111 arr sign byte   480 NULL I_IMUL[65150]
2EF5                ;  112 arr sign byte   481 NULL I_DIV[30207]
2EF5                ;  113 arr sign byte   482 NULL I_IDIV[15642]
2EF5                ;  114 arr sign byte   484 NULL I_LES[65535]
2EF5                ;  115 arr sign byte   485 NULL I_LDS[5493]
2EF5                ;  116 arr sign byte   486 NULL I_LEA[33574]
2EF5                ;  117 arr sign byte   487 NULL I_LSS[1151]
2EF5                ;  118 arr sign byte   488 NULL I_LFS[29696]
2EF5                ;  119 arr sign byte   489 NULL I_LGS[35593]
2EF5                ;  120 arr sign byte   491 NULL I_ADD[2630]
2EF5                ;  121 arr sign byte   492 NULL I_OR[14630]
2EF5                ;  122 arr sign byte   493 NULL I_ADC[1095]
2EF5                ;  123 arr sign byte   494 NULL I_SBB[26997]
2EF5                ;  124 arr sign byte   495 NULL I_AND[49203]
2EF5                ;  125 arr sign byte   496 NULL I_SUB[52169]
2EF5                ;  126 arr sign byte   497 NULL I_XOR[33680]
2EF5                ;  127 arr sign byte   498 NULL I_CMP[65150]
2EF5                ;  128 arr sign byte   499 NULL I_TEST[29729]
2EF5                ;  129 arr sign byte   501 NULL I_MOV[33618]
2EF5                ;  130 arr sign byte   502 NULL I_MOVSX[65150]
2EF5                ;  131 arr sign byte   503 NULL I_MOVZX[29731]
2EF5                ;  132 arr sign byte   505 NULL I_JO[33612]
2EF5                ;  133 arr sign byte   506 NULL I_JNO[65150]
2EF5                ;  134 arr sign byte   507 NULL I_JB[29732]
2EF5                ;  135 arr sign byte   508 NULL I_JNB[33606]
2EF5                ;  136 arr sign byte   509 NULL I_JAE[65150]
2EF5                ;  137 arr sign byte   510 NULL I_JE[29734]
2EF5                ;  138 arr sign byte   511 NULL I_JNE[33600]
2EF5                ;  139 arr sign byte   512 NULL I_JBE[65150]
2EF5                ;  140 arr sign byte   513 NULL I_JA[29730]
2EF5                ;  141 arr sign byte   514 NULL I_JS[33594]
2EF5                ;  142 arr sign byte   515 NULL I_JNS[65150]
2EF5                ;  143 arr sign byte   516 NULL I_JP[29737]
2EF5                ;  144 arr sign byte   517 NULL I_JNP[33588]
2EF5                ;  145 arr sign byte   518 NULL I_JL[65150]
2EF5                ;  146 arr sign byte   519 NULL I_JNL[29736]
2EF5                ;  147 arr sign byte   520 NULL I_JLE[33582]
2EF5                ;  148 arr sign byte   521 NULL I_JG[65150]
2EF5                ;  149 arr sign byte   523 NULL I_JMP[29733]
2EF5                ;  150 arr sign byte   524 NULL I_CALL[15656]
2EF5                ;  151 arr sign byte   526 NULL I_RET[33]
2EF5                ;  152 arr sign byte   527 NULL I_RETF[9076]
2EF5                ;  153 arr sign byte   529 NULL I_PUSH[9021]
2EF5                ;  154 arr sign byte   530 NULL I_POP[29696]
2EF5                ;  155 arr sign byte   532 NULL I_ROL[15646]
2EF5                ;  156 arr sign byte   533 NULL I_RCL[36]
2EF5                ;  157 arr sign byte   534 NULL I_SHL[6516]
2EF5                ;  158 arr sign byte   535 NULL I_SHR[9789]
2EF5                ;  159 arr sign byte   537 NULL I_INT[29696]
2EF5                ;  160 arr sign byte   539 NULL I_IN[15636]
2EF5                ;  161 arr sign byte   540 NULL I_INSB[34]
2EF5                ;  162 arr sign byte   541 NULL I_INSW[3956]
2EF5                ;  163 arr sign byte   542 NULL I_INSD[10557]
2EF5                ;  164 arr sign byte   543 NULL I_OUT[29696]
2EF5                ;  165 arr sign byte   544 NULL I_OUTSB[15626]
2EF5                ;  166 arr sign byte   545 NULL I_OUTSW[40]
2EF5                ;  167 arr sign byte   546 NULL I_OUTSD[1396]
2EF5                ;  168 arr sign byte   548 NULL I_XCHG[9533]
2EF5                ;  169 arr sign byte   550 NULL I_LOOPNZ[29952]
2EF5                ;  170 arr sign byte   551 NULL I_LOOPNE[33542]
2EF5                ;  171 arr sign byte   552 NULL I_LOOPZ[2686]
2EF5                ;  172 arr sign byte   553 NULL I_LOOPE[60176]
2EF5                ;  173 arr sign byte   554 NULL I_LOOP[33540]
2EF5                ;  174 arr sign byte   555 NULL I_JCXZ[2686]
2EF5                ;  175 arr sign byte   556 NULL I_JECXZ[29984]
2EF5                ;  176 arr sign byte   558 NULL I_ENTER[47255]
2EF5                ;  177 arr sign byte   560 NULL I_ORG[1]
2EF5                ;  178 arr sign byte   562 NULL I_SECTION[52169]
2EF5                ;  179 arr sign byte   563 NULL I_SEGMENT[21904]
2EF5                ;  180 arr sign byte   564 NULL I_ABSOLUTE[60555]
2EF5                ;  181 arr sign byte   565 NULL I_PROC[5816]
2EF5                ;  182 arr sign byte   566 NULL I_ENDP[39424]
2EF5                ;  183 arr sign byte   567 NULL I_DB[674]
2EF5                ;  184 arr sign byte   568 NULL I_DW[8125]
2EF5                ;  185 arr sign byte   569 NULL I_DD[51030]
2EF5                ;  186 arr sign byte   570 NULL I_RESB[65094]
2EF5                ;  187 arr sign byte   571 NULL I_RESW[0]
2EF5                ;  188 arr sign byte   572 NULL I_RESD[1678]
2EF5                ;  189 var sign byte   573 NULL I_END
2EF5                
2EF5                
2EF5                ;   # Calls Line Width  Name   list of functions
2EF5                
2EF5                ;    0    4   97   writetty
2EF5                ;    1    1   98   putch
2EF5                ;    2    8   99   cputs
2EF5                ;    3    6  101   DosInt
2EF5                ;    4    1  106   openR
2EF5                ;    5    2  107   creatR
2EF5                ;    6    3  108   fcloseR
2EF5                ;    7    5  109   exitR
2EF5                ;    8    2  110   readRL
2EF5                ;    9    2  112   fputcR
2EF5                ;   10    2  115   letterE
2EF5                ;   11    3  125   digit
2EF5                ;   12    1  130   alnumE
2EF5                ;   13    4  135   strlen
2EF5                ;   14   10  140   strcpy
2EF5                ;   15   35  146   eqstr
2EF5                ;   16    3  155   strcat1
2EF5                ;   17    2  159   toupper
2EF5                ;   18    1  166   testReg
2EF5                ;   19    7  209   prc
2EF5                ;   20    1  219   prscomment
2EF5                ;   21   38  227   prs
2EF5                ;   22    2  249   printhex4
2EF5                ;   23    3  254   printhex8a
2EF5                ;   24    3  259   printhex16
2EF5                ;   25    7  264   printIntU
2EF5                ;   26    1  274   printLine
2EF5                ;   27    2  297   epilog
2EF5                ;   28    2  345   end1
2EF5                ;   29   27  353   error1
2EF5                ;   30   13  360   errorexit
2EF5                ;   31    5  365   notfounderror
2EF5                ;   32 NULL  371   allowederror
2EF5                ;   33    3  372   addrerror
2EF5                ;   34    1  373   immeerror
2EF5                ;   35    2  374   implerror
2EF5                ;   36    4  375   indexerror
2EF5                ;   37    2  376   invaloperror
2EF5                ;   38    6  377   numbererror
2EF5                ;   39    1  378   regmemerror
2EF5                ;   40    3  379   reg16error
2EF5                ;   41    1  380   segregerror
2EF5                ;   42    5  381   syntaxerror
2EF5                ;   43 NULL  383   addrexit
2EF5                ;   44    3  384   dataexit
2EF5                ;   45 NULL  385   internexit
2EF5                ;   46    1  387   ifEOL
2EF5                ;   47    1  396   getLine
2EF5                ;   48    4  412   skipBlank
2EF5                ;   49    1  418   getDigit
2EF5                ;   50    1  430   getName
2EF5                ;   51    2  575   lookCode
2EF5                ;   52   37  591   genCode8
2EF5                ;   53    1  602   gen66h
2EF5                ;   54    8  604   genCode2
2EF5                ;   55   13  608   genCodeW
2EF5                ;   56   19  612   genCode16
2EF5                ;   57    1  616   genCode32
2EF5                ;   58   13  620   writeEA
2EF5                ;   59    4  662   genImmediate
2EF5                ;   60    2  669   setwflag
2EF5                ;   61    2  680   setsflag
2EF5                ;   62    2  690   checkConstSize
2EF5                ;   63    2  697   ChangeDirection
2EF5                ;   64   17  705   getTokeType
2EF5                ;   65   11  716   isToken
2EF5                ;   66    2  726   need
2EF5                ;   67    1  735   skipRest
2EF5                ;   68    2  741   checkOpL
2EF5                ;   69    6  750   searchLabel
2EF5                ;   70    4  763   getOp1
2EF5                ;   71    1  778   getIndReg1
2EF5                ;   72    1  786   getIndReg2
2EF5                ;   73    1  795   getMEM
2EF5                ;   74    2  822   getOpR
2EF5                ;   75    3  835   getOpL
2EF5                ;   76    1  842   get2Ops
2EF5                ;   77    4  847   check2Ops
2EF5                ;   78    3  857   storeJmp
2EF5                ;   79    2  868   storeLabel
2EF5                ;   80    1  881   genDB
2EF5                ;   81    1  902   getVariable
2EF5                ;   82    1  955   getCodeSize
2EF5                ;   83    1  965   getarg
2EF5                ;   84    1  999   fixJmp
2EF5                ;   85    1 1032   fixJmpMain
2EF5                ;   86    1 1058   getCodes
2EF5                ;   87    1 1064   process
2EF5                ;   88    1 1455   parse
2EF5                ;   89 NULL 1492   main
2EF5                ;   90 NULL 1498   LastFunctionByt
2EF5                
2EF5                ;    #  addr name   list of CALLs
2EF5                
2EF5                ;    0     0 writetty
2EF5                ;    1     9 writetty
2EF5                ;    2    18 putch
2EF5                ;    3    24 DosInt
2EF5                ;    4    31 DosInt
2EF5                ;    5    38 DosInt
2EF5                ;    6    45 DosInt
2EF5                ;    7    52 DosInt
2EF5                ;    8    59 DosInt
2EF5                ;    9    66 digit
2EF5                ;   10    72 letterE
2EF5                ;   11    80 strcpy
2EF5                ;   12    87 strlen
2EF5                ;   13    94 strlen
2EF5                ;   14   101 eqstr
2EF5                ;   15   107 eqstr
2EF5                ;   16   113 eqstr
2EF5                ;   17   119 eqstr
2EF5                ;   18   125 eqstr
2EF5                ;   19   131 eqstr
2EF5                ;   20   137 eqstr
2EF5                ;   21   143 eqstr
2EF5                ;   22   149 eqstr
2EF5                ;   23   155 eqstr
2EF5                ;   24   161 eqstr
2EF5                ;   25   167 eqstr
2EF5                ;   26   173 eqstr
2EF5                ;   27   179 eqstr
2EF5                ;   28   185 eqstr
2EF5                ;   29   191 eqstr
2EF5                ;   30   197 eqstr
2EF5                ;   31   203 eqstr
2EF5                ;   32   209 eqstr
2EF5                ;   33   215 eqstr
2EF5                ;   34   221 eqstr
2EF5                ;   35   227 eqstr
2EF5                ;   36   233 eqstr
2EF5                ;   37   239 eqstr
2EF5                ;   38   245 eqstr
2EF5                ;   39   251 eqstr
2EF5                ;   40   257 eqstr
2EF5                ;   41   263 eqstr
2EF5                ;   42   269 eqstr
2EF5                ;   43   275 eqstr
2EF5                ;   44   281 writetty
2EF5                ;   45   290 writetty
2EF5                ;   46   299 fputcR
2EF5                ;   47   306 prc
2EF5                ;   48   310 prc
2EF5                ;   49   314 prc
2EF5                ;   50   318 printhex4
2EF5                ;   51   328 printhex4
2EF5                ;   52   338 printhex8a
2EF5                ;   53   349 printhex8a
2EF5                ;   54   360 printIntU
2EF5                ;   55   370 prc
2EF5                ;   56   374 prs
2EF5                ;   57   378 printhex16
2EF5                ;   58   389 prs
2EF5                ;   59   393 prc
2EF5                ;   60   397 printhex8a
2EF5                ;   61   408 prs
2EF5                ;   62   412 prc
2EF5                ;   63   416 prscomment
2EF5                ;   64   427 prs
2EF5                ;   65   431 printIntU
2EF5                ;   66   441 prs
2EF5                ;   67   445 prs
2EF5                ;   68   449 prs
2EF5                ;   69   453 prs
2EF5                ;   70   457 prs
2EF5                ;   71   461 prs
2EF5                ;   72   465 printIntU
2EF5                ;   73   475 prs
2EF5                ;   74   479 prs
2EF5                ;   75   483 printIntU
2EF5                ;   76   493 fputcR
2EF5                ;   77   500 fcloseR
2EF5                ;   78   508 fcloseR
2EF5                ;   79   516 fcloseR
2EF5                ;   80   524 exitR
2EF5                ;   81   530 prs
2EF5                ;   82   534 prs
2EF5                ;   83   538 prs
2EF5                ;   84   542 prs
2EF5                ;   85   546 error1
2EF5                ;   86   553 epilog
2EF5                ;   87   560 end1
2EF5                ;   88   565 prs
2EF5                ;   89   569 prs
2EF5                ;   90   573 prs
2EF5                ;   91   577 error1
2EF5                ;   92   584 error1
2EF5                ;   93   591 error1
2EF5                ;   94   598 error1
2EF5                ;   95   605 error1
2EF5                ;   96   612 error1
2EF5                ;   97   619 error1
2EF5                ;   98   626 error1
2EF5                ;   99   633 error1
2EF5                ;  100   640 error1
2EF5                ;  101   647 error1
2EF5                ;  102   654 errorexit
2EF5                ;  103   664 errorexit
2EF5                ;  104   674 errorexit
2EF5                ;  105   684 readRL
2EF5                ;  106   691 errorexit
2EF5                ;  107   701 readRL
2EF5                ;  108   708 errorexit
2EF5                ;  109   718 errorexit
2EF5                ;  110   728 ifEOL
2EF5                ;  111   734 digit
2EF5                ;  112   740 alnumE
2EF5                ;  113   747 errorexit
2EF5                ;  114   757 strcpy
2EF5                ;  115   764 toupper
2EF5                ;  116   772 eqstr
2EF5                ;  117   778 errorexit
2EF5                ;  118   788 genCode8
2EF5                ;  119   797 genCode8
2EF5                ;  120   806 genCode8
2EF5                ;  121   815 genCode8
2EF5                ;  122   824 genCode8
2EF5                ;  123   833 genCode16
2EF5                ;  124   843 genCode16
2EF5                ;  125   853 genCode8
2EF5                ;  126   862 genCode8
2EF5                ;  127   871 genCode16
2EF5                ;  128   881 genCode32
2EF5                ;  129   891 genCode16
2EF5                ;  130   901 genCode8
2EF5                ;  131   910 gen66h
2EF5                ;  132   917 error1
2EF5                ;  133   924 skipBlank
2EF5                ;  134   934 digit
2EF5                ;  135   940 getDigit
2EF5                ;  136   949 letterE
2EF5                ;  137   957 getName
2EF5                ;  138   965 skipBlank
2EF5                ;  139   975 isToken
2EF5                ;  140   983 getTokeType
2EF5                ;  141   995 error1
2EF5                ;  142  1002 prs
2EF5                ;  143  1006 prc
2EF5                ;  144  1010 getTokeType
2EF5                ;  145  1022 error1
2EF5                ;  146  1029 implerror
2EF5                ;  147  1039 segregerror
2EF5                ;  148  1051 setwflag
2EF5                ;  149  1060 error1
2EF5                ;  150  1067 error1
2EF5                ;  151  1074 eqstr
2EF5                ;  152  1080 strlen
2EF5                ;  153  1087 testReg
2EF5                ;  154  1095 searchLabel
2EF5                ;  155  1107 indexerror
2EF5                ;  156  1118 indexerror
2EF5                ;  157  1129 indexerror
2EF5                ;  158  1140 indexerror
2EF5                ;  159  1151 getTokeType
2EF5                ;  160  1163 getOp1
2EF5                ;  161  1170 syntaxerror
2EF5                ;  162  1182 getIndReg2
2EF5                ;  163  1193 getIndReg1
2EF5                ;  164  1204 notfounderror
2EF5                ;  165  1218 isToken
2EF5                ;  166  1226 getTokeType
2EF5                ;  167  1238 numbererror
2EF5                ;  168  1250 isToken
2EF5                ;  169  1258 isToken
2EF5                ;  170  1266 errorexit
2EF5                ;  171  1276 getOp1
2EF5                ;  172  1283 isToken
2EF5                ;  173  1291 getMEM
2EF5                ;  174  1298 invaloperror
2EF5                ;  175  1311 error1
2EF5                ;  176  1318 getOpR
2EF5                ;  177  1325 getOpL
2EF5                ;  178  1332 need
2EF5                ;  179  1337 getOpR
2EF5                ;  180  1344 get2Ops
2EF5                ;  181  1352 addrerror
2EF5                ;  182  1362 invaloperror
2EF5                ;  183  1375 immeerror
2EF5                ;  184  1385 addrerror
2EF5                ;  185  1395 setwflag
2EF5                ;  186  1404 errorexit
2EF5                ;  187  1414 strcpy
2EF5                ;  188  1421 errorexit
2EF5                ;  189  1431 searchLabel
2EF5                ;  190  1443 error1
2EF5                ;  191  1450 errorexit
2EF5                ;  192  1460 strcpy
2EF5                ;  193  1467 errorexit
2EF5                ;  194  1477 getTokeType
2EF5                ;  195  1489 genCode8
2EF5                ;  196  1498 skipBlank
2EF5                ;  197  1508 isToken
2EF5                ;  198  1516 genCode8
2EF5                ;  199  1525 isToken
2EF5                ;  200  1533 storeLabel
2EF5                ;  201  1544 getTokeType
2EF5                ;  202  1556 lookCode
2EF5                ;  203  1565 dataexit
2EF5                ;  204  1574 dataexit
2EF5                ;  205  1583 getTokeType
2EF5                ;  206  1595 genCode8
2EF5                ;  207  1604 skipBlank
2EF5                ;  208  1614 isToken
2EF5                ;  209  1622 genCode8
2EF5                ;  210  1631 isToken
2EF5                ;  211  1639 getTokeType
2EF5                ;  212  1651 genCode16
2EF5                ;  213  1661 isToken
2EF5                ;  214  1669 getTokeType
2EF5                ;  215  1681 genCode16
2EF5                ;  216  1691 genCode16
2EF5                ;  217  1701 isToken
2EF5                ;  218  1709 getTokeType
2EF5                ;  219  1721 syntaxerror
2EF5                ;  220  1733 error1
2EF5                ;  221  1740 numbererror
2EF5                ;  222  1752 dataexit
2EF5                ;  223  1761 eqstr
2EF5                ;  224  1767 getTokeType
2EF5                ;  225  1779 eqstr
2EF5                ;  226  1785 getTokeType
2EF5                ;  227  1797 eqstr
2EF5                ;  228  1803 getTokeType
2EF5                ;  229  1815 cputs
2EF5                ;  230  1821 cputs
2EF5                ;  231  1827 exitR
2EF5                ;  232  1833 toupper
2EF5                ;  233  1841 strcpy
2EF5                ;  234  1848 strcat1
2EF5                ;  235  1856 strcpy
2EF5                ;  236  1863 strcat1
2EF5                ;  237  1871 strcpy
2EF5                ;  238  1878 strcat1
2EF5                ;  239  1886 openR
2EF5                ;  240  1892 cputs
2EF5                ;  241  1898 cputs
2EF5                ;  242  1904 exitR
2EF5                ;  243  1910 creatR
2EF5                ;  244  1917 cputs
2EF5                ;  245  1923 cputs
2EF5                ;  246  1929 exitR
2EF5                ;  247  1935 creatR
2EF5                ;  248  1942 cputs
2EF5                ;  249  1948 cputs
2EF5                ;  250  1954 exitR
2EF5                ;  251  1960 prs
2EF5                ;  252  1964 prs
2EF5                ;  253  1968 prs
2EF5                ;  254  1972 prs
2EF5                ;  255  1976 prs
2EF5                ;  256  1980 prs
2EF5                ;  257  1984 prs
2EF5                ;  258  1988 prs
2EF5                ;  259  1992 prs
2EF5                ;  260  1996 strcpy
2EF5                ;  261  2003 strlen
2EF5                ;  262  2010 searchLabel
2EF5                ;  263  2022 notfounderror
2EF5                ;  264  2036 prs
2EF5                ;  265  2040 printIntU
2EF5                ;  266  2050 error1
2EF5                ;  267  2057 strcpy
2EF5                ;  268  2064 searchLabel
2EF5                ;  269  2076 notfounderror
2EF5                ;  270  2090 prs
2EF5                ;  271  2094 printhex16
2EF5                ;  272  2105 prs
2EF5                ;  273  2109 printhex16
2EF5                ;  274  2120 getTokeType
2EF5                ;  275  2132 getCodeSize
2EF5                ;  276  2144 getCodes
2EF5                ;  277  2153 genCode8
2EF5                ;  278  2162 getOpL
2EF5                ;  279  2169 checkOpL
2EF5                ;  280  2178 genCode2
2EF5                ;  281  2187 getTokeType
2EF5                ;  282  2199 implerror
2EF5                ;  283  2209 genCodeW
2EF5                ;  284  2218 writeEA
2EF5                ;  285  2226 check2Ops
2EF5                ;  286  2236 reg16error
2EF5                ;  287  2247 addrerror
2EF5                ;  288  2257 genCode8
2EF5                ;  289  2266 genCode8
2EF5                ;  290  2275 writeEA
2EF5                ;  291  2283 check2Ops
2EF5                ;  292  2293 notfounderror
2EF5                ;  293  2307 setsflag
2EF5                ;  294  2316 genCodeW
2EF5                ;  295  2325 genImmediate
2EF5                ;  296  2338 genCodeW
2EF5                ;  297  2347 writeEA
2EF5                ;  298  2355 genCode8
2EF5                ;  299  2364 genImmediate
2EF5                ;  300  2377 genCodeW
2EF5                ;  301  2386 writeEA
2EF5                ;  302  2394 genCodeW
2EF5                ;  303  2403 writeEA
2EF5                ;  304  2411 syntaxerror
2EF5                ;  305  2423 check2Ops
2EF5                ;  306  2433 notfounderror
2EF5                ;  307  2447 genCode2
2EF5                ;  308  2456 genImmediate
2EF5                ;  309  2469 genCodeW
2EF5                ;  310  2478 writeEA
2EF5                ;  311  2486 genImmediate
2EF5                ;  312  2499 regmemerror
2EF5                ;  313  2511 ChangeDirection
2EF5                ;  314  2527 reg16error
2EF5                ;  315  2538 genCode2
2EF5                ;  316  2547 writeEA
2EF5                ;  317  2555 genCodeW
2EF5                ;  318  2564 genCode16
2EF5                ;  319  2574 genCodeW
2EF5                ;  320  2583 genCode16
2EF5                ;  321  2593 genCodeW
2EF5                ;  322  2602 writeEA
2EF5                ;  323  2610 ChangeDirection
2EF5                ;  324  2626 genCodeW
2EF5                ;  325  2635 writeEA
2EF5                ;  326  2643 syntaxerror
2EF5                ;  327  2655 searchLabel
2EF5                ;  328  2667 checkConstSize
2EF5                ;  329  2682 genCode2
2EF5                ;  330  2691 genCode8
2EF5                ;  331  2700 genCode8
2EF5                ;  332  2709 genCode2
2EF5                ;  333  2718 genCode16
2EF5                ;  334  2728 genCode8
2EF5                ;  335  2737 genCode2
2EF5                ;  336  2746 storeJmp
2EF5                ;  337  2755 genCode16
2EF5                ;  338  2765 searchLabel
2EF5                ;  339  2777 checkConstSize
2EF5                ;  340  2792 genCode8
2EF5                ;  341  2801 genCode8
2EF5                ;  342  2810 genCode8
2EF5                ;  343  2819 genCode16
2EF5                ;  344  2829 genCode8
2EF5                ;  345  2838 genCode16
2EF5                ;  346  2848 genCode8
2EF5                ;  347  2857 storeJmp
2EF5                ;  348  2866 genCode16
2EF5                ;  349  2876 genCode8
2EF5                ;  350  2885 genCode16
2EF5                ;  351  2895 genCode8
2EF5                ;  352  2904 getOpL
2EF5                ;  353  2911 setsflag
2EF5                ;  354  2920 genCode2
2EF5                ;  355  2929 genCode8
2EF5                ;  356  2938 genCode16
2EF5                ;  357  2948 genCode8
2EF5                ;  358  2957 genCode16
2EF5                ;  359  2967 genCode8
2EF5                ;  360  2976 storeJmp
2EF5                ;  361  2985 genCode16
2EF5                ;  362  2995 error1
2EF5                ;  363  3002 genCode8
2EF5                ;  364  3011 genCode8
2EF5                ;  365  3020 checkOpL
2EF5                ;  366  3029 reg16error
2EF5                ;  367  3040 genCode2
2EF5                ;  368  3049 genCode8
2EF5                ;  369  3058 writeEA
2EF5                ;  370  3066 syntaxerror
2EF5                ;  371  3078 check2Ops
2EF5                ;  372  3088 genCodeW
2EF5                ;  373  3097 writeEA
2EF5                ;  374  3105 genCodeW
2EF5                ;  375  3114 writeEA
2EF5                ;  376  3122 genCode8
2EF5                ;  377  3131 genCodeW
2EF5                ;  378  3140 writeEA
2EF5                ;  379  3148 genCode8
2EF5                ;  380  3157 genCode8
2EF5                ;  381  3166 genCode8
2EF5                ;  382  3175 getOp1
2EF5                ;  383  3182 genCode16
2EF5                ;  384  3192 numbererror
2EF5                ;  385  3204 need
2EF5                ;  386  3209 getOp1
2EF5                ;  387  3216 genCode8
2EF5                ;  388  3225 numbererror
2EF5                ;  389  3237 numbererror
2EF5                ;  390  3249 numbererror
2EF5                ;  391  3261 prs
2EF5                ;  392  3265 prs
2EF5                ;  393  3269 error1
2EF5                ;  394  3276 error1
2EF5                ;  395  3283 prs
2EF5                ;  396  3287 prs
2EF5                ;  397  3291 prs
2EF5                ;  398  3295 printIntU
2EF5                ;  399  3305 prs
2EF5                ;  400  3309 printIntU
2EF5                ;  401  3319 fixJmp
2EF5                ;  402  3326 genDB
2EF5                ;  403  3332 error1
2EF5                ;  404  3339 getLine
2EF5                ;  405  3347 getTokeType
2EF5                ;  406  3359 strcpy
2EF5                ;  407  3366 storeLabel
2EF5                ;  408  3377 getTokeType
2EF5                ;  409  3389 lookCode
2EF5                ;  410  3398 process
2EF5                ;  411  3406 getVariable
2EF5                ;  412  3418 skipRest
2EF5                ;  413  3427 error1
2EF5                ;  414  3434 error1
2EF5                ;  415  3441 printLine
2EF5                ;  416  3451 getarg
2EF5                ;  417  3458 parse
2EF5                ;  418  3464 fixJmpMain
2EF5                ;  419  3475 epilog
2EF5                ;  420  3482 end1
2EF5                ;Input: AS.C, List: AS.S,  Lines: 1499
2EF5                ;Glob. variables:  189 max.:  200
2EF5                ;Functions      :   91 max.:  300
2EF5                ;Calls          :  421 max.: 2000, NameField: 3487 max.:    65535
2EF5                ;Code until     :21667 max.: 30000, free: 8333
2EF5                ;Data (HeapEnd) :59154, resting stacksize:  6381
2EF5                ;Max. Const in 'testReg' :  658 max. 3000, free: 2342x.:    65535
fix jmp to main. resting global jmp: 0
main ,Label+ORG:2FE2,rel:2EDF
 Errors: 1 *** ERRORS *** , Out: TE.LST, TE.COM= 12021 bytes. Labels: 260