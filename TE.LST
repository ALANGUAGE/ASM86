;AS.C V0.2, Source: TE.S, Output: TE.LST, TE.COM

0000                
0000                ; A.COM V0.9, Source: AS.C, Output asm: AS.S
0000                org  256 
0000 E9 00 00      Rjmp main
0003                
0003                ;-1 char Version1[]="AS.C V0.2";//BAS.BAT, AS TE, NAS.BAT
0003                
0003 41 53 2E 43 20 Version1 db "AS.C V0.2",0
000D                
000D                ;-2 //#include "DECL.C"
000D                
000D                
000D                ;-3 #define SYMBOLMAX    31
000D                
000D                
000D                ;-4 char Symbol[SYMBOLMAX]; //next symbol to decode
000D                
000D                section .bss
000D                absolute 30000
000D                Symbol resb 31
000D                section .text
000D                
000D                ;-5 char SymbolUpper[SYMBOLMAX];//set toupper in getName
000D                
000D                section .bss
000D                absolute 30031
000D                SymbolUpper resb 31
000D                section .text
000D                
000D                ;-6 char ProcName[SYMBOLMAX];//name of actual proc
000D                
000D                section .bss
000D                absolute 30062
000D                ProcName resb 31
000D                section .text
000D                
000D                ;-7 char isInProc=0;        //is inside a procedure
000D                
000D 00             isInProc db 0
000E                
000E                ;-8 unsigned int SymbolInt; //integer value set in getDigit
000E                
000E 00 00          SymbolInt dw 0
0010                
0010                ;-9 unsigned long SymbolLong;//integer value set in getDigit
0010                
0010 00 00 00 00    SymbolLong dd 0
0014                
0014                ;-10 #define INPUTBUFMAX 255
0014                
0014                
0014                ;-11 char InputBuf[INPUTBUFMAX];//filled in getLine, no overflow test
0014                
0014                section .bss
0014                absolute 30093
0014                InputBuf resb 255
0014                section .text
0014                
0014                ;-12 unsigned char *InputPtr;//position in InputBuf
0014                
0014 00 00          InputPtr dw 0
0016                
0016                ;-13 char namein [67];       //input file name  .S
0016                
0016                section .bss
0016                absolute 30348
0016                namein resb 67
0016                section .text
0016                
0016                ;-14 char namelst[67];       //list file name   .LST
0016                
0016                section .bss
0016                absolute 30415
0016                namelst resb 67
0016                section .text
0016                
0016                ;-15 char namebin[67];       //output file name .COM
0016                
0016                section .bss
0016                absolute 30482
0016                namebin resb 67
0016                section .text
0016                
0016                ;-16 int  asm_fd;            //input file descriptor
0016                
0016 00 00          asm_fd dw 0
0018                
0018                ;-17 int lst_fd;             //list file descriptor
0018                
0018 00 00          lst_fd dw 0
001A                
001A                ;-18 int bin_fd;             //output file descriptor
001A                
001A 00 00          bin_fd dw 0
001C                
001C                ;-19 int DOS_ERR=0;          //global var
001C                
001C 00 00          DOS_ERR dw 0
001E                
001E                ;-20 int ErrorCount=0;       //number of errors
001E                
001E 00 00          ErrorCount dw 0
0020                
0020                ;-21 int DOS_NoBytes;        //number of bytes read (0 or 1)
0020                
0020 00 00          DOS_NoBytes dw 0
0022                
0022                ;-22 char DOS_ByteRead;      //the byte just read by DOS
0022                
0022 00             DOS_ByteRead db 0
0023                
0023                ;-23 
0023                
0023                
0023                ;-24 unsigned int PC=0;      //program counter
0023                
0023 00 00          PC dw 0
0025                
0025                ;-25 unsigned int Origin=0;  //ORG nn
0025                
0025 00 00          Origin dw 0
0027                
0027                ;-26 unsigned int AbsoluteLab=0;//uninitialised data
0027                
0027 00 00          AbsoluteLab dw 0
0029                
0029                ;-27 unsigned int PCStart;   //PC at start of line by PrintLine()
0029                
0029 00 00          PCStart dw 0
002B                
002B                ;-28 char isLabel;           //by getName()
002B                
002B 00             isLabel db 0
002C                
002C                ;-29 #define DIGIT    1      //0-9
002C                
002C                
002C                ;-30 #define LETTERE  2      //a-z A-Z @ . _
002C                
002C                
002C                ;-31 #define ALNUME   3      //a-z A-Z @ . _  0-9
002C                
002C                
002C                ;-32 #define NOALNUME 4      //other char
002C                
002C                
002C                ;-33 char TokeType;          //0, DIGIT, LETTERE, ALNUME, NOALNUME
002C                
002C 00             TokeType db 0
002D                
002D                ;-34 #define BYTE     1
002D                
002D                
002D                ;-35 #define WORD     2
002D                
002D                
002D                ;-36 #define DWORD    3
002D                
002D                
002D                ;-37 #define SEGREG   4
002D                
002D                
002D                ;-38 #define IMM      1      //const  ,123
002D                
002D                
002D                ;-39 #define REG      2      //       ,BX    mode=11
002D                
002D                
002D                ;-40 #define ADR      3      //DIRECT: VALUE  ,var1  mod=00, r/m=110
002D                
002D                
002D                ;-41 #define MEM      4      //[var1],[BX+SI],[table+BX],[bp-4] disp0,8,16
002D                
002D                
002D                ;-42 char Op;                //1. operand: 0, IMM, REG, ADR, MEM
002D                
002D 00             Op db 0
002E                
002E                ;-43 char Op2;               //2. operand
002E                
002E 00             Op2 db 0
002F                
002F                ;-44 char CodeType;          //1-207 by searchSymbol(), must be byte size
002F                
002F 00             CodeType db 0
0030                
0030                ;-45 char Code1;             //1. Opcode
0030                
0030 00             Code1 db 0
0031                
0031                ;-46 char Code2;             //2. Opcode
0031                
0031 00             Code2 db 0
0032                
0032                ;-47 char Code3;             //3. Opcode
0032                
0032 00             Code3 db 0
0033                
0033                ;-48 char R2No;              //0 - 7 AL, CL, ...  set in testReg()
0033                
0033 00             R2No db 0
0034                
0034                ;-49 char R1No;              //temp for 1. register
0034                
0034 00             R1No db 0
0035                
0035                ;-50 char R2Type;            //0=no reg, BYTE, WORD, DWORD, SEGREG
0035                
0035 00             R2Type db 0
0036                
0036                ;-51 char R1Type;            //temp for 1. register
0036                
0036 00             R1Type db 0
0037                
0037                ;-52 char OpSize;            //0, BYTE, WORD, DWORD by getCodeSize()
0037                
0037 00             OpSize db 0
0038                
0038                ;-53 char wflag;             //wordflag: 0=byte, 1=word/dword
0038                
0038 00             wflag db 0
0039                
0039                ;-54 char dflag;             //directionflag: 1=to reg MOV,ALU
0039                
0039 00             dflag db 0
003A                
003A                ;-55 char sflag;             //sign extended, imm8 to word PUSH,ALU,IMUL3
003A                
003A 00             sflag db 0
003B                
003B                ;-56 char rm;                //combination of index and base reg
003B                
003B 00             rm db 0
003C                
003C                ;-57 char isDirect;          //set in process and getMeM, need in WriteEA
003C                
003C 00             isDirect db 0
003D                
003D                ;-58 int disp;               //displacement      0-8 bytes
003D                
003D 00 00          disp dw 0
003F                
003F                ;-59 unsigned int imme;      //immediate         0-8 bytes
003F                
003F 00 00          imme dw 0
0041                
0041                ;-60 
0041                
0041                
0041                ;-61 #define OPMAXLEN 5
0041                
0041                
0041                ;-62 char OpPos[OPMAXLEN];   //array for one opcode to list
0041                
0041                section .bss
0041                absolute 30549
0041                OpPos resb 5
0041                section .text
0041                
0041                ;-63 int OpPrintIndex;       //0-OPMAXLEN, pos to print opcode, by genCode8
0041                
0041 00 00          OpPrintIndex dw 0
0043                
0043                ;-64 char *OpCodePtr;        //position in OpCodeTable by searchSymbol
0043                
0043 00 00          OpCodePtr dw 0
0045                
0045                ;-65 char PrintRA;           //print * for forward relocative jmp
0045                
0045 00             PrintRA db 0
0046                
0046                ;-66 
0046                
0046                
0046                ;-67 #define LABELNAMESMAX 5969//next number - SYMBOLMAX
0046                
0046                
0046                ;-68 char LabelNames[6000];  //space for names of all labels
0046                
0046                section .bss
0046                absolute 30554
0046                LabelNames resb 6000
0046                section .text
0046                
0046                ;-69 char *LabelNamePtr;     //first free position
0046                
0046 00 00          LabelNamePtr dw 0
0048                
0048                ;-70 char *tmpLabelNamePtr;  //set after PROC to LabelNamePtr
0048                
0048 00 00          tmpLabelNamePtr dw 0
004A                
004A                ;-71 
004A                
004A                
004A                ;-72 #define LABELADRMAX 600
004A                
004A                
004A                ;-73 unsigned int LabelAddr[LABELADRMAX];//addr of each label
004A                
004A                section .bss
004A                absolute 36554
004A                LabelAddr resw 600
004A                section .text
004A                
004A                ;-74 int LabelMaxIx=0;       //actual # of stored labels. 1 to LABELADRMAX-1
004A                
004A 00 00          LabelMaxIx dw 0
004C                
004C                ;-75 int tmpLabelMaxIx;      //set after PROC to LabelMaxIx
004C                
004C 00 00          tmpLabelMaxIx dw 0
004E                
004E                ;-76 int LabelIx;            //actual # of just searched label
004E                
004E 00 00          LabelIx dw 0
0050                
0050                ;-77 
0050                
0050                
0050                ;-78 #define JMPNAMESMAX 3969//next number - SYMBOLMAX
0050                
0050                
0050                ;-79 char JmpNames[4000];    //space for names of jmp, call
0050                
0050                section .bss
0050                absolute 37754
0050                JmpNames resb 4000
0050                section .text
0050                
0050                ;-80 char *JmpNamePtr;       //first free position
0050                
0050 00 00          JmpNamePtr dw 0
0052                
0052                ;-81 char *tmpJmpNamePtr;    //set after PROC to JmpNamePtr
0052                
0052 00 00          tmpJmpNamePtr dw 0
0054                
0054                ;-82 
0054                
0054                
0054                ;-83 #define JMPMAX 200      //max. jmp and call
0054                
0054                
0054                ;-84 unsigned int JmpAddr[JMPMAX];//addr to be fixed
0054                
0054                section .bss
0054                absolute 41754
0054                JmpAddr resw 200
0054                section .text
0054                
0054                ;-85 int JmpMaxIx=0;         //actual # of jmp, call. 1 to JMPMAX-1
0054                
0054 00 00          JmpMaxIx dw 0
0056                
0056                ;-86 int tmpJmpMaxIx=0;      //set after PROC to JmpMaxIx
0056                
0056 00 00          tmpJmpMaxIx dw 0
0058                
0058                ;-87 
0058                
0058                
0058                ;-88 #define FILEBINMAX 17000
0058                
0058                
0058                ;-89 char FileBin  [FILEBINMAX];//output binary file
0058                
0058                section .bss
0058                absolute 42154
0058                FileBin resb 17000
0058                section .text
0058                
0058                ;-90 unsigned int BinLen=0;  //length of binary file
0058                
0058 00 00          BinLen dw 0
005A                
005A                ;-91 
005A                
005A                
005A                ;-92 char *arglen=0x80;      // for main only
005A                
005A 80 00          arglen dw 128
005C                
005C                ;-93 char *argv=0x82;        // for main only
005C                
005C 82 00          argv dw 130
005E                
005E                ;-94 
005E                
005E                
005E                ;-95 
005E                
005E                
005E                ;-96 //#include "HELPER.C"
005E                
005E                
005E                ;-97 int writetty()     { ah=0x0E; bx=0; __emit__(0xCD,0x10); }
005E                
005E                
entering: writetty
005E                writetty: PROC
005E B4 0E           mov  ah, 14
0060 BB 00 00        mov  bx, 0
0063 CD 10           db 205,16
0065                
0065                ;-98 int putch(char c)  {if (_ c==10) {al=13; writetty();} al=c; writetty(); }
0065                
0065 C3              ret
leaving: writetty, loc labels: 0, loc jmp forward: 0
0066                ENDP
0066                
entering: putch
0066                putch: PROC
0066                ;Function : putch, Number of local variables: 1
0066                ;   # type sign width addr used name   list of local variables
0066                ;  200 var sign byte    98 NULL c = bp+4;
0066 C8 00 00 00     ENTER  0,0 ; constant expression
006A 80 7E 04 0A    cmp byte[bp+4], 10
006E 0F 85 00 00   r jne .putch1
0072 B0 0D           mov  al, 13
0074 E8 E7 FF        call writetty
0077                .putch1:
0077 8A 46 04        mov  al, [bp+4]
007A E8 E1 FF        call writetty
007D                
007D                ;-99 int cputs(char *s) {char c;  while(*s) { c=*s; putch(c); s++; } }
007D C9              LEAVE
007E C3              ret
leaving: putch, loc labels: 1, loc jmp forward: 1
007F                ENDP
007F                
entering: cputs
007F                cputs: PROC
007F                ;Function : cputs, Number of local variables: 2
007F                ;   # type sign width addr used name   list of local variables
007F                ;  200 ptr sign byte    99 NULL s = bp+4
007F                ;  201 var sign byte    99 NULL c = bp-2;
007F C8 02 00 00     ENTER  2,0
0083                .cputs2:
0083 8B 5E 04        mov bx, [bp+4]
0086 8A 07           mov al, [bx]
0088 B4 00           mov ah, 0
008A 08 C0           or  al, al
008C 0F 84 00 00   r je .cputs3
0090 8B 5E 04        mov bx, [bp+4]
0093 8A 07           mov al, [bx]
0095 B4 00           mov ah, 0
0097 88 46 FE        mov [bp-2], al
009A 8A 46 FE        mov al, byte [bp-2]
009D B4 00           mov ah, 0
009F 50              push ax
00A0 E8 C3 FF        call putch
00A3 83 C4 02        add  sp, 2
00A6 FF 46 04        inc  word[bp+4]
00A9 EB D8           jmp .cputs2
00AB                .cputs3:
00AB                
00AB                ;-100 
00AB                
00AB                
00AB                ;-101 int DosInt() {
00AB C9              LEAVE
00AC C3              ret
leaving: cputs, loc labels: 2, loc jmp forward: 1
00AD                ENDP
00AD                
entering: DosInt
00AD                DosInt: PROC
00AD                
00AD                ;-102     __emit__(0xCD,0x21);//inth 0x21;
00AD                
00AD CD 21           db 205,33
00AF                
00AF                ;-103     __emit__(0x73, 04); //ifcarry DOS_ERR++;
00AF                
00AF 73 04           db 115,4
00B1                
00B1                ;-104     DOS_ERR++;
00B1                
00B1 FF 06 1C 01     inc  word[DOS_ERR]
00B5                
00B5                ;-105 }
00B5                
00B5                
00B5                ;-106 int openR (char *s) { dx=s;       ax=0x3D02; DosInt(); }
00B5                
00B5 C3              ret
leaving: DosInt, loc labels: 0, loc jmp forward: 0
00B6                ENDP
00B6                
entering: openR
00B6                openR: PROC
00B6                ;Function : openR, Number of local variables: 1
00B6                ;   # type sign width addr used name   list of local variables
00B6                ;  200 ptr sign byte   106 NULL s = bp+4;
00B6 C8 00 00 00     ENTER  0,0
00BA 8B 56 04        mov  dx, [bp+4]
00BD B8 02 3D        mov  ax, 15618
00C0 E8 EA FF        call DosInt
00C3                
00C3                ;-107 int creatR(char *s) { dx=s; cx=0; ax=0x3C00; DosInt(); }
00C3 C9              LEAVE
00C4 C3              ret
leaving: openR, loc labels: 0, loc jmp forward: 0
00C5                ENDP
00C5                
entering: creatR
00C5                creatR: PROC
00C5                ;Function : creatR, Number of local variables: 1
00C5                ;   # type sign width addr used name   list of local variables
00C5                ;  200 ptr sign byte   107 NULL s = bp+4;
00C5 C8 00 00 00     ENTER  0,0
00C9 8B 56 04        mov  dx, [bp+4]
00CC B9 00 00        mov  cx, 0
00CF B8 00 3C        mov  ax, 15360
00D2 E8 D8 FF        call DosInt
00D5                
00D5                ;-108 int fcloseR(int fd) {bx=fd;       ax=0x3E00; DosInt(); }
00D5 C9              LEAVE
00D6 C3              ret
leaving: creatR, loc labels: 0, loc jmp forward: 0
00D7                ENDP
00D7                
entering: fcloseR
00D7                fcloseR: PROC
00D7                ;Function : fcloseR, Number of local variables: 1
00D7                ;   # type sign width addr used name   list of local variables
00D7                ;  200 var sign word   108 NULL fd = bp+4;
00D7 C8 00 00 00     ENTER  0,0
00DB 8B 5E 04        mov  bx, [bp+4]
00DE B8 00 3E        mov  ax, 15872
00E1 E8 C9 FF        call DosInt
00E4                
00E4                ;-109 int exitR  (char c) {ah=0x4C; al=c;          DosInt(); }
00E4 C9              LEAVE
00E5 C3              ret
leaving: fcloseR, loc labels: 0, loc jmp forward: 0
00E6                ENDP
00E6                
entering: exitR
00E6                exitR: PROC
00E6                ;Function : exitR, Number of local variables: 1
00E6                ;   # type sign width addr used name   list of local variables
00E6                ;  200 var sign byte   109 NULL c = bp+4;
00E6 C8 00 00 00     ENTER  0,0
00EA B4 4C           mov  ah, 76
00EC 8A 46 04        mov  al, [bp+4]
00EF E8 BB FF        call DosInt
00F2                
00F2                ;-110 int readRL(char *s, int fd, int len){
00F2 C9              LEAVE
00F3 C3              ret
leaving: exitR, loc labels: 0, loc jmp forward: 0
00F4                ENDP
00F4                
entering: readRL
00F4                readRL: PROC
00F4                
00F4                ;-111     dx=s; cx=len; bx=fd; ax=0x3F00; DosInt();}
00F4                
00F4                ;Function : readRL, Number of local variables: 3
00F4                ;   # type sign width addr used name   list of local variables
00F4                ;  200 ptr sign byte   110 NULL s = bp+4
00F4                ;  201 var sign word   110 NULL fd = bp+6
00F4                ;  202 var sign word   110 NULL len = bp+8;
00F4 C8 00 00 00     ENTER  0,0
00F8 8B 56 04        mov  dx, [bp+4]
00FB 8B 4E 08        mov  cx, [bp+8]
00FE 8B 5E 06        mov  bx, [bp+6]
0101 B8 00 3F        mov  ax, 16128
0104 E8 A6 FF        call DosInt
0107                
0107                ;-112 int fputcR(char *n, int fd) { __asm{lea dx, [bp+4]}; /* = *n */
0107 C9              LEAVE
0108 C3              ret
leaving: readRL, loc labels: 0, loc jmp forward: 0
0109                ENDP
0109                
entering: fputcR
0109                fputcR: PROC
0109                ;Function : fputcR, Number of local variables: 2
0109                ;   # type sign width addr used name   list of local variables
0109                ;  200 ptr sign byte   112 NULL n = bp+4
0109                ;  201 var sign word   112 NULL fd = bp+6;
0109 C8 00 00 00     ENTER  0,0
010D 8D 56 04       lea dx, [bp+4]
0110                
0110                ;-113   cx=1; bx=fd; ax=0x4000; DosInt(); }
0110                
0110 B9 01 00        mov  cx, 1
0113 8B 5E 06        mov  bx, [bp+6]
0116 B8 00 40        mov  ax, 16384
0119 E8 91 FF        call DosInt
011C                
011C                ;-114 
011C                
011C                
011C                ;-115 int letterE(char c) {
011C C9              LEAVE
011D C3              ret
leaving: fputcR, loc labels: 0, loc jmp forward: 0
011E                ENDP
011E                
entering: letterE
011E                letterE: PROC
011E                
011E                ;-116   if (c=='_') return 1;
011E                
011E                ;Function : letterE, Number of local variables: 1
011E                ;   # type sign width addr used name   list of local variables
011E                ;  200 var sign byte   115 NULL c = bp+4;
011E C8 00 00 00     ENTER  0,0
0122 8A 46 04        mov al, [bp+4]
0125 3C 5F           cmp al, 95
0127 0F 85 00 00   r jne .letterE4
012B B8 01 00        mov ax, 1
012E E9 00 00      R jmp .retnletterE
0131                
0131                ;-117   if (c=='.') return 1;
0131                
0131                .letterE4:
0131 8A 46 04        mov al, [bp+4]
0134 3C 2E           cmp al, 46
0136 0F 85 00 00   r jne .letterE5
013A B8 01 00        mov ax, 1
013D E9 00 00      R jmp .retnletterE
0140                
0140                ;-118   if (c=='?') return 1;
0140                
0140                .letterE5:
0140 8A 46 04        mov al, [bp+4]
0143 3C 3F           cmp al, 63
0145 0F 85 00 00   r jne .letterE6
0149 B8 01 00        mov ax, 1
014C E9 00 00      R jmp .retnletterE
014F                
014F                ;-119   if (c=='$') return 1;
014F                
014F                .letterE6:
014F 8A 46 04        mov al, [bp+4]
0152 3C 24           cmp al, 36
0154 0F 85 00 00   r jne .letterE7
0158 B8 01 00        mov ax, 1
015B E9 00 00      R jmp .retnletterE
015E                
015E                ;-120   if (c> 'z') return 0;
015E                
015E                .letterE7:
015E 8A 46 04        mov al, [bp+4]
0161 3C 7A           cmp al, 122
0163 0F 8E 00 00   r jle .letterE8
0167 B8 00 00        mov ax, 0
016A E9 00 00      R jmp .retnletterE
016D                
016D                ;-121   if (c< '@') return 0; // at included
016D                
016D                .letterE8:
016D 8A 46 04        mov al, [bp+4]
0170 3C 40           cmp al, 64
0172 0F 8D 00 00   r jge .letterE9
0176 B8 00 00        mov ax, 0
0179 E9 00 00      R jmp .retnletterE
017C                
017C                ;-122   if (c> 'Z') { if (c< 'a') return 0; }
017C                
017C                .letterE9:
017C 8A 46 04        mov al, [bp+4]
017F 3C 5A           cmp al, 90
0181 0F 8E 00 00   r jle .letterE10
0185 8A 46 04        mov al, [bp+4]
0188 3C 61           cmp al, 97
018A 0F 8D 00 00   r jge .letterE11
018E B8 00 00        mov ax, 0
0191 E9 00 00      R jmp .retnletterE
0194                .letterE11:
0194                
0194                ;-123   return 1;
0194                
0194                .letterE10:
0194 B8 01 00        mov ax, 1
0197 E9 00 00      R jmp .retnletterE
019A                
019A                ;-124 }
019A                
019A                
019A                ;-125 int digit(char c){
019A                
019A C9              .retnletterE: LEAVE
019B C3              ret
leaving: letterE, loc labels: 9, loc jmp forward: 16
019C                ENDP
019C                
entering: digit
019C                digit: PROC
019C                
019C                ;-126     if(c<'0') return 0;
019C                
019C                ;Function : digit, Number of local variables: 1
019C                ;   # type sign width addr used name   list of local variables
019C                ;  200 var sign byte   125 NULL c = bp+4;
019C C8 00 00 00     ENTER  0,0
01A0 8A 46 04        mov al, [bp+4]
01A3 3C 30           cmp al, 48
01A5 0F 8D 00 00   r jge .digit12
01A9 B8 00 00        mov ax, 0
01AC E9 00 00      R jmp .retndigit
01AF                
01AF                ;-127     if(c>'9') return 0;
01AF                
01AF                .digit12:
01AF 8A 46 04        mov al, [bp+4]
01B2 3C 39           cmp al, 57
01B4 0F 8E 00 00   r jle .digit13
01B8 B8 00 00        mov ax, 0
01BB E9 00 00      R jmp .retndigit
01BE                
01BE                ;-128     return 1;
01BE                
01BE                .digit13:
01BE B8 01 00        mov ax, 1
01C1 E9 00 00      R jmp .retndigit
01C4                
01C4                ;-129 }
01C4                
01C4                
01C4                ;-130 int alnumE(char c) {
01C4                
01C4 C9              .retndigit: LEAVE
01C5 C3              ret
leaving: digit, loc labels: 3, loc jmp forward: 5
01C6                ENDP
01C6                
entering: alnumE
01C6                alnumE: PROC
01C6                
01C6                ;-131   if (digit(c)) return 1;
01C6                
01C6                ;Function : alnumE, Number of local variables: 1
01C6                ;   # type sign width addr used name   list of local variables
01C6                ;  200 var sign byte   130 NULL c = bp+4;
01C6 C8 00 00 00     ENTER  0,0
01CA 8A 46 04        mov al, byte [bp+4]
01CD B4 00           mov ah, 0
01CF 50              push ax
01D0 E8 C9 FF        call digit
01D3 83 C4 02        add  sp, 2
01D6 08 C0           or  al, al
01D8 0F 84 00 00   r je .alnumE14
01DC B8 01 00        mov ax, 1
01DF E9 00 00      R jmp .retnalnumE
01E2                
01E2                ;-132   if (letterE(c)) return 1;
01E2                
01E2                .alnumE14:
01E2 8A 46 04        mov al, byte [bp+4]
01E5 B4 00           mov ah, 0
01E7 50              push ax
01E8 E8 33 FF        call letterE
01EB 83 C4 02        add  sp, 2
01EE 08 C0           or  al, al
01F0 0F 84 00 00   r je .alnumE15
01F4 B8 01 00        mov ax, 1
01F7 E9 00 00      R jmp .retnalnumE
01FA                
01FA                ;-133   return 0;
01FA                
01FA                .alnumE15:
01FA B8 00 00        mov ax, 0
01FD E9 00 00      R jmp .retnalnumE
0200                
0200                ;-134 }
0200                
0200                
0200                ;-135 int strlen(char *s) { int c;
0200                
0200 C9              .retnalnumE: LEAVE
0201 C3              ret
leaving: alnumE, loc labels: 3, loc jmp forward: 5
0202                ENDP
0202                
entering: strlen
0202                strlen: PROC
0202                
0202                ;-136     c=0;
0202                
0202                ;Function : strlen, Number of local variables: 2
0202                ;   # type sign width addr used name   list of local variables
0202                ;  200 ptr sign byte   135 NULL s = bp+4
0202                ;  201 var sign word   135 NULL c = bp-2;
0202 C8 02 00 00     ENTER  2,0
0206 B8 00 00        mov ax, 0
0209 89 46 FE        mov [bp-2], ax
020C                
020C                ;-137     while (*s!=0) {s++; c++;}
020C                
020C                .strlen16:
020C 8B 5E 04        mov bx, [bp+4]
020F 8A 07           mov al, [bx]
0211 B4 00           mov ah, 0
0213 83 F8 00        cmp ax, 0
0216 0F 84 00 00   r je  .strlen17
021A FF 46 04        inc  word[bp+4]
021D FF 46 FE        inc  word[bp-2]
0220                
0220                ;-138     return c;
0220                
0220 EB EA           jmp .strlen16
0222                .strlen17:
0222 8B 46 FE        mov ax, [bp-2]
0225 E9 00 00      R jmp .retnstrlen
0228                
0228                ;-139     }
0228                
0228                
0228                ;-140 int strcpy(char *s, char *t) {
0228                
0228 C9              .retnstrlen: LEAVE
0229 C3              ret
leaving: strlen, loc labels: 3, loc jmp forward: 2
022A                ENDP
022A                
entering: strcpy
022A                strcpy: PROC
022A                
022A                ;-141     do { *s=*t; s++; t++; }
022A                
022A                ;Function : strcpy, Number of local variables: 2
022A                ;   # type sign width addr used name   list of local variables
022A                ;  200 ptr sign byte   140 NULL s = bp+4
022A                ;  201 ptr sign byte   140 NULL t = bp+6;
022A C8 00 00 00     ENTER  0,0
022E                .strcpy18:
022E 8B 5E 06        mov bx, [bp+6]
0231 8A 07           mov al, [bx]
0233 B4 00           mov ah, 0
0235 8B 5E 04        mov  bx, [bp+4]
0238 88 07           mov  [bx], al
023A FF 46 04        inc  word[bp+4]
023D FF 46 06        inc  word[bp+6]
0240                
0240                ;-142     while (*t!=0);
0240                
0240 8B 5E 06        mov bx, [bp+6]
0243 8A 07           mov al, [bx]
0245 B4 00           mov ah, 0
0247 83 F8 00        cmp ax, 0
024A 0F 84 00 00   r je  .strcpy19
024E EB DE           jmp .strcpy18
0250                .strcpy19:
0250                
0250                ;-143     *s=0;
0250                
0250 B8 00 00        mov ax, 0
0253 8B 5E 04        mov  bx, [bp+4]
0256 88 07           mov  [bx], al
0258                
0258                ;-144     return s;
0258                
0258 8B 46 04        mov ax, [bp+4]
025B E9 00 00      R jmp .retnstrcpy
025E                
025E                ;-145     }
025E                
025E                
025E                ;-146 int eqstr(char *p, char *q) {
025E                
025E C9              .retnstrcpy: LEAVE
025F C3              ret
leaving: strcpy, loc labels: 3, loc jmp forward: 2
0260                ENDP
0260                
entering: eqstr
0260                eqstr: PROC
0260                
0260                ;-147     while(*p) {
0260                
0260                ;Function : eqstr, Number of local variables: 2
0260                ;   # type sign width addr used name   list of local variables
0260                ;  200 ptr sign byte   146 NULL p = bp+4
0260                ;  201 ptr sign byte   146 NULL q = bp+6;
0260 C8 00 00 00     ENTER  0,0
0264                .eqstr20:
0264 8B 5E 04        mov bx, [bp+4]
0267 8A 07           mov al, [bx]
0269 B4 00           mov ah, 0
026B 08 C0           or  al, al
026D 0F 84 00 00   r je .eqstr21
0271                
0271                ;-148         if (*p != *q) return 0;
0271                
0271 8B 5E 04        mov bx, [bp+4]
0274 8A 07           mov al, [bx]
0276 B4 00           mov ah, 0
0278 8B 5E 06        mov bx, [bp+6]
027B 3A 07           cmp al, [bx]
027D B4 00           mov ah, 0
027F 0F 84 00 00   r je  .eqstr22
0283 B8 00 00        mov ax, 0
0286 E9 00 00      R jmp .retneqstr
0289                
0289                ;-149             p++;
0289                
0289                .eqstr22:
0289 FF 46 04        inc  word[bp+4]
028C                
028C                ;-150             q++;
028C                
028C FF 46 06        inc  word[bp+6]
028F                
028F                ;-151             }
028F                
028F                
028F                ;-152     if(*q) return 0;
028F                
028F EB D3           jmp .eqstr20
0291                .eqstr21:
0291 8B 5E 06        mov bx, [bp+6]
0294 8A 07           mov al, [bx]
0296 B4 00           mov ah, 0
0298 08 C0           or  al, al
029A 0F 84 00 00   r je .eqstr23
029E B8 00 00        mov ax, 0
02A1 E9 00 00      R jmp .retneqstr
02A4                
02A4                ;-153     return 1;
02A4                
02A4                .eqstr23:
02A4 B8 01 00        mov ax, 1
02A7 E9 00 00      R jmp .retneqstr
02AA                
02AA                ;-154     }
02AA                
02AA                
02AA                ;-155 int strcat1(char *s, char *t) {
02AA                
02AA C9              .retneqstr: LEAVE
02AB C3              ret
leaving: eqstr, loc labels: 5, loc jmp forward: 6
02AC                ENDP
02AC                
entering: strcat1
02AC                strcat1: PROC
02AC                
02AC                ;-156     while (*s != 0) s++;
02AC                
02AC                ;Function : strcat1, Number of local variables: 2
02AC                ;   # type sign width addr used name   list of local variables
02AC                ;  200 ptr sign byte   155 NULL s = bp+4
02AC                ;  201 ptr sign byte   155 NULL t = bp+6;
02AC C8 00 00 00     ENTER  0,0
02B0                .strcat124:
02B0 8B 5E 04        mov bx, [bp+4]
02B3 8A 07           mov al, [bx]
02B5 B4 00           mov ah, 0
02B7 83 F8 00        cmp ax, 0
02BA 0F 84 00 00   r je  .strcat125
02BE FF 46 04        inc  word[bp+4]
02C1                
02C1                ;-157     strcpy(s, t);
02C1                
02C1 EB ED           jmp .strcat124
02C3                .strcat125:
02C3 FF 76 06        push word [bp+6]
02C6 FF 76 04        push word [bp+4]
02C9 E8 5E FF        call strcpy
02CC 83 C4 04        add  sp, 4
02CF                
02CF                ;-158     }
02CF                
02CF                
02CF                ;-159 int toupper(char *s) {
02CF C9              LEAVE
02D0 C3              ret
leaving: strcat1, loc labels: 2, loc jmp forward: 1
02D1                ENDP
02D1                
entering: toupper
02D1                toupper: PROC
02D1                
02D1                ;-160     while(*s) {
02D1                
02D1                ;Function : toupper, Number of local variables: 1
02D1                ;   # type sign width addr used name   list of local variables
02D1                ;  200 ptr sign byte   159 NULL s = bp+4;
02D1 C8 00 00 00     ENTER  0,0
02D5                .toupper26:
02D5 8B 5E 04        mov bx, [bp+4]
02D8 8A 07           mov al, [bx]
02DA B4 00           mov ah, 0
02DC 08 C0           or  al, al
02DE 0F 84 00 00   r je .toupper27
02E2                
02E2                ;-161         if (*s >= 'a') if (*s <= 'z') *s=*s-32;
02E2                
02E2 8B 5E 04        mov bx, [bp+4]
02E5 8A 07           mov al, [bx]
02E7 B4 00           mov ah, 0
02E9 83 F8 61        cmp ax, 97 ;unsigned : 1
02EC 0F 8C 00 00   r jl  .toupper28
02F0 8B 5E 04        mov bx, [bp+4]
02F3 8A 07           mov al, [bx]
02F5 B4 00           mov ah, 0
02F7 83 F8 7A        cmp ax, 122
02FA 0F 8F 00 00   r jg  .toupper29
02FE 8B 5E 04        mov bx, [bp+4]
0301 8A 07           mov al, [bx]
0303 B4 00           mov ah, 0
0305 83 E8 20        sub ax, 32
0308 8B 5E 04        mov  bx, [bp+4]
030B 88 07           mov  [bx], al
030D                
030D                ;-162             s++;
030D                
030D                .toupper29:
030D                .toupper28:
030D FF 46 04        inc  word[bp+4]
0310                
0310                ;-163               }
0310                
0310                
0310                ;-164     }
0310                
0310 EB C3           jmp .toupper26
0312                .toupper27:
0312                
0312                ;-165 
0312                
0312                
0312                ;-166 int testReg() {
0312 C9              LEAVE
0313 C3              ret
leaving: toupper, loc labels: 4, loc jmp forward: 3
0314                ENDP
0314                
entering: testReg
0314                testReg: PROC
0314                
0314                ;-167 //ret:RegNo: 0 - 7 AL, CL  set:R2Type: 0=no reg,BYTE,WORD,SEGREG,DWORD
0314                
0314                
0314                ;-168   R2Type=0;
0314                
0314 B8 00 00        mov ax, 0
0317 A2 35 01        mov byte [R2Type], al
031A                
031A                ;-169   if (strlen(Symbol) < 2) return 0;
031A                
031A 8D 06 30 75     lea  ax, [Symbol]
031E 50              push ax
031F E8 E0 FE        call strlen
0322 83 C4 02        add  sp, 2
0325 3C 02           cmp al, 2
0327 0F 8D 00 00   r jge .testReg30
032B B8 00 00        mov ax, 0
032E E9 00 00      R jmp .retntestReg
0331                
0331                ;-170   if (strlen(Symbol) > 3) return 0;
0331                
0331                .testReg30:
0331 8D 06 30 75     lea  ax, [Symbol]
0335 50              push ax
0336 E8 C9 FE        call strlen
0339 83 C4 02        add  sp, 2
033C 3C 03           cmp al, 3
033E 0F 8E 00 00   r jle .testReg31
0342 B8 00 00        mov ax, 0
0345 E9 00 00      R jmp .retntestReg
0348                
0348                ;-171   R2Type=BYTE;
0348                
0348                .testReg31:
0348 B8 01 00        mov ax, 1
034B A2 35 01        mov byte [R2Type], al
034E                
034E                ;-172   if (eqstr(SymbolUpper, "AL")) return 0;
034E                
034E 68 AA AA      A push testReg_0
0351 8D 06 4F 75     lea  ax, [SymbolUpper]
0355 50              push ax
0356 E8 07 FF        call eqstr
0359 83 C4 04        add  sp, 4
035C 08 C0           or  al, al
035E 0F 84 00 00   r je .testReg32
0362 B8 00 00        mov ax, 0
0365 E9 00 00      R jmp .retntestReg
0368                
0368                ;-173   if (eqstr(SymbolUpper, "CL")) return 1;
0368                
0368                .testReg32:
0368 68 AA AA      A push testReg_1
036B 8D 06 4F 75     lea  ax, [SymbolUpper]
036F 50              push ax
0370 E8 ED FE        call eqstr
0373 83 C4 04        add  sp, 4
0376 08 C0           or  al, al
0378 0F 84 00 00   r je .testReg33
037C B8 01 00        mov ax, 1
037F E9 00 00      R jmp .retntestReg
0382                
0382                ;-174   if (eqstr(SymbolUpper, "DL")) return 2;
0382                
0382                .testReg33:
0382 68 AA AA      A push testReg_2
0385 8D 06 4F 75     lea  ax, [SymbolUpper]
0389 50              push ax
038A E8 D3 FE        call eqstr
038D 83 C4 04        add  sp, 4
0390 08 C0           or  al, al
0392 0F 84 00 00   r je .testReg34
0396 B8 02 00        mov ax, 2
0399 E9 00 00      R jmp .retntestReg
039C                
039C                ;-175   if (eqstr(SymbolUpper, "BL")) return 3;
039C                
039C                .testReg34:
039C 68 AA AA      A push testReg_3
039F 8D 06 4F 75     lea  ax, [SymbolUpper]
03A3 50              push ax
03A4 E8 B9 FE        call eqstr
03A7 83 C4 04        add  sp, 4
03AA 08 C0           or  al, al
03AC 0F 84 00 00   r je .testReg35
03B0 B8 03 00        mov ax, 3
03B3 E9 00 00      R jmp .retntestReg
03B6                
03B6                ;-176   if (eqstr(SymbolUpper, "AH")) return 4;
03B6                
03B6                .testReg35:
03B6 68 AA AA      A push testReg_4
03B9 8D 06 4F 75     lea  ax, [SymbolUpper]
03BD 50              push ax
03BE E8 9F FE        call eqstr
03C1 83 C4 04        add  sp, 4
03C4 08 C0           or  al, al
03C6 0F 84 00 00   r je .testReg36
03CA B8 04 00        mov ax, 4
03CD E9 00 00      R jmp .retntestReg
03D0                
03D0                ;-177   if (eqstr(SymbolUpper, "CH")) return 5;
03D0                
03D0                .testReg36:
03D0 68 AA AA      A push testReg_5
03D3 8D 06 4F 75     lea  ax, [SymbolUpper]
03D7 50              push ax
03D8 E8 85 FE        call eqstr
03DB 83 C4 04        add  sp, 4
03DE 08 C0           or  al, al
03E0 0F 84 00 00   r je .testReg37
03E4 B8 05 00        mov ax, 5
03E7 E9 00 00      R jmp .retntestReg
03EA                
03EA                ;-178   if (eqstr(SymbolUpper, "DH")) return 6;
03EA                
03EA                .testReg37:
03EA 68 AA AA      A push testReg_6
03ED 8D 06 4F 75     lea  ax, [SymbolUpper]
03F1 50              push ax
03F2 E8 6B FE        call eqstr
03F5 83 C4 04        add  sp, 4
03F8 08 C0           or  al, al
03FA 0F 84 00 00   r je .testReg38
03FE B8 06 00        mov ax, 6
0401 E9 00 00      R jmp .retntestReg
0404                
0404                ;-179   if (eqstr(SymbolUpper, "BH")) return 7;
0404                
0404                .testReg38:
0404 68 AA AA      A push testReg_7
0407 8D 06 4F 75     lea  ax, [SymbolUpper]
040B 50              push ax
040C E8 51 FE        call eqstr
040F 83 C4 04        add  sp, 4
0412 08 C0           or  al, al
0414 0F 84 00 00   r je .testReg39
0418 B8 07 00        mov ax, 7
041B E9 00 00      R jmp .retntestReg
041E                
041E                ;-180   R2Type=WORD;
041E                
041E                .testReg39:
041E B8 02 00        mov ax, 2
0421 A2 35 01        mov byte [R2Type], al
0424                
0424                ;-181   if (eqstr(SymbolUpper, "AX")) return 0;
0424                
0424 68 AA AA      A push testReg_8
0427 8D 06 4F 75     lea  ax, [SymbolUpper]
042B 50              push ax
042C E8 31 FE        call eqstr
042F 83 C4 04        add  sp, 4
0432 08 C0           or  al, al
0434 0F 84 00 00   r je .testReg40
0438 B8 00 00        mov ax, 0
043B E9 00 00      R jmp .retntestReg
043E                
043E                ;-182   if (eqstr(SymbolUpper, "CX")) return 1;
043E                
043E                .testReg40:
043E 68 AA AA      A push testReg_9
0441 8D 06 4F 75     lea  ax, [SymbolUpper]
0445 50              push ax
0446 E8 17 FE        call eqstr
0449 83 C4 04        add  sp, 4
044C 08 C0           or  al, al
044E 0F 84 00 00   r je .testReg41
0452 B8 01 00        mov ax, 1
0455 E9 00 00      R jmp .retntestReg
0458                
0458                ;-183   if (eqstr(SymbolUpper, "DX")) return 2;
0458                
0458                .testReg41:
0458 68 AA AA      A push testReg_10
045B 8D 06 4F 75     lea  ax, [SymbolUpper]
045F 50              push ax
0460 E8 FD FD        call eqstr
0463 83 C4 04        add  sp, 4
0466 08 C0           or  al, al
0468 0F 84 00 00   r je .testReg42
046C B8 02 00        mov ax, 2
046F E9 00 00      R jmp .retntestReg
0472                
0472                ;-184   if (eqstr(SymbolUpper, "BX")) return 3;
0472                
0472                .testReg42:
0472 68 AA AA      A push testReg_11
0475 8D 06 4F 75     lea  ax, [SymbolUpper]
0479 50              push ax
047A E8 E3 FD        call eqstr
047D 83 C4 04        add  sp, 4
0480 08 C0           or  al, al
0482 0F 84 00 00   r je .testReg43
0486 B8 03 00        mov ax, 3
0489 E9 00 00      R jmp .retntestReg
048C                
048C                ;-185   if (eqstr(SymbolUpper, "SP")) return 4;
048C                
048C                .testReg43:
048C 68 AA AA      A push testReg_12
048F 8D 06 4F 75     lea  ax, [SymbolUpper]
0493 50              push ax
0494 E8 C9 FD        call eqstr
0497 83 C4 04        add  sp, 4
049A 08 C0           or  al, al
049C 0F 84 00 00   r je .testReg44
04A0 B8 04 00        mov ax, 4
04A3 E9 00 00      R jmp .retntestReg
04A6                
04A6                ;-186   if (eqstr(SymbolUpper, "BP")) return 5;
04A6                
04A6                .testReg44:
04A6 68 AA AA      A push testReg_13
04A9 8D 06 4F 75     lea  ax, [SymbolUpper]
04AD 50              push ax
04AE E8 AF FD        call eqstr
04B1 83 C4 04        add  sp, 4
04B4 08 C0           or  al, al
04B6 0F 84 00 00   r je .testReg45
04BA B8 05 00        mov ax, 5
04BD E9 00 00      R jmp .retntestReg
04C0                
04C0                ;-187   if (eqstr(SymbolUpper, "SI")) return 6;
04C0                
04C0                .testReg45:
04C0 68 AA AA      A push testReg_14
04C3 8D 06 4F 75     lea  ax, [SymbolUpper]
04C7 50              push ax
04C8 E8 95 FD        call eqstr
04CB 83 C4 04        add  sp, 4
04CE 08 C0           or  al, al
04D0 0F 84 00 00   r je .testReg46
04D4 B8 06 00        mov ax, 6
04D7 E9 00 00      R jmp .retntestReg
04DA                
04DA                ;-188   if (eqstr(SymbolUpper, "DI")) return 7;
04DA                
04DA                .testReg46:
04DA 68 AA AA      A push testReg_15
04DD 8D 06 4F 75     lea  ax, [SymbolUpper]
04E1 50              push ax
04E2 E8 7B FD        call eqstr
04E5 83 C4 04        add  sp, 4
04E8 08 C0           or  al, al
04EA 0F 84 00 00   r je .testReg47
04EE B8 07 00        mov ax, 7
04F1 E9 00 00      R jmp .retntestReg
04F4                
04F4                ;-189   R2Type=SEGREG;
04F4                
04F4                .testReg47:
04F4 B8 04 00        mov ax, 4
04F7 A2 35 01        mov byte [R2Type], al
04FA                
04FA                ;-190   if (eqstr(SymbolUpper, "ES")) return 0;
04FA                
04FA 68 AA AA      A push testReg_16
04FD 8D 06 4F 75     lea  ax, [SymbolUpper]
0501 50              push ax
0502 E8 5B FD        call eqstr
0505 83 C4 04        add  sp, 4
0508 08 C0           or  al, al
050A 0F 84 00 00   r je .testReg48
050E B8 00 00        mov ax, 0
0511 E9 00 00      R jmp .retntestReg
0514                
0514                ;-191   if (eqstr(SymbolUpper, "CS")) return 1;
0514                
0514                .testReg48:
0514 68 AA AA      A push testReg_17
0517 8D 06 4F 75     lea  ax, [SymbolUpper]
051B 50              push ax
051C E8 41 FD        call eqstr
051F 83 C4 04        add  sp, 4
0522 08 C0           or  al, al
0524 0F 84 00 00   r je .testReg49
0528 B8 01 00        mov ax, 1
052B E9 00 00      R jmp .retntestReg
052E                
052E                ;-192   if (eqstr(SymbolUpper, "SS")) return 2;
052E                
052E                .testReg49:
052E 68 AA AA      A push testReg_18
0531 8D 06 4F 75     lea  ax, [SymbolUpper]
0535 50              push ax
0536 E8 27 FD        call eqstr
0539 83 C4 04        add  sp, 4
053C 08 C0           or  al, al
053E 0F 84 00 00   r je .testReg50
0542 B8 02 00        mov ax, 2
0545 E9 00 00      R jmp .retntestReg
0548                
0548                ;-193   if (eqstr(SymbolUpper, "DS")) return 3;
0548                
0548                .testReg50:
0548 68 AA AA      A push testReg_19
054B 8D 06 4F 75     lea  ax, [SymbolUpper]
054F 50              push ax
0550 E8 0D FD        call eqstr
0553 83 C4 04        add  sp, 4
0556 08 C0           or  al, al
0558 0F 84 00 00   r je .testReg51
055C B8 03 00        mov ax, 3
055F E9 00 00      R jmp .retntestReg
0562                
0562                ;-194   if (eqstr(SymbolUpper, "FS")) return 4;
0562                
0562                .testReg51:
0562 68 AA AA      A push testReg_20
0565 8D 06 4F 75     lea  ax, [SymbolUpper]
0569 50              push ax
056A E8 F3 FC        call eqstr
056D 83 C4 04        add  sp, 4
0570 08 C0           or  al, al
0572 0F 84 00 00   r je .testReg52
0576 B8 04 00        mov ax, 4
0579 E9 00 00      R jmp .retntestReg
057C                
057C                ;-195   if (eqstr(SymbolUpper, "GS")) return 5;
057C                
057C                .testReg52:
057C 68 AA AA      A push testReg_21
057F 8D 06 4F 75     lea  ax, [SymbolUpper]
0583 50              push ax
0584 E8 D9 FC        call eqstr
0587 83 C4 04        add  sp, 4
058A 08 C0           or  al, al
058C 0F 84 00 00   r je .testReg53
0590 B8 05 00        mov ax, 5
0593 E9 00 00      R jmp .retntestReg
0596                
0596                ;-196   R2Type=DWORD;
0596                
0596                .testReg53:
0596 B8 03 00        mov ax, 3
0599 A2 35 01        mov byte [R2Type], al
059C                
059C                ;-197   if (eqstr(SymbolUpper, "EAX"))return 0;
059C                
059C 68 AA AA      A push testReg_22
059F 8D 06 4F 75     lea  ax, [SymbolUpper]
05A3 50              push ax
05A4 E8 B9 FC        call eqstr
05A7 83 C4 04        add  sp, 4
05AA 08 C0           or  al, al
05AC 0F 84 00 00   r je .testReg54
05B0 B8 00 00        mov ax, 0
05B3 E9 00 00      R jmp .retntestReg
05B6                
05B6                ;-198   if (eqstr(SymbolUpper, "ECX"))return 1;
05B6                
05B6                .testReg54:
05B6 68 AA AA      A push testReg_23
05B9 8D 06 4F 75     lea  ax, [SymbolUpper]
05BD 50              push ax
05BE E8 9F FC        call eqstr
05C1 83 C4 04        add  sp, 4
05C4 08 C0           or  al, al
05C6 0F 84 00 00   r je .testReg55
05CA B8 01 00        mov ax, 1
05CD E9 00 00      R jmp .retntestReg
05D0                
05D0                ;-199   if (eqstr(SymbolUpper, "EDX"))return 2;
05D0                
05D0                .testReg55:
05D0 68 AA AA      A push testReg_24
05D3 8D 06 4F 75     lea  ax, [SymbolUpper]
05D7 50              push ax
05D8 E8 85 FC        call eqstr
05DB 83 C4 04        add  sp, 4
05DE 08 C0           or  al, al
05E0 0F 84 00 00   r je .testReg56
05E4 B8 02 00        mov ax, 2
05E7 E9 00 00      R jmp .retntestReg
05EA                
05EA                ;-200   if (eqstr(SymbolUpper, "EBX"))return 3;
05EA                
05EA                .testReg56:
05EA 68 AA AA      A push testReg_25
05ED 8D 06 4F 75     lea  ax, [SymbolUpper]
05F1 50              push ax
05F2 E8 6B FC        call eqstr
05F5 83 C4 04        add  sp, 4
05F8 08 C0           or  al, al
05FA 0F 84 00 00   r je .testReg57
05FE B8 03 00        mov ax, 3
0601 E9 00 00      R jmp .retntestReg
0604                
0604                ;-201   if (eqstr(SymbolUpper, "ESP"))return 4;
0604                
0604                .testReg57:
0604 68 AA AA      A push testReg_26
0607 8D 06 4F 75     lea  ax, [SymbolUpper]
060B 50              push ax
060C E8 51 FC        call eqstr
060F 83 C4 04        add  sp, 4
0612 08 C0           or  al, al
0614 0F 84 00 00   r je .testReg58
0618 B8 04 00        mov ax, 4
061B E9 00 00      R jmp .retntestReg
061E                
061E                ;-202   if (eqstr(SymbolUpper, "EBP"))return 5;
061E                
061E                .testReg58:
061E 68 AA AA      A push testReg_27
0621 8D 06 4F 75     lea  ax, [SymbolUpper]
0625 50              push ax
0626 E8 37 FC        call eqstr
0629 83 C4 04        add  sp, 4
062C 08 C0           or  al, al
062E 0F 84 00 00   r je .testReg59
0632 B8 05 00        mov ax, 5
0635 E9 00 00      R jmp .retntestReg
0638                
0638                ;-203   if (eqstr(SymbolUpper, "ESI"))return 6;
0638                
0638                .testReg59:
0638 68 AA AA      A push testReg_28
063B 8D 06 4F 75     lea  ax, [SymbolUpper]
063F 50              push ax
0640 E8 1D FC        call eqstr
0643 83 C4 04        add  sp, 4
0646 08 C0           or  al, al
0648 0F 84 00 00   r je .testReg60
064C B8 06 00        mov ax, 6
064F E9 00 00      R jmp .retntestReg
0652                
0652                ;-204   if (eqstr(SymbolUpper, "EDI"))return 7;
0652                
0652                .testReg60:
0652 68 AA AA      A push testReg_29
0655 8D 06 4F 75     lea  ax, [SymbolUpper]
0659 50              push ax
065A E8 03 FC        call eqstr
065D 83 C4 04        add  sp, 4
0660 08 C0           or  al, al
0662 0F 84 00 00   r je .testReg61
0666 B8 07 00        mov ax, 7
0669 E9 00 00      R jmp .retntestReg
066C                
066C                ;-205   R2Type=0; return 0;
066C                
066C                .testReg61:
066C B8 00 00        mov ax, 0
066F A2 35 01        mov byte [R2Type], al
0672 B8 00 00        mov ax, 0
0675 E9 00 00      R jmp .retntestReg
0678                
0678                ;-206 }
0678                
0678                
0678                ;-207 
0678                
0678                
0678                ;-208 
0678                
0678                
0678                ;-209 int prc(unsigned char c) {//print char
0678                
0678                 .retntestReg:
0678 C3              ret
0679 41 4C 00       testReg_0 db "AL",0
067C 43 4C 00       testReg_1 db "CL",0
067F 44 4C 00       testReg_2 db "DL",0
0682 42 4C 00       testReg_3 db "BL",0
0685 41 48 00       testReg_4 db "AH",0
0688 43 48 00       testReg_5 db "CH",0
068B 44 48 00       testReg_6 db "DH",0
068E 42 48 00       testReg_7 db "BH",0
0691 41 58 00       testReg_8 db "AX",0
0694 43 58 00       testReg_9 db "CX",0
0697 44 58 00       testReg_10 db "DX",0
069A 42 58 00       testReg_11 db "BX",0
069D 53 50 00       testReg_12 db "SP",0
06A0 42 50 00       testReg_13 db "BP",0
06A3 53 49 00       testReg_14 db "SI",0
06A6 44 49 00       testReg_15 db "DI",0
06A9 45 53 00       testReg_16 db "ES",0
06AC 43 53 00       testReg_17 db "CS",0
06AF 53 53 00       testReg_18 db "SS",0
06B2 44 53 00       testReg_19 db "DS",0
06B5 46 53 00       testReg_20 db "FS",0
06B8 47 53 00       testReg_21 db "GS",0
06BB 45 41 58 00    testReg_22 db "EAX",0
06BF 45 43 58 00    testReg_23 db "ECX",0
06C3 45 44 58 00    testReg_24 db "EDX",0
06C7 45 42 58 00    testReg_25 db "EBX",0
06CB 45 53 50 00    testReg_26 db "ESP",0
06CF 45 42 50 00    testReg_27 db "EBP",0
06D3 45 53 49 00    testReg_28 db "ESI",0
06D7 45 44 49 00    testReg_29 db "EDI",0
leaving: testReg, loc labels: 63, loc jmp forward: 95
06DB                ENDP
06DB                
entering: prc
06DB                prc: PROC
06DB                
06DB                ;-210         if ( _ c==10) {
06DB                
06DB                ;Function : prc, Number of local variables: 1
06DB                ;   # type sign width addr used name   list of local variables
06DB                ;  200 var unsg byte   209 NULL c = bp+4;
06DB C8 00 00 00     ENTER  0,0 ; constant expression
06DF 80 7E 04 0A    cmp byte[bp+4], 10
06E3 0F 85 00 00   r jne .prc62
06E7                
06E7                ;-211             ax=13;
06E7                
06E7 B8 0D 00        mov  ax, 13
06EA                
06EA                ;-212             writetty();
06EA                
06EA E8 71 F9        call writetty
06ED                
06ED                ;-213             }
06ED                
06ED                
06ED                ;-214         al=c;
06ED                
06ED                .prc62:
06ED 8A 46 04        mov  al, [bp+4]
06F0                
06F0                ;-215         writetty();
06F0                
06F0 E8 6B F9        call writetty
06F3                
06F3                ;-216     fputcR(c,lst_fd);
06F3                
06F3 FF 36 18 01     push word [lst_fd]
06F7 8A 46 04        mov al, byte [bp+4]
06FA B4 00           mov ah, 0
06FC 50              push ax
06FD E8 09 FA        call fputcR
0700 83 C4 04        add  sp, 4
0703                
0703                ;-217 }
0703                
0703                
0703                ;-218 
0703                
0703                
0703                ;-219 int prscomment(unsigned char *s) {
0703 C9              LEAVE
0704 C3              ret
leaving: prc, loc labels: 1, loc jmp forward: 1
0705                ENDP
0705                
entering: prscomment
0705                prscomment: PROC
0705                
0705                ;-220     unsigned char c;
0705                
0705                
0705                ;-221     while (*s){
0705                
0705                ;Function : prscomment, Number of local variables: 2
0705                ;   # type sign width addr used name   list of local variables
0705                ;  200 ptr unsg byte   219 NULL s = bp+4
0705                ;  201 var unsg byte   220 NULL c = bp-2;
0705 C8 02 00 00     ENTER  2,0
0709                .prscomment63:
0709 8B 5E 04        mov bx, [bp+4]
070C 8A 07           mov al, [bx]
070E B4 00           mov ah, 0
0710 08 C0           or  al, al
0712 0F 84 00 00   r je .prscomment64
0716                
0716                ;-222         c=*s;
0716                
0716 8B 5E 04        mov bx, [bp+4]
0719 8A 07           mov al, [bx]
071B B4 00           mov ah, 0
071D 88 46 FE        mov [bp-2], al
0720                
0720                ;-223         prc(c);
0720                
0720 8A 46 FE        mov al, byte [bp-2]
0723 B4 00           mov ah, 0
0725 50              push ax
0726 E8 B2 FF        call prc
0729 83 C4 02        add  sp, 2
072C                
072C                ;-224         s++;
072C                
072C FF 46 04        inc  word[bp+4]
072F                
072F                ;-225     }
072F                
072F                
072F                ;-226 }
072F                
072F EB D8           jmp .prscomment63
0731                .prscomment64:
0731                
0731                ;-227 int prs(unsigned char *s) {
0731 C9              LEAVE
0732 C3              ret
leaving: prscomment, loc labels: 2, loc jmp forward: 1
0733                ENDP
0733                
entering: prs
0733                prs: PROC
0733                
0733                ;-228     unsigned char c;
0733                
0733                
0733                ;-229     int com;
0733                
0733                
0733                ;-230     com=0;
0733                
0733                ;Function : prs, Number of local variables: 3
0733                ;   # type sign width addr used name   list of local variables
0733                ;  200 ptr unsg byte   227 NULL s = bp+4
0733                ;  201 var unsg byte   228 NULL c = bp-2
0733                ;  202 var sign word   229 NULL com = bp-4;
0733 C8 04 00 00     ENTER  4,0
0737 B8 00 00        mov ax, 0
073A 89 46 FC        mov [bp-4], ax
073D                
073D                ;-231     while (*s) {
073D                
073D                .prs65:
073D 8B 5E 04        mov bx, [bp+4]
0740 8A 07           mov al, [bx]
0742 B4 00           mov ah, 0
0744 08 C0           or  al, al
0746 0F 84 00 00   r je .prs66
074A                
074A                ;-232         c=*s;
074A                
074A 8B 5E 04        mov bx, [bp+4]
074D 8A 07           mov al, [bx]
074F B4 00           mov ah, 0
0751 88 46 FE        mov [bp-2], al
0754                
0754                ;-233         if (c==34) {
0754                
0754 8A 46 FE        mov al, [bp-2]
0757 3C 22           cmp al, 34
0759 0F 85 00 00   r jne .prs67
075D                
075D                ;-234             if (com) com=0;
075D                
075D 8B 46 FC        mov ax, [bp-4]
0760 08 C0           or  al, al
0762 0F 84 00 00   r je .prs68
0766 B8 00 00        mov ax, 0
0769 89 46 FC        mov [bp-4], ax
076C                
076C                ;-235                 else com=1;
076C                
076C E9 00 00      R jmp .prs69
076F                .prs68:
076F B8 01 00        mov ax, 1
0772 89 46 FC        mov [bp-4], ax
0775                
0775                ;-236         }
0775                
0775                .prs69:
0775                
0775                ;-237         if (c==92) {
0775                
0775                .prs67:
0775 8A 46 FE        mov al, [bp-2]
0778 3C 5C           cmp al, 92
077A 0F 85 00 00   r jne .prs70
077E                
077E                ;-238             if (com==0) {
077E                
077E 8B 46 FC        mov ax, [bp-4]
0781 83 F8 00        cmp ax, 0
0784 0F 85 00 00   r jne .prs71
0788                
0788                ;-239                 s++;
0788                
0788 FF 46 04        inc  word[bp+4]
078B                
078B                ;-240                 c=*s;
078B                
078B 8B 5E 04        mov bx, [bp+4]
078E 8A 07           mov al, [bx]
0790 B4 00           mov ah, 0
0792 88 46 FE        mov [bp-2], al
0795                
0795                ;-241                 if (c=='n') c=10;
0795                
0795 8A 46 FE        mov al, [bp-2]
0798 3C 6E           cmp al, 110
079A 0F 85 00 00   r jne .prs72
079E B8 0A 00        mov ax, 10
07A1 88 46 FE        mov [bp-2], al
07A4                
07A4                ;-242                 if (c=='t') c= 9;
07A4                
07A4                .prs72:
07A4 8A 46 FE        mov al, [bp-2]
07A7 3C 74           cmp al, 116
07A9 0F 85 00 00   r jne .prs73
07AD B8 09 00        mov ax, 9
07B0 88 46 FE        mov [bp-2], al
07B3                
07B3                ;-243             }
07B3                
07B3                .prs73:
07B3                
07B3                ;-244         }
07B3                
07B3                .prs71:
07B3                
07B3                ;-245         prc(c);
07B3                
07B3                .prs70:
07B3 8A 46 FE        mov al, byte [bp-2]
07B6 B4 00           mov ah, 0
07B8 50              push ax
07B9 E8 1F FF        call prc
07BC 83 C4 02        add  sp, 2
07BF                
07BF                ;-246         s++;
07BF                
07BF FF 46 04        inc  word[bp+4]
07C2                
07C2                ;-247     }
07C2                
07C2                
07C2                ;-248 }
07C2                
07C2 E9 78 FF        jmp .prs65
07C5                .prs66:
07C5                
07C5                ;-249 int printhex4(unsigned char c) {
07C5 C9              LEAVE
07C6 C3              ret
leaving: prs, loc labels: 9, loc jmp forward: 8
07C7                ENDP
07C7                
entering: printhex4
07C7                printhex4: PROC
07C7                
07C7                ;-250     c += 48;
07C7                
07C7                ;Function : printhex4, Number of local variables: 1
07C7                ;   # type sign width addr used name   list of local variables
07C7                ;  200 var unsg byte   249 NULL c = bp+4;
07C7 C8 00 00 00     ENTER  0,0
07CB 80 46 04 30     add  byte[bp+4], 48
07CF                
07CF                ;-251     if (c > 57) c += 7;
07CF                
07CF 8A 46 04        mov al, [bp+4]
07D2 3C 39           cmp al, 57
07D4 0F 8E 00 00   r jle .printhex474
07D8 80 46 04 07     add  byte[bp+4], 7
07DC                
07DC                ;-252     prc(c);
07DC                
07DC                .printhex474:
07DC 8A 46 04        mov al, byte [bp+4]
07DF B4 00           mov ah, 0
07E1 50              push ax
07E2 E8 F6 FE        call prc
07E5 83 C4 02        add  sp, 2
07E8                
07E8                ;-253 }
07E8                
07E8                
07E8                ;-254 int printhex8a(unsigned char c) {
07E8 C9              LEAVE
07E9 C3              ret
leaving: printhex4, loc labels: 1, loc jmp forward: 1
07EA                ENDP
07EA                
entering: printhex8a
07EA                printhex8a: PROC
07EA                
07EA                ;-255     unsigned char nib;
07EA                
07EA                
07EA                ;-256     nib = c >> 4; printhex4(nib);
07EA                
07EA                ;Function : printhex8a, Number of local variables: 2
07EA                ;   # type sign width addr used name   list of local variables
07EA                ;  200 var unsg byte   254 NULL c = bp+4
07EA                ;  201 var unsg byte   255 NULL nib = bp-2;
07EA C8 02 00 00     ENTER  2,0
07EE 8A 46 04        mov al, [bp+4]
07F1 C0 E8 04        shr al, 4
07F4 88 46 FE        mov [bp-2], al
07F7 8A 46 FE        mov al, byte [bp-2]
07FA B4 00           mov ah, 0
07FC 50              push ax
07FD E8 C7 FF        call printhex4
0800 83 C4 02        add  sp, 2
0803                
0803                ;-257     nib = c & 15; printhex4(nib);
0803                
0803 8A 46 04        mov al, [bp+4]
0806 24 0F           and al, 15
0808 88 46 FE        mov [bp-2], al
080B 8A 46 FE        mov al, byte [bp-2]
080E B4 00           mov ah, 0
0810 50              push ax
0811 E8 B3 FF        call printhex4
0814 83 C4 02        add  sp, 2
0817                
0817                ;-258 }
0817                
0817                
0817                ;-259 int printhex16(unsigned int i) {
0817 C9              LEAVE
0818 C3              ret
leaving: printhex8a, loc labels: 0, loc jmp forward: 0
0819                ENDP
0819                
entering: printhex16
0819                printhex16: PROC
0819                
0819                ;-260     unsigned int half;
0819                
0819                
0819                ;-261     half = i >>  8; printhex8a(half);
0819                
0819                ;Function : printhex16, Number of local variables: 2
0819                ;   # type sign width addr used name   list of local variables
0819                ;  200 var unsg word   259 NULL i = bp+4
0819                ;  201 var unsg word   260 NULL half = bp-2;
0819 C8 02 00 00     ENTER  2,0
081D 8B 46 04        mov ax, [bp+4]
0820 C1 E8 08        shr ax, 8
0823 89 46 FE        mov [bp-2], ax
0826 FF 76 FE        push word [bp-2]
0829 E8 BE FF        call printhex8a
082C 83 C4 02        add  sp, 2
082F                
082F                ;-262     half = i & 255; printhex8a(half);
082F                
082F 8B 46 04        mov ax, [bp+4]
0832 25 FF 00        and ax, 255
0835 89 46 FE        mov [bp-2], ax
0838 FF 76 FE        push word [bp-2]
083B E8 AC FF        call printhex8a
083E 83 C4 02        add  sp, 2
0841                
0841                ;-263 }
0841                
0841                
0841                ;-264 int printIntU(unsigned int n) {
0841 C9              LEAVE
0842 C3              ret
leaving: printhex16, loc labels: 0, loc jmp forward: 0
0843                ENDP
0843                
entering: printIntU
0843                printIntU: PROC
0843                
0843                ;-265     unsigned int e;
0843                
0843                
0843                ;-266     if ( _ n >= 10) {
0843                
0843                ;Function : printIntU, Number of local variables: 2
0843                ;   # type sign width addr used name   list of local variables
0843                ;  200 var unsg word   264 NULL n = bp+4
0843                ;  201 var unsg word   265 NULL e = bp-2;
0843 C8 02 00 00     ENTER  2,0 ; constant expression
0847 83 7E 04 0A    cmp word[bp+4], 10 ;unsigned : 0
084B 0F 82 00 00   r jb  .printIntU75
084F                
084F                ;-267         e=n/10; //DIV
084F                
084F 8B 46 04        mov ax, [bp+4]
0852 BB 0A 00        mov bx, 10
0855 BA 00 00        mov dx, 0
0858 F7 F3           div bx
085A 89 46 FE        mov [bp-2], ax
085D                
085D                ;-268         printIntU(e);
085D                
085D FF 76 FE        push word [bp-2]
0860 E8 E0 FF        call printIntU
0863 83 C4 02        add  sp, 2
0866                
0866                ;-269     }
0866                
0866                
0866                ;-270     n = n % 10; //unsigned mod
0866                
0866                .printIntU75:
0866 8B 46 04        mov ax, [bp+4]
0869 BB 0A 00        mov bx, 10
086C BA 00 00        mov dx, 0
086F F7 F3           div bx
0871 89 D0           mov ax, dx
0873 89 46 04        mov [bp+4], ax
0876                
0876                ;-271     n += '0';
0876                
0876 83 46 04 30     add  word[bp+4], 48
087A                
087A                ;-272     prc(n);
087A                
087A FF 76 04        push word [bp+4]
087D E8 5B FE        call prc
0880 83 C4 02        add  sp, 2
0883                
0883                ;-273 }
0883                
0883                
0883                ;-274 int printLine() {
0883 C9              LEAVE
0884 C3              ret
leaving: printIntU, loc labels: 1, loc jmp forward: 1
0885                ENDP
0885                
entering: printLine
0885                printLine: PROC
0885                
0885                ;-275     int i; char c;
0885                
0885                
0885                ;-276     prs("\n");
0885                
0885                ;Function : printLine, Number of local variables: 2
0885                ;   # type sign width addr used name   list of local variables
0885                ;  200 var sign word   275 NULL i = bp-2
0885                ;  201 var sign byte   275 NULL c = bp-4;
0885 C8 04 00 00     ENTER  4,0
0889 68 AA AA      A push printLine_0
088C E8 A4 FE        call prs
088F 83 C4 02        add  sp, 2
0892                
0892                ;-277     printhex16(PCStart);
0892                
0892 FF 36 29 01     push word [PCStart]
0896 E8 80 FF        call printhex16
0899 83 C4 02        add  sp, 2
089C                
089C                ;-278     if (OpPrintIndex == 0) prs("               ");
089C                
089C A1 41 01        mov ax, [OpPrintIndex]
089F 83 F8 00        cmp ax, 0
08A2 0F 85 00 00   r jne .printLine76
08A6 68 AA AA      A push printLine_1
08A9 E8 87 FE        call prs
08AC 83 C4 02        add  sp, 2
08AF                
08AF                ;-279     else {
08AF                
08AF E9 00 00      R jmp .printLine77
08B2                .printLine76:
08B2                
08B2                ;-280 //        prc(' ');
08B2                
08B2                
08B2                ;-281         i=0;
08B2                
08B2 B8 00 00        mov ax, 0
08B5 89 46 FE        mov [bp-2], ax
08B8                
08B8                ;-282         do {
08B8                
08B8                .printLine78:
08B8                
08B8                ;-283             c=OpPos[i];
08B8                
08B8 8B 5E FE        mov bx, [bp-2]
08BB 8A 87 55 77     mov al, [OpPos + bx]
08BF 88 46 FC        mov [bp-4], al
08C2                
08C2                ;-284             prc(' ');
08C2                
08C2 6A 20           push 32
08C4 E8 14 FE        call prc
08C7 83 C4 02        add  sp, 2
08CA                
08CA                ;-285             printhex8a(c);
08CA                
08CA 8A 46 FC        mov al, byte [bp-4]
08CD B4 00           mov ah, 0
08CF 50              push ax
08D0 E8 17 FF        call printhex8a
08D3 83 C4 02        add  sp, 2
08D6                
08D6                ;-286             i++;
08D6                
08D6 FF 46 FE        inc  word[bp-2]
08D9                
08D9                ;-287         } while (i < OpPrintIndex);
08D9                
08D9 8B 46 FE        mov ax, [bp-2]
08DC 3B 06 41 01     cmp ax, [OpPrintIndex]
08E0 0F 8D 00 00   r jge .printLine79
08E4 EB D2           jmp .printLine78
08E6                .printLine79:
08E6                
08E6                ;-288         while (i < OPMAXLEN) {// fill rest with blank
08E6                
08E6                .printLine80:
08E6 8B 46 FE        mov ax, [bp-2]
08E9 83 F8 05        cmp ax, 5
08EC 0F 8D 00 00   r jge .printLine81
08F0                
08F0                ;-289             prs("   ");
08F0                
08F0 68 AA AA      A push printLine_2
08F3 E8 3D FE        call prs
08F6 83 C4 02        add  sp, 2
08F9                
08F9                ;-290             i++;
08F9                
08F9 FF 46 FE        inc  word[bp-2]
08FC                
08FC                ;-291         }
08FC                
08FC                
08FC                ;-292     }
08FC                
08FC EB E8           jmp .printLine80
08FE                .printLine81:
08FE                
08FE                ;-293     prc(PrintRA);
08FE                
08FE                .printLine77:
08FE A0 45 01        mov al, byte [PrintRA]
0901 B4 00           mov ah, 0
0903 50              push ax
0904 E8 D4 FD        call prc
0907 83 C4 02        add  sp, 2
090A                
090A                ;-294     prscomment(InputBuf);
090A                
090A 8D 06 8D 75     lea  ax, [InputBuf]
090E 50              push ax
090F E8 F3 FD        call prscomment
0912 83 C4 02        add  sp, 2
0915                
0915                ;-295 }
0915                
0915                
0915                ;-296 
0915                
0915                
0915                ;-297 int epilog() {
0915 C9              LEAVE
0916 C3              ret
0917 5C 6E 00       printLine_0 db "\n",0
091A 20 20 20 20 20 printLine_1 db "               ",0
092A 20 20 20 00    printLine_2 db "   ",0
leaving: printLine, loc labels: 9, loc jmp forward: 7
092E                ENDP
092E                
entering: epilog
092E                epilog: PROC
092E                
092E                ;-298     unsigned int i; char c;     int j;
092E                
092E                
092E                ;-299     prs("\n Errors: ");
092E                
092E                ;Function : epilog, Number of local variables: 3
092E                ;   # type sign width addr used name   list of local variables
092E                ;  200 var unsg word   298 NULL i = bp-2
092E                ;  201 var sign byte   298 NULL c = bp-4
092E                ;  202 var sign word   298 NULL j = bp-6;
092E C8 06 00 00     ENTER  6,0
0932 68 AA AA      A push epilog_0
0935 E8 FB FD        call prs
0938 83 C4 02        add  sp, 2
093B                
093B                ;-300     printIntU(ErrorCount);
093B                
093B FF 36 1E 01     push word [ErrorCount]
093F E8 01 FF        call printIntU
0942 83 C4 02        add  sp, 2
0945                
0945                ;-301     if (ErrorCount) prs(" *** ERRORS *** ");
0945                
0945 A1 1E 01        mov ax, [ErrorCount]
0948 08 C0           or  al, al
094A 0F 84 00 00   r je .epilog82
094E 68 AA AA      A push epilog_1
0951 E8 DF FD        call prs
0954 83 C4 02        add  sp, 2
0957                
0957                ;-302     prs(", Out: ");
0957                
0957                .epilog82:
0957 68 AA AA      A push epilog_2
095A E8 D6 FD        call prs
095D 83 C4 02        add  sp, 2
0960                
0960                ;-303     prs(namelst);
0960                
0960 8D 06 CF 76     lea  ax, [namelst]
0964 50              push ax
0965 E8 CB FD        call prs
0968 83 C4 02        add  sp, 2
096B                
096B                ;-304     prs(", ");
096B                
096B 68 AA AA      A push epilog_3
096E E8 C2 FD        call prs
0971 83 C4 02        add  sp, 2
0974                
0974                ;-305     prs(namebin);
0974                
0974 8D 06 12 77     lea  ax, [namebin]
0978 50              push ax
0979 E8 B7 FD        call prs
097C 83 C4 02        add  sp, 2
097F                
097F                ;-306     prs("= ");
097F                
097F 68 AA AA      A push epilog_4
0982 E8 AE FD        call prs
0985 83 C4 02        add  sp, 2
0988                
0988                ;-307     printIntU(BinLen);
0988                
0988 FF 36 58 01     push word [BinLen]
098C E8 B4 FE        call printIntU
098F 83 C4 02        add  sp, 2
0992                
0992                ;-308     prs(" bytes.");
0992                
0992 68 AA AA      A push epilog_5
0995 E8 9B FD        call prs
0998 83 C4 02        add  sp, 2
099B                
099B                ;-309     prs(" Labels: ");
099B                
099B 68 AA AA      A push epilog_6
099E E8 92 FD        call prs
09A1 83 C4 02        add  sp, 2
09A4                
09A4                ;-310     printIntU(LabelMaxIx);
09A4                
09A4 FF 36 4A 01     push word [LabelMaxIx]
09A8 E8 98 FE        call printIntU
09AB 83 C4 02        add  sp, 2
09AE                
09AE                ;-311 // prs(", code:\n ");//debug
09AE                
09AE                
09AE                ;-312 
09AE                
09AE                
09AE                ;-313     i=0;
09AE                
09AE B8 00 00        mov ax, 0
09B1 89 46 FE        mov [bp-2], ax
09B4                
09B4                ;-314     do {
09B4                
09B4                .epilog83:
09B4                
09B4                ;-315         c = FileBin[i];
09B4                
09B4 8B 5E FE        mov bx, [bp-2]
09B7 8A 87 AA A4     mov al, [FileBin + bx]
09BB 88 46 FC        mov [bp-4], al
09BE                
09BE                ;-316         fputcR(c, bin_fd);
09BE                
09BE FF 36 1A 01     push word [bin_fd]
09C2 8A 46 FC        mov al, byte [bp-4]
09C5 B4 00           mov ah, 0
09C7 50              push ax
09C8 E8 3E F7        call fputcR
09CB 83 C4 04        add  sp, 4
09CE                
09CE                ;-317 // printhex8a(c); prc(' ');//debug
09CE                
09CE                
09CE                ;-318         i++;
09CE                
09CE FF 46 FE        inc  word[bp-2]
09D1                
09D1                ;-319     } while (i < BinLen);
09D1                
09D1 8B 46 FE        mov ax, [bp-2]
09D4 3B 06 58 01     cmp ax, [BinLen]
09D8 0F 8D 00 00   r jge .epilog84
09DC EB D6           jmp .epilog83
09DE                .epilog84:
09DE                
09DE                ;-320 
09DE                
09DE                
09DE                ;-321 /* 
09DE                
09DE                
09DE                ;-322   prs("\n\n LabelNamePtr:"); printIntU(LabelNamePtr);
09DE                
09DE                
09DE                ;-323   i= &LabelNames;
09DE                
09DE                
09DE                ;-324   prs(" &LabelNames:"); printIntU(i);
09DE                
09DE                
09DE                ;-325   i=LabelNamePtr-i;
09DE                
09DE                
09DE                ;-326   prs(", size: ");
09DE                
09DE                
09DE                ;-327   printIntU(i);
09DE                
09DE                
09DE                ;-328   prs(".\n >>");
09DE                
09DE                
09DE                ;-329   i= &LabelNames;
09DE                
09DE                
09DE                ;-330   do { c=*i; if (c==0) c=' '; prc(c); i++;
09DE                
09DE                
09DE                ;-331   } while (i < LabelNamePtr); prs("<< \n");
09DE                
09DE                
09DE                ;-332    i = 1;
09DE                
09DE                
09DE                ;-333     LabelNamePtr= &LabelNames;
09DE                
09DE                
09DE                ;-334     do {
09DE                
09DE                
09DE                ;-335       prs(LabelNamePtr); prc(' ');
09DE                
09DE                
09DE                ;-336       j=LabelAddr[i]; printhex16(j); prs(", ");
09DE                
09DE                
09DE                ;-337       j=strlen(LabelNamePtr);//get end of actual name
09DE                
09DE                
09DE                ;-338       LabelNamePtr=LabelNamePtr+j;
09DE                
09DE                
09DE                ;-339       LabelNamePtr++;
09DE                
09DE                
09DE                ;-340       i++;
09DE                
09DE                
09DE                ;-341     } while (i <= LabelMaxIx);
09DE                
09DE                
09DE                ;-342 */
09DE                
09DE                
09DE                ;-343 }
09DE                
09DE                
09DE                ;-344 
09DE                
09DE                
09DE                ;-345 int end1(int n) {
09DE C9              LEAVE
09DF C3              ret
09E0 5C 6E 20 45 72 epilog_0 db "\n Errors: ",0
09EC 20 2A 2A 2A 20 epilog_1 db " *** ERRORS *** ",0
09FD 2C 20 4F 75 74 epilog_2 db ", Out: ",0
0A05 2C 20 00       epilog_3 db ", ",0
0A08 3D 20 00       epilog_4 db "= ",0
0A0B 20 62 79 74 65 epilog_5 db " bytes.",0
0A13 20 4C 61 62 65 epilog_6 db " Labels: ",0
leaving: epilog, loc labels: 10, loc jmp forward: 9
0A1D                ENDP
0A1D                
entering: end1
0A1D                end1: PROC
0A1D                
0A1D                ;-346     fcloseR(asm_fd);
0A1D                
0A1D                ;Function : end1, Number of local variables: 1
0A1D                ;   # type sign width addr used name   list of local variables
0A1D                ;  200 var sign word   345 NULL n = bp+4;
0A1D C8 00 00 00     ENTER  0,0
0A21 FF 36 16 01     push word [asm_fd]
0A25 E8 AF F6        call fcloseR
0A28 83 C4 02        add  sp, 2
0A2B                
0A2B                ;-347     fcloseR(lst_fd);
0A2B                
0A2B FF 36 18 01     push word [lst_fd]
0A2F E8 A5 F6        call fcloseR
0A32 83 C4 02        add  sp, 2
0A35                
0A35                ;-348     fcloseR(bin_fd);
0A35                
0A35 FF 36 1A 01     push word [bin_fd]
0A39 E8 9B F6        call fcloseR
0A3C 83 C4 02        add  sp, 2
0A3F                
0A3F                ;-349     exitR(n);
0A3F                
0A3F FF 76 04        push word [bp+4]
0A42 E8 A1 F6        call exitR
0A45 83 C4 02        add  sp, 2
0A48                
0A48                ;-350 }
0A48                
0A48                
0A48                ;-351 
0A48                
0A48                
0A48                ;-352 
0A48                
0A48                
0A48                ;-353 int error1(char *s) {
0A48 C9              LEAVE
0A49 C3              ret
leaving: end1, loc labels: 0, loc jmp forward: 0
0A4A                ENDP
0A4A                
entering: error1
0A4A                error1: PROC
0A4A                
0A4A                ;-354     ErrorCount++;
0A4A                
0A4A                ;Function : error1, Number of local variables: 1
0A4A                ;   # type sign width addr used name   list of local variables
0A4A                ;  200 ptr sign byte   353 NULL s = bp+4;
0A4A C8 00 00 00     ENTER  0,0
0A4E FF 06 1E 01     inc  word[ErrorCount]
0A52                
0A52                ;-355     prs("\n******* next line ERROR: ");
0A52                
0A52 68 AA AA      A push error1_0
0A55 E8 DB FC        call prs
0A58 83 C4 02        add  sp, 2
0A5B                
0A5B                ;-356     prs(s);
0A5B                
0A5B FF 76 04        push word [bp+4]
0A5E E8 D2 FC        call prs
0A61 83 C4 02        add  sp, 2
0A64                
0A64                ;-357     prs(", Symbol: ");
0A64                
0A64 68 AA AA      A push error1_1
0A67 E8 C9 FC        call prs
0A6A 83 C4 02        add  sp, 2
0A6D                
0A6D                ;-358     prs(Symbol);
0A6D                
0A6D 8D 06 30 75     lea  ax, [Symbol]
0A71 50              push ax
0A72 E8 BE FC        call prs
0A75 83 C4 02        add  sp, 2
0A78                
0A78                ;-359 }
0A78                
0A78                
0A78                ;-360 int errorexit(char *s) {
0A78 C9              LEAVE
0A79 C3              ret
0A7A 5C 6E 2A 2A 2A error1_0 db "\n******* next line ERROR: ",0
0A96 2C 20 53 79 6D error1_1 db ", Symbol: ",0
leaving: error1, loc labels: 2, loc jmp forward: 2
0AA1                ENDP
0AA1                
entering: errorexit
0AA1                errorexit: PROC
0AA1                
0AA1                ;-361     error1(s);
0AA1                
0AA1                ;Function : errorexit, Number of local variables: 1
0AA1                ;   # type sign width addr used name   list of local variables
0AA1                ;  200 ptr sign byte   360 NULL s = bp+4;
0AA1 C8 00 00 00     ENTER  0,0
0AA5 FF 76 04        push word [bp+4]
0AA8 E8 9F FF        call error1
0AAB 83 C4 02        add  sp, 2
0AAE                
0AAE                ;-362     epilog();
0AAE                
0AAE E8 7D FE        call epilog
0AB1                
0AB1                ;-363     end1(1);
0AB1                
0AB1 6A 01           push 1
0AB3 E8 67 FF        call end1
0AB6 83 C4 02        add  sp, 2
0AB9                
0AB9                ;-364 }
0AB9                
0AB9                
0AB9                ;-365 int notfounderror(){
0AB9 C9              LEAVE
0ABA C3              ret
leaving: errorexit, loc labels: 0, loc jmp forward: 0
0ABB                ENDP
0ABB                
entering: notfounderror
0ABB                notfounderror: PROC
0ABB                
0ABB                ;-366     ErrorCount++;
0ABB                
0ABB FF 06 1E 01     inc  word[ErrorCount]
0ABF                
0ABF                ;-367     prs("\n******* ERROR: label not found: ");
0ABF                
0ABF 68 AA AA      A push notfounderror_0
0AC2 E8 6E FC        call prs
0AC5 83 C4 02        add  sp, 2
0AC8                
0AC8                ;-368     prs(Symbol);
0AC8                
0AC8 8D 06 30 75     lea  ax, [Symbol]
0ACC 50              push ax
0ACD E8 63 FC        call prs
0AD0 83 C4 02        add  sp, 2
0AD3                
0AD3                ;-369     prs(" ");
0AD3                
0AD3 68 AA AA      A push notfounderror_1
0AD6 E8 5A FC        call prs
0AD9 83 C4 02        add  sp, 2
0ADC                
0ADC                ;-370 }
0ADC                
0ADC                
0ADC                ;-371 int allowederror() {error1("not allowed here"); }
0ADC                
0ADC C3              ret
0ADD 5C 6E 2A 2A 2A notfounderror_0 db "\n******* ERROR: label not found: ",0
0B00 20 00          notfounderror_1 db " ",0
leaving: notfounderror, loc labels: 2, loc jmp forward: 2
0B02                ENDP
0B02                
entering: allowederror
0B02                allowederror: PROC
0B02 68 AA AA      A push allowederror_0
0B05 E8 42 FF        call error1
0B08 83 C4 02        add  sp, 2
0B0B                
0B0B                ;-372 int addrerror()    {error1("address missing");}
0B0B                
0B0B C3              ret
0B0C 6E 6F 74 20 61 allowederror_0 db "not allowed here",0
leaving: allowederror, loc labels: 1, loc jmp forward: 1
0B1D                ENDP
0B1D                
entering: addrerror
0B1D                addrerror: PROC
0B1D 68 AA AA      A push addrerror_0
0B20 E8 27 FF        call error1
0B23 83 C4 02        add  sp, 2
0B26                
0B26                ;-373 int immeerror()    {error1("immediate not allowed here");}
0B26                
0B26 C3              ret
0B27 61 64 64 72 65 addrerror_0 db "address missing",0
leaving: addrerror, loc labels: 1, loc jmp forward: 1
0B37                ENDP
0B37                
entering: immeerror
0B37                immeerror: PROC
0B37 68 AA AA      A push immeerror_0
0B3A E8 0D FF        call error1
0B3D 83 C4 02        add  sp, 2
0B40                
0B40                ;-374 int implerror()    {error1("not implemented");}
0B40                
0B40 C3              ret
0B41 69 6D 6D 65 64 immeerror_0 db "immediate not allowed here",0
leaving: immeerror, loc labels: 1, loc jmp forward: 1
0B5C                ENDP
0B5C                
entering: implerror
0B5C                implerror: PROC
0B5C 68 AA AA      A push implerror_0
0B5F E8 E8 FE        call error1
0B62 83 C4 02        add  sp, 2
0B65                
0B65                ;-375 int indexerror()   {error1("invalid index register");}
0B65                
0B65 C3              ret
0B66 6E 6F 74 20 69 implerror_0 db "not implemented",0
leaving: implerror, loc labels: 1, loc jmp forward: 1
0B76                ENDP
0B76                
entering: indexerror
0B76                indexerror: PROC
0B76 68 AA AA      A push indexerror_0
0B79 E8 CE FE        call error1
0B7C 83 C4 02        add  sp, 2
0B7F                
0B7F                ;-376 int invaloperror() {error1("invalid or no operands");}
0B7F                
0B7F C3              ret
0B80 69 6E 76 61 6C indexerror_0 db "invalid index register",0
leaving: indexerror, loc labels: 1, loc jmp forward: 1
0B97                ENDP
0B97                
entering: invaloperror
0B97                invaloperror: PROC
0B97 68 AA AA      A push invaloperror_0
0B9A E8 AD FE        call error1
0B9D 83 C4 02        add  sp, 2
0BA0                
0BA0                ;-377 int numbererror()  {error1("number expected");}
0BA0                
0BA0 C3              ret
0BA1 69 6E 76 61 6C invaloperror_0 db "invalid or no operands",0
leaving: invaloperror, loc labels: 1, loc jmp forward: 1
0BB8                ENDP
0BB8                
entering: numbererror
0BB8                numbererror: PROC
0BB8 68 AA AA      A push numbererror_0
0BBB E8 8C FE        call error1
0BBE 83 C4 02        add  sp, 2
0BC1                
0BC1                ;-378 int regmemerror()  {error1("only register or memory allowed");}
0BC1                
0BC1 C3              ret
0BC2 6E 75 6D 62 65 numbererror_0 db "number expected",0
leaving: numbererror, loc labels: 1, loc jmp forward: 1
0BD2                ENDP
0BD2                
entering: regmemerror
0BD2                regmemerror: PROC
0BD2 68 AA AA      A push regmemerror_0
0BD5 E8 72 FE        call error1
0BD8 83 C4 02        add  sp, 2
0BDB                
0BDB                ;-379 int reg16error()   {error1("only reg16, no segreg allowed");}
0BDB                
0BDB C3              ret
0BDC 6F 6E 6C 79 20 regmemerror_0 db "only register or memory allowed",0
leaving: regmemerror, loc labels: 1, loc jmp forward: 1
0BFC                ENDP
0BFC                
entering: reg16error
0BFC                reg16error: PROC
0BFC 68 AA AA      A push reg16error_0
0BFF E8 48 FE        call error1
0C02 83 C4 02        add  sp, 2
0C05                
0C05                ;-380 int segregerror()  {error1("segment register not allowed");}
0C05                
0C05 C3              ret
0C06 6F 6E 6C 79 20 reg16error_0 db "only reg16, no segreg allowed",0
leaving: reg16error, loc labels: 1, loc jmp forward: 1
0C24                ENDP
0C24                
entering: segregerror
0C24                segregerror: PROC
0C24 68 AA AA      A push segregerror_0
0C27 E8 20 FE        call error1
0C2A 83 C4 02        add  sp, 2
0C2D                
0C2D                ;-381 int syntaxerror()  {error1("syntax");}
0C2D                
0C2D C3              ret
0C2E 73 65 67 6D 65 segregerror_0 db "segment register not allowed",0
leaving: segregerror, loc labels: 1, loc jmp forward: 1
0C4B                ENDP
0C4B                
entering: syntaxerror
0C4B                syntaxerror: PROC
0C4B 68 AA AA      A push syntaxerror_0
0C4E E8 F9 FD        call error1
0C51 83 C4 02        add  sp, 2
0C54                
0C54                ;-382 
0C54                
0C54                
0C54                ;-383 int addrexit()     {errorexit("illegal address");}
0C54                
0C54 C3              ret
0C55 73 79 6E 74 61 syntaxerror_0 db "syntax",0
leaving: syntaxerror, loc labels: 1, loc jmp forward: 1
0C5C                ENDP
0C5C                
entering: addrexit
0C5C                addrexit: PROC
0C5C 68 AA AA      A push addrexit_0
0C5F E8 3F FE        call errorexit
0C62 83 C4 02        add  sp, 2
0C65                
0C65                ;-384 int dataexit()     {errorexit("DB,DW,DD or RESB,W,D expected");}
0C65                
0C65 C3              ret
0C66 69 6C 6C 65 67 addrexit_0 db "illegal address",0
leaving: addrexit, loc labels: 1, loc jmp forward: 1
0C76                ENDP
0C76                
entering: dataexit
0C76                dataexit: PROC
0C76 68 AA AA      A push dataexit_0
0C79 E8 25 FE        call errorexit
0C7C 83 C4 02        add  sp, 2
0C7F                
0C7F                ;-385 int internexit()   {errorexit("intern compiler error");}
0C7F                
0C7F C3              ret
0C80 44 42 2C 44 57 dataexit_0 db "DB,DW,DD or RESB,W,D expected",0
leaving: dataexit, loc labels: 1, loc jmp forward: 1
0C9E                ENDP
0C9E                
entering: internexit
0C9E                internexit: PROC
0C9E 68 AA AA      A push internexit_0
0CA1 E8 FD FD        call errorexit
0CA4 83 C4 02        add  sp, 2
0CA7                
0CA7                ;-386 
0CA7                
0CA7                
0CA7                ;-387 int ifEOL(char c) {//unix LF, win CRLF= 13/10, mac CR
0CA7                
0CA7 C3              ret
0CA8 69 6E 74 65 72 internexit_0 db "intern compiler error",0
leaving: internexit, loc labels: 1, loc jmp forward: 1
0CBE                ENDP
0CBE                
entering: ifEOL
0CBE                ifEOL: PROC
0CBE                
0CBE                ;-388   if (c == 10) return 1;//LF
0CBE                
0CBE                ;Function : ifEOL, Number of local variables: 1
0CBE                ;   # type sign width addr used name   list of local variables
0CBE                ;  200 var sign byte   387 NULL c = bp+4;
0CBE C8 00 00 00     ENTER  0,0
0CC2 8A 46 04        mov al, [bp+4]
0CC5 3C 0A           cmp al, 10
0CC7 0F 85 00 00   r jne .ifEOL85
0CCB B8 01 00        mov ax, 1
0CCE E9 00 00      R jmp .retnifEOL
0CD1                
0CD1                ;-389   if (c == 13) {//CR
0CD1                
0CD1                .ifEOL85:
0CD1 8A 46 04        mov al, [bp+4]
0CD4 3C 0D           cmp al, 13
0CD6 0F 85 00 00   r jne .ifEOL86
0CDA                
0CDA                ;-390     DOS_NoBytes=readRL(&DOS_ByteRead, asm_fd, 1);
0CDA                
0CDA 6A 01           push 1
0CDC FF 36 16 01     push word [asm_fd]
0CE0 8D 06 22 01     lea  ax, [DOS_ByteRead]
0CE4 50              push ax
0CE5 E8 0C F4        call readRL
0CE8 83 C4 06        add  sp, 6
0CEB A3 20 01        mov word [DOS_NoBytes], ax
0CEE                
0CEE                ;-391     if (DOS_ByteRead != 10) errorexit("missing LF(10) after CR(13)");
0CEE                
0CEE A0 22 01        mov al, [DOS_ByteRead]
0CF1 3C 0A           cmp al, 10
0CF3 0F 84 00 00   r je  .ifEOL87
0CF7 68 AA AA      A push ifEOL_0
0CFA E8 A4 FD        call errorexit
0CFD 83 C4 02        add  sp, 2
0D00                
0D00                ;-392     return 1;
0D00                
0D00                .ifEOL87:
0D00 B8 01 00        mov ax, 1
0D03 E9 00 00      R jmp .retnifEOL
0D06                
0D06                ;-393   }
0D06                
0D06                
0D06                ;-394   return 0;
0D06                
0D06                .ifEOL86:
0D06 B8 00 00        mov ax, 0
0D09 E9 00 00      R jmp .retnifEOL
0D0C                
0D0C                ;-395 }
0D0C                
0D0C                
0D0C                ;-396 int getLine() {// make ASCIIZ, skip LF=10 and CR=13
0D0C                
0D0C C9              .retnifEOL: LEAVE
0D0D C3              ret
0D0E 6D 69 73 73 69 ifEOL_0 db "missing LF(10) after CR(13)",0
leaving: ifEOL, loc labels: 5, loc jmp forward: 7
0D2A                ENDP
0D2A                
entering: getLine
0D2A                getLine: PROC
0D2A                
0D2A                ;-397   unsigned int i;
0D2A                
0D2A                
0D2A                ;-398   InputPtr= &InputBuf;
0D2A                
0D2A                ;Function : getLine, Number of local variables: 1
0D2A                ;   # type sign width addr used name   list of local variables
0D2A                ;  200 var unsg word   397 NULL i = bp-2;
0D2A C8 02 00 00     ENTER  2,0
0D2E B8 8D 75        mov ax, InputBuf
0D31 A3 14 01        mov word [InputPtr], ax
0D34                
0D34                ;-399   *InputPtr=0;//if last line is empty
0D34                
0D34 B8 00 00        mov ax, 0
0D37 8B 1E 14 01     mov  bx, [InputPtr]
0D3B 88 07           mov  [bx], al
0D3D                
0D3D                ;-400   do {
0D3D                
0D3D                .getLine88:
0D3D                
0D3D                ;-401     DOS_NoBytes=readRL(&DOS_ByteRead, asm_fd, 1);
0D3D                
0D3D 6A 01           push 1
0D3F FF 36 16 01     push word [asm_fd]
0D43 8D 06 22 01     lea  ax, [DOS_ByteRead]
0D47 50              push ax
0D48 E8 A9 F3        call readRL
0D4B 83 C4 06        add  sp, 6
0D4E A3 20 01        mov word [DOS_NoBytes], ax
0D51                
0D51                ;-402     if (DOS_ERR) errorexit("Reading Source");
0D51                
0D51 A1 1C 01        mov ax, [DOS_ERR]
0D54 08 C0           or  al, al
0D56 0F 84 00 00   r je .getLine89
0D5A 68 AA AA      A push getLine_0
0D5D E8 41 FD        call errorexit
0D60 83 C4 02        add  sp, 2
0D63                
0D63                ;-403     if (DOS_NoBytes == 0) return;
0D63                
0D63                .getLine89:
0D63 A1 20 01        mov ax, [DOS_NoBytes]
0D66 83 F8 00        cmp ax, 0
0D69 0F 85 00 00   r jne .getLine90
0D6D E9 00 00      R jmp .retngetLine
0D70                
0D70                ;-404     *InputPtr = DOS_ByteRead;
0D70                
0D70                .getLine90:
0D70 A0 22 01        mov al, [DOS_ByteRead]
0D73 8B 1E 14 01     mov  bx, [InputPtr]
0D77 88 07           mov  [bx], al
0D79                
0D79                ;-405     InputPtr++;
0D79                
0D79 FF 06 14 01     inc  word[InputPtr]
0D7D                
0D7D                ;-406     i = InputPtr - &InputBuf;
0D7D                
0D7D A1 14 01        mov ax, [InputPtr]
0D80 2D 8D 75        sub ax, InputBuf
0D83 89 46 FE        mov [bp-2], ax
0D86                
0D86                ;-407     if (i >= INPUTBUFMAX) errorexit("input line too long");
0D86                
0D86 8B 46 FE        mov ax, [bp-2]
0D89 3D FF 00        cmp ax, 255 ;unsigned : 0
0D8C 0F 82 00 00   r jb  .getLine91
0D90 68 AA AA      A push getLine_1
0D93 E8 0B FD        call errorexit
0D96 83 C4 02        add  sp, 2
0D99                
0D99                ;-408   } while (ifEOL(DOS_ByteRead) == 0);
0D99                
0D99                .getLine91:
0D99 A0 22 01        mov al, byte [DOS_ByteRead]
0D9C B4 00           mov ah, 0
0D9E 50              push ax
0D9F E8 1C FF        call ifEOL
0DA2 83 C4 02        add  sp, 2
0DA5 3C 00           cmp al, 0
0DA7 0F 85 00 00   r jne .getLine92
0DAB EB 90           jmp .getLine88
0DAD                .getLine92:
0DAD                
0DAD                ;-409   InputPtr--;
0DAD                
0DAD FF 0E 14 01     dec  word[InputPtr]
0DB1                
0DB1                ;-410   *InputPtr=0;
0DB1                
0DB1 B8 00 00        mov ax, 0
0DB4 8B 1E 14 01     mov  bx, [InputPtr]
0DB8 88 07           mov  [bx], al
0DBA                
0DBA                ;-411 }
0DBA                
0DBA                
0DBA                ;-412 int skipBlank() {
0DBA                
0DBA C9              .retngetLine: LEAVE
0DBB C3              ret
0DBC 52 65 61 64 69 getLine_0 db "Reading Source",0
0DCB 69 6E 70 75 74 getLine_1 db "input line too long",0
leaving: getLine, loc labels: 8, loc jmp forward: 7
0DDF                ENDP
0DDF                
entering: skipBlank
0DDF                skipBlank: PROC
0DDF                
0DDF                ;-413   skipblank1:
0DDF                
0DDF                .skipblank1:
0DDF                
0DDF                ;-414     if (*InputPtr == ' ') { InputPtr++; goto skipblank1; }
0DDF                
0DDF 8B 1E 14 01     mov bx, [InputPtr]
0DE3 8A 07           mov al, [bx]
0DE5 B4 00           mov ah, 0
0DE7 83 F8 20        cmp ax, 32
0DEA 0F 85 00 00   r jne .skipBlank93
0DEE FF 06 14 01     inc  word[InputPtr]
0DF2 EB EB           jmp .skipblank1
0DF4                
0DF4                ;-415     if (*InputPtr == 9  ) { InputPtr++; goto skipblank1; }
0DF4                
0DF4                .skipBlank93:
0DF4 8B 1E 14 01     mov bx, [InputPtr]
0DF8 8A 07           mov al, [bx]
0DFA B4 00           mov ah, 0
0DFC 83 F8 09        cmp ax, 9
0DFF 0F 85 00 00   r jne .skipBlank94
0E03 FF 06 14 01     inc  word[InputPtr]
0E07 EB D6           jmp .skipblank1
0E09                
0E09                ;-416 }
0E09                
0E09                .skipBlank94:
0E09                
0E09                ;-417 
0E09                
0E09                
0E09                ;-418 int getDigit(unsigned char c) {//ret: SymbolInt
0E09                
0E09 C3              ret
leaving: skipBlank, loc labels: 3, loc jmp forward: 2
0E0A                ENDP
0E0A                
entering: getDigit
0E0A                getDigit: PROC
0E0A                
0E0A                ;-419   unsigned int CastInt;
0E0A                
0E0A                
0E0A                ;-420   SymbolInt=0;
0E0A                
0E0A                ;Function : getDigit, Number of local variables: 2
0E0A                ;   # type sign width addr used name   list of local variables
0E0A                ;  200 var unsg byte   418 NULL c = bp+4
0E0A                ;  201 var unsg word   419 NULL CastInt = bp-2;
0E0A C8 02 00 00     ENTER  2,0
0E0E B8 00 00        mov ax, 0
0E11 A3 0E 01        mov word [SymbolInt], ax
0E14                
0E14                ;-421   do {
0E14                
0E14                .getDigit95:
0E14                
0E14                ;-422     c-='0';
0E14                
0E14 80 6E 04 30     sub  byte[bp+4], 48
0E18                
0E18                ;-423     SymbolInt=SymbolInt*10;
0E18                
0E18 A1 0E 01        mov ax, [SymbolInt]
0E1B BB 0A 00        mov bx, 10
0E1E F7 E3           mul bx
0E20 A3 0E 01        mov word [SymbolInt], ax
0E23                
0E23                ;-424     ax=0; CastInt=c; //cast b2w
0E23                
0E23 B8 00 00        mov  ax, 0
0E26 8A 46 04        mov al, [bp+4]
0E29 89 46 FE        mov [bp-2], ax
0E2C                
0E2C                ;-425     SymbolInt=SymbolInt+CastInt;
0E2C                
0E2C A1 0E 01        mov ax, [SymbolInt]
0E2F 03 46 FE        add ax, [bp-2]
0E32 A3 0E 01        mov word [SymbolInt], ax
0E35                
0E35                ;-426     InputPtr++;
0E35                
0E35 FF 06 14 01     inc  word[InputPtr]
0E39                
0E39                ;-427     c = *InputPtr;
0E39                
0E39 8B 1E 14 01     mov bx, [InputPtr]
0E3D 8A 07           mov al, [bx]
0E3F B4 00           mov ah, 0
0E41 88 46 04        mov [bp+4], al
0E44                
0E44                ;-428   } while(digit(c));
0E44                
0E44 8A 46 04        mov al, byte [bp+4]
0E47 B4 00           mov ah, 0
0E49 50              push ax
0E4A E8 4F F3        call digit
0E4D 83 C4 02        add  sp, 2
0E50 08 C0           or  al, al
0E52 0F 84 00 00   r je .getDigit96
0E56 EB BC           jmp .getDigit95
0E58                .getDigit96:
0E58                
0E58                ;-429 }
0E58                
0E58                
0E58                ;-430 int getName(unsigned char c) {//ret: Symbol, SymbolUpper, isLabel
0E58 C9              LEAVE
0E59 C3              ret
leaving: getDigit, loc labels: 2, loc jmp forward: 1
0E5A                ENDP
0E5A                
entering: getName
0E5A                getName: PROC
0E5A                
0E5A                ;-431   char *p; unsigned int i;
0E5A                
0E5A                
0E5A                ;-432   p = &Symbol;
0E5A                
0E5A                ;Function : getName, Number of local variables: 3
0E5A                ;   # type sign width addr used name   list of local variables
0E5A                ;  200 var unsg byte   430 NULL c = bp+4
0E5A                ;  201 ptr sign byte   431 NULL p = bp-2
0E5A                ;  202 var unsg word   431 NULL i = bp-4;
0E5A C8 04 00 00     ENTER  4,0
0E5E B8 30 75        mov ax, Symbol
0E61 89 46 FE        mov [bp-2], ax
0E64                
0E64                ;-433   *p = c;
0E64                
0E64 8A 46 04        mov al, [bp+4]
0E67 8B 5E FE        mov  bx, [bp-2]
0E6A 88 07           mov  [bx], al
0E6C                
0E6C                ;-434   p++;
0E6C                
0E6C FF 46 FE        inc  word[bp-2]
0E6F                
0E6F                ;-435   while (alnumE(c)) {
0E6F                
0E6F                .getName97:
0E6F 8A 46 04        mov al, byte [bp+4]
0E72 B4 00           mov ah, 0
0E74 50              push ax
0E75 E8 4E F3        call alnumE
0E78 83 C4 02        add  sp, 2
0E7B 08 C0           or  al, al
0E7D 0F 84 00 00   r je .getName98
0E81                
0E81                ;-436     InputPtr++;
0E81                
0E81 FF 06 14 01     inc  word[InputPtr]
0E85                
0E85                ;-437     c = *InputPtr;
0E85                
0E85 8B 1E 14 01     mov bx, [InputPtr]
0E89 8A 07           mov al, [bx]
0E8B B4 00           mov ah, 0
0E8D 88 46 04        mov [bp+4], al
0E90                
0E90                ;-438     *p = c;
0E90                
0E90 8A 46 04        mov al, [bp+4]
0E93 8B 5E FE        mov  bx, [bp-2]
0E96 88 07           mov  [bx], al
0E98                
0E98                ;-439     p++;
0E98                
0E98 FF 46 FE        inc  word[bp-2]
0E9B                
0E9B                ;-440     i = p - &Symbol;
0E9B                
0E9B 8B 46 FE        mov ax, [bp-2]
0E9E 2D 30 75        sub ax, Symbol
0EA1 89 46 FC        mov [bp-4], ax
0EA4                
0EA4                ;-441     if (i >= SYMBOLMAX) errorexit("symbol too long");
0EA4                
0EA4 8B 46 FC        mov ax, [bp-4]
0EA7 83 F8 1F        cmp ax, 31 ;unsigned : 0
0EAA 0F 82 00 00   r jb  .getName99
0EAE 68 AA AA      A push getName_0
0EB1 E8 ED FB        call errorexit
0EB4 83 C4 02        add  sp, 2
0EB7                
0EB7                ;-442   }
0EB7                
0EB7                .getName99:
0EB7                
0EB7                ;-443   if (c == ':') isLabel=1; else isLabel=0;
0EB7                
0EB7 EB B6           jmp .getName97
0EB9                .getName98:
0EB9 8A 46 04        mov al, [bp+4]
0EBC 3C 3A           cmp al, 58
0EBE 0F 85 00 00   r jne .getName100
0EC2 B8 01 00        mov ax, 1
0EC5 A2 2B 01        mov byte [isLabel], al
0EC8 E9 00 00      R jmp .getName101
0ECB                .getName100:
0ECB B8 00 00        mov ax, 0
0ECE A2 2B 01        mov byte [isLabel], al
0ED1                
0ED1                ;-444   p--;
0ED1                
0ED1                .getName101:
0ED1 FF 4E FE        dec  word[bp-2]
0ED4                
0ED4                ;-445   *p = 0;
0ED4                
0ED4 B8 00 00        mov ax, 0
0ED7 8B 5E FE        mov  bx, [bp-2]
0EDA 88 07           mov  [bx], al
0EDC                
0EDC                ;-446   strcpy(SymbolUpper, Symbol);
0EDC                
0EDC 8D 06 30 75     lea  ax, [Symbol]
0EE0 50              push ax
0EE1 8D 06 4F 75     lea  ax, [SymbolUpper]
0EE5 50              push ax
0EE6 E8 41 F3        call strcpy
0EE9 83 C4 04        add  sp, 4
0EEC                
0EEC                ;-447   toupper(SymbolUpper);
0EEC                
0EEC 8D 06 4F 75     lea  ax, [SymbolUpper]
0EF0 50              push ax
0EF1 E8 DD F3        call toupper
0EF4 83 C4 02        add  sp, 2
0EF7                
0EF7                ;-448 }
0EF7                
0EF7                
0EF7                ;-449 
0EF7                
0EF7                
0EF7                ;-450 //#include "OPTABL.C"
0EF7                
0EF7                
0EF7                ;-451 char I_START=0xF1;
0EF7 C9              LEAVE
0EF8 C3              ret
0EF9 73 79 6D 62 6F getName_0 db "symbol too long",0
leaving: getName, loc labels: 6, loc jmp forward: 5
0F09                ENDP
0F09 F1             I_START db 241
0F0A                
0F0A                ;-452 //OpName, 0, CodeType, OpCode1-n, F1h
0F0A                
0F0A                
0F0A                ;-453 //  1:   1 byte opcode
0F0A                
0F0A                
0F0A                ;-454 char I_PUSHA[]={'P','U','S','H','A',0,1,0x60,0xF1, 'P','O','P','A',0,    1,0x61,0xF1};
0F0A                
0F0A 50 55 53 48 41 I_PUSHA db 80,85,83,72,65,0,1,96,241,80,79,80,65,0,1,97,241
0F1B                
0F1B                ;-455 char I_NOP[]=  {'N','O','P',0,        1,0x90,0xF1, 'C','B','W',0,        1,0x98,0xF1};
0F1B                
0F1B 4E 4F 50 00 01 I_NOP db 78,79,80,0,1,144,241,67,66,87,0,1,152,241
0F29                
0F29                ;-456 char I_CWDE[]= {'C','W','D','E',0,    1,0x98,0xF1, 'C','W','D',0,        1,0x99,0xF1};
0F29                
0F29 43 57 44 45 00 I_CWDE db 67,87,68,69,0,1,152,241,67,87,68,0,1,153,241
0F38                
0F38                ;-457 char I_CDQ[]=  {'C','D','Q',0,        1,0x99,0xF1, 'W','A','I','T',0,    1,0x9B,0xF1};
0F38                
0F38 43 44 51 00 01 I_CDQ db 67,68,81,0,1,153,241,87,65,73,84,0,1,155,241
0F47                
0F47                ;-458 char I_PUSHF[]={'P','U','S','H','F',0,1,0x9C,0xF1, 'P','O','P','F',0,    1,0x9D,0xF1};
0F47                
0F47 50 55 53 48 46 I_PUSHF db 80,85,83,72,70,0,1,156,241,80,79,80,70,0,1,157,241
0F58                
0F58                ;-459 char I_SAHF[]= {'S','A','H','F',0,    1,0x9E,0xF1, 'L','A','H','F',0,    1,0x9F,0xF1};
0F58                
0F58 53 41 48 46 00 I_SAHF db 83,65,72,70,0,1,158,241,76,65,72,70,0,1,159,241
0F68                
0F68                ;-460 char I_MOVSB[]={'M','O','V','S','B',0,1,0xA4,0xF1, 'M','O','V','S','W',0,1,0xA5,0xF1};
0F68                
0F68 4D 4F 56 53 42 I_MOVSB db 77,79,86,83,66,0,1,164,241,77,79,86,83,87,0,1,165,241
0F7A                
0F7A                ;-461 char I_CMPSB[]={'C','M','P','S','B',0,1,0xA6,0xF1, 'C','M','P','S','W',0,1,0xA7,0xF1};
0F7A                
0F7A 43 4D 50 53 42 I_CMPSB db 67,77,80,83,66,0,1,166,241,67,77,80,83,87,0,1,167,241
0F8C                
0F8C                ;-462 char I_STOSB[]={'S','T','O','S','B',0,1,0xAA,0xF1, 'S','T','O','S','W',0,1,0xAB,0xF1};
0F8C                
0F8C 53 54 4F 53 42 I_STOSB db 83,84,79,83,66,0,1,170,241,83,84,79,83,87,0,1,171,241
0F9E                
0F9E                ;-463 char I_LODSB[]={'L','O','D','S','B',0,1,0xAC,0xF1, 'L','O','D','S','W',0,1,0xAD,0xF1};
0F9E                
0F9E 4C 4F 44 53 42 I_LODSB db 76,79,68,83,66,0,1,172,241,76,79,68,83,87,0,1,173,241
0FB0                
0FB0                ;-464 char I_SCASB[]={'S','C','A','S','B',0,1,0xAE,0xF1, 'S','C','A','S','W',0,1,0xAF,0xF1};
0FB0                
0FB0 53 43 41 53 42 I_SCASB db 83,67,65,83,66,0,1,174,241,83,67,65,83,87,0,1,175,241
0FC2                
0FC2                ;-465 char I_LEAVE[]={'L','E','A','V','E',0,1,0xC9,0xF1, 'I','N','T','3',0,    1,0xCC,0xF1};
0FC2                
0FC2 4C 45 41 56 45 I_LEAVE db 76,69,65,86,69,0,1,201,241,73,78,84,51,0,1,204,241
0FD3                
0FD3                ;-466 char I_INTO[]= {'I','N','T','O',0,    1,0xCE,0xF1, 'I','R','E','T',0,    1,0xCF,0xF1};
0FD3                
0FD3 49 4E 54 4F 00 I_INTO db 73,78,84,79,0,1,206,241,73,82,69,84,0,1,207,241
0FE3                
0FE3                ;-467 char I_XLAT[]= {'X','L','A','T',0,    1,0xD7,0xF1, 'L','O','C','K',0,    1,0xF0,0xF1};
0FE3                
0FE3 58 4C 41 54 00 I_XLAT db 88,76,65,84,0,1,215,241,76,79,67,75,0,1,240,241
0FF3                
0FF3                ;-468 char I_REPNE[]={'R','E','P','N','E',0,1,0xF2,0xF1, 'R','E','P','N','Z',0,1,0xF2,0xF1};
0FF3                
0FF3 52 45 50 4E 45 I_REPNE db 82,69,80,78,69,0,1,242,241,82,69,80,78,90,0,1,242,241
1005                
1005                ;-469 char I_REPE[]= {'R','E','P','E',0,    1,0xF3,0xF1, 'R','E','P','Z',0,    1,0xF3,0xF1};
1005                
1005 52 45 50 45 00 I_REPE db 82,69,80,69,0,1,243,241,82,69,80,90,0,1,243,241
1015                
1015                ;-470 char I_HLT[]=  {'H','L','T',0,        1,0xF4,0xF1, 'C','L','C',0,        1,0xF8,0xF1};
1015                
1015 48 4C 54 00 01 I_HLT db 72,76,84,0,1,244,241,67,76,67,0,1,248,241
1023                
1023                ;-471 char I_STC[]=  {'S','T','C',0,        1,0xF9,0xF1, 'C','L','I',0,        1,0xFA,0xF1};
1023                
1023 53 54 43 00 01 I_STC db 83,84,67,0,1,249,241,67,76,73,0,1,250,241
1031                
1031                ;-472 char I_STI[]=  {'S','T','I',0,        1,0xFB,0xF1, 'C','L','D',0,        1,0xFC,0xF1};
1031                
1031 53 54 49 00 01 I_STI db 83,84,73,0,1,251,241,67,76,68,0,1,252,241
103F                
103F                ;-473 char I_STD[]=  {'S','T','D',0,        1,0xFD,0xF1};
103F                
103F 53 54 44 00 01 I_STD db 83,84,68,0,1,253,241
1046                
1046                ;-474 // 2: mem reg 16 bit
1046                
1046                
1046                ;-475 char I_INC[]=  {'I','N','C',0,          2,0xFE, 0,0x40,0xF1};
1046                
1046 49 4E 43 00 02 I_INC db 73,78,67,0,2,254,0,64,241
104F                
104F                ;-476 char I_DEC[]=  {'D','E','C',0,          2,0xFE, 1,0x48,0xF1};
104F                
104F 44 45 43 00 02 I_DEC db 68,69,67,0,2,254,1,72,241
1058                
1058                ;-477 char I_NOT[]=  {'N','O','T',0,          2,0xF6, 2,     0xF1};
1058                
1058 4E 4F 54 00 02 I_NOT db 78,79,84,0,2,246,2,241
1060                
1060                ;-478 char I_NEG[]=  {'N','E','G',0,          2,0xF6, 3,     0xF1};
1060                
1060 4E 45 47 00 02 I_NEG db 78,69,71,0,2,246,3,241
1068                
1068                ;-479 char I_MUL[]=  {'M','U','L',0,          2,0xF6, 4,     0xF1};
1068                
1068 4D 55 4C 00 02 I_MUL db 77,85,76,0,2,246,4,241
1070                
1070                ;-480 char I_IMUL[]= {'I','M','U','L',0,      2,0xF6, 5,     0xF1};//only acc
1070                
1070 49 4D 55 4C 00 I_IMUL db 73,77,85,76,0,2,246,5,241
1079                
1079                ;-481 char I_DIV[]=  {'D','I','V',0,          2,0xF6, 6,     0xF1};
1079                
1079 44 49 56 00 02 I_DIV db 68,73,86,0,2,246,6,241
1081                
1081                ;-482 char I_IDIV[]= {'I','D','I','V',0,      2,0xF6, 7,     0xF1};
1081                
1081 49 44 49 56 00 I_IDIV db 73,68,73,86,0,2,246,7,241
108A                
108A                ;-483 //  3: les, lda, lea, lss, lfs, lgs
108A                
108A                
108A                ;-484 char I_LES[]=  {'L','E','S',0,          3,0xC4,     0xF1};
108A                
108A 4C 45 53 00 03 I_LES db 76,69,83,0,3,196,241
1091                
1091                ;-485 char I_LDS[]=  {'L','D','S',0,          3,0xC5,     0xF1};
1091                
1091 4C 44 53 00 03 I_LDS db 76,68,83,0,3,197,241
1098                
1098                ;-486 char I_LEA[]=  {'L','E','A',0,          3,0x8D,     0xF1};//r, m16
1098                
1098 4C 45 41 00 03 I_LEA db 76,69,65,0,3,141,241
109F                
109F                ;-487 char I_LSS[]=  {'L','S','S',0,          3,0x0F,0xB2,0xF1};
109F                
109F 4C 53 53 00 03 I_LSS db 76,83,83,0,3,15,178,241
10A7                
10A7                ;-488 char I_LFS[]=  {'L','F','S',0,          3,0x0F,0xB4,0xF1};
10A7                
10A7 4C 46 53 00 03 I_LFS db 76,70,83,0,3,15,180,241
10AF                
10AF                ;-489 char I_LGS[]=  {'L','G','S',0,          3,0x0F,0xB5,0xF1};
10AF                
10AF 4C 47 53 00 03 I_LGS db 76,71,83,0,3,15,181,241
10B7                
10B7                ;-490 //  4: acc,imm  reg,imm  index,reg
10B7                
10B7                
10B7                ;-491 char I_ADD[]=  {'A','D','D',0,          4, 0,     0xF1};
10B7                
10B7 41 44 44 00 04 I_ADD db 65,68,68,0,4,0,241
10BE                
10BE                ;-492 char I_OR []=  {'O','R',0,              4, 1,     0xF1};
10BE                
10BE 4F 52 00 04 01 I_OR db 79,82,0,4,1,241
10C4                
10C4                ;-493 char I_ADC[]=  {'A','D','C',0,          4, 2,     0xF1};
10C4                
10C4 41 44 43 00 04 I_ADC db 65,68,67,0,4,2,241
10CB                
10CB                ;-494 char I_SBB[]=  {'S','B','B',0,          4, 3,     0xF1};
10CB                
10CB 53 42 42 00 04 I_SBB db 83,66,66,0,4,3,241
10D2                
10D2                ;-495 char I_AND[]=  {'A','N','D',0,          4, 4,     0xF1};
10D2                
10D2 41 4E 44 00 04 I_AND db 65,78,68,0,4,4,241
10D9                
10D9                ;-496 char I_SUB[]=  {'S','U','B',0,          4, 5,     0xF1};
10D9                
10D9 53 55 42 00 04 I_SUB db 83,85,66,0,4,5,241
10E0                
10E0                ;-497 char I_XOR[]=  {'X','O','R',0,          4, 6,     0xF1};
10E0                
10E0 58 4F 52 00 04 I_XOR db 88,79,82,0,4,6,241
10E7                
10E7                ;-498 char I_CMP[]=  {'C','M','P',0,          4, 7,     0xF1};
10E7                
10E7 43 4D 50 00 04 I_CMP db 67,77,80,0,4,7,241
10EE                
10EE                ;-499 char I_TEST[]= {'T','E','S','T',0,     41,0xA8,0x84,0xF6,0,0xF1};
10EE                
10EE 54 45 53 54 00 I_TEST db 84,69,83,84,0,41,168,132,246,0,241
10F9                
10F9                ;-500 //  5: mov
10F9                
10F9                
10F9                ;-501 char I_MOV[]=  {'M','O','V',0,          5,        0xF1};
10F9                
10F9 4D 4F 56 00 05 I_MOV db 77,79,86,0,5,241
10FF                
10FF                ;-502 char I_MOVSX[]={'M','O','V','S','X',0, 51,0xBE,   0xF1};
10FF                
10FF 4D 4F 56 53 58 I_MOVSX db 77,79,86,83,88,0,51,190,241
1108                
1108                ;-503 char I_MOVZX[]={'M','O','V','Z','X',0, 51,0xB6,   0xF1};
1108                
1108 4D 4F 56 5A 58 I_MOVZX db 77,79,86,90,88,0,51,182,241
1111                
1111                ;-504 //  6: single byte relative jump
1111                
1111                
1111                ;-505 char I_JO []=  {'J','O',0,     6, 0,0xF1};
1111                
1111 4A 4F 00 06 00 I_JO db 74,79,0,6,0,241
1117                
1117                ;-506 char I_JNO[]=  {'J','N','O',0, 6, 1,0xF1};
1117                
1117 4A 4E 4F 00 06 I_JNO db 74,78,79,0,6,1,241
111E                
111E                ;-507 char I_JB []=  {'J','B',0,     6, 2,0xF1, 'J','C',0,     6, 2,0xF1};
111E                
111E 4A 42 00 06 02 I_JB db 74,66,0,6,2,241,74,67,0,6,2,241
112A                
112A                ;-508 char I_JNB[]=  {'J','N','B',0, 6, 3,0xF1};
112A                
112A 4A 4E 42 00 06 I_JNB db 74,78,66,0,6,3,241
1131                
1131                ;-509 char I_JAE[]=  {'J','A','E',0, 6, 3,0xF1, 'J','N','C',0, 6, 3,0xF1};
1131                
1131 4A 41 45 00 06 I_JAE db 74,65,69,0,6,3,241,74,78,67,0,6,3,241
113F                
113F                ;-510 char I_JE []=  {'J','E',0,     6, 4,0xF1, 'J','Z',0,     6, 4,0xF1};
113F                
113F 4A 45 00 06 04 I_JE db 74,69,0,6,4,241,74,90,0,6,4,241
114B                
114B                ;-511 char I_JNE[]=  {'J','N','E',0, 6, 5,0xF1, 'J','N','Z',0, 6, 5,0xF1};
114B                
114B 4A 4E 45 00 06 I_JNE db 74,78,69,0,6,5,241,74,78,90,0,6,5,241
1159                
1159                ;-512 char I_JBE[]=  {'J','B','E',0, 6, 6,0xF1, 'J','N','A',0, 6, 6,0xF1};
1159                
1159 4A 42 45 00 06 I_JBE db 74,66,69,0,6,6,241,74,78,65,0,6,6,241
1167                
1167                ;-513 char I_JA []=  {'J','A',0,     6, 7,0xF1};
1167                
1167 4A 41 00 06 07 I_JA db 74,65,0,6,7,241
116D                
116D                ;-514 char I_JS []=  {'J','S',0,     6, 8,0xF1};
116D                
116D 4A 53 00 06 08 I_JS db 74,83,0,6,8,241
1173                
1173                ;-515 char I_JNS[]=  {'J','N','S',0, 6, 9,0xF1};
1173                
1173 4A 4E 53 00 06 I_JNS db 74,78,83,0,6,9,241
117A                
117A                ;-516 char I_JP []=  {'J','P',0,     6,10,0xF1, 'J','P','E',0, 6,10,0xF1};
117A                
117A 4A 50 00 06 0A I_JP db 74,80,0,6,10,241,74,80,69,0,6,10,241
1187                
1187                ;-517 char I_JNP[]=  {'J','N','P',0, 6,11,0xF1, 'J','P','O',0, 6,11,0xF1};
1187                
1187 4A 4E 50 00 06 I_JNP db 74,78,80,0,6,11,241,74,80,79,0,6,11,241
1195                
1195                ;-518 char I_JL []=  {'J','L',0,     6,12,0xF1};
1195                
1195 4A 4C 00 06 0C I_JL db 74,76,0,6,12,241
119B                
119B                ;-519 char I_JNL[]=  {'J','N','L',0, 6,13,0xF1, 'J','G','E',0, 6,13,0xF1};
119B                
119B 4A 4E 4C 00 06 I_JNL db 74,78,76,0,6,13,241,74,71,69,0,6,13,241
11A9                
11A9                ;-520 char I_JLE[]=  {'J','L','E',0, 6,14,0xF1, 'J','N','G',0, 6,14,0xF1};
11A9                
11A9 4A 4C 45 00 06 I_JLE db 74,76,69,0,6,14,241,74,78,71,0,6,14,241
11B7                
11B7                ;-521 char I_JG []=  {'J','G',0,     6,15,0xF1};
11B7                
11B7 4A 47 00 06 0F I_JG db 74,71,0,6,15,241
11BD                
11BD                ;-522 //  7: jmp, call
11BD                
11BD                
11BD                ;-523 char I_JMP[]=  {'J','M','P',0,          7,0xE9, 4,0xF1};
11BD                
11BD 4A 4D 50 00 07 I_JMP db 74,77,80,0,7,233,4,241
11C5                
11C5                ;-524 char I_CALL[]= {'C','A','L','L',0,      7,0xE8, 2,0xF1};
11C5                
11C5 43 41 4C 4C 00 I_CALL db 67,65,76,76,0,7,232,2,241
11CE                
11CE                ;-525 //  8: ret
11CE                
11CE                
11CE                ;-526 char I_RET[]=  {'R','E','T',0,          8,0xC3,0xC2,0xF1};
11CE                
11CE 52 45 54 00 08 I_RET db 82,69,84,0,8,195,194,241
11D6                
11D6                ;-527 char I_RETF[]= {'R','E','T','F',0,      8,0xCB,0xCA,0xF1};
11D6                
11D6 52 45 54 46 00 I_RETF db 82,69,84,70,0,8,203,202,241
11DF                
11DF                ;-528 //  9: seg, r/m
11DF                
11DF                
11DF                ;-529 char I_PUSH[]= {'P','U','S','H',0,      9,0x50,0xF1};
11DF                
11DF 50 55 53 48 00 I_PUSH db 80,85,83,72,0,9,80,241
11E7                
11E7                ;-530 char I_POP[]=  {'P','O','P',0,          9,0x58,0xF1};
11E7                
11E7 50 4F 50 00 09 I_POP db 80,79,80,0,9,88,241
11EE                
11EE                ;-531 //  11: shift, rotates
11EE                
11EE                
11EE                ;-532 char I_ROL[]=  {'R','O','L',0, 11, 0,0xF1, 'R','O','R',0, 11, 1,0xF1};
11EE                
11EE 52 4F 4C 00 0B I_ROL db 82,79,76,0,11,0,241,82,79,82,0,11,1,241
11FC                
11FC                ;-533 char I_RCL[]=  {'R','C','L',0, 11, 2,0xF1, 'R','C','R',0, 11, 3,0xF1};
11FC                
11FC 52 43 4C 00 0B I_RCL db 82,67,76,0,11,2,241,82,67,82,0,11,3,241
120A                
120A                ;-534 char I_SHL[]=  {'S','H','L',0, 11, 4,0xF1, 'S','A','L',0, 11, 4,0xF1};
120A                
120A 53 48 4C 00 0B I_SHL db 83,72,76,0,11,4,241,83,65,76,0,11,4,241
1218                
1218                ;-535 char I_SHR[]=  {'S','H','R',0, 11, 5,0xF1, 'S','A','R',0, 11, 7,0xF1};
1218                
1218 53 48 52 00 0B I_SHR db 83,72,82,0,11,5,241,83,65,82,0,11,7,241
1226                
1226                ;-536 //  12: int
1226                
1226                
1226                ;-537 char I_INT[]=  {'I','N','T',0,          12,0xCD,0xCC,0xF1};
1226                
1226 49 4E 54 00 0C I_INT db 73,78,84,0,12,205,204,241
122E                
122E                ;-538 //  14: in/out
122E                
122E                
122E                ;-539 char I_IN[]=   {'I','N',0,              14,0xE4,0xEC,0xF1};
122E                
122E 49 4E 00 0E E4 I_IN db 73,78,0,14,228,236,241
1235                
1235                ;-540 char I_INSB[]= {'I','N','S','B',0,      14,0x6C,   0xF1};
1235                
1235 49 4E 53 42 00 I_INSB db 73,78,83,66,0,14,108,241
123D                
123D                ;-541 char I_INSW[]= {'I','N','S','W',0,      14,0x6D,   0xF1};
123D                
123D 49 4E 53 57 00 I_INSW db 73,78,83,87,0,14,109,241
1245                
1245                ;-542 char I_INSD[]= {'I','N','S','D',0,      14,0x6D,   0xF1};
1245                
1245 49 4E 53 44 00 I_INSD db 73,78,83,68,0,14,109,241
124D                
124D                ;-543 char I_OUT[]=  {'O','U','T',0,          14,0xE6,0xEE,0xF1};
124D                
124D 4F 55 54 00 0E I_OUT db 79,85,84,0,14,230,238,241
1255                
1255                ;-544 char I_OUTSB[]={'O','U','T','B',0,      14,0x6E,   0xF1};
1255                
1255 4F 55 54 42 00 I_OUTSB db 79,85,84,66,0,14,110,241
125D                
125D                ;-545 char I_OUTSW[]={'O','U','T','W',0,      14,0x6F,   0xF1};
125D                
125D 4F 55 54 57 00 I_OUTSW db 79,85,84,87,0,14,111,241
1265                
1265                ;-546 char I_OUTSD[]={'O','U','T','D',0,      14,0x6F,   0xF1};
1265                
1265 4F 55 54 44 00 I_OUTSD db 79,85,84,68,0,14,111,241
126D                
126D                ;-547 //  15: xchg
126D                
126D                
126D                ;-548 char I_XCHG[]= {'X','C','H','G',0,      15,0x86,0x90,0xF1};
126D                
126D 58 43 48 47 00 I_XCHG db 88,67,72,71,0,15,134,144,241
1276                
1276                ;-549 //  16: loop, jcxz
1276                
1276                
1276                ;-550 char I_LOOPNZ[]={'L','O','O','P','N','Z',0, 16,0xE0,0xF1};
1276                
1276 4C 4F 4F 50 4E I_LOOPNZ db 76,79,79,80,78,90,0,16,224,241
1280                
1280                ;-551 char I_LOOPNE[]={'L','O','O','P','N','E',0, 16,0xE0,0xF1};
1280                
1280 4C 4F 4F 50 4E I_LOOPNE db 76,79,79,80,78,69,0,16,224,241
128A                
128A                ;-552 char I_LOOPZ[]={'L','O','O','P','Z',0,      16,0xE1,0xF1};
128A                
128A 4C 4F 4F 50 5A I_LOOPZ db 76,79,79,80,90,0,16,225,241
1293                
1293                ;-553 char I_LOOPE[]={'L','O','O','P','E',0,      16,0xE1,0xF1};
1293                
1293 4C 4F 4F 50 45 I_LOOPE db 76,79,79,80,69,0,16,225,241
129C                
129C                ;-554 char I_LOOP[]= {'L','O','O','P',0,          16,0xE2,0xF1};
129C                
129C 4C 4F 4F 50 00 I_LOOP db 76,79,79,80,0,16,226,241
12A4                
12A4                ;-555 char I_JCXZ[]= {'J','C','X','Z',0,          16,0xE3,0xF1};
12A4                
12A4 4A 43 58 5A 00 I_JCXZ db 74,67,88,90,0,16,227,241
12AC                
12AC                ;-556 char I_JECXZ[]= {'J','E','C','X','Z',0,     16,0xE3,0xF1};
12AC                
12AC 4A 45 43 58 5A I_JECXZ db 74,69,67,88,90,0,16,227,241
12B5                
12B5                ;-557 //  30: enter
12B5                
12B5                
12B5                ;-558 char I_ENTER[]={'E','N','T','E','R',0, 30,        0xF1};
12B5                
12B5 45 4E 54 45 52 I_ENTER db 69,78,84,69,82,0,30,241
12BD                
12BD                ;-559 // 100: directives
12BD                
12BD                
12BD                ;-560 char I_ORG[]=  {'O','R','G',0,        101,        0xF1};
12BD                
12BD 4F 52 47 00 65 I_ORG db 79,82,71,0,101,241
12C3                
12C3                ;-561 // section, segment .TEXT .DATA .BSS
12C3                
12C3                
12C3                ;-562 char I_SECTION[]={'S','E','C','T','I','O','N',0,      102, 0xF1};
12C3                
12C3 53 45 43 54 49 I_SECTION db 83,69,67,84,73,79,78,0,102,241
12CD                
12CD                ;-563 char I_SEGMENT[]={'S','E','G','M','E','N','T',0,      102, 0xF1};
12CD                
12CD 53 45 47 4D 45 I_SEGMENT db 83,69,71,77,69,78,84,0,102,241
12D7                
12D7                ;-564 char I_ABSOLUTE[]={'A','B','S','O','L','U','T','E',0, 110, 0xF1};
12D7                
12D7 41 42 53 4F 4C I_ABSOLUTE db 65,66,83,79,76,85,84,69,0,110,241
12E2                
12E2                ;-565 char I_PROC[]= {'P','R','O','C',0,    111,        0xF1};
12E2                
12E2 50 52 4F 43 00 I_PROC db 80,82,79,67,0,111,241
12E9                
12E9                ;-566 char I_ENDP[]= {'E','N','D','P',0,    112,        0xF1};
12E9                
12E9 45 4E 44 50 00 I_ENDP db 69,78,68,80,0,112,241
12F0                
12F0                ;-567 char I_DB[]=   {'D','B',0,            200,        0xF1};
12F0                
12F0 44 42 00 C8 F1 I_DB db 68,66,0,200,241
12F5                
12F5                ;-568 char I_DW[]=   {'D','W',0,            201,        0xF1};
12F5                
12F5 44 57 00 C9 F1 I_DW db 68,87,0,201,241
12FA                
12FA                ;-569 char I_DD[]=   {'D','D',0,            202,        0xF1};
12FA                
12FA 44 44 00 CA F1 I_DD db 68,68,0,202,241
12FF                
12FF                ;-570 char I_RESB[]= {'R','E','S','B',0,    203,        0xF1};
12FF                
12FF 52 45 53 42 00 I_RESB db 82,69,83,66,0,203,241
1306                
1306                ;-571 char I_RESW[]= {'R','E','S','W',0,    204,        0xF1};
1306                
1306 52 45 53 57 00 I_RESW db 82,69,83,87,0,204,241
130D                
130D                ;-572 char I_RESD[]= {'R','E','S','D',0,    205,        0xF1};
130D                
130D 52 45 53 44 00 I_RESD db 82,69,83,68,0,205,241
1314                
1314                ;-573 char I_END=0;// end of table char
1314                
1314 00             I_END db 0
1315                
1315                ;-574 
1315                
1315                
1315                ;-575 int lookCode() {//ret: CodeType, *OpCodePtr
1315                
1315                
entering: lookCode
1315                lookCode: PROC
1315                
1315                ;-576     CodeType=0;
1315                
1315 B8 00 00        mov ax, 0
1318 A2 2F 01        mov byte [CodeType], al
131B                
131B                ;-577     OpCodePtr= &I_START;
131B                
131B B8 09 10        mov ax, I_START
131E A3 43 01        mov word [OpCodePtr], ax
1321                
1321                ;-578     OpCodePtr++;
1321                
1321 FF 06 43 01     inc  word[OpCodePtr]
1325                
1325                ;-579     do  {
1325                
1325                .lookCode102:
1325                
1325                ;-580         if (eqstr(SymbolUpper, OpCodePtr))  {
1325                
1325 FF 36 43 01     push word [OpCodePtr]
1329 8D 06 4F 75     lea  ax, [SymbolUpper]
132D 50              push ax
132E E8 2F EF        call eqstr
1331 83 C4 04        add  sp, 4
1334 08 C0           or  al, al
1336 0F 84 00 00   r je .lookCode103
133A                
133A                ;-581             while(*OpCodePtr!=0) OpCodePtr++;
133A                
133A                .lookCode104:
133A 8B 1E 43 01     mov bx, [OpCodePtr]
133E 8A 07           mov al, [bx]
1340 B4 00           mov ah, 0
1342 83 F8 00        cmp ax, 0
1345 0F 84 00 00   r je  .lookCode105
1349 FF 06 43 01     inc  word[OpCodePtr]
134D                
134D                ;-582             OpCodePtr++;
134D                
134D EB EB           jmp .lookCode104
134F                .lookCode105:
134F FF 06 43 01     inc  word[OpCodePtr]
1353                
1353                ;-583             CodeType =*OpCodePtr;
1353                
1353 8B 1E 43 01     mov bx, [OpCodePtr]
1357 8A 07           mov al, [bx]
1359 B4 00           mov ah, 0
135B A2 2F 01        mov byte [CodeType], al
135E                
135E                ;-584             return;
135E                
135E E9 00 00      R jmp .retnlookCode
1361                
1361                ;-585         }
1361                
1361                
1361                ;-586     while(*OpCodePtr!=0xF1) OpCodePtr++;
1361                
1361                .lookCode103:
1361                .lookCode106:
1361 8B 1E 43 01     mov bx, [OpCodePtr]
1365 8A 07           mov al, [bx]
1367 B4 00           mov ah, 0
1369 3D F1 00        cmp ax, 241
136C 0F 84 00 00   r je  .lookCode107
1370 FF 06 43 01     inc  word[OpCodePtr]
1374                
1374                ;-587     OpCodePtr++;
1374                
1374 EB EB           jmp .lookCode106
1376                .lookCode107:
1376 FF 06 43 01     inc  word[OpCodePtr]
137A                
137A                ;-588     } while(*OpCodePtr!=0);
137A                
137A 8B 1E 43 01     mov bx, [OpCodePtr]
137E 8A 07           mov al, [bx]
1380 B4 00           mov ah, 0
1382 83 F8 00        cmp ax, 0
1385 0F 84 00 00   r je  .lookCode108
1389 EB 9A           jmp .lookCode102
138B                .lookCode108:
138B                
138B                ;-589 }
138B                
138B                
138B                ;-590 
138B                
138B                
138B                ;-591 int genCode8(char c) {
138B                
138B                 .retnlookCode:
138B C3              ret
leaving: lookCode, loc labels: 8, loc jmp forward: 5
138C                ENDP
138C                
entering: genCode8
138C                genCode8: PROC
138C                
138C                ;-592 //set: BinLen++, OpPrintIndex++
138C                
138C                
138C                ;-593     FileBin[BinLen]=c;
138C                
138C                ;Function : genCode8, Number of local variables: 1
138C                ;   # type sign width addr used name   list of local variables
138C                ;  200 var sign byte   591 NULL c = bp+4;
138C C8 00 00 00     ENTER  0,0
1390 8A 46 04        mov al, [bp+4]
1393 8B 1E 58 01     mov bx, [BinLen]
1397 88 87 AA A4     mov [FileBin+bx], al
139B                
139B                ;-594     BinLen++;
139B                
139B FF 06 58 01     inc  word[BinLen]
139F                
139F                ;-595     PC++;
139F                
139F FF 06 23 01     inc  word[PC]
13A3                
13A3                ;-596     if (BinLen >= FILEBINMAX) errorexit("COM file too long");
13A3                
13A3 A1 58 01        mov ax, [BinLen]
13A6 3D 68 42        cmp ax, 17000 ;unsigned : 0
13A9 0F 82 00 00   r jb  .genCode8109
13AD 68 AA AA      A push genCode8_0
13B0 E8 EE F6        call errorexit
13B3 83 C4 02        add  sp, 2
13B6                
13B6                ;-597     if (OpPrintIndex < OPMAXLEN) {
13B6                
13B6                .genCode8109:
13B6 A1 41 01        mov ax, [OpPrintIndex]
13B9 83 F8 05        cmp ax, 5
13BC 0F 8D 00 00   r jge .genCode8110
13C0                
13C0                ;-598         OpPos[OpPrintIndex]=c;
13C0                
13C0 8A 46 04        mov al, [bp+4]
13C3 8B 1E 41 01     mov bx, [OpPrintIndex]
13C7 88 87 55 77     mov [OpPos+bx], al
13CB                
13CB                ;-599         OpPrintIndex++;
13CB                
13CB FF 06 41 01     inc  word[OpPrintIndex]
13CF                
13CF                ;-600     }
13CF                
13CF                
13CF                ;-601 }
13CF                
13CF                .genCode8110:
13CF                
13CF                ;-602 int gen66h() {genCode8(0x66);
13CF C9              LEAVE
13D0 C3              ret
13D1 43 4F 4D 20 66 genCode8_0 db "COM file too long",0
leaving: genCode8, loc labels: 3, loc jmp forward: 3
13E3                ENDP
13E3                
entering: gen66h
13E3                gen66h: PROC
13E3 6A 66           push 102
13E5 E8 A4 FF        call genCode8
13E8 83 C4 02        add  sp, 2
13EB                
13EB                ;-603 }
13EB                
13EB                
13EB                ;-604 int genCode2(char c, char d) {
13EB                
13EB C3              ret
leaving: gen66h, loc labels: 0, loc jmp forward: 0
13EC                ENDP
13EC                
entering: genCode2
13EC                genCode2: PROC
13EC                
13EC                ;-605     c = c + d;
13EC                
13EC                ;Function : genCode2, Number of local variables: 2
13EC                ;   # type sign width addr used name   list of local variables
13EC                ;  200 var sign byte   604 NULL c = bp+4
13EC                ;  201 var sign byte   604 NULL d = bp+6;
13EC C8 00 00 00     ENTER  0,0
13F0 8A 46 04        mov al, [bp+4]
13F3 02 46 06        add al, [bp+6]
13F6 88 46 04        mov [bp+4], al
13F9                
13F9                ;-606     genCode8(c);
13F9                
13F9 8A 46 04        mov al, byte [bp+4]
13FC B4 00           mov ah, 0
13FE 50              push ax
13FF E8 8A FF        call genCode8
1402 83 C4 02        add  sp, 2
1405                
1405                ;-607 }
1405                
1405                
1405                ;-608 int genCodeW(char c) {
1405 C9              LEAVE
1406 C3              ret
leaving: genCode2, loc labels: 0, loc jmp forward: 0
1407                ENDP
1407                
entering: genCodeW
1407                genCodeW: PROC
1407                
1407                ;-609     c = c + wflag;
1407                
1407                ;Function : genCodeW, Number of local variables: 1
1407                ;   # type sign width addr used name   list of local variables
1407                ;  200 var sign byte   608 NULL c = bp+4;
1407 C8 00 00 00     ENTER  0,0
140B 8A 46 04        mov al, [bp+4]
140E 02 06 38 01     add al, [wflag]
1412 88 46 04        mov [bp+4], al
1415                
1415                ;-610     genCode8(c);
1415                
1415 8A 46 04        mov al, byte [bp+4]
1418 B4 00           mov ah, 0
141A 50              push ax
141B E8 6E FF        call genCode8
141E 83 C4 02        add  sp, 2
1421                
1421                ;-611 }
1421                
1421                
1421                ;-612 int genCode16(unsigned int i) {
1421 C9              LEAVE
1422 C3              ret
leaving: genCodeW, loc labels: 0, loc jmp forward: 0
1423                ENDP
1423                
entering: genCode16
1423                genCode16: PROC
1423                
1423                ;-613     genCode8(i); i=i >> 8;
1423                
1423                ;Function : genCode16, Number of local variables: 1
1423                ;   # type sign width addr used name   list of local variables
1423                ;  200 var unsg word   612 NULL i = bp+4;
1423 C8 00 00 00     ENTER  0,0
1427 FF 76 04        push word [bp+4]
142A E8 5F FF        call genCode8
142D 83 C4 02        add  sp, 2
1430 8B 46 04        mov ax, [bp+4]
1433 C1 E8 08        shr ax, 8
1436 89 46 04        mov [bp+4], ax
1439                
1439                ;-614     genCode8(i);
1439                
1439 FF 76 04        push word [bp+4]
143C E8 4D FF        call genCode8
143F 83 C4 02        add  sp, 2
1442                
1442                ;-615 }
1442                
1442                
1442                ;-616 int genCode32(unsigned long L) {
1442 C9              LEAVE
1443 C3              ret
leaving: genCode16, loc labels: 0, loc jmp forward: 0
1444                ENDP
1444                
entering: genCode32
1444                genCode32: PROC
1444                
1444                ;-617     genCode16(L); L=L >>16;
1444                
1444                ;Function : genCode32, Number of local variables: 1
1444                ;   # type sign width addr used name   list of local variables
1444                ;  200 var unsg dwrd   616 NULL L = bp+4;
1444 C8 00 00 00     ENTER  0,0
1448 8A 46 04        mov al, byte [bp+4]
144B B4 00           mov ah, 0
144D 50              push ax
144E E8 D2 FF        call genCode16
1451 83 C4 02        add  sp, 2
1454 66 8B 46 04     mov eax, [bp+4]
1458 66 C1 E8 10     shr eax, 16
145C 66 89 46 04     mov [bp+4], eax
1460                
1460                ;-618     genCode16(L);
1460                
1460 8A 46 04        mov al, byte [bp+4]
1463 B4 00           mov ah, 0
1465 50              push ax
1466 E8 BA FF        call genCode16
1469 83 C4 02        add  sp, 2
146C                
146C                ;-619 } 
146C                
146C                
146C                ;-620 /*
146C                
146C                
146C                ;-621 int getLen(unsigned int i) {
146C                
146C                
146C                ;-622     if (i >  127) return 2;
146C                
146C                
146C                ;-623     if (i < 0x80) return 2;//-128
146C                
146C                
146C                ;-624     return 1;
146C                
146C                
146C                ;-625 }
146C                
146C                
146C                ;-626 */        
146C                
146C                
146C                ;-627 int writeEA(char xxx) {//value for reg/operand
146C C9              LEAVE
146D C3              ret
leaving: genCode32, loc labels: 0, loc jmp forward: 0
146E                ENDP
146E                
entering: writeEA
146E                writeEA: PROC
146E                
146E                ;-628 //need: Op, Op2, disp, R1No, R2No, rm, isDirect
146E                
146E                
146E                ;-629 //mod-bits: mode76, reg/opcode543, r/m210
146E                
146E                
146E                ;-630 //Op: 0, IMM, REG, ADR, MEM
146E                
146E                
146E                ;-631     char len;
146E                
146E                
146E                ;-632     len=0;
146E                
146E                ;Function : writeEA, Number of local variables: 2
146E                ;   # type sign width addr used name   list of local variables
146E                ;  200 var sign byte   627 NULL xxx = bp+4
146E                ;  201 var sign byte   631 NULL len = bp-2;
146E C8 02 00 00     ENTER  2,0
1472 B8 00 00        mov ax, 0
1475 88 46 FE        mov [bp-2], al
1478                
1478                ;-633     xxx = xxx << 3;//in reg/opcode field
1478                
1478 8A 46 04        mov al, [bp+4]
147B C0 E0 03        shl al, 3
147E 88 46 04        mov [bp+4], al
1481                
1481                ;-634     if (Op == REG) {
1481                
1481 A0 2D 01        mov al, [Op]
1484 3C 02           cmp al, 2
1486 0F 85 00 00   r jne .writeEA111
148A                
148A                ;-635         xxx |= 0xC0;
148A                
148A 80 4E 04 C0     or  byte[bp+4], 192
148E                
148E                ;-636         if (Op2 <= IMM) xxx = xxx + R1No;//empty or IMM
148E                
148E A0 2E 01        mov al, [Op2]
1491 3C 01           cmp al, 1
1493 0F 8F 00 00   r jg  .writeEA112
1497 8A 46 04        mov al, [bp+4]
149A 02 06 34 01     add al, [R1No]
149E 88 46 04        mov [bp+4], al
14A1                
14A1                ;-637             else {
14A1                
14A1 E9 00 00      R jmp .writeEA113
14A4                .writeEA112:
14A4                
14A4                ;-638                 if (Op2 == REG) xxx = xxx + R1No;
14A4                
14A4 A0 2E 01        mov al, [Op2]
14A7 3C 02           cmp al, 2
14A9 0F 85 00 00   r jne .writeEA114
14AD 8A 46 04        mov al, [bp+4]
14B0 02 06 34 01     add al, [R1No]
14B4 88 46 04        mov [bp+4], al
14B7                
14B7                ;-639                 else            xxx = xxx + R2No;
14B7                
14B7 E9 00 00      R jmp .writeEA115
14BA                .writeEA114:
14BA 8A 46 04        mov al, [bp+4]
14BD 02 06 33 01     add al, [R2No]
14C1 88 46 04        mov [bp+4], al
14C4                
14C4                ;-640             }
14C4                
14C4                .writeEA115:
14C4                
14C4                ;-641         }
14C4                
14C4                .writeEA113:
14C4                
14C4                ;-642     if (Op == MEM) {
14C4                
14C4                .writeEA111:
14C4 A0 2D 01        mov al, [Op]
14C7 3C 04           cmp al, 4
14C9 0F 85 00 00   r jne .writeEA116
14CD                
14CD                ;-643         if (isDirect) {
14CD                
14CD A0 3C 01        mov al, [isDirect]
14D0 08 C0           or  al, al
14D2 0F 84 00 00   r je .writeEA117
14D6                
14D6                ;-644             xxx |= 6;
14D6                
14D6 80 4E 04 06     or  byte[bp+4], 6
14DA                
14DA                ;-645             len = 2;
14DA                
14DA B8 02 00        mov ax, 2
14DD 88 46 FE        mov [bp-2], al
14E0                
14E0                ;-646         }
14E0                
14E0                
14E0                ;-647         else {
14E0                
14E0 E9 00 00      R jmp .writeEA118
14E3                .writeEA117:
14E3                
14E3                ;-648             xxx = xxx + rm;
14E3                
14E3 8A 46 04        mov al, [bp+4]
14E6 02 06 3B 01     add al, [rm]
14EA 88 46 04        mov [bp+4], al
14ED                
14ED                ;-649             if (rm == 6) {//make [BP+00]
14ED                
14ED A0 3B 01        mov al, [rm]
14F0 3C 06           cmp al, 6
14F2 0F 85 00 00   r jne .writeEA119
14F6                
14F6                ;-650                 len=1;
14F6                
14F6 B8 01 00        mov ax, 1
14F9 88 46 FE        mov [bp-2], al
14FC                
14FC                ;-651                 if (disp == 0) xxx |= 0x40;
14FC                
14FC A1 3D 01        mov ax, [disp]
14FF 83 F8 00        cmp ax, 0
1502 0F 85 00 00   r jne .writeEA120
1506 80 4E 04 40     or  byte[bp+4], 64
150A                
150A                ;-652             }
150A                
150A                .writeEA120:
150A                
150A                ;-653 
150A                
150A                
150A                ;-654             if (disp) {  
150A                
150A                .writeEA119:
150A A1 3D 01        mov ax, [disp]
150D 08 C0           or  al, al
150F 0F 84 00 00   r je .writeEA121
1513                
1513                ;-655                 ax = disp;
1513                
1513 A1 3D 01        mov  ax, [disp]
1516                
1516                ;-656                 if (ax < 0) __asm{ neg ax }
1516                
1516 83 F8 00        cmp  ax, 0
1519 0F 8D 00 00   r jge .writeEA122
151D F7 D8           neg ax 
151F                
151F                ;-657                 if (ax > 127) len=2;
151F                
151F                .writeEA122:
151F 83 F8 7F        cmp  ax, 127
1522 0F 8E 00 00   r jle .writeEA123
1526 B8 02 00        mov ax, 2
1529 88 46 FE        mov [bp-2], al
152C                
152C                ;-658                 else len=1;
152C                
152C E9 00 00      R jmp .writeEA124
152F                .writeEA123:
152F B8 01 00        mov ax, 1
1532 88 46 FE        mov [bp-2], al
1535                
1535                ;-659                 if (len == 1) xxx |= 0x40;
1535                
1535                .writeEA124:
1535 8A 46 FE        mov al, [bp-2]
1538 3C 01           cmp al, 1
153A 0F 85 00 00   r jne .writeEA125
153E 80 4E 04 40     or  byte[bp+4], 64
1542                
1542                ;-660                 else xxx |= 0x80;
1542                
1542 E9 00 00      R jmp .writeEA126
1545                .writeEA125:
1545 80 4E 04 80     or  byte[bp+4], 128
1549                
1549                ;-661             }
1549                
1549                .writeEA126:
1549                
1549                ;-662         }
1549                
1549                .writeEA121:
1549                
1549                ;-663     }
1549                
1549                .writeEA118:
1549                
1549                ;-664 
1549                
1549                
1549                ;-665     genCode8(xxx);// gen second byte
1549                
1549                .writeEA116:
1549 8A 46 04        mov al, byte [bp+4]
154C B4 00           mov ah, 0
154E 50              push ax
154F E8 3A FE        call genCode8
1552 83 C4 02        add  sp, 2
1555                
1555                ;-666     if (len == 1) genCode8 (disp);
1555                
1555 8A 46 FE        mov al, [bp-2]
1558 3C 01           cmp al, 1
155A 0F 85 00 00   r jne .writeEA127
155E FF 36 3D 01     push word [disp]
1562 E8 27 FE        call genCode8
1565 83 C4 02        add  sp, 2
1568                
1568                ;-667     if (len == 2) genCode16(disp);
1568                
1568                .writeEA127:
1568 8A 46 FE        mov al, [bp-2]
156B 3C 02           cmp al, 2
156D 0F 85 00 00   r jne .writeEA128
1571 FF 36 3D 01     push word [disp]
1575 E8 AB FE        call genCode16
1578 83 C4 02        add  sp, 2
157B                
157B                ;-668 }
157B                
157B                .writeEA128:
157B                
157B                ;-669 
157B                
157B                
157B                ;-670 int genImmediate() {
157B C9              LEAVE
157C C3              ret
leaving: writeEA, loc labels: 18, loc jmp forward: 18
157D                ENDP
157D                
entering: genImmediate
157D                genImmediate: PROC
157D                
157D                ;-671     if (wflag) if (OpSize == DWORD) genCode32(imme);
157D                
157D A0 38 01        mov al, [wflag]
1580 08 C0           or  al, al
1582 0F 84 00 00   r je .genImmediate129
1586 A0 37 01        mov al, [OpSize]
1589 3C 03           cmp al, 3
158B 0F 85 00 00   r jne .genImmediate130
158F FF 36 3F 01     push word [imme]
1593 E8 AE FE        call genCode32
1596 83 C4 02        add  sp, 2
1599                
1599                ;-672         //todo imme long
1599                
1599                
1599                ;-673         else genCode16(imme);
1599                
1599 E9 00 00      R jmp .genImmediate131
159C                .genImmediate130:
159C FF 36 3F 01     push word [imme]
15A0 E8 80 FE        call genCode16
15A3 83 C4 02        add  sp, 2
15A6                
15A6                ;-674     else       genCode8 (imme);
15A6                
15A6                .genImmediate131:
15A6 E9 00 00      R jmp .genImmediate132
15A9                .genImmediate129:
15A9 FF 36 3F 01     push word [imme]
15AD E8 DC FD        call genCode8
15B0 83 C4 02        add  sp, 2
15B3                
15B3                ;-675 }
15B3                
15B3                .genImmediate132:
15B3                
15B3                ;-676 
15B3                
15B3                
15B3                ;-677 int setwflag() {//word size, bit 0
15B3                
15B3 C3              ret
leaving: genImmediate, loc labels: 4, loc jmp forward: 4
15B4                ENDP
15B4                
entering: setwflag
15B4                setwflag: PROC
15B4                
15B4                ;-678     wflag=0;
15B4                
15B4 B8 00 00        mov ax, 0
15B7 A2 38 01        mov byte [wflag], al
15BA                
15BA                ;-679     if (OpSize == 0) {//do not override OpSize
15BA                
15BA A0 37 01        mov al, [OpSize]
15BD 3C 00           cmp al, 0
15BF 0F 85 00 00   r jne .setwflag133
15C3                
15C3                ;-680         if (Op == REG) OpSize=R1Type;
15C3                
15C3 A0 2D 01        mov al, [Op]
15C6 3C 02           cmp al, 2
15C8 0F 85 00 00   r jne .setwflag134
15CC A0 36 01        mov al, [R1Type]
15CF A2 37 01        mov byte [OpSize], al
15D2                
15D2                ;-681         if (Op2== REG) OpSize=R2Type;
15D2                
15D2                .setwflag134:
15D2 A0 2E 01        mov al, [Op2]
15D5 3C 02           cmp al, 2
15D7 0F 85 00 00   r jne .setwflag135
15DB A0 35 01        mov al, [R2Type]
15DE A2 37 01        mov byte [OpSize], al
15E1                
15E1                ;-682         if (R2Type== SEGREG) OpSize=WORD;
15E1                
15E1                .setwflag135:
15E1 A0 35 01        mov al, [R2Type]
15E4 3C 04           cmp al, 4
15E6 0F 85 00 00   r jne .setwflag136
15EA B8 02 00        mov ax, 2
15ED A2 37 01        mov byte [OpSize], al
15F0                
15F0                ;-683         if (R1Type == SEGREG) OpSize=WORD;
15F0                
15F0                .setwflag136:
15F0 A0 36 01        mov al, [R1Type]
15F3 3C 04           cmp al, 4
15F5 0F 85 00 00   r jne .setwflag137
15F9 B8 02 00        mov ax, 2
15FC A2 37 01        mov byte [OpSize], al
15FF                
15FF                ;-684     }
15FF                
15FF                .setwflag137:
15FF                
15FF                ;-685     if (OpSize  == DWORD) {gen66h(); wflag=1;}
15FF                
15FF                .setwflag133:
15FF A0 37 01        mov al, [OpSize]
1602 3C 03           cmp al, 3
1604 0F 85 00 00   r jne .setwflag138
1608 E8 D8 FD        call gen66h
160B B8 01 00        mov ax, 1
160E A2 38 01        mov byte [wflag], al
1611                
1611                ;-686     if (OpSize  ==  WORD) wflag=1;
1611                
1611                .setwflag138:
1611 A0 37 01        mov al, [OpSize]
1614 3C 02           cmp al, 2
1616 0F 85 00 00   r jne .setwflag139
161A B8 01 00        mov ax, 1
161D A2 38 01        mov byte [wflag], al
1620                
1620                ;-687 }
1620                
1620                .setwflag139:
1620                
1620                ;-688 int setsflag() {//sign-extend, bit 1, only PUSH, ALU, IMUL3
1620                
1620 C3              ret
leaving: setwflag, loc labels: 7, loc jmp forward: 7
1621                ENDP
1621                
entering: setsflag
1621                setsflag: PROC
1621                
1621                ;-689     unsigned int ui;
1621                
1621                
1621                ;-690     sflag=2;
1621                
1621                ;Function : setsflag, Number of local variables: 1
1621                ;   # type sign width addr used name   list of local variables
1621                ;  200 var unsg word   689 NULL ui = bp-2;
1621 C8 02 00 00     ENTER  2,0
1625 B8 02 00        mov ax, 2
1628 A2 3A 01        mov byte [sflag], al
162B                
162B                ;-691     ui = imme & 0xFF80;//is greater than signed 127?
162B                
162B A1 3F 01        mov ax, [imme]
162E 25 80 FF        and ax, 65408
1631 89 46 FE        mov [bp-2], ax
1634                
1634                ;-692     if(ui != 0) sflag = 0;
1634                
1634 8B 46 FE        mov ax, [bp-2]
1637 83 F8 00        cmp ax, 0
163A 0F 84 00 00   r je  .setsflag140
163E B8 00 00        mov ax, 0
1641 A2 3A 01        mov byte [sflag], al
1644                
1644                ;-693     if (OpSize == BYTE) {
1644                
1644                .setsflag140:
1644 A0 37 01        mov al, [OpSize]
1647 3C 01           cmp al, 1
1649 0F 85 00 00   r jne .setsflag141
164D                
164D                ;-694         if (imme > 255) error1("too big for byte r/m");
164D                
164D A1 3F 01        mov ax, [imme]
1650 3D FF 00        cmp ax, 255
1653 0F 8E 00 00   r jle .setsflag142
1657 68 AA AA      A push setsflag_0
165A E8 ED F3        call error1
165D 83 C4 02        add  sp, 2
1660                
1660                ;-695         sflag=0;//byte reg does not need sign extended
1660                
1660                .setsflag142:
1660 B8 00 00        mov ax, 0
1663 A2 3A 01        mov byte [sflag], al
1666                
1666                ;-696     }
1666                
1666                
1666                ;-697 }
1666                
1666                .setsflag141:
1666                
1666                ;-698 int checkConstSize(unsigned int ui) {
1666 C9              LEAVE
1667 C3              ret
1668 74 6F 6F 20 62 setsflag_0 db "too big for byte r/m",0
leaving: setsflag, loc labels: 4, loc jmp forward: 4
167D                ENDP
167D                
entering: checkConstSize
167D                checkConstSize: PROC
167D                
167D                ;-699     if (ui > 127   ) return 0;//is near; return sflag
167D                
167D                ;Function : checkConstSize, Number of local variables: 1
167D                ;   # type sign width addr used name   list of local variables
167D                ;  200 var unsg word   698 NULL ui = bp+4;
167D C8 00 00 00     ENTER  0,0
1681 8B 46 04        mov ax, [bp+4]
1684 83 F8 7F        cmp ax, 127
1687 0F 8E 00 00   r jle .checkConstSize143
168B B8 00 00        mov ax, 0
168E E9 00 00      R jmp .retncheckConstSize
1691                
1691                ;-700     if (ui < 0xFF80) return 0;//-128dez
1691                
1691                .checkConstSize143:
1691 8B 46 04        mov ax, [bp+4]
1694 3D 80 FF        cmp ax, 65408
1697 0F 8D 00 00   r jge .checkConstSize144
169B B8 00 00        mov ax, 0
169E E9 00 00      R jmp .retncheckConstSize
16A1                
16A1                ;-701     return 2;// is short
16A1                
16A1                .checkConstSize144:
16A1 B8 02 00        mov ax, 2
16A4 E9 00 00      R jmp .retncheckConstSize
16A7                
16A7                ;-702 }
16A7                
16A7                
16A7                ;-703 
16A7                
16A7                
16A7                ;-704 
16A7                
16A7                
16A7                ;-705 int ChangeDirection() {
16A7                
16A7 C9              .retncheckConstSize: LEAVE
16A8 C3              ret
leaving: checkConstSize, loc labels: 3, loc jmp forward: 5
16A9                ENDP
16A9                
entering: ChangeDirection
16A9                ChangeDirection: PROC
16A9                
16A9                ;-706     char c;
16A9                
16A9                
16A9                ;-707     c=Op;     Op    =Op2;    Op2   =c;
16A9                
16A9                ;Function : ChangeDirection, Number of local variables: 1
16A9                ;   # type sign width addr used name   list of local variables
16A9                ;  200 var sign byte   706 NULL c = bp-2;
16A9 C8 02 00 00     ENTER  2,0
16AD A0 2D 01        mov al, [Op]
16B0 88 46 FE        mov [bp-2], al
16B3 A0 2E 01        mov al, [Op2]
16B6 A2 2D 01        mov byte [Op], al
16B9 8A 46 FE        mov al, [bp-2]
16BC A2 2E 01        mov byte [Op2], al
16BF                
16BF                ;-708     c=R1Type; R1Type=R2Type; R2Type=c;
16BF                
16BF A0 36 01        mov al, [R1Type]
16C2 88 46 FE        mov [bp-2], al
16C5 A0 35 01        mov al, [R2Type]
16C8 A2 36 01        mov byte [R1Type], al
16CB 8A 46 FE        mov al, [bp-2]
16CE A2 35 01        mov byte [R2Type], al
16D1                
16D1                ;-709     c=R1No;   R1No  =R2No;   R2No  =c;
16D1                
16D1 A0 34 01        mov al, [R1No]
16D4 88 46 FE        mov [bp-2], al
16D7 A0 33 01        mov al, [R2No]
16DA A2 34 01        mov byte [R1No], al
16DD 8A 46 FE        mov al, [bp-2]
16E0 A2 33 01        mov byte [R2No], al
16E3                
16E3                ;-710     dflag=2;
16E3                
16E3 B8 02 00        mov ax, 2
16E6 A2 39 01        mov byte [dflag], al
16E9                
16E9                ;-711 }
16E9                
16E9                
16E9                ;-712 
16E9                
16E9                
16E9                ;-713 int getTokeType() {
16E9 C9              LEAVE
16EA C3              ret
leaving: ChangeDirection, loc labels: 0, loc jmp forward: 0
16EB                ENDP
16EB                
entering: getTokeType
16EB                getTokeType: PROC
16EB                
16EB                ;-714     char c;
16EB                
16EB                
16EB                ;-715     skipBlank();
16EB                
16EB                ;Function : getTokeType, Number of local variables: 1
16EB                ;   # type sign width addr used name   list of local variables
16EB                ;  200 var sign byte   714 NULL c = bp-2;
16EB C8 02 00 00     ENTER  2,0
16EF E8 ED F6        call skipBlank
16F2                
16F2                ;-716     c = *InputPtr;
16F2                
16F2 8B 1E 14 01     mov bx, [InputPtr]
16F6 8A 07           mov al, [bx]
16F8 B4 00           mov ah, 0
16FA 88 46 FE        mov [bp-2], al
16FD                
16FD                ;-717     if (c == 0)   {TokeType=0; return; }//last line or empty line
16FD                
16FD 8A 46 FE        mov al, [bp-2]
1700 3C 00           cmp al, 0
1702 0F 85 00 00   r jne .getTokeType145
1706 B8 00 00        mov ax, 0
1709 A2 2C 01        mov byte [TokeType], al
170C E9 00 00      R jmp .retngetTokeType
170F                
170F                ;-718     if (c == ';') {TokeType=0; return; }//comment
170F                
170F                .getTokeType145:
170F 8A 46 FE        mov al, [bp-2]
1712 3C 3B           cmp al, 59
1714 0F 85 00 00   r jne .getTokeType146
1718 B8 00 00        mov ax, 0
171B A2 2C 01        mov byte [TokeType], al
171E E9 00 00      R jmp .retngetTokeType
1721                
1721                ;-719     if (digit(c)) {getDigit(c); TokeType=DIGIT; return;}//ret:1=SymbolInt
1721                
1721                .getTokeType146:
1721 8A 46 FE        mov al, byte [bp-2]
1724 B4 00           mov ah, 0
1726 50              push ax
1727 E8 72 EA        call digit
172A 83 C4 02        add  sp, 2
172D 08 C0           or  al, al
172F 0F 84 00 00   r je .getTokeType147
1733 8A 46 FE        mov al, byte [bp-2]
1736 B4 00           mov ah, 0
1738 50              push ax
1739 E8 CE F6        call getDigit
173C 83 C4 02        add  sp, 2
173F B8 01 00        mov ax, 1
1742 A2 2C 01        mov byte [TokeType], al
1745 E9 00 00      R jmp .retngetTokeType
1748                
1748                ;-720     if (letterE (c)) {getName(c); TokeType=ALNUME; return;}//ret:2=Symbol
1748                
1748                .getTokeType147:
1748 8A 46 FE        mov al, byte [bp-2]
174B B4 00           mov ah, 0
174D 50              push ax
174E E8 CD E9        call letterE
1751 83 C4 02        add  sp, 2
1754 08 C0           or  al, al
1756 0F 84 00 00   r je .getTokeType148
175A 8A 46 FE        mov al, byte [bp-2]
175D B4 00           mov ah, 0
175F 50              push ax
1760 E8 F7 F6        call getName
1763 83 C4 02        add  sp, 2
1766 B8 03 00        mov ax, 3
1769 A2 2C 01        mov byte [TokeType], al
176C E9 00 00      R jmp .retngetTokeType
176F                
176F                ;-721     TokeType=NOALNUME;
176F                
176F                .getTokeType148:
176F B8 04 00        mov ax, 4
1772 A2 2C 01        mov byte [TokeType], al
1775                
1775                ;-722 }
1775                
1775                
1775                ;-723 
1775                
1775                
1775                ;-724 int isToken(char c) {
1775                
1775 C9              .retngetTokeType: LEAVE
1776 C3              ret
leaving: getTokeType, loc labels: 5, loc jmp forward: 8
1777                ENDP
1777                
entering: isToken
1777                isToken: PROC
1777                
1777                ;-725     skipBlank();
1777                
1777                ;Function : isToken, Number of local variables: 1
1777                ;   # type sign width addr used name   list of local variables
1777                ;  200 var sign byte   724 NULL c = bp+4;
1777 C8 00 00 00     ENTER  0,0
177B E8 61 F6        call skipBlank
177E                
177E                ;-726     if (*InputPtr == c) {
177E                
177E 8B 1E 14 01     mov bx, [InputPtr]
1782 8A 07           mov al, [bx]
1784 B4 00           mov ah, 0
1786 3A 46 04        cmp al, [bp+4]
1789 0F 85 00 00   r jne .isToken149
178D                
178D                ;-727         InputPtr++;
178D                
178D FF 06 14 01     inc  word[InputPtr]
1791                
1791                ;-728         return 1;
1791                
1791 B8 01 00        mov ax, 1
1794 E9 00 00      R jmp .retnisToken
1797                
1797                ;-729         }
1797                
1797                
1797                ;-730     return 0;
1797                
1797                .isToken149:
1797 B8 00 00        mov ax, 0
179A E9 00 00      R jmp .retnisToken
179D                
179D                ;-731 }
179D                
179D                
179D                ;-732 
179D                
179D                
179D                ;-733 
179D                
179D                
179D                ;-734 int need(char c) {
179D                
179D C9              .retnisToken: LEAVE
179E C3              ret
leaving: isToken, loc labels: 2, loc jmp forward: 3
179F                ENDP
179F                
entering: need
179F                need: PROC
179F                
179F                ;-735     if (isToken(c)) {
179F                
179F                ;Function : need, Number of local variables: 1
179F                ;   # type sign width addr used name   list of local variables
179F                ;  200 var sign byte   734 NULL c = bp+4;
179F C8 00 00 00     ENTER  0,0
17A3 8A 46 04        mov al, byte [bp+4]
17A6 B4 00           mov ah, 0
17A8 50              push ax
17A9 E8 CB FF        call isToken
17AC 83 C4 02        add  sp, 2
17AF 08 C0           or  al, al
17B1 0F 84 00 00   r je .need150
17B5                
17B5                ;-736         getTokeType();
17B5                
17B5 E8 33 FF        call getTokeType
17B8                
17B8                ;-737         return;
17B8                
17B8 E9 00 00      R jmp .retnneed
17BB                
17BB                ;-738         }
17BB                
17BB                
17BB                ;-739     error1();
17BB                
17BB                .need150:
17BB E8 8C F2        call error1
17BE                
17BE                ;-740     prs(". need: ");
17BE                
17BE 68 AA AA      A push need_0
17C1 E8 6F EF        call prs
17C4 83 C4 02        add  sp, 2
17C7                
17C7                ;-741     prc(c);
17C7                
17C7 8A 46 04        mov al, byte [bp+4]
17CA B4 00           mov ah, 0
17CC 50              push ax
17CD E8 0B EF        call prc
17D0 83 C4 02        add  sp, 2
17D3                
17D3                ;-742 }
17D3                
17D3                
17D3                ;-743 int skipRest() {
17D3                
17D3 C9              .retnneed: LEAVE
17D4 C3              ret
17D5 2E 20 6E 65 65 need_0 db ". need: ",0
leaving: need, loc labels: 3, loc jmp forward: 3
17DE                ENDP
17DE                
entering: skipRest
17DE                skipRest: PROC
17DE                
17DE                ;-744     getTokeType();
17DE                
17DE E8 0A FF        call getTokeType
17E1                
17E1                ;-745     if(TokeType)error1("extra char ignored");
17E1                
17E1 A0 2C 01        mov al, [TokeType]
17E4 08 C0           or  al, al
17E6 0F 84 00 00   r je .skipRest151
17EA 68 AA AA      A push skipRest_0
17ED E8 5A F2        call error1
17F0 83 C4 02        add  sp, 2
17F3                
17F3                ;-746 }
17F3                
17F3                .skipRest151:
17F3                
17F3                ;-747 
17F3                
17F3                
17F3                ;-748 
17F3                
17F3                
17F3                ;-749 int checkOpL() {
17F3                
17F3 C3              ret
17F4 65 78 74 72 61 skipRest_0 db "extra char ignored",0
leaving: skipRest, loc labels: 2, loc jmp forward: 2
1807                ENDP
1807                
entering: checkOpL
1807                checkOpL: PROC
1807                
1807                ;-750     if (Op == ADR) implerror();
1807                
1807 A0 2D 01        mov al, [Op]
180A 3C 03           cmp al, 3
180C 0F 85 00 00   r jne .checkOpL152
1810 E8 49 F3        call implerror
1813                
1813                ;-751     if (R1Type==SEGREG) {segregerror();return;}//only move,push,pop
1813                
1813                .checkOpL152:
1813 A0 36 01        mov al, [R1Type]
1816 3C 04           cmp al, 4
1818 0F 85 00 00   r jne .checkOpL153
181C E8 05 F4        call segregerror
181F E9 00 00      R jmp .retncheckOpL
1822                
1822                ;-752     setwflag();
1822                
1822                .checkOpL153:
1822 E8 8F FD        call setwflag
1825                
1825                ;-753     if (OpSize == 0) error1("no op size declared");
1825                
1825 A0 37 01        mov al, [OpSize]
1828 3C 00           cmp al, 0
182A 0F 85 00 00   r jne .checkOpL154
182E 68 AA AA      A push checkOpL_0
1831 E8 16 F2        call error1
1834 83 C4 02        add  sp, 2
1837                
1837                ;-754     if (OpSize == R1Type) return;
1837                
1837                .checkOpL154:
1837 A0 37 01        mov al, [OpSize]
183A 3A 06 36 01     cmp al, [R1Type]
183E 0F 85 00 00   r jne .checkOpL155
1842 E9 00 00      R jmp .retncheckOpL
1845                
1845                ;-755     if (Op == REG) if (R1Type==0) error1("no register defined");
1845                
1845                .checkOpL155:
1845 A0 2D 01        mov al, [Op]
1848 3C 02           cmp al, 2
184A 0F 85 00 00   r jne .checkOpL156
184E A0 36 01        mov al, [R1Type]
1851 3C 00           cmp al, 0
1853 0F 85 00 00   r jne .checkOpL157
1857 68 AA AA      A push checkOpL_1
185A E8 ED F1        call error1
185D 83 C4 02        add  sp, 2
1860                
1860                ;-756 }
1860                
1860                .checkOpL157:
1860                .checkOpL156:
1860                
1860                ;-757 
1860                
1860                
1860                ;-758 int searchLabel() {
1860                
1860                 .retncheckOpL:
1860 C3              ret
1861 6E 6F 20 6F 70 checkOpL_0 db "no op size declared",0
1875 6E 6F 20 72 65 checkOpL_1 db "no register defined",0
leaving: checkOpL, loc labels: 9, loc jmp forward: 10
1889                ENDP
1889                
entering: searchLabel
1889                searchLabel: PROC
1889                
1889                ;-759     int LIx; char *p;
1889                
1889                
1889                ;-760     p = &LabelNames;
1889                
1889                ;Function : searchLabel, Number of local variables: 2
1889                ;   # type sign width addr used name   list of local variables
1889                ;  200 var sign word   759 NULL LIx = bp-2
1889                ;  201 ptr sign byte   759 NULL p = bp-4;
1889 C8 04 00 00     ENTER  4,0
188D B8 5A 77        mov ax, LabelNames
1890 89 46 FC        mov [bp-4], ax
1893                
1893                ;-761     LIx = 1;
1893                
1893 B8 01 00        mov ax, 1
1896 89 46 FE        mov [bp-2], ax
1899                
1899                ;-762     while (LIx <= LabelMaxIx) {
1899                
1899                .searchLabel158:
1899 8B 46 FE        mov ax, [bp-2]
189C 3B 06 4A 01     cmp ax, [LabelMaxIx]
18A0 0F 8F 00 00   r jg  .searchLabel159
18A4                
18A4                ;-763         if (eqstr(p, Symbol)) return LIx;//pos of label
18A4                
18A4 8D 06 30 75     lea  ax, [Symbol]
18A8 50              push ax
18A9 FF 76 FC        push word [bp-4]
18AC E8 B1 E9        call eqstr
18AF 83 C4 04        add  sp, 4
18B2 08 C0           or  al, al
18B4 0F 84 00 00   r je .searchLabel160
18B8 8B 46 FE        mov ax, [bp-2]
18BB E9 00 00      R jmp .retnsearchLabel
18BE                
18BE                ;-764         p=strlen(p) + p;
18BE                
18BE                .searchLabel160:
18BE FF 76 FC        push word [bp-4]
18C1 E8 3E E9        call strlen
18C4 83 C4 02        add  sp, 2
18C7 03 46 FC        add ax, [bp-4]
18CA 89 46 FC        mov [bp-4], ax
18CD                
18CD                ;-765         p++;
18CD                
18CD FF 46 FC        inc  word[bp-4]
18D0                
18D0                ;-766         LIx++;
18D0                
18D0 FF 46 FE        inc  word[bp-2]
18D3                
18D3                ;-767     }
18D3                
18D3                
18D3                ;-768     return 0;
18D3                
18D3 EB C4           jmp .searchLabel158
18D5                .searchLabel159:
18D5 B8 00 00        mov ax, 0
18D8 E9 00 00      R jmp .retnsearchLabel
18DB                
18DB                ;-769 }
18DB                
18DB                
18DB                ;-770 
18DB                
18DB                
18DB                ;-771 int getOp1() {//scan for a single operand
18DB                
18DB C9              .retnsearchLabel: LEAVE
18DC C3              ret
leaving: searchLabel, loc labels: 4, loc jmp forward: 4
18DD                ENDP
18DD                
entering: getOp1
18DD                getOp1: PROC
18DD                
18DD                ;-772 //return:0, IMM, REG, ADR (not MEM)
18DD                
18DD                
18DD                ;-773 //set   :R2Type, R2No by testReg
18DD                
18DD                
18DD                ;-774 //set   :LabelIx by searchLabel
18DD                
18DD                
18DD                ;-775     if (TokeType == 0)      return 0;
18DD                
18DD A0 2C 01        mov al, [TokeType]
18E0 3C 00           cmp al, 0
18E2 0F 85 00 00   r jne .getOp1161
18E6 B8 00 00        mov ax, 0
18E9 E9 00 00      R jmp .retngetOp1
18EC                
18EC                ;-776     if (TokeType == DIGIT)  return IMM;
18EC                
18EC                .getOp1161:
18EC A0 2C 01        mov al, [TokeType]
18EF 3C 01           cmp al, 1
18F1 0F 85 00 00   r jne .getOp1162
18F5 B8 01 00        mov ax, 1
18F8 E9 00 00      R jmp .retngetOp1
18FB                
18FB                ;-777     if (TokeType == ALNUME) {
18FB                
18FB                .getOp1162:
18FB A0 2C 01        mov al, [TokeType]
18FE 3C 03           cmp al, 3
1900 0F 85 00 00   r jne .getOp1163
1904                
1904                ;-778         R2No=testReg();
1904                
1904 E8 0D EA        call testReg
1907 A2 33 01        mov byte [R2No], al
190A                
190A                ;-779         if (R2Type)        return REG;
190A                
190A A0 35 01        mov al, [R2Type]
190D 08 C0           or  al, al
190F 0F 84 00 00   r je .getOp1164
1913 B8 02 00        mov ax, 2
1916 E9 00 00      R jmp .retngetOp1
1919                
1919                ;-780         LabelIx=searchLabel();
1919                
1919                .getOp1164:
1919 E8 6D FF        call searchLabel
191C A3 4E 01        mov word [LabelIx], ax
191F                
191F                ;-781         return ADR;
191F                
191F B8 03 00        mov ax, 3
1922 E9 00 00      R jmp .retngetOp1
1925                
1925                ;-782     }
1925                
1925                
1925                ;-783     return 0;
1925                
1925                .getOp1163:
1925 B8 00 00        mov ax, 0
1928 E9 00 00      R jmp .retngetOp1
192B                
192B                ;-784 }
192B                
192B                
192B                ;-785 
192B                
192B                
192B                ;-786 int getIndReg1() {
192B                
192B                 .retngetOp1:
192B C3              ret
leaving: getOp1, loc labels: 5, loc jmp forward: 9
192C                ENDP
192C                
entering: getIndReg1
192C                getIndReg1: PROC
192C                
192C                ;-787     if (R2Type !=WORD) indexerror();
192C                
192C A0 35 01        mov al, [R2Type]
192F 3C 02           cmp al, 2
1931 0F 84 00 00   r je  .getIndReg1165
1935 E8 3E F2        call indexerror
1938                
1938                ;-788     if (R2No==3) rm=7;//BX
1938                
1938                .getIndReg1165:
1938 A0 33 01        mov al, [R2No]
193B 3C 03           cmp al, 3
193D 0F 85 00 00   r jne .getIndReg1166
1941 B8 07 00        mov ax, 7
1944 A2 3B 01        mov byte [rm], al
1947                
1947                ;-789     if (R2No==5) rm=6;//BP, change to BP+0
1947                
1947                .getIndReg1166:
1947 A0 33 01        mov al, [R2No]
194A 3C 05           cmp al, 5
194C 0F 85 00 00   r jne .getIndReg1167
1950 B8 06 00        mov ax, 6
1953 A2 3B 01        mov byte [rm], al
1956                
1956                ;-790     if (R2No==7) rm=5;//DI
1956                
1956                .getIndReg1167:
1956 A0 33 01        mov al, [R2No]
1959 3C 07           cmp al, 7
195B 0F 85 00 00   r jne .getIndReg1168
195F B8 05 00        mov ax, 5
1962 A2 3B 01        mov byte [rm], al
1965                
1965                ;-791     if (R2No==6) rm=4;//SI
1965                
1965                .getIndReg1168:
1965 A0 33 01        mov al, [R2No]
1968 3C 06           cmp al, 6
196A 0F 85 00 00   r jne .getIndReg1169
196E B8 04 00        mov ax, 4
1971 A2 3B 01        mov byte [rm], al
1974                
1974                ;-792     if (rm==0) indexerror();
1974                
1974                .getIndReg1169:
1974 A0 3B 01        mov al, [rm]
1977 3C 00           cmp al, 0
1979 0F 85 00 00   r jne .getIndReg1170
197D E8 F6 F1        call indexerror
1980                
1980                ;-793 }
1980                
1980                .getIndReg1170:
1980                
1980                ;-794 int getIndReg2() {char m; m=4;//because m=0 is BX+DI
1980                
1980 C3              ret
leaving: getIndReg1, loc labels: 6, loc jmp forward: 6
1981                ENDP
1981                
entering: getIndReg2
1981                getIndReg2: PROC
1981                ;Function : getIndReg2, Number of local variables: 1
1981                ;   # type sign width addr used name   list of local variables
1981                ;  200 var sign byte   794 NULL m = bp-2;
1981 C8 02 00 00     ENTER  2,0
1985 B8 04 00        mov ax, 4
1988 88 46 FE        mov [bp-2], al
198B                
198B                ;-795     if (R2Type !=WORD) indexerror();
198B                
198B A0 35 01        mov al, [R2Type]
198E 3C 02           cmp al, 2
1990 0F 84 00 00   r je  .getIndReg2171
1994 E8 DF F1        call indexerror
1997                
1997                ;-796     if (R2No==7) if (rm==6) m=3;//BP+DI
1997                
1997                .getIndReg2171:
1997 A0 33 01        mov al, [R2No]
199A 3C 07           cmp al, 7
199C 0F 85 00 00   r jne .getIndReg2172
19A0 A0 3B 01        mov al, [rm]
19A3 3C 06           cmp al, 6
19A5 0F 85 00 00   r jne .getIndReg2173
19A9 B8 03 00        mov ax, 3
19AC 88 46 FE        mov [bp-2], al
19AF                
19AF                ;-797              else if (rm==7) m=1;//BX+DI
19AF                
19AF E9 00 00      R jmp .getIndReg2174
19B2                .getIndReg2173:
19B2 A0 3B 01        mov al, [rm]
19B5 3C 07           cmp al, 7
19B7 0F 85 00 00   r jne .getIndReg2175
19BB B8 01 00        mov ax, 1
19BE 88 46 FE        mov [bp-2], al
19C1                
19C1                ;-798     if (R2No==6) if (rm==6) m=2;//BP+SI
19C1                
19C1                .getIndReg2175:
19C1                .getIndReg2174:
19C1                .getIndReg2172:
19C1 A0 33 01        mov al, [R2No]
19C4 3C 06           cmp al, 6
19C6 0F 85 00 00   r jne .getIndReg2176
19CA A0 3B 01        mov al, [rm]
19CD 3C 06           cmp al, 6
19CF 0F 85 00 00   r jne .getIndReg2177
19D3 B8 02 00        mov ax, 2
19D6 88 46 FE        mov [bp-2], al
19D9                
19D9                ;-799              else if (rm==7) m=0;//BX+SI
19D9                
19D9 E9 00 00      R jmp .getIndReg2178
19DC                .getIndReg2177:
19DC A0 3B 01        mov al, [rm]
19DF 3C 07           cmp al, 7
19E1 0F 85 00 00   r jne .getIndReg2179
19E5 B8 00 00        mov ax, 0
19E8 88 46 FE        mov [bp-2], al
19EB                
19EB                ;-800     if (m > 3) indexerror();
19EB                
19EB                .getIndReg2179:
19EB                .getIndReg2178:
19EB                .getIndReg2176:
19EB 8A 46 FE        mov al, [bp-2]
19EE 3C 03           cmp al, 3
19F0 0F 8E 00 00   r jle .getIndReg2180
19F4 E8 7F F1        call indexerror
19F7                
19F7                ;-801     return m;
19F7                
19F7                .getIndReg2180:
19F7 8A 46 FE        mov al, [bp-2]
19FA E9 00 00      R jmp .retngetIndReg2
19FD                
19FD                ;-802 }
19FD                
19FD                
19FD                ;-803 int getMEM() {// e.g. [array+bp+si-4]
19FD                
19FD C9              .retngetIndReg2: LEAVE
19FE C3              ret
leaving: getIndReg2, loc labels: 11, loc jmp forward: 11
19FF                ENDP
19FF                
entering: getMEM
19FF                getMEM: PROC
19FF                
19FF                ;-804 //set: disp, rm, R2Type
19FF                
19FF                
19FF                ;-805     char c;
19FF                
19FF                
19FF                ;-806     disp=0; rm=0;
19FF                
19FF                ;Function : getMEM, Number of local variables: 1
19FF                ;   # type sign width addr used name   list of local variables
19FF                ;  200 var sign byte   805 NULL c = bp-2;
19FF C8 02 00 00     ENTER  2,0
1A03 B8 00 00        mov ax, 0
1A06 A3 3D 01        mov word [disp], ax
1A09 B8 00 00        mov ax, 0
1A0C A2 3B 01        mov byte [rm], al
1A0F                
1A0F                ;-807     do {
1A0F                
1A0F                .getMEM181:
1A0F                
1A0F                ;-808         getTokeType();
1A0F                
1A0F E8 D9 FC        call getTokeType
1A12                
1A12                ;-809         c=getOp1();
1A12                
1A12 E8 C8 FE        call getOp1
1A15 88 46 FE        mov [bp-2], al
1A18                
1A18                ;-810         if (c ==   0) syntaxerror();
1A18                
1A18 8A 46 FE        mov al, [bp-2]
1A1B 3C 00           cmp al, 0
1A1D 0F 85 00 00   r jne .getMEM182
1A21 E8 27 F2        call syntaxerror
1A24                
1A24                ;-811         if (c == REG) {
1A24                
1A24                .getMEM182:
1A24 8A 46 FE        mov al, [bp-2]
1A27 3C 02           cmp al, 2
1A29 0F 85 00 00   r jne .getMEM183
1A2D                
1A2D                ;-812             isDirect=0;
1A2D                
1A2D B8 00 00        mov ax, 0
1A30 A2 3C 01        mov byte [isDirect], al
1A33                
1A33                ;-813             if (rm) rm=getIndReg2();
1A33                
1A33 A0 3B 01        mov al, [rm]
1A36 08 C0           or  al, al
1A38 0F 84 00 00   r je .getMEM184
1A3C E8 42 FF        call getIndReg2
1A3F A2 3B 01        mov byte [rm], al
1A42                
1A42                ;-814             else getIndReg1();
1A42                
1A42 E9 00 00      R jmp .getMEM185
1A45                .getMEM184:
1A45 E8 E4 FE        call getIndReg1
1A48                
1A48                ;-815         }
1A48                
1A48                .getMEM185:
1A48                
1A48                ;-816         if (c == ADR) {
1A48                
1A48                .getMEM183:
1A48 8A 46 FE        mov al, [bp-2]
1A4B 3C 03           cmp al, 3
1A4D 0F 85 00 00   r jne .getMEM186
1A51                
1A51                ;-817             if (LabelIx)    disp=disp+LabelAddr[LabelIx];
1A51                
1A51 A1 4E 01        mov ax, [LabelIx]
1A54 08 C0           or  al, al
1A56 0F 84 00 00   r je .getMEM187
1A5A A1 3D 01        mov ax, [disp]
1A5D 8B 1E 4E 01     mov bx, [LabelIx]
1A61 D1 E3           shl bx, 1
1A63 03 87 CA 8E     add ax, [LabelAddr + bx]
1A67 A3 3D 01        mov word [disp], ax
1A6A                
1A6A                ;-818             else notfounderror();
1A6A                
1A6A E9 00 00      R jmp .getMEM188
1A6D                .getMEM187:
1A6D E8 4B F0        call notfounderror
1A70                
1A70                ;-819         }
1A70                
1A70                .getMEM188:
1A70                
1A70                ;-820         if (c == IMM) disp=disp+SymbolInt;
1A70                
1A70                .getMEM186:
1A70 8A 46 FE        mov al, [bp-2]
1A73 3C 01           cmp al, 1
1A75 0F 85 00 00   r jne .getMEM189
1A79 A1 3D 01        mov ax, [disp]
1A7C 03 06 0E 01     add ax, [SymbolInt]
1A80 A3 3D 01        mov word [disp], ax
1A83                
1A83                ;-821         if (isToken('-')) {
1A83                
1A83                .getMEM189:
1A83 6A 2D           push 45
1A85 E8 EF FC        call isToken
1A88 83 C4 02        add  sp, 2
1A8B 08 C0           or  al, al
1A8D 0F 84 00 00   r je .getMEM190
1A91                
1A91                ;-822             getTokeType();
1A91                
1A91 E8 57 FC        call getTokeType
1A94                
1A94                ;-823             if (TokeType != DIGIT) numbererror();
1A94                
1A94 A0 2C 01        mov al, [TokeType]
1A97 3C 01           cmp al, 1
1A99 0F 84 00 00   r je  .getMEM191
1A9D E8 18 F1        call numbererror
1AA0                
1AA0                ;-824             disp = disp - SymbolInt;
1AA0                
1AA0                .getMEM191:
1AA0 A1 3D 01        mov ax, [disp]
1AA3 2B 06 0E 01     sub ax, [SymbolInt]
1AA7 A3 3D 01        mov word [disp], ax
1AAA                
1AAA                ;-825         }
1AAA                
1AAA                
1AAA                ;-826     } while (isToken('+'));
1AAA                
1AAA                .getMEM190:
1AAA 6A 2B           push 43
1AAC E8 C8 FC        call isToken
1AAF 83 C4 02        add  sp, 2
1AB2 08 C0           or  al, al
1AB4 0F 84 00 00   r je .getMEM192
1AB8 E9 54 FF        jmp .getMEM181
1ABB                .getMEM192:
1ABB                
1ABB                ;-827     if (isToken(']') == 0) errorexit("] expected");
1ABB                
1ABB 6A 5D           push 93
1ABD E8 B7 FC        call isToken
1AC0 83 C4 02        add  sp, 2
1AC3 83 F8 00        cmp ax, 0
1AC6 0F 85 00 00   r jne .getMEM193
1ACA 68 AA AA      A push getMEM_0
1ACD E8 D1 EF        call errorexit
1AD0 83 C4 02        add  sp, 2
1AD3                
1AD3                ;-828 }
1AD3                
1AD3                .getMEM193:
1AD3                
1AD3                ;-829 
1AD3                
1AD3                
1AD3                ;-830 int getOpR() {
1AD3 C9              LEAVE
1AD4 C3              ret
1AD5 5D 20 65 78 70 getMEM_0 db "] expected",0
leaving: getMEM, loc labels: 14, loc jmp forward: 13
1AE0                ENDP
1AE0                
entering: getOpR
1AE0                getOpR: PROC
1AE0                
1AE0                ;-831     Op2=getOp1();
1AE0                
1AE0 E8 FA FD        call getOp1
1AE3 A2 2E 01        mov byte [Op2], al
1AE6                
1AE6                ;-832     if (isToken('[')) {Op2 = MEM; getMEM();    return;}
1AE6                
1AE6 6A 5B           push 91
1AE8 E8 8C FC        call isToken
1AEB 83 C4 02        add  sp, 2
1AEE 08 C0           or  al, al
1AF0 0F 84 00 00   r je .getOpR194
1AF4 B8 04 00        mov ax, 4
1AF7 A2 2E 01        mov byte [Op2], al
1AFA E8 02 FF        call getMEM
1AFD E9 00 00      R jmp .retngetOpR
1B00                
1B00                ;-833     if (Op2 == 0)     {invaloperror();         return;}
1B00                
1B00                .getOpR194:
1B00 A0 2E 01        mov al, [Op2]
1B03 3C 00           cmp al, 0
1B05 0F 85 00 00   r jne .getOpR195
1B09 E8 8B F0        call invaloperror
1B0C E9 00 00      R jmp .retngetOpR
1B0F                
1B0F                ;-834     if (Op2 == IMM)   {imme=SymbolInt;         return;}
1B0F                
1B0F                .getOpR195:
1B0F A0 2E 01        mov al, [Op2]
1B12 3C 01           cmp al, 1
1B14 0F 85 00 00   r jne .getOpR196
1B18 A1 0E 01        mov ax, [SymbolInt]
1B1B A3 3F 01        mov word [imme], ax
1B1E E9 00 00      R jmp .retngetOpR
1B21                
1B21                ;-835     if (Op2 == REG)                            return;
1B21                
1B21                .getOpR196:
1B21 A0 2E 01        mov al, [Op2]
1B24 3C 02           cmp al, 2
1B26 0F 85 00 00   r jne .getOpR197
1B2A E9 00 00      R jmp .retngetOpR
1B2D                
1B2D                ;-836     if (Op2 == ADR)   {
1B2D                
1B2D                .getOpR197:
1B2D A0 2E 01        mov al, [Op2]
1B30 3C 03           cmp al, 3
1B32 0F 85 00 00   r jne .getOpR198
1B36                
1B36                ;-837         if (LabelIx == 0) disp=0;
1B36                
1B36 A1 4E 01        mov ax, [LabelIx]
1B39 83 F8 00        cmp ax, 0
1B3C 0F 85 00 00   r jne .getOpR199
1B40 B8 00 00        mov ax, 0
1B43 A3 3D 01        mov word [disp], ax
1B46                
1B46                ;-838         else disp=LabelAddr[LabelIx];
1B46                
1B46 E9 00 00      R jmp .getOpR200
1B49                .getOpR199:
1B49 8B 1E 4E 01     mov bx, [LabelIx]
1B4D D1 E3           shl bx, 1
1B4F 8B 87 CA 8E     mov ax, [LabelAddr + bx]
1B53 A3 3D 01        mov word [disp], ax
1B56                
1B56                ;-839         return;}
1B56                
1B56                .getOpR200:
1B56 E9 00 00      R jmp .retngetOpR
1B59                
1B59                ;-840     error1("Name of operand expected");
1B59                
1B59                .getOpR198:
1B59 68 AA AA      A push getOpR_0
1B5C E8 EB EE        call error1
1B5F 83 C4 02        add  sp, 2
1B62                
1B62                ;-841 }
1B62                
1B62                
1B62                ;-842 
1B62                
1B62                
1B62                ;-843 int getOpL() {//set: op=0,IMM,REG,ADR,MEM
1B62                
1B62                 .retngetOpR:
1B62 C3              ret
1B63 4E 61 6D 65 20 getOpR_0 db "Name of operand expected",0
leaving: getOpR, loc labels: 9, loc jmp forward: 13
1B7C                ENDP
1B7C                
entering: getOpL
1B7C                getOpL: PROC
1B7C                
1B7C                ;-844     getOpR();
1B7C                
1B7C E8 61 FF        call getOpR
1B7F                
1B7F                ;-845     Op=Op2;         Op2=0;
1B7F                
1B7F A0 2E 01        mov al, [Op2]
1B82 A2 2D 01        mov byte [Op], al
1B85 B8 00 00        mov ax, 0
1B88 A2 2E 01        mov byte [Op2], al
1B8B                
1B8B                ;-846     R1No=R2No;      R2No=0;
1B8B                
1B8B A0 33 01        mov al, [R2No]
1B8E A2 34 01        mov byte [R1No], al
1B91 B8 00 00        mov ax, 0
1B94 A2 33 01        mov byte [R2No], al
1B97                
1B97                ;-847     R1Type=R2Type;  R2Type=0;
1B97                
1B97 A0 35 01        mov al, [R2Type]
1B9A A2 36 01        mov byte [R1Type], al
1B9D B8 00 00        mov ax, 0
1BA0 A2 35 01        mov byte [R2Type], al
1BA3                
1BA3                ;-848 }
1BA3                
1BA3                
1BA3                ;-849 
1BA3                
1BA3                
1BA3                ;-850 int get2Ops() {
1BA3                
1BA3 C3              ret
leaving: getOpL, loc labels: 0, loc jmp forward: 0
1BA4                ENDP
1BA4                
entering: get2Ops
1BA4                get2Ops: PROC
1BA4                
1BA4                ;-851     getOpL();
1BA4                
1BA4 E8 D5 FF        call getOpL
1BA7                
1BA7                ;-852     need(',');
1BA7                
1BA7 6A 2C           push 44
1BA9 E8 F3 FB        call need
1BAC 83 C4 02        add  sp, 2
1BAF                
1BAF                ;-853     getOpR();
1BAF                
1BAF E8 2E FF        call getOpR
1BB2                
1BB2                ;-854 }
1BB2                
1BB2                
1BB2                ;-855 int check2Ops() {
1BB2                
1BB2 C3              ret
leaving: get2Ops, loc labels: 0, loc jmp forward: 0
1BB3                ENDP
1BB3                
entering: check2Ops
1BB3                check2Ops: PROC
1BB3                
1BB3                ;-856     get2Ops();
1BB3                
1BB3 E8 EE FF        call get2Ops
1BB6                
1BB6                ;-857     if (Op ==   0) addrerror();
1BB6                
1BB6 A0 2D 01        mov al, [Op]
1BB9 3C 00           cmp al, 0
1BBB 0F 85 00 00   r jne .check2Ops201
1BBF E8 5B EF        call addrerror
1BC2                
1BC2                ;-858     if (Op == ADR) invaloperror();
1BC2                
1BC2                .check2Ops201:
1BC2 A0 2D 01        mov al, [Op]
1BC5 3C 03           cmp al, 3
1BC7 0F 85 00 00   r jne .check2Ops202
1BCB E8 C9 EF        call invaloperror
1BCE                
1BCE                ;-859     if (Op == IMM) immeerror();
1BCE                
1BCE                .check2Ops202:
1BCE A0 2D 01        mov al, [Op]
1BD1 3C 01           cmp al, 1
1BD3 0F 85 00 00   r jne .check2Ops203
1BD7 E8 5D EF        call immeerror
1BDA                
1BDA                ;-860     if (Op2==   0) addrerror();
1BDA                
1BDA                .check2Ops203:
1BDA A0 2E 01        mov al, [Op2]
1BDD 3C 00           cmp al, 0
1BDF 0F 85 00 00   r jne .check2Ops204
1BE3 E8 37 EF        call addrerror
1BE6                
1BE6                ;-861 //if (CodeType != 5) if (Op2==ADR) invaloperror();//only mov,add
1BE6                
1BE6                
1BE6                ;-862     setwflag();
1BE6                
1BE6                .check2Ops204:
1BE6 E8 CB F9        call setwflag
1BE9                
1BE9                ;-863 }
1BE9                
1BE9                
1BE9                ;-864 
1BE9                
1BE9                
1BE9                ;-865 int storeJmp() {
1BE9                
1BE9 C3              ret
leaving: check2Ops, loc labels: 4, loc jmp forward: 4
1BEA                ENDP
1BEA                
entering: storeJmp
1BEA                storeJmp: PROC
1BEA                
1BEA                ;-866     unsigned int i;
1BEA                
1BEA                
1BEA                ;-867     JmpMaxIx++;
1BEA                
1BEA                ;Function : storeJmp, Number of local variables: 1
1BEA                ;   # type sign width addr used name   list of local variables
1BEA                ;  200 var unsg word   866 NULL i = bp-2;
1BEA C8 02 00 00     ENTER  2,0
1BEE FF 06 54 01     inc  word[JmpMaxIx]
1BF2                
1BF2                ;-868     if (JmpMaxIx >= JMPMAX) errorexit("too many Jmp");
1BF2                
1BF2 A1 54 01        mov ax, [JmpMaxIx]
1BF5 3D C8 00        cmp ax, 200 ;unsigned : 1
1BF8 0F 8C 00 00   r jl  .storeJmp205
1BFC 68 AA AA      A push storeJmp_0
1BFF E8 9F EE        call errorexit
1C02 83 C4 02        add  sp, 2
1C05                
1C05                ;-869     JmpNamePtr=strcpy(JmpNamePtr, Symbol);
1C05                
1C05                .storeJmp205:
1C05 8D 06 30 75     lea  ax, [Symbol]
1C09 50              push ax
1C0A FF 36 50 01     push word [JmpNamePtr]
1C0E E8 19 E6        call strcpy
1C11 83 C4 04        add  sp, 4
1C14 A3 50 01        mov word [JmpNamePtr], ax
1C17                
1C17                ;-870     JmpNamePtr++;
1C17                
1C17 FF 06 50 01     inc  word[JmpNamePtr]
1C1B                
1C1B                ;-871     i = JmpNamePtr - &JmpNames;
1C1B                
1C1B A1 50 01        mov ax, [JmpNamePtr]
1C1E 2D 7A 93        sub ax, JmpNames
1C21 89 46 FE        mov [bp-2], ax
1C24                
1C24                ;-872     if ( i >= JMPNAMESMAX) errorexit("too many Jmp names");
1C24                
1C24 8B 46 FE        mov ax, [bp-2]
1C27 3D 81 0F        cmp ax, 3969 ;unsigned : 0
1C2A 0F 82 00 00   r jb  .storeJmp206
1C2E 68 AA AA      A push storeJmp_1
1C31 E8 6D EE        call errorexit
1C34 83 C4 02        add  sp, 2
1C37                
1C37                ;-873     JmpAddr[JmpMaxIx] = PC;
1C37                
1C37                .storeJmp206:
1C37 A1 23 01        mov ax, [PC]
1C3A 8B 1E 54 01     mov bx, [JmpMaxIx]
1C3E D1 E3           shl bx, 1
1C40 89 87 1A A3     mov [JmpAddr+bx], ax
1C44                
1C44                ;-874 }
1C44                
1C44                
1C44                ;-875 
1C44                
1C44                
1C44                ;-876 int storeLabel() {
1C44 C9              LEAVE
1C45 C3              ret
1C46 74 6F 6F 20 6D storeJmp_0 db "too many Jmp",0
1C53 74 6F 6F 20 6D storeJmp_1 db "too many Jmp names",0
leaving: storeJmp, loc labels: 4, loc jmp forward: 4
1C66                ENDP
1C66                
entering: storeLabel
1C66                storeLabel: PROC
1C66                
1C66                ;-877     unsigned int i;
1C66                
1C66                
1C66                ;-878     if(searchLabel()) error1("duplicate label");
1C66                
1C66                ;Function : storeLabel, Number of local variables: 1
1C66                ;   # type sign width addr used name   list of local variables
1C66                ;  200 var unsg word   877 NULL i = bp-2;
1C66 C8 02 00 00     ENTER  2,0
1C6A E8 1C FC        call searchLabel
1C6D 08 C0           or  al, al
1C6F 0F 84 00 00   r je .storeLabel207
1C73 68 AA AA      A push storeLabel_0
1C76 E8 D1 ED        call error1
1C79 83 C4 02        add  sp, 2
1C7C                
1C7C                ;-879     LabelMaxIx++;
1C7C                
1C7C                .storeLabel207:
1C7C FF 06 4A 01     inc  word[LabelMaxIx]
1C80                
1C80                ;-880     if (LabelMaxIx >= LABELADRMAX) errorexit("too many labels");
1C80                
1C80 A1 4A 01        mov ax, [LabelMaxIx]
1C83 3D 58 02        cmp ax, 600 ;unsigned : 1
1C86 0F 8C 00 00   r jl  .storeLabel208
1C8A 68 AA AA      A push storeLabel_1
1C8D E8 11 EE        call errorexit
1C90 83 C4 02        add  sp, 2
1C93                
1C93                ;-881     LabelNamePtr=strcpy(LabelNamePtr, Symbol);
1C93                
1C93                .storeLabel208:
1C93 8D 06 30 75     lea  ax, [Symbol]
1C97 50              push ax
1C98 FF 36 46 01     push word [LabelNamePtr]
1C9C E8 8B E5        call strcpy
1C9F 83 C4 04        add  sp, 4
1CA2 A3 46 01        mov word [LabelNamePtr], ax
1CA5                
1CA5                ;-882     LabelNamePtr++;
1CA5                
1CA5 FF 06 46 01     inc  word[LabelNamePtr]
1CA9                
1CA9                ;-883     i = LabelNamePtr - &LabelNames;
1CA9                
1CA9 A1 46 01        mov ax, [LabelNamePtr]
1CAC 2D 5A 77        sub ax, LabelNames
1CAF 89 46 FE        mov [bp-2], ax
1CB2                
1CB2                ;-884     if (i >= LABELNAMESMAX) errorexit("too many label names");
1CB2                
1CB2 8B 46 FE        mov ax, [bp-2]
1CB5 3D 51 17        cmp ax, 5969 ;unsigned : 0
1CB8 0F 82 00 00   r jb  .storeLabel209
1CBC 68 AA AA      A push storeLabel_2
1CBF E8 DF ED        call errorexit
1CC2 83 C4 02        add  sp, 2
1CC5                
1CC5                ;-885     LabelAddr[LabelMaxIx] = PC + Origin;
1CC5                
1CC5                .storeLabel209:
1CC5 A1 23 01        mov ax, [PC]
1CC8 03 06 25 01     add ax, [Origin]
1CCC 8B 1E 4A 01     mov bx, [LabelMaxIx]
1CD0 D1 E3           shl bx, 1
1CD2 89 87 CA 8E     mov [LabelAddr+bx], ax
1CD6                
1CD6                ;-886 }
1CD6                
1CD6                
1CD6                ;-887 
1CD6                
1CD6                
1CD6                ;-888 
1CD6                
1CD6                
1CD6                ;-889 int genDB() {
1CD6 C9              LEAVE
1CD7 C3              ret
1CD8 64 75 70 6C 69 storeLabel_0 db "duplicate label",0
1CE8 74 6F 6F 20 6D storeLabel_1 db "too many labels",0
1CF8 74 6F 6F 20 6D storeLabel_2 db "too many label names",0
leaving: storeLabel, loc labels: 6, loc jmp forward: 6
1D0D                ENDP
1D0D                
entering: genDB
1D0D                genDB: PROC
1D0D                
1D0D                ;-890     char c;  char isloop;
1D0D                
1D0D                
1D0D                ;-891         isloop = 0;
1D0D                
1D0D                ;Function : genDB, Number of local variables: 2
1D0D                ;   # type sign width addr used name   list of local variables
1D0D                ;  200 var sign byte   890 NULL c = bp-2
1D0D                ;  201 var sign byte   890 NULL isloop = bp-4;
1D0D C8 04 00 00     ENTER  4,0
1D11 B8 00 00        mov ax, 0
1D14 88 46 FC        mov [bp-4], al
1D17                
1D17                ;-892             do {
1D17                
1D17                .genDB210:
1D17                
1D17                ;-893                 if (isloop) getTokeType();//omit ,  
1D17                
1D17 8A 46 FC        mov al, [bp-4]
1D1A 08 C0           or  al, al
1D1C 0F 84 00 00   r je .genDB211
1D20 E8 C8 F9        call getTokeType
1D23                
1D23                ;-894                 if (TokeType == DIGIT) genCode8(SymbolInt);
1D23                
1D23                .genDB211:
1D23 A0 2C 01        mov al, [TokeType]
1D26 3C 01           cmp al, 1
1D28 0F 85 00 00   r jne .genDB212
1D2C FF 36 0E 01     push word [SymbolInt]
1D30 E8 59 F6        call genCode8
1D33 83 C4 02        add  sp, 2
1D36                
1D36                ;-895                 else {
1D36                
1D36 E9 00 00      R jmp .genDB213
1D39                .genDB212:
1D39                
1D39                ;-896                     skipBlank();
1D39                
1D39 E8 A3 F0        call skipBlank
1D3C                
1D3C                ;-897                     if (isToken('"')) {
1D3C                
1D3C 6A 22           push 34
1D3E E8 36 FA        call isToken
1D41 83 C4 02        add  sp, 2
1D44 08 C0           or  al, al
1D46 0F 84 00 00   r je .genDB214
1D4A                
1D4A                ;-898                         do {
1D4A                
1D4A                .genDB215:
1D4A                
1D4A                ;-899                             c= *InputPtr;
1D4A                
1D4A 8B 1E 14 01     mov bx, [InputPtr]
1D4E 8A 07           mov al, [bx]
1D50 B4 00           mov ah, 0
1D52 88 46 FE        mov [bp-2], al
1D55                
1D55                ;-900                             genCode8(c);
1D55                
1D55 8A 46 FE        mov al, byte [bp-2]
1D58 B4 00           mov ah, 0
1D5A 50              push ax
1D5B E8 2E F6        call genCode8
1D5E 83 C4 02        add  sp, 2
1D61                
1D61                ;-901                             InputPtr++;
1D61                
1D61 FF 06 14 01     inc  word[InputPtr]
1D65                
1D65                ;-902                         } while (*InputPtr != '"' );
1D65                
1D65 8B 1E 14 01     mov bx, [InputPtr]
1D69 8A 07           mov al, [bx]
1D6B B4 00           mov ah, 0
1D6D 83 F8 22        cmp ax, 34
1D70 0F 84 00 00   r je  .genDB216
1D74 EB D4           jmp .genDB215
1D76                .genDB216:
1D76                
1D76                ;-903                         InputPtr++;
1D76                
1D76 FF 06 14 01     inc  word[InputPtr]
1D7A                
1D7A                ;-904                     }
1D7A                
1D7A                
1D7A                ;-905                 } 
1D7A                
1D7A                .genDB214:
1D7A                
1D7A                ;-906                 isloop = 1;
1D7A                
1D7A                .genDB213:
1D7A B8 01 00        mov ax, 1
1D7D 88 46 FC        mov [bp-4], al
1D80                
1D80                ;-907             } while (isToken(','));
1D80                
1D80 6A 2C           push 44
1D82 E8 F2 F9        call isToken
1D85 83 C4 02        add  sp, 2
1D88 08 C0           or  al, al
1D8A 0F 84 00 00   r je .genDB217
1D8E EB 87           jmp .genDB210
1D90                .genDB217:
1D90                
1D90                ;-908 }
1D90                
1D90                
1D90                ;-909 
1D90                
1D90                
1D90                ;-910 int getVariable() {
1D90 C9              LEAVE
1D91 C3              ret
leaving: genDB, loc labels: 8, loc jmp forward: 6
1D92                ENDP
1D92                
entering: getVariable
1D92                getVariable: PROC
1D92                
1D92                ;-911     char c;
1D92                
1D92                
1D92                ;-912     storeLabel();
1D92                
1D92                ;Function : getVariable, Number of local variables: 1
1D92                ;   # type sign width addr used name   list of local variables
1D92                ;  200 var sign byte   911 NULL c = bp-2;
1D92 C8 02 00 00     ENTER  2,0
1D96 E8 CD FE        call storeLabel
1D99                
1D99                ;-913     getTokeType();
1D99                
1D99 E8 4F F9        call getTokeType
1D9C                
1D9C                ;-914     if(TokeType==ALNUME) {//getName
1D9C                
1D9C A0 2C 01        mov al, [TokeType]
1D9F 3C 03           cmp al, 3
1DA1 0F 85 00 00   r jne .getVariable218
1DA5                
1DA5                ;-915         lookCode();
1DA5                
1DA5 E8 6D F5        call lookCode
1DA8                
1DA8                ;-916         if (CodeType < 200) dataexit();
1DA8                
1DA8 A0 2F 01        mov al, [CodeType]
1DAB 3C C8           cmp al, 200
1DAD 0F 8D 00 00   r jge .getVariable219
1DB1 E8 C2 EE        call dataexit
1DB4                
1DB4                ;-917         if (CodeType > 205) dataexit();
1DB4                
1DB4                .getVariable219:
1DB4 A0 2F 01        mov al, [CodeType]
1DB7 3C CD           cmp al, 205
1DB9 0F 8E 00 00   r jle .getVariable220
1DBD E8 B6 EE        call dataexit
1DC0                
1DC0                ;-918         if (CodeType== 200) {//DB
1DC0                
1DC0                .getVariable220:
1DC0 A0 2F 01        mov al, [CodeType]
1DC3 3C C8           cmp al, 200
1DC5 0F 85 00 00   r jne .getVariable221
1DC9                
1DC9                ;-919             do {
1DC9                
1DC9                .getVariable222:
1DC9                
1DC9                ;-920                 getTokeType();
1DC9                
1DC9 E8 1F F9        call getTokeType
1DCC                
1DCC                ;-921                 if (TokeType == DIGIT) genCode8(SymbolInt);
1DCC                
1DCC A0 2C 01        mov al, [TokeType]
1DCF 3C 01           cmp al, 1
1DD1 0F 85 00 00   r jne .getVariable223
1DD5 FF 36 0E 01     push word [SymbolInt]
1DD9 E8 B0 F5        call genCode8
1DDC 83 C4 02        add  sp, 2
1DDF                
1DDF                ;-922                 else {
1DDF                
1DDF E9 00 00      R jmp .getVariable224
1DE2                .getVariable223:
1DE2                
1DE2                ;-923                     skipBlank();
1DE2                
1DE2 E8 FA EF        call skipBlank
1DE5                
1DE5                ;-924                     if (isToken('"')) {
1DE5                
1DE5 6A 22           push 34
1DE7 E8 8D F9        call isToken
1DEA 83 C4 02        add  sp, 2
1DED 08 C0           or  al, al
1DEF 0F 84 00 00   r je .getVariable225
1DF3                
1DF3                ;-925                         do {
1DF3                
1DF3                .getVariable226:
1DF3                
1DF3                ;-926                             c= *InputPtr;
1DF3                
1DF3 8B 1E 14 01     mov bx, [InputPtr]
1DF7 8A 07           mov al, [bx]
1DF9 B4 00           mov ah, 0
1DFB 88 46 FE        mov [bp-2], al
1DFE                
1DFE                ;-927                             genCode8(c);
1DFE                
1DFE 8A 46 FE        mov al, byte [bp-2]
1E01 B4 00           mov ah, 0
1E03 50              push ax
1E04 E8 85 F5        call genCode8
1E07 83 C4 02        add  sp, 2
1E0A                
1E0A                ;-928                             InputPtr++;
1E0A                
1E0A FF 06 14 01     inc  word[InputPtr]
1E0E                
1E0E                ;-929                         } while (*InputPtr != '"' );
1E0E                
1E0E 8B 1E 14 01     mov bx, [InputPtr]
1E12 8A 07           mov al, [bx]
1E14 B4 00           mov ah, 0
1E16 83 F8 22        cmp ax, 34
1E19 0F 84 00 00   r je  .getVariable227
1E1D EB D4           jmp .getVariable226
1E1F                .getVariable227:
1E1F                
1E1F                ;-930                         InputPtr++;
1E1F                
1E1F FF 06 14 01     inc  word[InputPtr]
1E23                
1E23                ;-931                     }
1E23                
1E23                
1E23                ;-932                 }
1E23                
1E23                .getVariable225:
1E23                
1E23                ;-933             } while (isToken(','));
1E23                
1E23                .getVariable224:
1E23 6A 2C           push 44
1E25 E8 4F F9        call isToken
1E28 83 C4 02        add  sp, 2
1E2B 08 C0           or  al, al
1E2D 0F 84 00 00   r je .getVariable228
1E31 EB 96           jmp .getVariable222
1E33                .getVariable228:
1E33                
1E33                ;-934         }
1E33                
1E33                
1E33                ;-935         if (CodeType == 201) {//DW
1E33                
1E33                .getVariable221:
1E33 A0 2F 01        mov al, [CodeType]
1E36 3C C9           cmp al, 201
1E38 0F 85 00 00   r jne .getVariable229
1E3C                
1E3C                ;-936             do {
1E3C                
1E3C                .getVariable230:
1E3C                
1E3C                ;-937                 getTokeType();
1E3C                
1E3C E8 AC F8        call getTokeType
1E3F                
1E3F                ;-938                 if (TokeType ==DIGIT) genCode16(SymbolInt);
1E3F                
1E3F A0 2C 01        mov al, [TokeType]
1E42 3C 01           cmp al, 1
1E44 0F 85 00 00   r jne .getVariable231
1E48 FF 36 0E 01     push word [SymbolInt]
1E4C E8 D4 F5        call genCode16
1E4F 83 C4 02        add  sp, 2
1E52                
1E52                ;-939             } while (isToken(','));
1E52                
1E52                .getVariable231:
1E52 6A 2C           push 44
1E54 E8 20 F9        call isToken
1E57 83 C4 02        add  sp, 2
1E5A 08 C0           or  al, al
1E5C 0F 84 00 00   r je .getVariable232
1E60 EB DA           jmp .getVariable230
1E62                .getVariable232:
1E62                
1E62                ;-940         }
1E62                
1E62                
1E62                ;-941         if (CodeType == 202) {//DD
1E62                
1E62                .getVariable229:
1E62 A0 2F 01        mov al, [CodeType]
1E65 3C CA           cmp al, 202
1E67 0F 85 00 00   r jne .getVariable233
1E6B                
1E6B                ;-942             do {
1E6B                
1E6B                .getVariable234:
1E6B                
1E6B                ;-943                 getTokeType();
1E6B                
1E6B E8 7D F8        call getTokeType
1E6E                
1E6E                ;-944                 if (TokeType ==DIGIT) { genCode16(SymbolInt);
1E6E                
1E6E A0 2C 01        mov al, [TokeType]
1E71 3C 01           cmp al, 1
1E73 0F 85 00 00   r jne .getVariable235
1E77 FF 36 0E 01     push word [SymbolInt]
1E7B E8 A5 F5        call genCode16
1E7E 83 C4 02        add  sp, 2
1E81                
1E81                ;-945                                     genCode16(0);}//todo genCode32(SymbolLong);
1E81                
1E81 6A 00           push 0
1E83 E8 9D F5        call genCode16
1E86 83 C4 02        add  sp, 2
1E89                
1E89                ;-946             } while (isToken(','));
1E89                
1E89                .getVariable235:
1E89 6A 2C           push 44
1E8B E8 E9 F8        call isToken
1E8E 83 C4 02        add  sp, 2
1E91 08 C0           or  al, al
1E93 0F 84 00 00   r je .getVariable236
1E97 EB D2           jmp .getVariable234
1E99                .getVariable236:
1E99                
1E99                ;-947         }
1E99                
1E99                
1E99                ;-948         if (CodeType >= 203) {//resb, resw, resd
1E99                
1E99                .getVariable233:
1E99 A0 2F 01        mov al, [CodeType]
1E9C 3C CB           cmp al, 203 ;unsigned : 1
1E9E 0F 8C 00 00   r jl  .getVariable237
1EA2                
1EA2                ;-949             getTokeType();
1EA2                
1EA2 E8 46 F8        call getTokeType
1EA5                
1EA5                ;-950             if (TokeType == DIGIT) {
1EA5                
1EA5 A0 2C 01        mov al, [TokeType]
1EA8 3C 01           cmp al, 1
1EAA 0F 85 00 00   r jne .getVariable238
1EAE                
1EAE                ;-951                 if (SymbolInt <= 0) syntaxerror();
1EAE                
1EAE A1 0E 01        mov ax, [SymbolInt]
1EB1 83 F8 00        cmp ax, 0
1EB4 0F 87 00 00   r ja  .getVariable239
1EB8 E8 90 ED        call syntaxerror
1EBB                
1EBB                ;-952                 if (AbsoluteLab == 0) error1("Absolute is null");
1EBB                
1EBB                .getVariable239:
1EBB A1 27 01        mov ax, [AbsoluteLab]
1EBE 83 F8 00        cmp ax, 0
1EC1 0F 85 00 00   r jne .getVariable240
1EC5 68 AA AA      A push getVariable_0
1EC8 E8 7F EB        call error1
1ECB 83 C4 02        add  sp, 2
1ECE                
1ECE                ;-953                 LabelAddr[LabelMaxIx] = AbsoluteLab;
1ECE                
1ECE                .getVariable240:
1ECE A1 27 01        mov ax, [AbsoluteLab]
1ED1 8B 1E 4A 01     mov bx, [LabelMaxIx]
1ED5 D1 E3           shl bx, 1
1ED7 89 87 CA 8E     mov [LabelAddr+bx], ax
1EDB                
1EDB                ;-954                 if (CodeType == 204) SymbolInt=SymbolInt+SymbolInt;//resw
1EDB                
1EDB A0 2F 01        mov al, [CodeType]
1EDE 3C CC           cmp al, 204
1EE0 0F 85 00 00   r jne .getVariable241
1EE4 A1 0E 01        mov ax, [SymbolInt]
1EE7 03 06 0E 01     add ax, [SymbolInt]
1EEB A3 0E 01        mov word [SymbolInt], ax
1EEE                
1EEE                ;-955                 if (CodeType == 205) SymbolInt=SymbolInt * 4;//resd
1EEE                
1EEE                .getVariable241:
1EEE A0 2F 01        mov al, [CodeType]
1EF1 3C CD           cmp al, 205
1EF3 0F 85 00 00   r jne .getVariable242
1EF7 A1 0E 01        mov ax, [SymbolInt]
1EFA BB 04 00        mov bx, 4
1EFD F7 E3           mul bx
1EFF A3 0E 01        mov word [SymbolInt], ax
1F02                
1F02                ;-956                 AbsoluteLab = AbsoluteLab + SymbolInt;
1F02                
1F02                .getVariable242:
1F02 A1 27 01        mov ax, [AbsoluteLab]
1F05 03 06 0E 01     add ax, [SymbolInt]
1F09 A3 27 01        mov word [AbsoluteLab], ax
1F0C                
1F0C                ;-957             } else numbererror();
1F0C                
1F0C E9 00 00      R jmp .getVariable243
1F0F                .getVariable238:
1F0F E8 A6 EC        call numbererror
1F12                
1F12                ;-958         }
1F12                
1F12                .getVariable243:
1F12                
1F12                ;-959     }
1F12                
1F12                .getVariable237:
1F12                
1F12                ;-960     else dataexit();
1F12                
1F12 E9 00 00      R jmp .getVariable244
1F15                .getVariable218:
1F15 E8 5E ED        call dataexit
1F18                
1F18                ;-961 }
1F18                
1F18                .getVariable244:
1F18                
1F18                ;-962 
1F18                
1F18                
1F18                ;-963 int getCodeSize() {
1F18 C9              LEAVE
1F19 C3              ret
1F1A 41 62 73 6F 6C getVariable_0 db "Absolute is null",0
leaving: getVariable, loc labels: 28, loc jmp forward: 24
1F2B                ENDP
1F2B                
entering: getCodeSize
1F2B                getCodeSize: PROC
1F2B                
1F2B                ;-964     if (TokeType ==ALNUME) {
1F2B                
1F2B A0 2C 01        mov al, [TokeType]
1F2E 3C 03           cmp al, 3
1F30 0F 85 00 00   r jne .getCodeSize245
1F34                
1F34                ;-965         if (eqstr(SymbolUpper,"BYTE")) {getTokeType(); return BYTE;}
1F34                
1F34 68 AA AA      A push getCodeSize_0
1F37 8D 06 4F 75     lea  ax, [SymbolUpper]
1F3B 50              push ax
1F3C E8 21 E3        call eqstr
1F3F 83 C4 04        add  sp, 4
1F42 08 C0           or  al, al
1F44 0F 84 00 00   r je .getCodeSize246
1F48 E8 A0 F7        call getTokeType
1F4B B8 01 00        mov ax, 1
1F4E E9 00 00      R jmp .retngetCodeSize
1F51                
1F51                ;-966         if (eqstr(SymbolUpper,"WORD")) {getTokeType(); return WORD;}
1F51                
1F51                .getCodeSize246:
1F51 68 AA AA      A push getCodeSize_1
1F54 8D 06 4F 75     lea  ax, [SymbolUpper]
1F58 50              push ax
1F59 E8 04 E3        call eqstr
1F5C 83 C4 04        add  sp, 4
1F5F 08 C0           or  al, al
1F61 0F 84 00 00   r je .getCodeSize247
1F65 E8 83 F7        call getTokeType
1F68 B8 02 00        mov ax, 2
1F6B E9 00 00      R jmp .retngetCodeSize
1F6E                
1F6E                ;-967         if (eqstr(SymbolUpper,"DWORD")){getTokeType(); return DWORD;}
1F6E                
1F6E                .getCodeSize247:
1F6E 68 AA AA      A push getCodeSize_2
1F71 8D 06 4F 75     lea  ax, [SymbolUpper]
1F75 50              push ax
1F76 E8 E7 E2        call eqstr
1F79 83 C4 04        add  sp, 4
1F7C 08 C0           or  al, al
1F7E 0F 84 00 00   r je .getCodeSize248
1F82 E8 66 F7        call getTokeType
1F85 B8 03 00        mov ax, 3
1F88 E9 00 00      R jmp .retngetCodeSize
1F8B                
1F8B                ;-968     }
1F8B                
1F8B                .getCodeSize248:
1F8B                
1F8B                ;-969     return 0;
1F8B                
1F8B                .getCodeSize245:
1F8B B8 00 00        mov ax, 0
1F8E E9 00 00      R jmp .retngetCodeSize
1F91                
1F91                ;-970 }
1F91                
1F91                
1F91                ;-971 
1F91                
1F91                
1F91                ;-972 
1F91                
1F91                
1F91                ;-973 int getarg() {
1F91                
1F91                 .retngetCodeSize:
1F91 C3              ret
1F92 42 59 54 45 00 getCodeSize_0 db "BYTE",0
1F97 57 4F 52 44 00 getCodeSize_1 db "WORD",0
1F9C 44 57 4F 52 44 getCodeSize_2 db "DWORD",0
leaving: getCodeSize, loc labels: 8, loc jmp forward: 11
1FA2                ENDP
1FA2                
entering: getarg
1FA2                getarg: PROC
1FA2                
1FA2                ;-974     int arglen1; int i; char *c;
1FA2                
1FA2                
1FA2                ;-975     arglen1=*arglen;
1FA2                
1FA2                ;Function : getarg, Number of local variables: 3
1FA2                ;   # type sign width addr used name   list of local variables
1FA2                ;  200 var sign word   974 NULL arglen1 = bp-2
1FA2                ;  201 var sign word   974 NULL i = bp-4
1FA2                ;  202 ptr sign byte   974 NULL c = bp-6;
1FA2 C8 06 00 00     ENTER  6,0
1FA6 8B 1E 5A 01     mov bx, [arglen]
1FAA 8A 07           mov al, [bx]
1FAC B4 00           mov ah, 0
1FAE 89 46 FE        mov [bp-2], ax
1FB1                
1FB1                ;-976     if (arglen1==0) {
1FB1                
1FB1 8B 46 FE        mov ax, [bp-2]
1FB4 83 F8 00        cmp ax, 0
1FB7 0F 85 00 00   r jne .getarg249
1FBB                
1FBB                ;-977         cputs(Version1);
1FBB                
1FBB 8D 06 03 01     lea  ax, [Version1]
1FBF 50              push ax
1FC0 E8 BC E0        call cputs
1FC3 83 C4 02        add  sp, 2
1FC6                
1FC6                ;-978         cputs(", Usage: AS.COM filename [w/o .S] : ");
1FC6                
1FC6 68 AA AA      A push getarg_0
1FC9 E8 B3 E0        call cputs
1FCC 83 C4 02        add  sp, 2
1FCF                
1FCF                ;-979         exitR(3);
1FCF                
1FCF 6A 03           push 3
1FD1 E8 12 E1        call exitR
1FD4 83 C4 02        add  sp, 2
1FD7                
1FD7                ;-980     }
1FD7                
1FD7                
1FD7                ;-981     i=arglen1+129;
1FD7                
1FD7                .getarg249:
1FD7 8B 46 FE        mov ax, [bp-2]
1FDA 05 81 00        add ax, 129
1FDD 89 46 FC        mov [bp-4], ax
1FE0                
1FE0                ;-982     *i=0;
1FE0                
1FE0 B8 00 00        mov ax, 0
1FE3 8B 5E FC        mov  bx, [bp-4]
1FE6 89 07           mov  [bx], ax
1FE8                
1FE8                ;-983     arglen1--;
1FE8                
1FE8 FF 4E FE        dec  word[bp-2]
1FEB                
1FEB                ;-984     toupper(argv);
1FEB                
1FEB FF 36 5C 01     push word [argv]
1FEF E8 DF E2        call toupper
1FF2 83 C4 02        add  sp, 2
1FF5                
1FF5                ;-985 
1FF5                
1FF5                
1FF5                ;-986     strcpy(namein, argv); strcat1(namein, ".S");
1FF5                
1FF5 FF 36 5C 01     push word [argv]
1FF9 8D 06 8C 76     lea  ax, [namein]
1FFD 50              push ax
1FFE E8 29 E2        call strcpy
2001 83 C4 04        add  sp, 4
2004 68 AA AA      A push getarg_1
2007 8D 06 8C 76     lea  ax, [namein]
200B 50              push ax
200C E8 9D E2        call strcat1
200F 83 C4 04        add  sp, 4
2012                
2012                ;-987     strcpy(namelst,argv); strcat1(namelst,".LST");
2012                
2012 FF 36 5C 01     push word [argv]
2016 8D 06 CF 76     lea  ax, [namelst]
201A 50              push ax
201B E8 0C E2        call strcpy
201E 83 C4 04        add  sp, 4
2021 68 AA AA      A push getarg_2
2024 8D 06 CF 76     lea  ax, [namelst]
2028 50              push ax
2029 E8 80 E2        call strcat1
202C 83 C4 04        add  sp, 4
202F                
202F                ;-988     strcpy(namebin,argv); strcat1(namebin,".COM");
202F                
202F FF 36 5C 01     push word [argv]
2033 8D 06 12 77     lea  ax, [namebin]
2037 50              push ax
2038 E8 EF E1        call strcpy
203B 83 C4 04        add  sp, 4
203E 68 AA AA      A push getarg_3
2041 8D 06 12 77     lea  ax, [namebin]
2045 50              push ax
2046 E8 63 E2        call strcat1
2049 83 C4 04        add  sp, 4
204C                
204C                ;-989 
204C                
204C                
204C                ;-990   DOS_ERR=0; PC=0; ErrorCount=0;
204C                
204C B8 00 00        mov ax, 0
204F A3 1C 01        mov word [DOS_ERR], ax
2052 B8 00 00        mov ax, 0
2055 A3 23 01        mov word [PC], ax
2058 B8 00 00        mov ax, 0
205B A3 1E 01        mov word [ErrorCount], ax
205E                
205E                ;-991 
205E                
205E                
205E                ;-992     asm_fd=openR (namein);
205E                
205E 8D 06 8C 76     lea  ax, [namein]
2062 50              push ax
2063 E8 50 E0        call openR
2066 83 C4 02        add  sp, 2
2069 A3 16 01        mov word [asm_fd], ax
206C                
206C                ;-993     if(DOS_ERR){cputs("Source file missing: ") ;cputs(namein );exitR(1);}
206C                
206C A1 1C 01        mov ax, [DOS_ERR]
206F 08 C0           or  al, al
2071 0F 84 00 00   r je .getarg250
2075 68 AA AA      A push getarg_4
2078 E8 04 E0        call cputs
207B 83 C4 02        add  sp, 2
207E 8D 06 8C 76     lea  ax, [namein]
2082 50              push ax
2083 E8 F9 DF        call cputs
2086 83 C4 02        add  sp, 2
2089 6A 01           push 1
208B E8 58 E0        call exitR
208E 83 C4 02        add  sp, 2
2091                
2091                ;-994     lst_fd=creatR(namelst);
2091                
2091                .getarg250:
2091 8D 06 CF 76     lea  ax, [namelst]
2095 50              push ax
2096 E8 2C E0        call creatR
2099 83 C4 02        add  sp, 2
209C A3 18 01        mov word [lst_fd], ax
209F                
209F                ;-995     if(DOS_ERR){cputs("List file not create: ");cputs(namelst);exitR(2);}
209F                
209F A1 1C 01        mov ax, [DOS_ERR]
20A2 08 C0           or  al, al
20A4 0F 84 00 00   r je .getarg251
20A8 68 AA AA      A push getarg_5
20AB E8 D1 DF        call cputs
20AE 83 C4 02        add  sp, 2
20B1 8D 06 CF 76     lea  ax, [namelst]
20B5 50              push ax
20B6 E8 C6 DF        call cputs
20B9 83 C4 02        add  sp, 2
20BC 6A 02           push 2
20BE E8 25 E0        call exitR
20C1 83 C4 02        add  sp, 2
20C4                
20C4                ;-996     bin_fd=creatR(namebin);
20C4                
20C4                .getarg251:
20C4 8D 06 12 77     lea  ax, [namebin]
20C8 50              push ax
20C9 E8 F9 DF        call creatR
20CC 83 C4 02        add  sp, 2
20CF A3 1A 01        mov word [bin_fd], ax
20D2                
20D2                ;-997     if(DOS_ERR){cputs("COM file not create: ") ;cputs(namebin);exitR(2);}
20D2                
20D2 A1 1C 01        mov ax, [DOS_ERR]
20D5 08 C0           or  al, al
20D7 0F 84 00 00   r je .getarg252
20DB 68 AA AA      A push getarg_6
20DE E8 9E DF        call cputs
20E1 83 C4 02        add  sp, 2
20E4 8D 06 12 77     lea  ax, [namebin]
20E8 50              push ax
20E9 E8 93 DF        call cputs
20EC 83 C4 02        add  sp, 2
20EF 6A 02           push 2
20F1 E8 F2 DF        call exitR
20F4 83 C4 02        add  sp, 2
20F7                
20F7                ;-998 
20F7                
20F7                
20F7                ;-999     prs(";");
20F7                
20F7                .getarg252:
20F7 68 AA AA      A push getarg_7
20FA E8 36 E6        call prs
20FD 83 C4 02        add  sp, 2
2100                
2100                ;-1000     prs(Version1);
2100                
2100 8D 06 03 01     lea  ax, [Version1]
2104 50              push ax
2105 E8 2B E6        call prs
2108 83 C4 02        add  sp, 2
210B                
210B                ;-1001     prs(", Source: "); prs(namein);
210B                
210B 68 AA AA      A push getarg_8
210E E8 22 E6        call prs
2111 83 C4 02        add  sp, 2
2114 8D 06 8C 76     lea  ax, [namein]
2118 50              push ax
2119 E8 17 E6        call prs
211C 83 C4 02        add  sp, 2
211F                
211F                ;-1002     prs(", Output: "); prs(namelst);
211F                
211F 68 AA AA      A push getarg_9
2122 E8 0E E6        call prs
2125 83 C4 02        add  sp, 2
2128 8D 06 CF 76     lea  ax, [namelst]
212C 50              push ax
212D E8 03 E6        call prs
2130 83 C4 02        add  sp, 2
2133                
2133                ;-1003     prs(", "); prs(namebin);
2133                
2133 68 AA AA      A push getarg_10
2136 E8 FA E5        call prs
2139 83 C4 02        add  sp, 2
213C 8D 06 12 77     lea  ax, [namebin]
2140 50              push ax
2141 E8 EF E5        call prs
2144 83 C4 02        add  sp, 2
2147                
2147                ;-1004     prs("\n");
2147                
2147 68 AA AA      A push getarg_11
214A E8 E6 E5        call prs
214D 83 C4 02        add  sp, 2
2150                
2150                ;-1005 }
2150                
2150                
2150                ;-1006 
2150                
2150                
2150                ;-1007 int fixJmp() {   
2150 C9              LEAVE
2151 C3              ret
2152 2C 20 55 73 61 getarg_0 db ", Usage: AS.COM filename [w/o .S] : ",0
2177 2E 53 00       getarg_1 db ".S",0
217A 2E 4C 53 54 00 getarg_2 db ".LST",0
217F 2E 43 4F 4D 00 getarg_3 db ".COM",0
2184 53 6F 75 72 63 getarg_4 db "Source file missing: ",0
219A 4C 69 73 74 20 getarg_5 db "List file not create: ",0
21B1 43 4F 4D 20 66 getarg_6 db "COM file not create: ",0
21C7 3B 00          getarg_7 db ";",0
21C9 2C 20 53 6F 75 getarg_8 db ", Source: ",0
21D4 2C 20 4F 75 74 getarg_9 db ", Output: ",0
21DF 2C 20 00       getarg_10 db ", ",0
21E2 5C 6E 00       getarg_11 db "\n",0
leaving: getarg, loc labels: 16, loc jmp forward: 16
21E5                ENDP
21E5                
entering: fixJmp
21E5                fixJmp: PROC
21E5                
21E5                ;-1008     unsigned int hex; int i;
21E5                
21E5                
21E5                ;-1009     char *p; int Ix; char c;
21E5                
21E5                
21E5                ;-1010 //    prs("\, jmp to fix:"); printIntU(JmpMaxIx);
21E5                
21E5                
21E5                ;-1011     p = &JmpNames;
21E5                
21E5                ;Function : fixJmp, Number of local variables: 5
21E5                ;   # type sign width addr used name   list of local variables
21E5                ;  200 var unsg word  1008 NULL hex = bp-2
21E5                ;  201 var sign word  1008 NULL i = bp-4
21E5                ;  202 ptr sign byte  1009 NULL p = bp-6
21E5                ;  203 var sign word  1009 NULL Ix = bp-8
21E5                ;  204 var sign byte  1009 NULL c = bp-10;
21E5 C8 0A 00 00     ENTER  10,0
21E9 B8 7A 93        mov ax, JmpNames
21EC 89 46 FA        mov [bp-6], ax
21EF                
21EF                ;-1012     i = 1;
21EF                
21EF B8 01 00        mov ax, 1
21F2 89 46 FC        mov [bp-4], ax
21F5                
21F5                ;-1013     while (i <= JmpMaxIx) {
21F5                
21F5                .fixJmp253:
21F5 8B 46 FC        mov ax, [bp-4]
21F8 3B 06 54 01     cmp ax, [JmpMaxIx]
21FC 0F 8F 00 00   r jg  .fixJmp254
2200                
2200                ;-1014         strcpy(Symbol, p);
2200                
2200 FF 76 FA        push word [bp-6]
2203 8D 06 30 75     lea  ax, [Symbol]
2207 50              push ax
2208 E8 1F E0        call strcpy
220B 83 C4 04        add  sp, 4
220E                
220E                ;-1015         p = strlen(Symbol) + p;
220E                
220E 8D 06 30 75     lea  ax, [Symbol]
2212 50              push ax
2213 E8 EC DF        call strlen
2216 83 C4 02        add  sp, 2
2219 03 46 FA        add ax, [bp-6]
221C 89 46 FA        mov [bp-6], ax
221F                
221F                ;-1016         p++;
221F                
221F FF 46 FA        inc  word[bp-6]
2222                
2222                ;-1017         hex = JmpAddr[i];
2222                
2222 8B 5E FC        mov bx, [bp-4]
2225 D1 E3           shl bx, 1
2227 8B 87 1A A3     mov ax, [JmpAddr + bx]
222B 89 46 FE        mov [bp-2], ax
222E                
222E                ;-1018 //        prs("\n"); printIntU(i);
222E                
222E                
222E                ;-1019 //        prs("  "); prs(Symbol); prs(", from:");
222E                
222E                
222E                ;-1020 //        printhex16(hex);
222E                
222E                
222E                ;-1021         
222E                
222E                
222E                ;-1022         Ix=searchLabel();
222E                
222E E8 58 F6        call searchLabel
2231 89 46 F8        mov [bp-8], ax
2234                
2234                ;-1023         if (Ix == 0) notfounderror();
2234                
2234 8B 46 F8        mov ax, [bp-8]
2237 83 F8 00        cmp ax, 0
223A 0F 85 00 00   r jne .fixJmp255
223E E8 7A E8        call notfounderror
2241                
2241                ;-1024         disp = LabelAddr[Ix];   
2241                
2241                .fixJmp255:
2241 8B 5E F8        mov bx, [bp-8]
2244 D1 E3           shl bx, 1
2246 8B 87 CA 8E     mov ax, [LabelAddr + bx]
224A A3 3D 01        mov word [disp], ax
224D                
224D                ;-1025         c = FileBin[hex];//look for 'A' push Absolute 
224D                
224D 8B 5E FE        mov bx, [bp-2]
2250 8A 87 AA A4     mov al, [FileBin + bx]
2254 88 46 F6        mov [bp-10], al
2257                
2257                ;-1026 //        prs(", Label+ORG:"); printhex16(disp);
2257                
2257                
2257                ;-1027         if (c != 0xAA) {
2257                
2257 8A 46 F6        mov al, [bp-10]
225A 3C AA           cmp al, 170
225C 0F 84 00 00   r je  .fixJmp256
2260                
2260                ;-1028             disp = disp - hex;
2260                
2260 A1 3D 01        mov ax, [disp]
2263 2B 46 FE        sub ax, [bp-2]
2266 A3 3D 01        mov word [disp], ax
2269                
2269                ;-1029             disp = disp -2;//PC points to next instruction
2269                
2269 A1 3D 01        mov ax, [disp]
226C 83 E8 02        sub ax, 2
226F A3 3D 01        mov word [disp], ax
2272                
2272                ;-1030             disp = disp - Origin; 
2272                
2272 A1 3D 01        mov ax, [disp]
2275 2B 06 25 01     sub ax, [Origin]
2279 A3 3D 01        mov word [disp], ax
227C                
227C                ;-1031 //            prs(", rel:"); printhex16(disp);
227C                
227C                
227C                ;-1032         }
227C                
227C                
227C                ;-1033             FileBin[hex] = disp;//fix low byte
227C                
227C                .fixJmp256:
227C A1 3D 01        mov ax, [disp]
227F 8B 5E FE        mov bx, [bp-2]
2282 88 87 AA A4     mov [FileBin+bx], al
2286                
2286                ;-1034             hex++;
2286                
2286 FF 46 FE        inc  word[bp-2]
2289                
2289                ;-1035             disp = disp >> 8;
2289                
2289 A1 3D 01        mov ax, [disp]
228C C1 E8 08        shr ax, 8
228F A3 3D 01        mov word [disp], ax
2292                
2292                ;-1036             FileBin[hex] = disp; 
2292                
2292 A1 3D 01        mov ax, [disp]
2295 8B 5E FE        mov bx, [bp-2]
2298 88 87 AA A4     mov [FileBin+bx], al
229C                
229C                ;-1037         i++;  
229C                
229C FF 46 FC        inc  word[bp-4]
229F                
229F                ;-1038     }
229F                
229F                
229F                ;-1039 }
229F                
229F E9 53 FF        jmp .fixJmp253
22A2                .fixJmp254:
22A2                
22A2                ;-1040 int fixJmpMain() {   
22A2 C9              LEAVE
22A3 C3              ret
leaving: fixJmp, loc labels: 4, loc jmp forward: 3
22A4                ENDP
22A4                
entering: fixJmpMain
22A4                fixJmpMain: PROC
22A4                
22A4                ;-1041     unsigned int hex; 
22A4                
22A4                
22A4                ;-1042     int Ix; char c;
22A4                
22A4                
22A4                ;-1043     prs("\nfix jmp to main. resting global jmp: ");
22A4                
22A4                ;Function : fixJmpMain, Number of local variables: 3
22A4                ;   # type sign width addr used name   list of local variables
22A4                ;  200 var unsg word  1041 NULL hex = bp-2
22A4                ;  201 var sign word  1042 NULL Ix = bp-4
22A4                ;  202 var sign byte  1042 NULL c = bp-6;
22A4 C8 06 00 00     ENTER  6,0
22A8 68 AA AA      A push fixJmpMain_0
22AB E8 85 E4        call prs
22AE 83 C4 02        add  sp, 2
22B1                
22B1                ;-1044     printIntU(JmpMaxIx);  
22B1                
22B1 FF 36 54 01     push word [JmpMaxIx]
22B5 E8 8B E5        call printIntU
22B8 83 C4 02        add  sp, 2
22BB                
22BB                ;-1045     if (JmpMaxIx ) error1("resting global jmp");
22BB                
22BB A1 54 01        mov ax, [JmpMaxIx]
22BE 08 C0           or  al, al
22C0 0F 84 00 00   r je .fixJmpMain257
22C4 68 AA AA      A push fixJmpMain_1
22C7 E8 80 E7        call error1
22CA 83 C4 02        add  sp, 2
22CD                
22CD                ;-1046         strcpy(Symbol, "main");
22CD                
22CD                .fixJmpMain257:
22CD 68 AA AA      A push fixJmpMain_2
22D0 8D 06 30 75     lea  ax, [Symbol]
22D4 50              push ax
22D5 E8 52 DF        call strcpy
22D8 83 C4 04        add  sp, 4
22DB                
22DB                ;-1047         hex = 1;//first instruction, PC=1
22DB                
22DB B8 01 00        mov ax, 1
22DE 89 46 FE        mov [bp-2], ax
22E1                
22E1                ;-1048         Ix=searchLabel();
22E1                
22E1 E8 A5 F5        call searchLabel
22E4 89 46 FC        mov [bp-4], ax
22E7                
22E7                ;-1049         if (Ix == 0) notfounderror();
22E7                
22E7 8B 46 FC        mov ax, [bp-4]
22EA 83 F8 00        cmp ax, 0
22ED 0F 85 00 00   r jne .fixJmpMain258
22F1 E8 C7 E7        call notfounderror
22F4                
22F4                ;-1050         disp = LabelAddr[Ix];   
22F4                
22F4                .fixJmpMain258:
22F4 8B 5E FC        mov bx, [bp-4]
22F7 D1 E3           shl bx, 1
22F9 8B 87 CA 8E     mov ax, [LabelAddr + bx]
22FD A3 3D 01        mov word [disp], ax
2300                
2300                ;-1051         c = FileBin[hex];//look for 'A' push Absolute 
2300                
2300 8B 5E FE        mov bx, [bp-2]
2303 8A 87 AA A4     mov al, [FileBin + bx]
2307 88 46 FA        mov [bp-6], al
230A                
230A                ;-1052         prs("\nmain ,Label+ORG:"); printhex16(disp);
230A                
230A 68 AA AA      A push fixJmpMain_3
230D E8 23 E4        call prs
2310 83 C4 02        add  sp, 2
2313 FF 36 3D 01     push word [disp]
2317 E8 FF E4        call printhex16
231A 83 C4 02        add  sp, 2
231D                
231D                ;-1053         if (c != 0xAA) {
231D                
231D 8A 46 FA        mov al, [bp-6]
2320 3C AA           cmp al, 170
2322 0F 84 00 00   r je  .fixJmpMain259
2326                
2326                ;-1054             disp = disp - hex;
2326                
2326 A1 3D 01        mov ax, [disp]
2329 2B 46 FE        sub ax, [bp-2]
232C A3 3D 01        mov word [disp], ax
232F                
232F                ;-1055             disp = disp -2;//PC points to next instruction
232F                
232F A1 3D 01        mov ax, [disp]
2332 83 E8 02        sub ax, 2
2335 A3 3D 01        mov word [disp], ax
2338                
2338                ;-1056             disp = disp - Origin; 
2338                
2338 A1 3D 01        mov ax, [disp]
233B 2B 06 25 01     sub ax, [Origin]
233F A3 3D 01        mov word [disp], ax
2342                
2342                ;-1057             prs(",rel:"); printhex16(disp);
2342                
2342 68 AA AA      A push fixJmpMain_4
2345 E8 EB E3        call prs
2348 83 C4 02        add  sp, 2
234B FF 36 3D 01     push word [disp]
234F E8 C7 E4        call printhex16
2352 83 C4 02        add  sp, 2
2355                
2355                ;-1058         }
2355                
2355                
2355                ;-1059             FileBin[hex] = disp;//fix low byte
2355                
2355                .fixJmpMain259:
2355 A1 3D 01        mov ax, [disp]
2358 8B 5E FE        mov bx, [bp-2]
235B 88 87 AA A4     mov [FileBin+bx], al
235F                
235F                ;-1060             hex++;
235F                
235F FF 46 FE        inc  word[bp-2]
2362                
2362                ;-1061             disp = disp >> 8;
2362                
2362 A1 3D 01        mov ax, [disp]
2365 C1 E8 08        shr ax, 8
2368 A3 3D 01        mov word [disp], ax
236B                
236B                ;-1062             FileBin[hex] = disp; 
236B                
236B A1 3D 01        mov ax, [disp]
236E 8B 5E FE        mov bx, [bp-2]
2371 88 87 AA A4     mov [FileBin+bx], al
2375                
2375                ;-1063 }
2375                
2375                
2375                ;-1064 
2375                
2375                
2375                ;-1065 
2375                
2375                
2375                ;-1066 int getCodes() {
2375 C9              LEAVE
2376 C3              ret
2377 5C 6E 66 69 78 fixJmpMain_0 db "\nfix jmp to main. resting global jmp: ",0
239F 72 65 73 74 69 fixJmpMain_1 db "resting global jmp",0
23B2 6D 61 69 6E 00 fixJmpMain_2 db "main",0
23B7 5C 6E 6D 61 69 fixJmpMain_3 db "\nmain ,Label+ORG:",0
23CA 2C 72 65 6C 3A fixJmpMain_4 db ",rel:",0
leaving: fixJmpMain, loc labels: 8, loc jmp forward: 8
23D0                ENDP
23D0                
entering: getCodes
23D0                getCodes: PROC
23D0                
23D0                ;-1067     OpCodePtr ++; Code1 = *OpCodePtr;
23D0                
23D0 FF 06 43 01     inc  word[OpCodePtr]
23D4 8B 1E 43 01     mov bx, [OpCodePtr]
23D8 8A 07           mov al, [bx]
23DA B4 00           mov ah, 0
23DC A2 30 01        mov byte [Code1], al
23DF                
23DF                ;-1068     OpCodePtr ++; Code2 = *OpCodePtr;
23DF                
23DF FF 06 43 01     inc  word[OpCodePtr]
23E3 8B 1E 43 01     mov bx, [OpCodePtr]
23E7 8A 07           mov al, [bx]
23E9 B4 00           mov ah, 0
23EB A2 31 01        mov byte [Code2], al
23EE                
23EE                ;-1069     OpCodePtr ++; Code3 = *OpCodePtr;
23EE                
23EE FF 06 43 01     inc  word[OpCodePtr]
23F2 8B 1E 43 01     mov bx, [OpCodePtr]
23F6 8A 07           mov al, [bx]
23F8 B4 00           mov ah, 0
23FA A2 32 01        mov byte [Code3], al
23FD                
23FD                ;-1070 }
23FD                
23FD                
23FD                ;-1071 
23FD                
23FD                
23FD                ;-1072 int process() {
23FD                
23FD C3              ret
leaving: getCodes, loc labels: 0, loc jmp forward: 0
23FE                ENDP
23FE                
entering: process
23FE                process: PROC
23FE                
23FE                ;-1073     char c;
23FE                
23FE                
23FE                ;-1074     int i;
23FE                
23FE                
23FE                ;-1075     Op=Op2=R1Type=R2Type=R1No=R2No=dflag=wflag=rm=0;//char
23FE                
23FE                ;Function : process, Number of local variables: 2
23FE                ;   # type sign width addr used name   list of local variables
23FE                ;  200 var sign byte  1073 NULL c = bp-2
23FE                ;  201 var sign word  1074 NULL i = bp-4;
23FE C8 04 00 00     ENTER  4,0
2402 B8 00 00        mov ax, 0
2405 A2 3B 01        mov byte [rm], al
2408 A2 38 01        mov byte [wflag], al
240B A2 39 01        mov byte [dflag], al
240E A2 33 01        mov byte [R2No], al
2411 A2 34 01        mov byte [R1No], al
2414 A2 35 01        mov byte [R2Type], al
2417 A2 36 01        mov byte [R1Type], al
241A A2 2E 01        mov byte [Op2], al
241D A2 2D 01        mov byte [Op], al
2420                
2420                ;-1076     disp=imme=0;//int
2420                
2420 B8 00 00        mov ax, 0
2423 A3 3F 01        mov word [imme], ax
2426 A3 3D 01        mov word [disp], ax
2429                
2429                ;-1077     isDirect=1; //set in getMeM=0, need in WriteEA
2429                
2429 B8 01 00        mov ax, 1
242C A2 3C 01        mov byte [isDirect], al
242F                
242F                ;-1078     getTokeType();//0, DIGIT, ALNUME, NOALNUME
242F                
242F E8 B9 F2        call getTokeType
2432                
2432                ;-1079     OpSize=getCodeSize();//0, BYTE, WORD, DWORD
2432                
2432 E8 F6 FA        call getCodeSize
2435 A2 37 01        mov byte [OpSize], al
2438                
2438                ;-1080     getCodes();//set: Code1, Code2, Code3
2438                
2438 E8 95 FF        call getCodes
243B                
243B                ;-1081 
243B                
243B                
243B                ;-1082     if (CodeType ==  1) {//1 byte opcode
243B                
243B A0 2F 01        mov al, [CodeType]
243E 3C 01           cmp al, 1
2440 0F 85 00 00   r jne .process260
2444                
2444                ;-1083         genCode8(Code1);
2444                
2444 A0 30 01        mov al, byte [Code1]
2447 B4 00           mov ah, 0
2449 50              push ax
244A E8 3F EF        call genCode8
244D 83 C4 02        add  sp, 2
2450                
2450                ;-1084         return;
2450                
2450 E9 00 00      R jmp .retnprocess
2453                
2453                ;-1085     }
2453                
2453                
2453                ;-1086 
2453                
2453                
2453                ;-1087     if (CodeType ==  2) {//inc,dec,not,neg,mul,imul,div,idiv
2453                
2453                .process260:
2453 A0 2F 01        mov al, [CodeType]
2456 3C 02           cmp al, 2
2458 0F 85 00 00   r jne .process261
245C                
245C                ;-1088         getOpL();
245C                
245C E8 1D F7        call getOpL
245F                
245F                ;-1089         checkOpL();
245F                
245F E8 A5 F3        call checkOpL
2462                
2462                ;-1090         if (Code2 <= 1) {//inc,dec
2462                
2462 A0 31 01        mov al, [Code2]
2465 3C 01           cmp al, 1
2467 0F 8F 00 00   r jg  .process262
246B                
246B                ;-1091   	        if (Op == REG) {//short
246B                
246B A0 2D 01        mov al, [Op]
246E 3C 02           cmp al, 2
2470 0F 85 00 00   r jne .process263
2474                
2474                ;-1092                 if (wflag) {genCode2(Code3, R1No); return; }
2474                
2474 A0 38 01        mov al, [wflag]
2477 08 C0           or  al, al
2479 0F 84 00 00   r je .process264
247D A0 34 01        mov al, byte [R1No]
2480 B4 00           mov ah, 0
2482 50              push ax
2483 A0 32 01        mov al, byte [Code3]
2486 B4 00           mov ah, 0
2488 50              push ax
2489 E8 60 EF        call genCode2
248C 83 C4 04        add  sp, 4
248F E9 00 00      R jmp .retnprocess
2492                
2492                ;-1093             }
2492                
2492                .process264:
2492                
2492                ;-1094         }
2492                
2492                .process263:
2492                
2492                ;-1095         if (Code2 == 5) {//imul extension?
2492                
2492                .process262:
2492 A0 31 01        mov al, [Code2]
2495 3C 05           cmp al, 5
2497 0F 85 00 00   r jne .process265
249B                
249B                ;-1096             getTokeType();
249B                
249B E8 4D F2        call getTokeType
249E                
249E                ;-1097             if (TokeType) implerror();
249E                
249E A0 2C 01        mov al, [TokeType]
24A1 08 C0           or  al, al
24A3 0F 84 00 00   r je .process266
24A7 E8 B2 E6        call implerror
24AA                
24AA                ;-1098         }
24AA                
24AA                .process266:
24AA                
24AA                ;-1099         genCodeW(Code1);
24AA                
24AA                .process265:
24AA A0 30 01        mov al, byte [Code1]
24AD B4 00           mov ah, 0
24AF 50              push ax
24B0 E8 54 EF        call genCodeW
24B3 83 C4 02        add  sp, 2
24B6                
24B6                ;-1100         writeEA(Code2);
24B6                
24B6 A0 31 01        mov al, byte [Code2]
24B9 B4 00           mov ah, 0
24BB 50              push ax
24BC E8 AF EF        call writeEA
24BF 83 C4 02        add  sp, 2
24C2                
24C2                ;-1101         return;
24C2                
24C2 E9 00 00      R jmp .retnprocess
24C5                
24C5                ;-1102     }
24C5                
24C5                
24C5                ;-1103 
24C5                
24C5                
24C5                ;-1104     if (CodeType == 3) {//les,lds,lea,lss,lfs,lgs
24C5                
24C5                .process261:
24C5 A0 2F 01        mov al, [CodeType]
24C8 3C 03           cmp al, 3
24CA 0F 85 00 00   r jne .process267
24CE                
24CE                ;-1105         check2Ops();    //setwflag not applicable
24CE                
24CE E8 E2 F6        call check2Ops
24D1                
24D1                ;-1106         if (R1Type != WORD) reg16error();//only r16
24D1                
24D1 A0 36 01        mov al, [R1Type]
24D4 3C 02           cmp al, 2
24D6 0F 84 00 00   r je  .process268
24DA E8 1F E7        call reg16error
24DD                
24DD                ;-1107         if (Op2 != MEM) addrerror();//only m16
24DD                
24DD                .process268:
24DD A0 2E 01        mov al, [Op2]
24E0 3C 04           cmp al, 4
24E2 0F 84 00 00   r je  .process269
24E6 E8 34 E6        call addrerror
24E9                
24E9                ;-1108 
24E9                
24E9                
24E9                ;-1109         genCode8(Code1);//les,lds,lea
24E9                
24E9                .process269:
24E9 A0 30 01        mov al, byte [Code1]
24EC B4 00           mov ah, 0
24EE 50              push ax
24EF E8 9A EE        call genCode8
24F2 83 C4 02        add  sp, 2
24F5                
24F5                ;-1110         if (Code1 == 0x0F) genCode8(Code2);//lss,lfs,lgs
24F5                
24F5 A0 30 01        mov al, [Code1]
24F8 3C 0F           cmp al, 15
24FA 0F 85 00 00   r jne .process270
24FE A0 31 01        mov al, byte [Code2]
2501 B4 00           mov ah, 0
2503 50              push ax
2504 E8 85 EE        call genCode8
2507 83 C4 02        add  sp, 2
250A                
250A                ;-1111         Op=Op2;//set MEM for writeEA
250A                
250A                .process270:
250A A0 2E 01        mov al, [Op2]
250D A2 2D 01        mov byte [Op], al
2510                
2510                ;-1112         writeEA(R1No);
2510                
2510 A0 34 01        mov al, byte [R1No]
2513 B4 00           mov ah, 0
2515 50              push ax
2516 E8 55 EF        call writeEA
2519 83 C4 02        add  sp, 2
251C                
251C                ;-1113         return;
251C                
251C E9 00 00      R jmp .retnprocess
251F                
251F                ;-1114     }
251F                
251F                
251F                ;-1115 
251F                
251F                
251F                ;-1116     if (CodeType == 4) {//add,or,adc,sbb,and,sub,xor,cmp,->test
251F                
251F                .process267:
251F A0 2F 01        mov al, [CodeType]
2522 3C 04           cmp al, 4
2524 0F 85 00 00   r jne .process271
2528                
2528                ;-1117         check2Ops();  
2528                
2528 E8 88 F6        call check2Ops
252B                
252B                ;-1118         if (Op2 == ADR) {  
252B                
252B A0 2E 01        mov al, [Op2]
252E 3C 03           cmp al, 3
2530 0F 85 00 00   r jne .process272
2534                
2534                ;-1119             if (LabelIx == 0) notfounderror();
2534                
2534 A1 4E 01        mov ax, [LabelIx]
2537 83 F8 00        cmp ax, 0
253A 0F 85 00 00   r jne .process273
253E E8 7A E5        call notfounderror
2541                
2541                ;-1120             imme=LabelAddr[LabelIx];
2541                
2541                .process273:
2541 8B 1E 4E 01     mov bx, [LabelIx]
2545 D1 E3           shl bx, 1
2547 8B 87 CA 8E     mov ax, [LabelAddr + bx]
254B A3 3F 01        mov word [imme], ax
254E                
254E                ;-1121             Op2=IMM;//got the addr and fall through
254E                
254E B8 01 00        mov ax, 1
2551 A2 2E 01        mov byte [Op2], al
2554                
2554                ;-1122         }
2554                
2554                
2554                ;-1123         if (Op2 == IMM) {//second operand is imm
2554                
2554                .process272:
2554 A0 2E 01        mov al, [Op2]
2557 3C 01           cmp al, 1
2559 0F 85 00 00   r jne .process274
255D                
255D                ;-1124             setsflag();
255D                
255D E8 C1 F0        call setsflag
2560                
2560                ;-1125             if (Op == REG) {
2560                
2560 A0 2D 01        mov al, [Op]
2563 3C 02           cmp al, 2
2565 0F 85 00 00   r jne .process275
2569                
2569                ;-1126                 if (R1No == 0) {// acc,imm
2569                
2569 A0 34 01        mov al, [R1No]
256C 3C 00           cmp al, 0
256E 0F 85 00 00   r jne .process276
2572                
2572                ;-1127                     if (sflag == 0) {
2572                
2572 A0 3A 01        mov al, [sflag]
2575 3C 00           cmp al, 0
2577 0F 85 00 00   r jne .process277
257B                
257B                ;-1128                         c = Code1 << 3;
257B                
257B A0 30 01        mov al, [Code1]
257E C0 E0 03        shl al, 3
2581 88 46 FE        mov [bp-2], al
2584                
2584                ;-1129                         c += 4;
2584                
2584 80 46 FE 04     add  byte[bp-2], 4
2588                
2588                ;-1130                         genCodeW(c);
2588                
2588 8A 46 FE        mov al, byte [bp-2]
258B B4 00           mov ah, 0
258D 50              push ax
258E E8 76 EE        call genCodeW
2591 83 C4 02        add  sp, 2
2594                
2594                ;-1131                         genImmediate();
2594                
2594 E8 E6 EF        call genImmediate
2597                
2597                ;-1132                         return;
2597                
2597 E9 00 00      R jmp .retnprocess
259A                
259A                ;-1133                     }
259A                
259A                
259A                ;-1134                 }
259A                
259A                .process277:
259A                
259A                ;-1135             }
259A                
259A                .process276:
259A                
259A                ;-1136             //r/m, imm: 80 sign-extended,TTT,imm
259A                
259A                
259A                ;-1137             c = sflag + 0x80;
259A                
259A                .process275:
259A A0 3A 01        mov al, [sflag]
259D 04 80           add al, 128
259F 88 46 FE        mov [bp-2], al
25A2                
25A2                ;-1138             genCodeW(c);
25A2                
25A2 8A 46 FE        mov al, byte [bp-2]
25A5 B4 00           mov ah, 0
25A7 50              push ax
25A8 E8 5C EE        call genCodeW
25AB 83 C4 02        add  sp, 2
25AE                
25AE                ;-1139             writeEA(Code1);
25AE                
25AE A0 30 01        mov al, byte [Code1]
25B1 B4 00           mov ah, 0
25B3 50              push ax
25B4 E8 B7 EE        call writeEA
25B7 83 C4 02        add  sp, 2
25BA                
25BA                ;-1140             if (sflag) genCode8(imme);
25BA                
25BA A0 3A 01        mov al, [sflag]
25BD 08 C0           or  al, al
25BF 0F 84 00 00   r je .process278
25C3 FF 36 3F 01     push word [imme]
25C7 E8 C2 ED        call genCode8
25CA 83 C4 02        add  sp, 2
25CD                
25CD                ;-1141             else genImmediate();
25CD                
25CD E9 00 00      R jmp .process279
25D0                .process278:
25D0 E8 AA EF        call genImmediate
25D3                
25D3                ;-1142             return;
25D3                
25D3                .process279:
25D3 E9 00 00      R jmp .retnprocess
25D6                
25D6                ;-1143         }
25D6                
25D6                
25D6                ;-1144         c = Code1 << 3;//r/m, r/r
25D6                
25D6                .process274:
25D6 A0 30 01        mov al, [Code1]
25D9 C0 E0 03        shl al, 3
25DC 88 46 FE        mov [bp-2], al
25DF                
25DF                ;-1145         if (Op == REG) {
25DF                
25DF A0 2D 01        mov al, [Op]
25E2 3C 02           cmp al, 2
25E4 0F 85 00 00   r jne .process280
25E8                
25E8                ;-1146             if (Op2 == MEM) {//reg, mem
25E8                
25E8 A0 2E 01        mov al, [Op2]
25EB 3C 04           cmp al, 4
25ED 0F 85 00 00   r jne .process281
25F1                
25F1                ;-1147                 c += 2;//add direction flag
25F1                
25F1 80 46 FE 02     add  byte[bp-2], 2
25F5                
25F5                ;-1148                 genCodeW(c);
25F5                
25F5 8A 46 FE        mov al, byte [bp-2]
25F8 B4 00           mov ah, 0
25FA 50              push ax
25FB E8 09 EE        call genCodeW
25FE 83 C4 02        add  sp, 2
2601                
2601                ;-1149                 Op=Op2;//set MEM for writeEA
2601                
2601 A0 2E 01        mov al, [Op2]
2604 A2 2D 01        mov byte [Op], al
2607                
2607                ;-1150                 writeEA(R1No);
2607                
2607 A0 34 01        mov al, byte [R1No]
260A B4 00           mov ah, 0
260C 50              push ax
260D E8 5E EE        call writeEA
2610 83 C4 02        add  sp, 2
2613                
2613                ;-1151                 return;
2613                
2613 E9 00 00      R jmp .retnprocess
2616                
2616                ;-1152             }
2616                
2616                
2616                ;-1153         }
2616                
2616                .process281:
2616                
2616                ;-1154         if (Op2 == REG) {//mem,reg    reg,reg
2616                
2616                .process280:
2616 A0 2E 01        mov al, [Op2]
2619 3C 02           cmp al, 2
261B 0F 85 00 00   r jne .process282
261F                
261F                ;-1155             genCodeW(c);
261F                
261F 8A 46 FE        mov al, byte [bp-2]
2622 B4 00           mov ah, 0
2624 50              push ax
2625 E8 DF ED        call genCodeW
2628 83 C4 02        add  sp, 2
262B                
262B                ;-1156             writeEA(R2No);//2. Op in reg-field
262B                
262B A0 33 01        mov al, byte [R2No]
262E B4 00           mov ah, 0
2630 50              push ax
2631 E8 3A EE        call writeEA
2634 83 C4 02        add  sp, 2
2637                
2637                ;-1157             return;
2637                
2637 E9 00 00      R jmp .retnprocess
263A                
263A                ;-1158         }
263A                
263A                
263A                ;-1159         syntaxerror();
263A                
263A                .process282:
263A E8 0E E6        call syntaxerror
263D                
263D                ;-1160         return;
263D                
263D E9 00 00      R jmp .retnprocess
2640                
2640                ;-1161     }
2640                
2640                
2640                ;-1162 
2640                
2640                
2640                ;-1163     if (CodeType == 5) {//mov (movsx, movzx=51)
2640                
2640                .process271:
2640 A0 2F 01        mov al, [CodeType]
2643 3C 05           cmp al, 5
2645 0F 85 00 00   r jne .process283
2649                
2649                ;-1164         check2Ops();
2649                
2649 E8 67 F5        call check2Ops
264C                
264C                ;-1165         if (Op2 == ADR) {
264C                
264C A0 2E 01        mov al, [Op2]
264F 3C 03           cmp al, 3
2651 0F 85 00 00   r jne .process284
2655                
2655                ;-1166             if (disp) imme=disp;
2655                
2655 A1 3D 01        mov ax, [disp]
2658 08 C0           or  al, al
265A 0F 84 00 00   r je .process285
265E A1 3D 01        mov ax, [disp]
2661 A3 3F 01        mov word [imme], ax
2664                
2664                ;-1167             else notfounderror();
2664                
2664 E9 00 00      R jmp .process286
2667                .process285:
2667 E8 51 E4        call notfounderror
266A                
266A                ;-1168             Op2=IMM;//continue with IMM
266A                
266A                .process286:
266A B8 01 00        mov ax, 1
266D A2 2E 01        mov byte [Op2], al
2670                
2670                ;-1169         }
2670                
2670                
2670                ;-1170         if (Op2 == IMM) {// r,i
2670                
2670                .process284:
2670 A0 2E 01        mov al, [Op2]
2673 3C 01           cmp al, 1
2675 0F 85 00 00   r jne .process287
2679                
2679                ;-1171             if (Op == REG) {
2679                
2679 A0 2D 01        mov al, [Op]
267C 3C 02           cmp al, 2
267E 0F 85 00 00   r jne .process288
2682                
2682                ;-1172                 c = wflag << 3;
2682                
2682 A0 38 01        mov al, [wflag]
2685 C0 E0 03        shl al, 3
2688 88 46 FE        mov [bp-2], al
268B                
268B                ;-1173                 c += 0xB0;
268B                
268B 80 46 FE B0     add  byte[bp-2], 176
268F                
268F                ;-1174                 genCode2(c, R1No);
268F                
268F A0 34 01        mov al, byte [R1No]
2692 B4 00           mov ah, 0
2694 50              push ax
2695 8A 46 FE        mov al, byte [bp-2]
2698 B4 00           mov ah, 0
269A 50              push ax
269B E8 4E ED        call genCode2
269E 83 C4 04        add  sp, 4
26A1                
26A1                ;-1175                 genImmediate();
26A1                
26A1 E8 D9 EE        call genImmediate
26A4                
26A4                ;-1176                 return;
26A4                
26A4 E9 00 00      R jmp .retnprocess
26A7                
26A7                ;-1177             }
26A7                
26A7                
26A7                ;-1178             if (Op == MEM) {// m,i
26A7                
26A7                .process288:
26A7 A0 2D 01        mov al, [Op]
26AA 3C 04           cmp al, 4
26AC 0F 85 00 00   r jne .process289
26B0                
26B0                ;-1179                 genCodeW(0xC6);
26B0                
26B0 68 C6 00        push 198
26B3 E8 51 ED        call genCodeW
26B6 83 C4 02        add  sp, 2
26B9                
26B9                ;-1180                 writeEA( 0 );
26B9                
26B9 6A 00           push 0
26BB E8 B0 ED        call writeEA
26BE 83 C4 02        add  sp, 2
26C1                
26C1                ;-1181                 genImmediate();
26C1                
26C1 E8 B9 EE        call genImmediate
26C4                
26C4                ;-1182                 return;
26C4                
26C4 E9 00 00      R jmp .retnprocess
26C7                
26C7                ;-1183             }
26C7                
26C7                
26C7                ;-1184             regmemerror();
26C7                
26C7                .process289:
26C7 E8 08 E5        call regmemerror
26CA                
26CA                ;-1185             return;
26CA                
26CA E9 00 00      R jmp .retnprocess
26CD                
26CD                ;-1186         }
26CD                
26CD                
26CD                ;-1187         if (R1Type == SEGREG) ChangeDirection();//sreg,rm
26CD                
26CD                .process287:
26CD A0 36 01        mov al, [R1Type]
26D0 3C 04           cmp al, 4
26D2 0F 85 00 00   r jne .process290
26D6 E8 D0 EF        call ChangeDirection
26D9                
26D9                ;-1188         if (R2Type == SEGREG) {//rm,sreg
26D9                
26D9                .process290:
26D9 A0 35 01        mov al, [R2Type]
26DC 3C 04           cmp al, 4
26DE 0F 85 00 00   r jne .process291
26E2                
26E2                ;-1189             if (OpSize != WORD) reg16error();
26E2                
26E2 A0 37 01        mov al, [OpSize]
26E5 3C 02           cmp al, 2
26E7 0F 84 00 00   r je  .process292
26EB E8 0E E5        call reg16error
26EE                
26EE                ;-1190                 genCode2(0x8C, dflag);
26EE                
26EE                .process292:
26EE A0 39 01        mov al, byte [dflag]
26F1 B4 00           mov ah, 0
26F3 50              push ax
26F4 68 8C 00        push 140
26F7 E8 F2 EC        call genCode2
26FA 83 C4 04        add  sp, 4
26FD                
26FD                ;-1191                 writeEA(R2No);
26FD                
26FD A0 33 01        mov al, byte [R2No]
2700 B4 00           mov ah, 0
2702 50              push ax
2703 E8 68 ED        call writeEA
2706 83 C4 02        add  sp, 2
2709                
2709                ;-1192                 return;
2709                
2709 E9 00 00      R jmp .retnprocess
270C                
270C                ;-1193         }
270C                
270C                
270C                ;-1194         if (Op2 == MEM) {//acc, moffs16
270C                
270C                .process291:
270C A0 2E 01        mov al, [Op2]
270F 3C 04           cmp al, 4
2711 0F 85 00 00   r jne .process293
2715                
2715                ;-1195             if (Op == REG) {
2715                
2715 A0 2D 01        mov al, [Op]
2718 3C 02           cmp al, 2
271A 0F 85 00 00   r jne .process294
271E                
271E                ;-1196                 if (R1No == 0) {
271E                
271E A0 34 01        mov al, [R1No]
2721 3C 00           cmp al, 0
2723 0F 85 00 00   r jne .process295
2727                
2727                ;-1197                     if (isDirect) {
2727                
2727 A0 3C 01        mov al, [isDirect]
272A 08 C0           or  al, al
272C 0F 84 00 00   r je .process296
2730                
2730                ;-1198                         genCodeW(0xA0);
2730                
2730 68 A0 00        push 160
2733 E8 D1 EC        call genCodeW
2736 83 C4 02        add  sp, 2
2739                
2739                ;-1199                         genCode16(disp);
2739                
2739 FF 36 3D 01     push word [disp]
273D E8 E3 EC        call genCode16
2740 83 C4 02        add  sp, 2
2743                
2743                ;-1200                         return;
2743                
2743 E9 00 00      R jmp .retnprocess
2746                
2746                ;-1201                     }
2746                
2746                
2746                ;-1202                 }
2746                
2746                .process296:
2746                
2746                ;-1203             }
2746                
2746                .process295:
2746                
2746                ;-1204         }
2746                
2746                .process294:
2746                
2746                ;-1205         if (Op == MEM) {//moffs16, acc
2746                
2746                .process293:
2746 A0 2D 01        mov al, [Op]
2749 3C 04           cmp al, 4
274B 0F 85 00 00   r jne .process297
274F                
274F                ;-1206             if (Op2 == REG) {
274F                
274F A0 2E 01        mov al, [Op2]
2752 3C 02           cmp al, 2
2754 0F 85 00 00   r jne .process298
2758                
2758                ;-1207                 if (R2No == 0) {
2758                
2758 A0 33 01        mov al, [R2No]
275B 3C 00           cmp al, 0
275D 0F 85 00 00   r jne .process299
2761                
2761                ;-1208                     if (isDirect) {
2761                
2761 A0 3C 01        mov al, [isDirect]
2764 08 C0           or  al, al
2766 0F 84 00 00   r je .process300
276A                
276A                ;-1209                         genCodeW(0xA2);
276A                
276A 68 A2 00        push 162
276D E8 97 EC        call genCodeW
2770 83 C4 02        add  sp, 2
2773                
2773                ;-1210                         genCode16(disp);
2773                
2773 FF 36 3D 01     push word [disp]
2777 E8 A9 EC        call genCode16
277A 83 C4 02        add  sp, 2
277D                
277D                ;-1211                         return;
277D                
277D E9 00 00      R jmp .retnprocess
2780                
2780                ;-1212                     }
2780                
2780                
2780                ;-1213                 }
2780                
2780                .process300:
2780                
2780                ;-1214             }
2780                
2780                .process299:
2780                
2780                ;-1215 
2780                
2780                
2780                ;-1216         }
2780                
2780                .process298:
2780                
2780                ;-1217         if (Op2 == REG) {//rm, r
2780                
2780                .process297:
2780 A0 2E 01        mov al, [Op2]
2783 3C 02           cmp al, 2
2785 0F 85 00 00   r jne .process301
2789                
2789                ;-1218             genCodeW(0x88);
2789                
2789 68 88 00        push 136
278C E8 78 EC        call genCodeW
278F 83 C4 02        add  sp, 2
2792                
2792                ;-1219             writeEA(R2No);
2792                
2792 A0 33 01        mov al, byte [R2No]
2795 B4 00           mov ah, 0
2797 50              push ax
2798 E8 D3 EC        call writeEA
279B 83 C4 02        add  sp, 2
279E                
279E                ;-1220             return;
279E                
279E E9 00 00      R jmp .retnprocess
27A1                
27A1                ;-1221         }
27A1                
27A1                
27A1                ;-1222         if (Op2 == MEM) {//r, m
27A1                
27A1                .process301:
27A1 A0 2E 01        mov al, [Op2]
27A4 3C 04           cmp al, 4
27A6 0F 85 00 00   r jne .process302
27AA                
27AA                ;-1223             if (Op == REG) {
27AA                
27AA A0 2D 01        mov al, [Op]
27AD 3C 02           cmp al, 2
27AF 0F 85 00 00   r jne .process303
27B3                
27B3                ;-1224                 ChangeDirection();
27B3                
27B3 E8 F3 EE        call ChangeDirection
27B6                
27B6                ;-1225                 genCodeW(0x8A);
27B6                
27B6 68 8A 00        push 138
27B9 E8 4B EC        call genCodeW
27BC 83 C4 02        add  sp, 2
27BF                
27BF                ;-1226                 writeEA(R2No);
27BF                
27BF A0 33 01        mov al, byte [R2No]
27C2 B4 00           mov ah, 0
27C4 50              push ax
27C5 E8 A6 EC        call writeEA
27C8 83 C4 02        add  sp, 2
27CB                
27CB                ;-1227                 return;
27CB                
27CB E9 00 00      R jmp .retnprocess
27CE                
27CE                ;-1228             }
27CE                
27CE                
27CE                ;-1229         }
27CE                
27CE                .process303:
27CE                
27CE                ;-1230         syntaxerror();
27CE                
27CE                .process302:
27CE E8 7A E4        call syntaxerror
27D1                
27D1                ;-1231         return;
27D1                
27D1 E9 00 00      R jmp .retnprocess
27D4                
27D4                ;-1232     }
27D4                
27D4                
27D4                ;-1233 
27D4                
27D4                
27D4                ;-1234     if (CodeType == 6) {//Jcc
27D4                
27D4                .process283:
27D4 A0 2F 01        mov al, [CodeType]
27D7 3C 06           cmp al, 6
27D9 0F 85 00 00   r jne .process304
27DD                
27DD                ;-1235         if (TokeType == ALNUME) {
27DD                
27DD A0 2C 01        mov al, [TokeType]
27E0 3C 03           cmp al, 3
27E2 0F 85 00 00   r jne .process305
27E6                
27E6                ;-1236             LabelIx=searchLabel();
27E6                
27E6 E8 A0 F0        call searchLabel
27E9 A3 4E 01        mov word [LabelIx], ax
27EC                
27EC                ;-1237             if (LabelIx > 0) {
27EC                
27EC A1 4E 01        mov ax, [LabelIx]
27EF 83 F8 00        cmp ax, 0
27F2 0F 8E 00 00   r jle .process306
27F6                
27F6                ;-1238                 disp=LabelAddr[LabelIx];
27F6                
27F6 8B 1E 4E 01     mov bx, [LabelIx]
27FA D1 E3           shl bx, 1
27FC 8B 87 CA 8E     mov ax, [LabelAddr + bx]
2800 A3 3D 01        mov word [disp], ax
2803                
2803                ;-1239                 disp = disp - PC;
2803                
2803 A1 3D 01        mov ax, [disp]
2806 2B 06 23 01     sub ax, [PC]
280A A3 3D 01        mov word [disp], ax
280D                
280D                ;-1240                 disp = disp - Origin;
280D                
280D A1 3D 01        mov ax, [disp]
2810 2B 06 25 01     sub ax, [Origin]
2814 A3 3D 01        mov word [disp], ax
2817                
2817                ;-1241                 if (checkConstSize(disp) ) {
2817                
2817 FF 36 3D 01     push word [disp]
281B E8 5F EE        call checkConstSize
281E 83 C4 02        add  sp, 2
2821 08 C0           or  al, al
2823 0F 84 00 00   r je .process307
2827                
2827                ;-1242                     genCode2(Code1, 0x70);//short
2827                
2827 6A 70           push 112
2829 A0 30 01        mov al, byte [Code1]
282C B4 00           mov ah, 0
282E 50              push ax
282F E8 BA EB        call genCode2
2832 83 C4 04        add  sp, 4
2835                
2835                ;-1243                     disp -= 2;
2835                
2835 83 2E 3D 01 02  sub  word[disp], 2
283A                
283A                ;-1244                     genCode8(disp);
283A                
283A FF 36 3D 01     push word [disp]
283E E8 4B EB        call genCode8
2841 83 C4 02        add  sp, 2
2844                
2844                ;-1245                 } else {
2844                
2844 E9 00 00      R jmp .process308
2847                .process307:
2847                
2847                ;-1246                     genCode8(0x0F);
2847                
2847 6A 0F           push 15
2849 E8 40 EB        call genCode8
284C 83 C4 02        add  sp, 2
284F                
284F                ;-1247                     genCode2(Code1, 0x80);//near
284F                
284F 68 80 00        push 128
2852 A0 30 01        mov al, byte [Code1]
2855 B4 00           mov ah, 0
2857 50              push ax
2858 E8 91 EB        call genCode2
285B 83 C4 04        add  sp, 4
285E                
285E                ;-1248                     disp -= 4;
285E                
285E 83 2E 3D 01 04  sub  word[disp], 4
2863                
2863                ;-1249                     genCode16(disp);
2863                
2863 FF 36 3D 01     push word [disp]
2867 E8 B9 EB        call genCode16
286A 83 C4 02        add  sp, 2
286D                
286D                ;-1250                 }
286D                
286D                
286D                ;-1251             }
286D                
286D                .process308:
286D                
286D                ;-1252             else {//jump forward, near only
286D                
286D E9 00 00      R jmp .process309
2870                .process306:
2870                
2870                ;-1253                 genCode8(0x0F);
2870                
2870 6A 0F           push 15
2872 E8 17 EB        call genCode8
2875 83 C4 02        add  sp, 2
2878                
2878                ;-1254                 genCode2(Code1, 0x80);
2878                
2878 68 80 00        push 128
287B A0 30 01        mov al, byte [Code1]
287E B4 00           mov ah, 0
2880 50              push ax
2881 E8 68 EB        call genCode2
2884 83 C4 04        add  sp, 4
2887                
2887                ;-1255                 storeJmp();
2887                
2887 E8 60 F3        call storeJmp
288A                
288A                ;-1256                 genCode16(0);
288A                
288A 6A 00           push 0
288C E8 94 EB        call genCode16
288F 83 C4 02        add  sp, 2
2892                
2892                ;-1257                 PrintRA='r';
2892                
2892 B8 72 00        mov ax, 114
2895 A2 45 01        mov byte [PrintRA], al
2898                
2898                ;-1258             }
2898                
2898                
2898                ;-1259         return;
2898                
2898                .process309:
2898 E9 00 00      R jmp .retnprocess
289B                
289B                ;-1260         }
289B                
289B                
289B                ;-1261     }
289B                
289B                .process305:
289B                
289B                ;-1262 
289B                
289B                
289B                ;-1263     if (CodeType == 7) {//jmp, call
289B                
289B                .process304:
289B A0 2F 01        mov al, [CodeType]
289E 3C 07           cmp al, 7
28A0 0F 85 00 00   r jne .process310
28A4                
28A4                ;-1264         if (TokeType == ALNUME) {
28A4                
28A4 A0 2C 01        mov al, [TokeType]
28A7 3C 03           cmp al, 3
28A9 0F 85 00 00   r jne .process311
28AD                
28AD                ;-1265             LabelIx=searchLabel();
28AD                
28AD E8 D9 EF        call searchLabel
28B0 A3 4E 01        mov word [LabelIx], ax
28B3                
28B3                ;-1266             if (LabelIx > 0) {
28B3                
28B3 A1 4E 01        mov ax, [LabelIx]
28B6 83 F8 00        cmp ax, 0
28B9 0F 8E 00 00   r jle .process312
28BD                
28BD                ;-1267                 disp=LabelAddr[LabelIx];
28BD                
28BD 8B 1E 4E 01     mov bx, [LabelIx]
28C1 D1 E3           shl bx, 1
28C3 8B 87 CA 8E     mov ax, [LabelAddr + bx]
28C7 A3 3D 01        mov word [disp], ax
28CA                
28CA                ;-1268                 disp = disp - PC;
28CA                
28CA A1 3D 01        mov ax, [disp]
28CD 2B 06 23 01     sub ax, [PC]
28D1 A3 3D 01        mov word [disp], ax
28D4                
28D4                ;-1269                 disp = disp - Origin;
28D4                
28D4 A1 3D 01        mov ax, [disp]
28D7 2B 06 25 01     sub ax, [Origin]
28DB A3 3D 01        mov word [disp], ax
28DE                
28DE                ;-1270                 if (checkConstSize(disp) ) {
28DE                
28DE FF 36 3D 01     push word [disp]
28E2 E8 98 ED        call checkConstSize
28E5 83 C4 02        add  sp, 2
28E8 08 C0           or  al, al
28EA 0F 84 00 00   r je .process313
28EE                
28EE                ;-1271                     if (Code1 == 0xE9) {//jmp only
28EE                
28EE A0 30 01        mov al, [Code1]
28F1 3C E9           cmp al, 233
28F3 0F 85 00 00   r jne .process314
28F7                
28F7                ;-1272                         genCode8(0xEB);//short
28F7                
28F7 68 EB 00        push 235
28FA E8 8F EA        call genCode8
28FD 83 C4 02        add  sp, 2
2900                
2900                ;-1273                         disp -= 2;
2900                
2900 83 2E 3D 01 02  sub  word[disp], 2
2905                
2905                ;-1274                         genCode8(disp);
2905                
2905 FF 36 3D 01     push word [disp]
2909 E8 80 EA        call genCode8
290C 83 C4 02        add  sp, 2
290F                
290F                ;-1275                     }
290F                
290F                
290F                ;-1276                     else {
290F                
290F E9 00 00      R jmp .process315
2912                .process314:
2912                
2912                ;-1277                         genCode8(Code1);//near
2912                
2912 A0 30 01        mov al, byte [Code1]
2915 B4 00           mov ah, 0
2917 50              push ax
2918 E8 71 EA        call genCode8
291B 83 C4 02        add  sp, 2
291E                
291E                ;-1278                         disp -= 3;
291E                
291E 83 2E 3D 01 03  sub  word[disp], 3
2923                
2923                ;-1279                         genCode16(disp);
2923                
2923 FF 36 3D 01     push word [disp]
2927 E8 F9 EA        call genCode16
292A 83 C4 02        add  sp, 2
292D                
292D                ;-1280                     }
292D                
292D                
292D                ;-1281                 }
292D                
292D                .process315:
292D                
292D                ;-1282                 else {
292D                
292D E9 00 00      R jmp .process316
2930                .process313:
2930                
2930                ;-1283                     genCode8(Code1);//near
2930                
2930 A0 30 01        mov al, byte [Code1]
2933 B4 00           mov ah, 0
2935 50              push ax
2936 E8 53 EA        call genCode8
2939 83 C4 02        add  sp, 2
293C                
293C                ;-1284                     disp -= 3;
293C                
293C 83 2E 3D 01 03  sub  word[disp], 3
2941                
2941                ;-1285                     genCode16(disp);
2941                
2941 FF 36 3D 01     push word [disp]
2945 E8 DB EA        call genCode16
2948 83 C4 02        add  sp, 2
294B                
294B                ;-1286                 }
294B                
294B                
294B                ;-1287             }
294B                
294B                .process316:
294B                
294B                ;-1288             else {//jump forward, near only
294B                
294B E9 00 00      R jmp .process317
294E                .process312:
294E                
294E                ;-1289                 genCode8(Code1);  
294E                
294E A0 30 01        mov al, byte [Code1]
2951 B4 00           mov ah, 0
2953 50              push ax
2954 E8 35 EA        call genCode8
2957 83 C4 02        add  sp, 2
295A                
295A                ;-1290                 if (PC != 1) storeJmp();//omit jmp main
295A                
295A A1 23 01        mov ax, [PC]
295D 83 F8 01        cmp ax, 1
2960 0F 84 00 00   r je  .process318
2964 E8 83 F2        call storeJmp
2967                
2967                ;-1291                 genCode16(0);
2967                
2967                .process318:
2967 6A 00           push 0
2969 E8 B7 EA        call genCode16
296C 83 C4 02        add  sp, 2
296F                
296F                ;-1292                 PrintRA='R';
296F                
296F B8 52 00        mov ax, 82
2972 A2 45 01        mov byte [PrintRA], al
2975                
2975                ;-1293             }
2975                
2975                
2975                ;-1294         return;
2975                
2975                .process317:
2975 E9 00 00      R jmp .retnprocess
2978                
2978                ;-1295         }
2978                
2978                
2978                ;-1296     }
2978                
2978                .process311:
2978                
2978                ;-1297 
2978                
2978                
2978                ;-1298     if (CodeType ==  8) {//ret,retf
2978                
2978                .process310:
2978 A0 2F 01        mov al, [CodeType]
297B 3C 08           cmp al, 8
297D 0F 85 00 00   r jne .process319
2981                
2981                ;-1299         if (TokeType == DIGIT) {
2981                
2981 A0 2C 01        mov al, [TokeType]
2984 3C 01           cmp al, 1
2986 0F 85 00 00   r jne .process320
298A                
298A                ;-1300             genCode8(Code2);
298A                
298A A0 31 01        mov al, byte [Code2]
298D B4 00           mov ah, 0
298F 50              push ax
2990 E8 F9 E9        call genCode8
2993 83 C4 02        add  sp, 2
2996                
2996                ;-1301             genCode16(SymbolInt);
2996                
2996 FF 36 0E 01     push word [SymbolInt]
299A E8 86 EA        call genCode16
299D 83 C4 02        add  sp, 2
29A0                
29A0                ;-1302             return;
29A0                
29A0 E9 00 00      R jmp .retnprocess
29A3                
29A3                ;-1303         }
29A3                
29A3                
29A3                ;-1304         genCode8(Code1);
29A3                
29A3                .process320:
29A3 A0 30 01        mov al, byte [Code1]
29A6 B4 00           mov ah, 0
29A8 50              push ax
29A9 E8 E0 E9        call genCode8
29AC 83 C4 02        add  sp, 2
29AF                
29AF                ;-1305         return;
29AF                
29AF E9 00 00      R jmp .retnprocess
29B2                
29B2                ;-1306     }
29B2                
29B2                
29B2                ;-1307 
29B2                
29B2                
29B2                ;-1308     if (CodeType == 9) {//push, pop
29B2                
29B2                .process319:
29B2 A0 2F 01        mov al, [CodeType]
29B5 3C 09           cmp al, 9
29B7 0F 85 00 00   r jne .process321
29BB                
29BB                ;-1309         getOpL();
29BB                
29BB E8 BE F1        call getOpL
29BE                
29BE                ;-1310         if (Code1 == 0x50) {//push only
29BE                
29BE A0 30 01        mov al, [Code1]
29C1 3C 50           cmp al, 80
29C3 0F 85 00 00   r jne .process322
29C7                
29C7                ;-1311             if (Op == IMM) {//push imm8,16
29C7                
29C7 A0 2D 01        mov al, [Op]
29CA 3C 01           cmp al, 1
29CC 0F 85 00 00   r jne .process323
29D0                
29D0                ;-1312                 setsflag();
29D0                
29D0 E8 4E EC        call setsflag
29D3                
29D3                ;-1313                 genCode2(0x68, sflag);
29D3                
29D3 A0 3A 01        mov al, byte [sflag]
29D6 B4 00           mov ah, 0
29D8 50              push ax
29D9 6A 68           push 104
29DB E8 0E EA        call genCode2
29DE 83 C4 04        add  sp, 4
29E1                
29E1                ;-1314                 if (sflag) genCode8 (imme);
29E1                
29E1 A0 3A 01        mov al, [sflag]
29E4 08 C0           or  al, al
29E6 0F 84 00 00   r je .process324
29EA FF 36 3F 01     push word [imme]
29EE E8 9B E9        call genCode8
29F1 83 C4 02        add  sp, 2
29F4                
29F4                ;-1315                 else       genCode16(imme);
29F4                
29F4 E9 00 00      R jmp .process325
29F7                .process324:
29F7 FF 36 3F 01     push word [imme]
29FB E8 25 EA        call genCode16
29FE 83 C4 02        add  sp, 2
2A01                
2A01                ;-1316                 return;
2A01                
2A01                .process325:
2A01 E9 00 00      R jmp .retnprocess
2A04                
2A04                ;-1317             }
2A04                
2A04                
2A04                ;-1318             if (Op == ADR) {//push string ABSOLUTE i16 
2A04                
2A04                .process323:
2A04 A0 2D 01        mov al, [Op]
2A07 3C 03           cmp al, 3
2A09 0F 85 00 00   r jne .process326
2A0D                
2A0D                ;-1319                 if (disp) {
2A0D                
2A0D A1 3D 01        mov ax, [disp]
2A10 08 C0           or  al, al
2A12 0F 84 00 00   r je .process327
2A16                
2A16                ;-1320                     genCode8(0x68);
2A16                
2A16 6A 68           push 104
2A18 E8 71 E9        call genCode8
2A1B 83 C4 02        add  sp, 2
2A1E                
2A1E                ;-1321                     genCode16(disp);
2A1E                
2A1E FF 36 3D 01     push word [disp]
2A22 E8 FE E9        call genCode16
2A25 83 C4 02        add  sp, 2
2A28                
2A28                ;-1322                     return;
2A28                
2A28 E9 00 00      R jmp .retnprocess
2A2B                
2A2B                ;-1323                 }
2A2B                
2A2B                
2A2B                ;-1324                 else {
2A2B                
2A2B E9 00 00      R jmp .process328
2A2E                .process327:
2A2E                
2A2E                ;-1325                     genCode8(0x68);
2A2E                
2A2E 6A 68           push 104
2A30 E8 59 E9        call genCode8
2A33 83 C4 02        add  sp, 2
2A36                
2A36                ;-1326                     storeJmp();
2A36                
2A36 E8 B1 F1        call storeJmp
2A39                
2A39                ;-1327                     genCode16(0xAAAA);//magic for abs ADR
2A39                
2A39 68 AA AA        push 43690
2A3C E8 E4 E9        call genCode16
2A3F 83 C4 02        add  sp, 2
2A42                
2A42                ;-1328                     PrintRA='A';
2A42                
2A42 B8 41 00        mov ax, 65
2A45 A2 45 01        mov byte [PrintRA], al
2A48                
2A48                ;-1329                     return;
2A48                
2A48 E9 00 00      R jmp .retnprocess
2A4B                
2A4B                ;-1330                 }
2A4B                
2A4B                
2A4B                ;-1331             }
2A4B                
2A4B                .process328:
2A4B                
2A4B                ;-1332         }
2A4B                
2A4B                .process326:
2A4B                
2A4B                ;-1333         if (R1Type == SEGREG) {
2A4B                
2A4B                .process322:
2A4B A0 36 01        mov al, [R1Type]
2A4E 3C 04           cmp al, 4
2A50 0F 85 00 00   r jne .process329
2A54                
2A54                ;-1334             if (Code1 == 0x58) {//pop only
2A54                
2A54 A0 30 01        mov al, [Code1]
2A57 3C 58           cmp al, 88
2A59 0F 85 00 00   r jne .process330
2A5D                
2A5D                ;-1335                 if (R1No == 1) error1("pop cs not allowed");
2A5D                
2A5D A0 34 01        mov al, [R1No]
2A60 3C 01           cmp al, 1
2A62 0F 85 00 00   r jne .process331
2A66 68 AA AA      A push process_0
2A69 E8 DE DF        call error1
2A6C 83 C4 02        add  sp, 2
2A6F                
2A6F                ;-1336             }
2A6F                
2A6F                .process331:
2A6F                
2A6F                ;-1337             c = R1No <<3;
2A6F                
2A6F                .process330:
2A6F A0 34 01        mov al, [R1No]
2A72 C0 E0 03        shl al, 3
2A75 88 46 FE        mov [bp-2], al
2A78                
2A78                ;-1338             if (R1No > 3) {//FS, GS
2A78                
2A78 A0 34 01        mov al, [R1No]
2A7B 3C 03           cmp al, 3
2A7D 0F 8E 00 00   r jle .process332
2A81                
2A81                ;-1339                 c += 122;  //0x7A
2A81                
2A81 80 46 FE 7A     add  byte[bp-2], 122
2A85                
2A85                ;-1340                 genCode8(0x0F);
2A85                
2A85 6A 0F           push 15
2A87 E8 02 E9        call genCode8
2A8A 83 C4 02        add  sp, 2
2A8D                
2A8D                ;-1341             }
2A8D                
2A8D                
2A8D                ;-1342             if (Code1 == 0x50) c +=6;//push
2A8D                
2A8D                .process332:
2A8D A0 30 01        mov al, [Code1]
2A90 3C 50           cmp al, 80
2A92 0F 85 00 00   r jne .process333
2A96 80 46 FE 06     add  byte[bp-2], 6
2A9A                
2A9A                ;-1343                 else c += 7;//pop
2A9A                
2A9A E9 00 00      R jmp .process334
2A9D                .process333:
2A9D 80 46 FE 07     add  byte[bp-2], 7
2AA1                
2AA1                ;-1344             genCode8(c);
2AA1                
2AA1                .process334:
2AA1 8A 46 FE        mov al, byte [bp-2]
2AA4 B4 00           mov ah, 0
2AA6 50              push ax
2AA7 E8 E2 E8        call genCode8
2AAA 83 C4 02        add  sp, 2
2AAD                
2AAD                ;-1345             return;
2AAD                
2AAD E9 00 00      R jmp .retnprocess
2AB0                
2AB0                ;-1346         } 
2AB0                
2AB0                
2AB0                ;-1347         
2AB0                
2AB0                
2AB0                ;-1348         checkOpL();//sorts out:ADR,SEGREG  resting: REG, MEM    
2AB0                
2AB0                .process329:
2AB0 E8 54 ED        call checkOpL
2AB3                
2AB3                ;-1349 //prs("\nOp: "); printIntU(Op); prs(", R1Type: "); printIntU(R1Type);
2AB3                
2AB3                
2AB3                ;-1350 
2AB3                
2AB3                
2AB3                ;-1351         if (Op == MEM) {
2AB3                
2AB3 A0 2D 01        mov al, [Op]
2AB6 3C 04           cmp al, 4
2AB8 0F 85 00 00   r jne .process335
2ABC                
2ABC                ;-1352             if (Code1 == 0x50) {//push word [bp+6]
2ABC                
2ABC A0 30 01        mov al, [Code1]
2ABF 3C 50           cmp al, 80
2AC1 0F 85 00 00   r jne .process336
2AC5                
2AC5                ;-1353                 genCode8(0xFF);
2AC5                
2AC5 68 FF 00        push 255
2AC8 E8 C1 E8        call genCode8
2ACB 83 C4 02        add  sp, 2
2ACE                
2ACE                ;-1354                 writeEA(6);
2ACE                
2ACE 6A 06           push 6
2AD0 E8 9B E9        call writeEA
2AD3 83 C4 02        add  sp, 2
2AD6                
2AD6                ;-1355             }else {
2AD6                
2AD6 E9 00 00      R jmp .process337
2AD9                .process336:
2AD9                
2AD9                ;-1356                 genCode8(0x8F);
2AD9                
2AD9 68 8F 00        push 143
2ADC E8 AD E8        call genCode8
2ADF 83 C4 02        add  sp, 2
2AE2                
2AE2                ;-1357                 writeEA(0);
2AE2                
2AE2 6A 00           push 0
2AE4 E8 87 E9        call writeEA
2AE7 83 C4 02        add  sp, 2
2AEA                
2AEA                ;-1358             }
2AEA                
2AEA                
2AEA                ;-1359             return;
2AEA                
2AEA                .process337:
2AEA E9 00 00      R jmp .retnprocess
2AED                
2AED                ;-1360         }
2AED                
2AED                
2AED                ;-1361         
2AED                
2AED                
2AED                ;-1362         if (R1Type == BYTE) reg16error();
2AED                
2AED                .process335:
2AED A0 36 01        mov al, [R1Type]
2AF0 3C 01           cmp al, 1
2AF2 0F 85 00 00   r jne .process338
2AF6 E8 03 E1        call reg16error
2AF9                
2AF9                ;-1363         if (R1Type == WORD) {//is REG, w/o SEGREG
2AF9                
2AF9                .process338:
2AF9 A0 36 01        mov al, [R1Type]
2AFC 3C 02           cmp al, 2
2AFE 0F 85 00 00   r jne .process339
2B02                
2B02                ;-1364             genCode2(Code1, R1No);
2B02                
2B02 A0 34 01        mov al, byte [R1No]
2B05 B4 00           mov ah, 0
2B07 50              push ax
2B08 A0 30 01        mov al, byte [Code1]
2B0B B4 00           mov ah, 0
2B0D 50              push ax
2B0E E8 DB E8        call genCode2
2B11 83 C4 04        add  sp, 4
2B14                
2B14                ;-1365             return;
2B14                
2B14 E9 00 00      R jmp .retnprocess
2B17                
2B17                ;-1366         }  
2B17                
2B17                
2B17                ;-1367         
2B17                
2B17                
2B17                ;-1368         syntaxerror();
2B17                
2B17                .process339:
2B17 E8 31 E1        call syntaxerror
2B1A                
2B1A                ;-1369         return;
2B1A                
2B1A E9 00 00      R jmp .retnprocess
2B1D                
2B1D                ;-1370     }
2B1D                
2B1D                
2B1D                ;-1371 
2B1D                
2B1D                
2B1D                ;-1372     if (CodeType == 11) {//shift, rotate
2B1D                
2B1D                .process321:
2B1D A0 2F 01        mov al, [CodeType]
2B20 3C 0B           cmp al, 11
2B22 0F 85 00 00   r jne .process340
2B26                
2B26                ;-1373         check2Ops();
2B26                
2B26 E8 8A F0        call check2Ops
2B29                
2B29                ;-1374         if (Op2 == IMM) {
2B29                
2B29 A0 2E 01        mov al, [Op2]
2B2C 3C 01           cmp al, 1
2B2E 0F 85 00 00   r jne .process341
2B32                
2B32                ;-1375             if (imme == 1) {
2B32                
2B32 A1 3F 01        mov ax, [imme]
2B35 83 F8 01        cmp ax, 1
2B38 0F 85 00 00   r jne .process342
2B3C                
2B3C                ;-1376                 genCodeW(0xD0);
2B3C                
2B3C 68 D0 00        push 208
2B3F E8 C5 E8        call genCodeW
2B42 83 C4 02        add  sp, 2
2B45                
2B45                ;-1377                 writeEA(Code1);
2B45                
2B45 A0 30 01        mov al, byte [Code1]
2B48 B4 00           mov ah, 0
2B4A 50              push ax
2B4B E8 20 E9        call writeEA
2B4E 83 C4 02        add  sp, 2
2B51                
2B51                ;-1378                 return;
2B51                
2B51 E9 00 00      R jmp .retnprocess
2B54                
2B54                ;-1379             }
2B54                
2B54                
2B54                ;-1380             genCodeW(0xC0);//80186
2B54                
2B54                .process342:
2B54 68 C0 00        push 192
2B57 E8 AD E8        call genCodeW
2B5A 83 C4 02        add  sp, 2
2B5D                
2B5D                ;-1381             writeEA(Code1);
2B5D                
2B5D A0 30 01        mov al, byte [Code1]
2B60 B4 00           mov ah, 0
2B62 50              push ax
2B63 E8 08 E9        call writeEA
2B66 83 C4 02        add  sp, 2
2B69                
2B69                ;-1382             genCode8(imme);
2B69                
2B69 FF 36 3F 01     push word [imme]
2B6D E8 1C E8        call genCode8
2B70 83 C4 02        add  sp, 2
2B73                
2B73                ;-1383             return;
2B73                
2B73 E9 00 00      R jmp .retnprocess
2B76                
2B76                ;-1384         }
2B76                
2B76                
2B76                ;-1385         if (Op2 == REG) {
2B76                
2B76                .process341:
2B76 A0 2E 01        mov al, [Op2]
2B79 3C 02           cmp al, 2
2B7B 0F 85 00 00   r jne .process343
2B7F                
2B7F                ;-1386             if (R2Type == BYTE) {
2B7F                
2B7F A0 35 01        mov al, [R2Type]
2B82 3C 01           cmp al, 1
2B84 0F 85 00 00   r jne .process344
2B88                
2B88                ;-1387                 if (R2No == 1) {//CL-REG
2B88                
2B88 A0 33 01        mov al, [R2No]
2B8B 3C 01           cmp al, 1
2B8D 0F 85 00 00   r jne .process345
2B91                
2B91                ;-1388                     if (R1Type == WORD) wflag=1;//hack
2B91                
2B91 A0 36 01        mov al, [R1Type]
2B94 3C 02           cmp al, 2
2B96 0F 85 00 00   r jne .process346
2B9A B8 01 00        mov ax, 1
2B9D A2 38 01        mov byte [wflag], al
2BA0                
2BA0                ;-1389                     genCodeW(0xD2);
2BA0                
2BA0                .process346:
2BA0 68 D2 00        push 210
2BA3 E8 61 E8        call genCodeW
2BA6 83 C4 02        add  sp, 2
2BA9                
2BA9                ;-1390                     writeEA(Code1);
2BA9                
2BA9 A0 30 01        mov al, byte [Code1]
2BAC B4 00           mov ah, 0
2BAE 50              push ax
2BAF E8 BC E8        call writeEA
2BB2 83 C4 02        add  sp, 2
2BB5                
2BB5                ;-1391                     return;
2BB5                
2BB5 E9 00 00      R jmp .retnprocess
2BB8                
2BB8                ;-1392                 }
2BB8                
2BB8                
2BB8                ;-1393             }
2BB8                
2BB8                .process345:
2BB8                
2BB8                ;-1394         }
2BB8                
2BB8                .process344:
2BB8                
2BB8                ;-1395     }
2BB8                
2BB8                .process343:
2BB8                
2BB8                ;-1396 
2BB8                
2BB8                
2BB8                ;-1397     if (CodeType == 12) {//int
2BB8                
2BB8                .process340:
2BB8 A0 2F 01        mov al, [CodeType]
2BBB 3C 0C           cmp al, 12
2BBD 0F 85 00 00   r jne .process347
2BC1                
2BC1                ;-1398         if (TokeType == DIGIT) {
2BC1                
2BC1 A0 2C 01        mov al, [TokeType]
2BC4 3C 01           cmp al, 1
2BC6 0F 85 00 00   r jne .process348
2BCA                
2BCA                ;-1399             genCode8(Code1);
2BCA                
2BCA A0 30 01        mov al, byte [Code1]
2BCD B4 00           mov ah, 0
2BCF 50              push ax
2BD0 E8 B9 E7        call genCode8
2BD3 83 C4 02        add  sp, 2
2BD6                
2BD6                ;-1400             genCode8(SymbolInt);
2BD6                
2BD6 FF 36 0E 01     push word [SymbolInt]
2BDA E8 AF E7        call genCode8
2BDD 83 C4 02        add  sp, 2
2BE0                
2BE0                ;-1401             return;
2BE0                
2BE0 E9 00 00      R jmp .retnprocess
2BE3                
2BE3                ;-1402         }
2BE3                
2BE3                
2BE3                ;-1403     }
2BE3                
2BE3                .process348:
2BE3                
2BE3                ;-1404 
2BE3                
2BE3                
2BE3                ;-1405     if (CodeType == 30) {//enter i18,i8
2BE3                
2BE3                .process347:
2BE3 A0 2F 01        mov al, [CodeType]
2BE6 3C 1E           cmp al, 30
2BE8 0F 85 00 00   r jne .process349
2BEC                
2BEC                ;-1406         genCode8(0xC8);
2BEC                
2BEC 68 C8 00        push 200
2BEF E8 9A E7        call genCode8
2BF2 83 C4 02        add  sp, 2
2BF5                
2BF5                ;-1407         Op=getOp1();
2BF5                
2BF5 E8 E5 EC        call getOp1
2BF8 A2 2D 01        mov byte [Op], al
2BFB                
2BFB                ;-1408         if (Op == IMM) genCode16(SymbolInt);
2BFB                
2BFB A0 2D 01        mov al, [Op]
2BFE 3C 01           cmp al, 1
2C00 0F 85 00 00   r jne .process350
2C04 FF 36 0E 01     push word [SymbolInt]
2C08 E8 18 E8        call genCode16
2C0B 83 C4 02        add  sp, 2
2C0E                
2C0E                ;-1409         else numbererror();
2C0E                
2C0E E9 00 00      R jmp .process351
2C11                .process350:
2C11 E8 A4 DF        call numbererror
2C14                
2C14                ;-1410         need(',');
2C14                
2C14                .process351:
2C14 6A 2C           push 44
2C16 E8 86 EB        call need
2C19 83 C4 02        add  sp, 2
2C1C                
2C1C                ;-1411         Op=getOp1();
2C1C                
2C1C E8 BE EC        call getOp1
2C1F A2 2D 01        mov byte [Op], al
2C22                
2C22                ;-1412         if (Op == IMM) genCode8 (SymbolInt);
2C22                
2C22 A0 2D 01        mov al, [Op]
2C25 3C 01           cmp al, 1
2C27 0F 85 00 00   r jne .process352
2C2B FF 36 0E 01     push word [SymbolInt]
2C2F E8 5A E7        call genCode8
2C32 83 C4 02        add  sp, 2
2C35                
2C35                ;-1413         else numbererror();
2C35                
2C35 E9 00 00      R jmp .process353
2C38                .process352:
2C38 E8 7D DF        call numbererror
2C3B                
2C3B                ;-1414         return;
2C3B                
2C3B                .process353:
2C3B E9 00 00      R jmp .retnprocess
2C3E                
2C3E                ;-1415     }
2C3E                
2C3E                
2C3E                ;-1416 
2C3E                
2C3E                
2C3E                ;-1417     if (CodeType == 51) {//movsx, movzx=51
2C3E                
2C3E                .process349:
2C3E A0 2F 01        mov al, [CodeType]
2C41 3C 33           cmp al, 51
2C43 0F 85 00 00   r jne .process354
2C47                
2C47                ;-1418         implerror();
2C47                
2C47 E8 12 DF        call implerror
2C4A                
2C4A                ;-1419         return;   
2C4A                
2C4A E9 00 00      R jmp .retnprocess
2C4D                
2C4D                ;-1420     }
2C4D                
2C4D                
2C4D                ;-1421 
2C4D                
2C4D                
2C4D                ;-1422     if (CodeType==101) {//ORG nn
2C4D                
2C4D                .process354:
2C4D A0 2F 01        mov al, [CodeType]
2C50 3C 65           cmp al, 101
2C52 0F 85 00 00   r jne .process355
2C56                
2C56                ;-1423         if (TokeType != DIGIT) numbererror();
2C56                
2C56 A0 2C 01        mov al, [TokeType]
2C59 3C 01           cmp al, 1
2C5B 0F 84 00 00   r je  .process356
2C5F E8 56 DF        call numbererror
2C62                
2C62                ;-1424         Origin=SymbolInt;
2C62                
2C62                .process356:
2C62 A1 0E 01        mov ax, [SymbolInt]
2C65 A3 25 01        mov word [Origin], ax
2C68                
2C68                ;-1425         return;
2C68                
2C68 E9 00 00      R jmp .retnprocess
2C6B                
2C6B                ;-1426     }
2C6B                
2C6B                
2C6B                ;-1427 
2C6B                
2C6B                
2C6B                ;-1428     if (CodeType == 102) {//section, segment
2C6B                
2C6B                .process355:
2C6B A0 2F 01        mov al, [CodeType]
2C6E 3C 66           cmp al, 102
2C70 0F 85 00 00   r jne .process357
2C74                
2C74                ;-1429         //getTokeType();//ignore .bss .text .data
2C74                
2C74                
2C74                ;-1430         AbsoluteLab=0;//nasm resets erevy time
2C74                
2C74 B8 00 00        mov ax, 0
2C77 A3 27 01        mov word [AbsoluteLab], ax
2C7A                
2C7A                ;-1431         return;
2C7A                
2C7A E9 00 00      R jmp .retnprocess
2C7D                
2C7D                ;-1432     }
2C7D                
2C7D                
2C7D                ;-1433 
2C7D                
2C7D                
2C7D                ;-1434     if (CodeType == 110) {//absolute
2C7D                
2C7D                .process357:
2C7D A0 2F 01        mov al, [CodeType]
2C80 3C 6E           cmp al, 110
2C82 0F 85 00 00   r jne .process358
2C86                
2C86                ;-1435         if (TokeType != DIGIT) numbererror();
2C86                
2C86 A0 2C 01        mov al, [TokeType]
2C89 3C 01           cmp al, 1
2C8B 0F 84 00 00   r je  .process359
2C8F E8 26 DF        call numbererror
2C92                
2C92                ;-1436         AbsoluteLab=SymbolInt;
2C92                
2C92                .process359:
2C92 A1 0E 01        mov ax, [SymbolInt]
2C95 A3 27 01        mov word [AbsoluteLab], ax
2C98                
2C98                ;-1437         return;
2C98                
2C98 E9 00 00      R jmp .retnprocess
2C9B                
2C9B                ;-1438     }
2C9B                
2C9B                
2C9B                ;-1439     if (CodeType == 111) {//name: PROC
2C9B                
2C9B                .process358:
2C9B A0 2F 01        mov al, [CodeType]
2C9E 3C 6F           cmp al, 111
2CA0 0F 85 00 00   r jne .process360
2CA4                
2CA4                ;-1440         if (isInProc == 0)  {
2CA4                
2CA4 A0 0D 01        mov al, [isInProc]
2CA7 3C 00           cmp al, 0
2CA9 0F 85 00 00   r jne .process361
2CAD                
2CAD                ;-1441             prs("\nentering: ");
2CAD                
2CAD 68 AA AA      A push process_1
2CB0 E8 80 DA        call prs
2CB3 83 C4 02        add  sp, 2
2CB6                
2CB6                ;-1442             prs(ProcName);
2CB6                
2CB6 8D 06 6E 75     lea  ax, [ProcName]
2CBA 50              push ax
2CBB E8 75 DA        call prs
2CBE 83 C4 02        add  sp, 2
2CC1                
2CC1                ;-1443             isInProc=1;
2CC1                
2CC1 B8 01 00        mov ax, 1
2CC4 A2 0D 01        mov byte [isInProc], al
2CC7                
2CC7                ;-1444             tmpLabelNamePtr = LabelNamePtr;
2CC7                
2CC7 A1 46 01        mov ax, [LabelNamePtr]
2CCA A3 48 01        mov word [tmpLabelNamePtr], ax
2CCD                
2CCD                ;-1445             tmpLabelMaxIx   = LabelMaxIx;
2CCD                
2CCD A1 4A 01        mov ax, [LabelMaxIx]
2CD0 A3 4C 01        mov word [tmpLabelMaxIx], ax
2CD3                
2CD3                ;-1446             tmpJmpNamePtr   = JmpNamePtr;
2CD3                
2CD3 A1 50 01        mov ax, [JmpNamePtr]
2CD6 A3 52 01        mov word [tmpJmpNamePtr], ax
2CD9                
2CD9                ;-1447             tmpJmpMaxIx     = JmpMaxIx;
2CD9                
2CD9 A1 54 01        mov ax, [JmpMaxIx]
2CDC A3 56 01        mov word [tmpJmpMaxIx], ax
2CDF                
2CDF                ;-1448         } else error1("already in PROC");
2CDF                
2CDF E9 00 00      R jmp .process362
2CE2                .process361:
2CE2 68 AA AA      A push process_2
2CE5 E8 62 DD        call error1
2CE8 83 C4 02        add  sp, 2
2CEB                
2CEB                ;-1449         return;
2CEB                
2CEB                .process362:
2CEB E9 00 00      R jmp .retnprocess
2CEE                
2CEE                ;-1450     }
2CEE                
2CEE                
2CEE                ;-1451     if (CodeType == 112) {//ENDP 
2CEE                
2CEE                .process360:
2CEE A0 2F 01        mov al, [CodeType]
2CF1 3C 70           cmp al, 112
2CF3 0F 85 00 00   r jne .process363
2CF7                
2CF7                ;-1452         if (isInProc == 0) error1("not in PROC");
2CF7                
2CF7 A0 0D 01        mov al, [isInProc]
2CFA 3C 00           cmp al, 0
2CFC 0F 85 00 00   r jne .process364
2D00 68 AA AA      A push process_3
2D03 E8 44 DD        call error1
2D06 83 C4 02        add  sp, 2
2D09                
2D09                ;-1453         prs("\nleaving: ");
2D09                
2D09                .process364:
2D09 68 AA AA      A push process_4
2D0C E8 24 DA        call prs
2D0F 83 C4 02        add  sp, 2
2D12                
2D12                ;-1454         prs(ProcName);
2D12                
2D12 8D 06 6E 75     lea  ax, [ProcName]
2D16 50              push ax
2D17 E8 19 DA        call prs
2D1A 83 C4 02        add  sp, 2
2D1D                
2D1D                ;-1455         prs(", loc labels: ");
2D1D                
2D1D 68 AA AA      A push process_5
2D20 E8 10 DA        call prs
2D23 83 C4 02        add  sp, 2
2D26                
2D26                ;-1456         i = LabelMaxIx - tmpLabelMaxIx;
2D26                
2D26 A1 4A 01        mov ax, [LabelMaxIx]
2D29 2B 06 4C 01     sub ax, [tmpLabelMaxIx]
2D2D 89 46 FC        mov [bp-4], ax
2D30                
2D30                ;-1457         printIntU(i);
2D30                
2D30 FF 76 FC        push word [bp-4]
2D33 E8 0D DB        call printIntU
2D36 83 C4 02        add  sp, 2
2D39                
2D39                ;-1458         prs(", loc jmp forward: ");
2D39                
2D39 68 AA AA      A push process_6
2D3C E8 F4 D9        call prs
2D3F 83 C4 02        add  sp, 2
2D42                
2D42                ;-1459         i = JmpMaxIx - tmpJmpMaxIx;
2D42                
2D42 A1 54 01        mov ax, [JmpMaxIx]
2D45 2B 06 56 01     sub ax, [tmpJmpMaxIx]
2D49 89 46 FC        mov [bp-4], ax
2D4C                
2D4C                ;-1460         printIntU(i);        
2D4C                
2D4C FF 76 FC        push word [bp-4]
2D4F E8 F1 DA        call printIntU
2D52 83 C4 02        add  sp, 2
2D55                
2D55                ;-1461         fixJmp();
2D55                
2D55 E8 8D F4        call fixJmp
2D58                
2D58                ;-1462         isInProc=0;
2D58                
2D58 B8 00 00        mov ax, 0
2D5B A2 0D 01        mov byte [isInProc], al
2D5E                
2D5E                ;-1463         LabelNamePtr = tmpLabelNamePtr;//delete local Labels
2D5E                
2D5E A1 48 01        mov ax, [tmpLabelNamePtr]
2D61 A3 46 01        mov word [LabelNamePtr], ax
2D64                
2D64                ;-1464         LabelMaxIx   = tmpLabelMaxIx;                       
2D64                
2D64 A1 4C 01        mov ax, [tmpLabelMaxIx]
2D67 A3 4A 01        mov word [LabelMaxIx], ax
2D6A                
2D6A                ;-1465         JmpNamePtr   = tmpJmpNamePtr;//delete local Jmp
2D6A                
2D6A A1 52 01        mov ax, [tmpJmpNamePtr]
2D6D A3 50 01        mov word [JmpNamePtr], ax
2D70                
2D70                ;-1466         JmpMaxIx     = tmpJmpMaxIx;
2D70                
2D70 A1 56 01        mov ax, [tmpJmpMaxIx]
2D73 A3 54 01        mov word [JmpMaxIx], ax
2D76                
2D76                ;-1467         return;
2D76                
2D76 E9 00 00      R jmp .retnprocess
2D79                
2D79                ;-1468     } 
2D79                
2D79                
2D79                ;-1469     if (CodeType == 200) {//db  
2D79                
2D79                .process363:
2D79 A0 2F 01        mov al, [CodeType]
2D7C 3C C8           cmp al, 200
2D7E 0F 85 00 00   r jne .process365
2D82                
2D82                ;-1470         genDB();
2D82                
2D82 E8 88 EF        call genDB
2D85                
2D85                ;-1471         return;
2D85                
2D85 E9 00 00      R jmp .retnprocess
2D88                
2D88                ;-1472     }
2D88                
2D88                
2D88                ;-1473     
2D88                
2D88                
2D88                ;-1474     error1("Command not implemented or syntax error");
2D88                
2D88                .process365:
2D88 68 AA AA      A push process_7
2D8B E8 BC DC        call error1
2D8E 83 C4 02        add  sp, 2
2D91                
2D91                ;-1475 }
2D91                
2D91                
2D91                ;-1476 
2D91                
2D91                
2D91                ;-1477 int parse() {
2D91                
2D91 C9              .retnprocess: LEAVE
2D92 C3              ret
2D93 70 6F 70 20 63 process_0 db "pop cs not allowed",0
2DA6 5C 6E 65 6E 74 process_1 db "\nentering: ",0
2DB3 61 6C 72 65 61 process_2 db "already in PROC",0
2DC3 6E 6F 74 20 69 process_3 db "not in PROC",0
2DCF 5C 6E 6C 65 61 process_4 db "\nleaving: ",0
2DDB 2C 20 6C 6F 63 process_5 db ", loc labels: ",0
2DEA 2C 20 6C 6F 63 process_6 db ", loc jmp forward: ",0
2DFE 43 6F 6D 6D 61 process_7 db "Command not implemented or syntax error",0
leaving: process, loc labels: 115, loc jmp forward: 155
2E26                ENDP
2E26                
entering: parse
2E26                parse: PROC
2E26                
2E26                ;-1478     LabelNamePtr  = &LabelNames;
2E26                
2E26 B8 5A 77        mov ax, LabelNames
2E29 A3 46 01        mov word [LabelNamePtr], ax
2E2C                
2E2C                ;-1479     JmpNamePtr= &JmpNames;
2E2C                
2E2C B8 7A 93        mov ax, JmpNames
2E2F A3 50 01        mov word [JmpNamePtr], ax
2E32                
2E32                ;-1480     LabelMaxIx=0;
2E32                
2E32 B8 00 00        mov ax, 0
2E35 A3 4A 01        mov word [LabelMaxIx], ax
2E38                
2E38                ;-1481     JmpMaxIx=0;
2E38                
2E38 B8 00 00        mov ax, 0
2E3B A3 54 01        mov word [JmpMaxIx], ax
2E3E                
2E3E                ;-1482     BinLen=0;
2E3E                
2E3E B8 00 00        mov ax, 0
2E41 A3 58 01        mov word [BinLen], ax
2E44                
2E44                ;-1483     isInProc=0;
2E44                
2E44 B8 00 00        mov ax, 0
2E47 A2 0D 01        mov byte [isInProc], al
2E4A                
2E4A                ;-1484 
2E4A                
2E4A                
2E4A                ;-1485     do {//process a new line
2E4A                
2E4A                .parse366:
2E4A                
2E4A                ;-1486         PCStart=PC;
2E4A                
2E4A A1 23 01        mov ax, [PC]
2E4D A3 29 01        mov word [PCStart], ax
2E50                
2E50                ;-1487         OpSize=0;
2E50                
2E50 B8 00 00        mov ax, 0
2E53 A2 37 01        mov byte [OpSize], al
2E56                
2E56                ;-1488         OpPrintIndex=0;
2E56                
2E56 B8 00 00        mov ax, 0
2E59 A3 41 01        mov word [OpPrintIndex], ax
2E5C                
2E5C                ;-1489         PrintRA=' ';
2E5C                
2E5C B8 20 00        mov ax, 32
2E5F A2 45 01        mov byte [PrintRA], al
2E62                
2E62                ;-1490         getLine();
2E62                
2E62 E8 C5 DE        call getLine
2E65                
2E65                ;-1491         InputPtr = &InputBuf;
2E65                
2E65 B8 8D 75        mov ax, InputBuf
2E68 A3 14 01        mov word [InputPtr], ax
2E6B                
2E6B                ;-1492         getTokeType();//getCode in SymbolUpper,
2E6B                
2E6B E8 7D E8        call getTokeType
2E6E                
2E6E                ;-1493                       //set TokeType,isLabel by getName
2E6E                
2E6E                
2E6E                ;-1494         if (TokeType == ALNUME) {
2E6E                
2E6E A0 2C 01        mov al, [TokeType]
2E71 3C 03           cmp al, 3
2E73 0F 85 00 00   r jne .parse367
2E77                
2E77                ;-1495             if (isLabel) {//set in getName
2E77                
2E77 A0 2B 01        mov al, [isLabel]
2E7A 08 C0           or  al, al
2E7C 0F 84 00 00   r je .parse368
2E80                
2E80                ;-1496               if (isInProc == 0)  strcpy(ProcName, Symbol);
2E80                
2E80 A0 0D 01        mov al, [isInProc]
2E83 3C 00           cmp al, 0
2E85 0F 85 00 00   r jne .parse369
2E89 8D 06 30 75     lea  ax, [Symbol]
2E8D 50              push ax
2E8E 8D 06 6E 75     lea  ax, [ProcName]
2E92 50              push ax
2E93 E8 94 D3        call strcpy
2E96 83 C4 04        add  sp, 4
2E99                
2E99                ;-1497                 storeLabel();
2E99                
2E99                .parse369:
2E99 E8 CA ED        call storeLabel
2E9C                
2E9C                ;-1498                 InputPtr++;//remove :
2E9C                
2E9C FF 06 14 01     inc  word[InputPtr]
2EA0                
2EA0                ;-1499                 getTokeType();
2EA0                
2EA0 E8 48 E8        call getTokeType
2EA3                
2EA3                ;-1500             }
2EA3                
2EA3                
2EA3                ;-1501         }
2EA3                
2EA3                .parse368:
2EA3                
2EA3                ;-1502         if (TokeType == ALNUME) {
2EA3                
2EA3                .parse367:
2EA3 A0 2C 01        mov al, [TokeType]
2EA6 3C 03           cmp al, 3
2EA8 0F 85 00 00   r jne .parse370
2EAC                
2EAC                ;-1503             lookCode();// and OpCodePtr
2EAC                
2EAC E8 66 E4        call lookCode
2EAF                
2EAF                ;-1504             if(CodeType) process();
2EAF                
2EAF A0 2F 01        mov al, [CodeType]
2EB2 08 C0           or  al, al
2EB4 0F 84 00 00   r je .parse371
2EB8 E8 43 F5        call process
2EBB                
2EBB                ;-1505             else getVariable();
2EBB                
2EBB E9 00 00      R jmp .parse372
2EBE                .parse371:
2EBE E8 D1 EE        call getVariable
2EC1                
2EC1                ;-1506             skipRest();
2EC1                
2EC1                .parse372:
2EC1 E8 1A E9        call skipRest
2EC4                
2EC4                ;-1507         }
2EC4                
2EC4                
2EC4                ;-1508         else if (TokeType >ALNUME) error1("Label or instruction expected");
2EC4                
2EC4 E9 00 00      R jmp .parse373
2EC7                .parse370:
2EC7 A0 2C 01        mov al, [TokeType]
2ECA 3C 03           cmp al, 3
2ECC 0F 8E 00 00   r jle .parse374
2ED0 68 AA AA      A push parse_0
2ED3 E8 74 DB        call error1
2ED6 83 C4 02        add  sp, 2
2ED9                
2ED9                ;-1509         else if (TokeType==DIGIT ) error1("No digit allowed at start of line");
2ED9                
2ED9 E9 00 00      R jmp .parse375
2EDC                .parse374:
2EDC A0 2C 01        mov al, [TokeType]
2EDF 3C 01           cmp al, 1
2EE1 0F 85 00 00   r jne .parse376
2EE5 68 AA AA      A push parse_1
2EE8 E8 5F DB        call error1
2EEB 83 C4 02        add  sp, 2
2EEE                
2EEE                ;-1510         printLine();
2EEE                
2EEE                .parse376:
2EEE                .parse375:
2EEE                .parse373:
2EEE E8 94 D9        call printLine
2EF1                
2EF1                ;-1511     } while (DOS_NoBytes != 0 );
2EF1                
2EF1 A1 20 01        mov ax, [DOS_NoBytes]
2EF4 83 F8 00        cmp ax, 0
2EF7 0F 84 00 00   r je  .parse377
2EFB E9 4C FF        jmp .parse366
2EFE                .parse377:
2EFE                
2EFE                ;-1512 }
2EFE                
2EFE                
2EFE                ;-1513 
2EFE                
2EFE                
2EFE                ;-1514 int main() {
2EFE                
2EFE C3              ret
2EFF 4C 61 62 65 6C parse_0 db "Label or instruction expected",0
2F1D 4E 6F 20 64 69 parse_1 db "No digit allowed at start of line",0
leaving: parse, loc labels: 14, loc jmp forward: 13
2F3F                ENDP
2F3F                
entering: main
2F3F                main: PROC
2F3F                
2F3F                ;-1515     getarg();
2F3F                
2F3F E8 60 F0        call getarg
2F42                
2F42                ;-1516     parse();
2F42                
2F42 E8 E1 FE        call parse
2F45                
2F45                ;-1517     fixJmpMain();
2F45                
2F45 E8 5C F3        call fixJmpMain
2F48                
2F48                ;-1518     epilog();
2F48                
2F48 E8 E3 D9        call epilog
2F4B                
2F4B                ;-1519     end1();
2F4B                
2F4B E8 CF DA        call end1
2F4E                
2F4E                ;-1520 }
2F4E                
2F4E C3              ret
leaving: main, loc labels: 0, loc jmp forward: 0
2F4F                ENDP
2F4F                 
2F4F                ; missing functions: 
2F4F                ; Number of unresolved CALLs :    0 All FUNCTIONs in place
******* next line ERROR: extra char ignored, Symbol: E8h
2F4F 00             LastFunctionByt:db 0E8h, 0, 0
2F50 58             pop ax
2F51 C3             ret
2F52                 
2F52                ;   # type sign width  adr used name   list of global variables
2F52                
2F52                ;    1 arr sign byte     1    2 Version1[9]
2F52                ;    2 def unsg byte     3    - SYMBOLMAX=31
2F52                ;    3 arr sign byte     4   14 Symbol[31]
2F52                ;    4 arr sign byte     5   36 SymbolUpper[31]
2F52                ;    5 arr sign byte     6    3 ProcName[31]
2F52                ;    6 var sign byte     7    6 isInProc
2F52                ;    7 var unsg word     8   25 SymbolInt
2F52                ;    8 var unsg dwrd     9 NULL SymbolLong
2F52                ;    9 def unsg byte    10    - INPUTBUFMAX=255
2F52                ;   10 arr sign byte    11    4 InputBuf[255]
2F52                ;   11 ptr unsg byte    12   28 InputPtr
2F52                ;   12 arr sign byte    13    5 namein[67]
2F52                ;   13 arr sign byte    14    6 namelst[67]
2F52                ;   14 arr sign byte    15    6 namebin[67]
2F52                ;   15 var sign word    16    4 asm_fd
2F52                ;   16 var sign word    17    3 lst_fd
2F52                ;   17 var sign word    18    3 bin_fd
2F52                ;   18 var sign word    19    6 DOS_ERR
2F52                ;   19 var sign word    20    5 ErrorCount
2F52                ;   20 var sign word    21    4 DOS_NoBytes
2F52                ;   21 var sign byte    22    5 DOS_ByteRead
2F52                ;   22 var unsg word    24    8 PC
2F52                ;   23 var unsg word    25    6 Origin
2F52                ;   24 var unsg word    26    6 AbsoluteLab
2F52                ;   25 var unsg word    27    2 PCStart
2F52                ;   26 var sign byte    28    3 isLabel
2F52                ;   27 def unsg byte    29    - DIGIT=1
2F52                ;   28 def unsg byte    30    - LETTERE=2
2F52                ;   29 def unsg byte    31    - ALNUME=3
2F52                ;   30 def unsg byte    32    - NOALNUME=4
2F52                ;   31 var sign byte    33   28 TokeType
2F52                ;   32 def unsg byte    34    - BYTE=1
2F52                ;   33 def unsg byte    35    - WORD=2
2F52                ;   34 def unsg byte    36    - DWORD=3
2F52                ;   35 def unsg byte    37    - SEGREG=4
2F52                ;   36 def unsg byte    38    - IMM=1
2F52                ;   37 def unsg byte    39    - REG=2
2F52                ;   38 def unsg byte    40    - ADR=3
2F52                ;   39 def unsg byte    41    - MEM=4
2F52                ;   40 var sign byte    42   29 Op
2F52                ;   41 var sign byte    43   32 Op2
2F52                ;   42 var sign byte    44   30 CodeType
2F52                ;   43 var sign byte    45   25 Code1
2F52                ;   44 var sign byte    46    6 Code2
2F52                ;   45 var sign byte    47    2 Code3
2F52                ;   46 var sign byte    48   19 R2No
2F52                ;   47 var sign byte    49   16 R1No
2F52                ;   48 var sign byte    50   18 R2Type
2F52                ;   49 var sign byte    51   15 R1Type
2F52                ;   50 var sign byte    52   14 OpSize
2F52                ;   51 var sign byte    53    9 wflag
2F52                ;   52 var sign byte    54    3 dflag
2F52                ;   53 var sign byte    55    8 sflag
2F52                ;   54 var sign byte    56   15 rm
2F52                ;   55 var sign byte    57    5 isDirect
2F52                ;   56 var sign word    58   67 disp
2F52                ;   57 var unsg word    59   14 imme
2F52                ;   58 def unsg byte    61    - OPMAXLEN=5
2F52                ;   59 arr sign byte    62    2 OpPos[5]
2F52                ;   60 var sign word    63    6 OpPrintIndex
2F52                ;   61 ptr sign byte    64   17 OpCodePtr
2F52                ;   62 var sign byte    65    5 PrintRA
2F52                ;   63 def unsg byte    67    - LABELNAMESMAX=5969
2F52                ;   64 arr sign byte    68    3 LabelNames[6000]
2F52                ;   65 ptr sign byte    69    7 LabelNamePtr
2F52                ;   66 ptr sign byte    70    2 tmpLabelNamePtr
2F52                ;   67 def unsg byte    72    - LABELADRMAX=600
2F52                ;   68 arr unsg word    73    9 LabelAddr[600]
2F52                ;   69 var sign word    74   10 LabelMaxIx
2F52                ;   70 var sign word    75    3 tmpLabelMaxIx
2F52                ;   71 var sign word    76   13 LabelIx
2F52                ;   72 def unsg byte    78    - JMPNAMESMAX=3969
2F52                ;   73 arr sign byte    79    3 JmpNames[4000]
2F52                ;   74 ptr sign byte    80    7 JmpNamePtr
2F52                ;   75 ptr sign byte    81    2 tmpJmpNamePtr
2F52                ;   76 def unsg byte    83    - JMPMAX=200
2F52                ;   77 arr unsg word    84    2 JmpAddr[200]
2F52                ;   78 var sign word    85   10 JmpMaxIx
2F52                ;   79 var sign word    86    3 tmpJmpMaxIx
2F52                ;   80 def unsg byte    88    - FILEBINMAX=17000
2F52                ;   81 arr sign byte    89    8 FileBin[17000]
2F52                ;   82 var unsg word    90    6 BinLen
2F52                ;   83 ptr sign byte    92    1 arglen
2F52                ;   84 ptr sign byte    93    4 argv
2F52                ;   85 var sign byte   451    1 I_START
2F52                ;   86 arr sign byte   454 NULL I_PUSHA[8125]
2F52                ;   87 arr sign byte   455 NULL I_NOP[24260]
2F52                ;   88 arr sign byte   456 NULL I_CWDE[9734]
2F52                ;   89 arr sign byte   457 NULL I_CDQ[1931]
2F52                ;   90 arr sign byte   458 NULL I_PUSHF[35622]
2F52                ;   91 arr sign byte   459 NULL I_SAHF[599]
2F52                ;   92 arr sign byte   460 NULL I_MOVSB[53495]
2F52                ;   93 arr sign byte   461 NULL I_CMPSB[54007]
2F52                ;   94 arr sign byte   462 NULL I_STOSB[37]
2F52                ;   95 arr sign byte   463 NULL I_LODSB[33600]
2F52                ;   96 arr sign byte   464 NULL I_SCASB[8418]
2F52                ;   97 arr sign byte   465 NULL I_LEAVE[53259]
2F52                ;   98 arr sign byte   466 NULL I_INTO[12917]
2F52                ;   99 arr sign byte   467 NULL I_XLAT[35622]
2F52                ;  100 arr sign byte   468 NULL I_REPNE[2119]
2F52                ;  101 arr sign byte   469 NULL I_REPE[18057]
2F52                ;  102 arr sign byte   470 NULL I_HLT[9982]
2F52                ;  103 arr sign byte   471 NULL I_STC[18315]
2F52                ;  104 arr sign byte   472 NULL I_STI[9734]
2F52                ;  105 arr sign byte   473 NULL I_STD[32643]
2F52                ;  106 arr sign byte   475 NULL I_INC[10]
2F52                ;  107 arr sign byte   476 NULL I_DEC[1397]
2F52                ;  108 arr sign byte   477 NULL I_NOT[18119]
2F52                ;  109 arr sign byte   478 NULL I_NEG[65534]
2F52                ;  110 arr sign byte   479 NULL I_MUL[33791]
2F52                ;  111 arr sign byte   480 NULL I_IMUL[65150]
2F52                ;  112 arr sign byte   481 NULL I_DIV[30207]
2F52                ;  113 arr sign byte   482 NULL I_IDIV[15642]
2F52                ;  114 arr sign byte   484 NULL I_LES[65535]
2F52                ;  115 arr sign byte   485 NULL I_LDS[5493]
2F52                ;  116 arr sign byte   486 NULL I_LEA[33574]
2F52                ;  117 arr sign byte   487 NULL I_LSS[1151]
2F52                ;  118 arr sign byte   488 NULL I_LFS[29696]
2F52                ;  119 arr sign byte   489 NULL I_LGS[35593]
2F52                ;  120 arr sign byte   491 NULL I_ADD[2630]
2F52                ;  121 arr sign byte   492 NULL I_OR[14630]
2F52                ;  122 arr sign byte   493 NULL I_ADC[1095]
2F52                ;  123 arr sign byte   494 NULL I_SBB[26997]
2F52                ;  124 arr sign byte   495 NULL I_AND[49203]
2F52                ;  125 arr sign byte   496 NULL I_SUB[52169]
2F52                ;  126 arr sign byte   497 NULL I_XOR[33680]
2F52                ;  127 arr sign byte   498 NULL I_CMP[65150]
2F52                ;  128 arr sign byte   499 NULL I_TEST[29729]
2F52                ;  129 arr sign byte   501 NULL I_MOV[33618]
2F52                ;  130 arr sign byte   502 NULL I_MOVSX[65150]
2F52                ;  131 arr sign byte   503 NULL I_MOVZX[29731]
2F52                ;  132 arr sign byte   505 NULL I_JO[33612]
2F52                ;  133 arr sign byte   506 NULL I_JNO[65150]
2F52                ;  134 arr sign byte   507 NULL I_JB[29732]
2F52                ;  135 arr sign byte   508 NULL I_JNB[33606]
2F52                ;  136 arr sign byte   509 NULL I_JAE[65150]
2F52                ;  137 arr sign byte   510 NULL I_JE[29734]
2F52                ;  138 arr sign byte   511 NULL I_JNE[33600]
2F52                ;  139 arr sign byte   512 NULL I_JBE[65150]
2F52                ;  140 arr sign byte   513 NULL I_JA[29730]
2F52                ;  141 arr sign byte   514 NULL I_JS[33594]
2F52                ;  142 arr sign byte   515 NULL I_JNS[65150]
2F52                ;  143 arr sign byte   516 NULL I_JP[29737]
2F52                ;  144 arr sign byte   517 NULL I_JNP[33588]
2F52                ;  145 arr sign byte   518 NULL I_JL[65150]
2F52                ;  146 arr sign byte   519 NULL I_JNL[29736]
2F52                ;  147 arr sign byte   520 NULL I_JLE[33582]
2F52                ;  148 arr sign byte   521 NULL I_JG[65150]
2F52                ;  149 arr sign byte   523 NULL I_JMP[29733]
2F52                ;  150 arr sign byte   524 NULL I_CALL[15656]
2F52                ;  151 arr sign byte   526 NULL I_RET[33]
2F52                ;  152 arr sign byte   527 NULL I_RETF[9076]
2F52                ;  153 arr sign byte   529 NULL I_PUSH[9021]
2F52                ;  154 arr sign byte   530 NULL I_POP[29696]
2F52                ;  155 arr sign byte   532 NULL I_ROL[15646]
2F52                ;  156 arr sign byte   533 NULL I_RCL[36]
2F52                ;  157 arr sign byte   534 NULL I_SHL[6516]
2F52                ;  158 arr sign byte   535 NULL I_SHR[9789]
2F52                ;  159 arr sign byte   537 NULL I_INT[29696]
2F52                ;  160 arr sign byte   539 NULL I_IN[15636]
2F52                ;  161 arr sign byte   540 NULL I_INSB[34]
2F52                ;  162 arr sign byte   541 NULL I_INSW[3956]
2F52                ;  163 arr sign byte   542 NULL I_INSD[10557]
2F52                ;  164 arr sign byte   543 NULL I_OUT[29696]
2F52                ;  165 arr sign byte   544 NULL I_OUTSB[15626]
2F52                ;  166 arr sign byte   545 NULL I_OUTSW[40]
2F52                ;  167 arr sign byte   546 NULL I_OUTSD[1396]
2F52                ;  168 arr sign byte   548 NULL I_XCHG[9533]
2F52                ;  169 arr sign byte   550 NULL I_LOOPNZ[29952]
2F52                ;  170 arr sign byte   551 NULL I_LOOPNE[33542]
2F52                ;  171 arr sign byte   552 NULL I_LOOPZ[2686]
2F52                ;  172 arr sign byte   553 NULL I_LOOPE[60176]
2F52                ;  173 arr sign byte   554 NULL I_LOOP[33540]
2F52                ;  174 arr sign byte   555 NULL I_JCXZ[2686]
2F52                ;  175 arr sign byte   556 NULL I_JECXZ[29984]
2F52                ;  176 arr sign byte   558 NULL I_ENTER[47255]
2F52                ;  177 arr sign byte   560 NULL I_ORG[1]
2F52                ;  178 arr sign byte   562 NULL I_SECTION[52169]
2F52                ;  179 arr sign byte   563 NULL I_SEGMENT[21904]
2F52                ;  180 arr sign byte   564 NULL I_ABSOLUTE[60555]
2F52                ;  181 arr sign byte   565 NULL I_PROC[5816]
2F52                ;  182 arr sign byte   566 NULL I_ENDP[39424]
2F52                ;  183 arr sign byte   567 NULL I_DB[674]
2F52                ;  184 arr sign byte   568 NULL I_DW[8125]
2F52                ;  185 arr sign byte   569 NULL I_DD[51030]
2F52                ;  186 arr sign byte   570 NULL I_RESB[65094]
2F52                ;  187 arr sign byte   571 NULL I_RESW[0]
2F52                ;  188 arr sign byte   572 NULL I_RESD[1678]
2F52                ;  189 var sign byte   573 NULL I_END
2F52                
2F52                
2F52                ;   # Calls Line Width  Name   list of functions
2F52                
2F52                ;    0    4   97   writetty
2F52                ;    1    1   98   putch
2F52                ;    2    8   99   cputs
2F52                ;    3    6  101   DosInt
2F52                ;    4    1  106   openR
2F52                ;    5    2  107   creatR
2F52                ;    6    3  108   fcloseR
2F52                ;    7    5  109   exitR
2F52                ;    8    2  110   readRL
2F52                ;    9    2  112   fputcR
2F52                ;   10    2  115   letterE
2F52                ;   11    3  125   digit
2F52                ;   12    1  130   alnumE
2F52                ;   13    4  135   strlen
2F52                ;   14   10  140   strcpy
2F52                ;   15   35  146   eqstr
2F52                ;   16    3  155   strcat1
2F52                ;   17    2  159   toupper
2F52                ;   18    1  166   testReg
2F52                ;   19    7  209   prc
2F52                ;   20    1  219   prscomment
2F52                ;   21   38  227   prs
2F52                ;   22    2  249   printhex4
2F52                ;   23    3  254   printhex8a
2F52                ;   24    3  259   printhex16
2F52                ;   25    7  264   printIntU
2F52                ;   26    1  274   printLine
2F52                ;   27    2  297   epilog
2F52                ;   28    2  345   end1
2F52                ;   29   27  353   error1
2F52                ;   30   13  360   errorexit
2F52                ;   31    5  365   notfounderror
2F52                ;   32 NULL  371   allowederror
2F52                ;   33    3  372   addrerror
2F52                ;   34    1  373   immeerror
2F52                ;   35    3  374   implerror
2F52                ;   36    4  375   indexerror
2F52                ;   37    2  376   invaloperror
2F52                ;   38    6  377   numbererror
2F52                ;   39    1  378   regmemerror
2F52                ;   40    3  379   reg16error
2F52                ;   41    1  380   segregerror
2F52                ;   42    5  381   syntaxerror
2F52                ;   43 NULL  383   addrexit
2F52                ;   44    3  384   dataexit
2F52                ;   45 NULL  385   internexit
2F52                ;   46    1  387   ifEOL
2F52                ;   47    1  396   getLine
2F52                ;   48    4  412   skipBlank
2F52                ;   49    1  418   getDigit
2F52                ;   50    1  430   getName
2F52                ;   51    2  575   lookCode
2F52                ;   52   38  591   genCode8
2F52                ;   53    1  602   gen66h
2F52                ;   54    8  604   genCode2
2F52                ;   55   13  608   genCodeW
2F52                ;   56   19  612   genCode16
2F52                ;   57    1  616   genCode32
2F52                ;   58   14  627   writeEA
2F52                ;   59    4  670   genImmediate
2F52                ;   60    2  677   setwflag
2F52                ;   61    2  688   setsflag
2F52                ;   62    2  698   checkConstSize
2F52                ;   63    2  705   ChangeDirection
2F52                ;   64   17  713   getTokeType
2F52                ;   65   11  724   isToken
2F52                ;   66    2  734   need
2F52                ;   67    1  743   skipRest
2F52                ;   68    2  749   checkOpL
2F52                ;   69    6  758   searchLabel
2F52                ;   70    4  771   getOp1
2F52                ;   71    1  786   getIndReg1
2F52                ;   72    1  794   getIndReg2
2F52                ;   73    1  803   getMEM
2F52                ;   74    2  830   getOpR
2F52                ;   75    3  843   getOpL
2F52                ;   76    1  850   get2Ops
2F52                ;   77    4  855   check2Ops
2F52                ;   78    3  865   storeJmp
2F52                ;   79    2  876   storeLabel
2F52                ;   80    1  889   genDB
2F52                ;   81    1  910   getVariable
2F52                ;   82    1  963   getCodeSize
2F52                ;   83    1  973   getarg
2F52                ;   84    1 1007   fixJmp
2F52                ;   85    1 1040   fixJmpMain
2F52                ;   86    1 1066   getCodes
2F52                ;   87    1 1072   process
2F52                ;   88    1 1477   parse
2F52                ;   89 NULL 1514   main
2F52                ;   90 NULL 1520   LastFunctionByt
2F52                
2F52                ;    #  addr name   list of CALLs
2F52                
2F52                ;    0     0 writetty
2F52                ;    1     9 writetty
2F52                ;    2    18 putch
2F52                ;    3    24 DosInt
2F52                ;    4    31 DosInt
2F52                ;    5    38 DosInt
2F52                ;    6    45 DosInt
2F52                ;    7    52 DosInt
2F52                ;    8    59 DosInt
2F52                ;    9    66 digit
2F52                ;   10    72 letterE
2F52                ;   11    80 strcpy
2F52                ;   12    87 strlen
2F52                ;   13    94 strlen
2F52                ;   14   101 eqstr
2F52                ;   15   107 eqstr
2F52                ;   16   113 eqstr
2F52                ;   17   119 eqstr
2F52                ;   18   125 eqstr
2F52                ;   19   131 eqstr
2F52                ;   20   137 eqstr
2F52                ;   21   143 eqstr
2F52                ;   22   149 eqstr
2F52                ;   23   155 eqstr
2F52                ;   24   161 eqstr
2F52                ;   25   167 eqstr
2F52                ;   26   173 eqstr
2F52                ;   27   179 eqstr
2F52                ;   28   185 eqstr
2F52                ;   29   191 eqstr
2F52                ;   30   197 eqstr
2F52                ;   31   203 eqstr
2F52                ;   32   209 eqstr
2F52                ;   33   215 eqstr
2F52                ;   34   221 eqstr
2F52                ;   35   227 eqstr
2F52                ;   36   233 eqstr
2F52                ;   37   239 eqstr
2F52                ;   38   245 eqstr
2F52                ;   39   251 eqstr
2F52                ;   40   257 eqstr
2F52                ;   41   263 eqstr
2F52                ;   42   269 eqstr
2F52                ;   43   275 eqstr
2F52                ;   44   281 writetty
2F52                ;   45   290 writetty
2F52                ;   46   299 fputcR
2F52                ;   47   306 prc
2F52                ;   48   310 prc
2F52                ;   49   314 prc
2F52                ;   50   318 printhex4
2F52                ;   51   328 printhex4
2F52                ;   52   338 printhex8a
2F52                ;   53   349 printhex8a
2F52                ;   54   360 printIntU
2F52                ;   55   370 prc
2F52                ;   56   374 prs
2F52                ;   57   378 printhex16
2F52                ;   58   389 prs
2F52                ;   59   393 prc
2F52                ;   60   397 printhex8a
2F52                ;   61   408 prs
2F52                ;   62   412 prc
2F52                ;   63   416 prscomment
2F52                ;   64   427 prs
2F52                ;   65   431 printIntU
2F52                ;   66   441 prs
2F52                ;   67   445 prs
2F52                ;   68   449 prs
2F52                ;   69   453 prs
2F52                ;   70   457 prs
2F52                ;   71   461 prs
2F52                ;   72   465 printIntU
2F52                ;   73   475 prs
2F52                ;   74   479 prs
2F52                ;   75   483 printIntU
2F52                ;   76   493 fputcR
2F52                ;   77   500 fcloseR
2F52                ;   78   508 fcloseR
2F52                ;   79   516 fcloseR
2F52                ;   80   524 exitR
2F52                ;   81   530 prs
2F52                ;   82   534 prs
2F52                ;   83   538 prs
2F52                ;   84   542 prs
2F52                ;   85   546 error1
2F52                ;   86   553 epilog
2F52                ;   87   560 end1
2F52                ;   88   565 prs
2F52                ;   89   569 prs
2F52                ;   90   573 prs
2F52                ;   91   577 error1
2F52                ;   92   584 error1
2F52                ;   93   591 error1
2F52                ;   94   598 error1
2F52                ;   95   605 error1
2F52                ;   96   612 error1
2F52                ;   97   619 error1
2F52                ;   98   626 error1
2F52                ;   99   633 error1
2F52                ;  100   640 error1
2F52                ;  101   647 error1
2F52                ;  102   654 errorexit
2F52                ;  103   664 errorexit
2F52                ;  104   674 errorexit
2F52                ;  105   684 readRL
2F52                ;  106   691 errorexit
2F52                ;  107   701 readRL
2F52                ;  108   708 errorexit
2F52                ;  109   718 errorexit
2F52                ;  110   728 ifEOL
2F52                ;  111   734 digit
2F52                ;  112   740 alnumE
2F52                ;  113   747 errorexit
2F52                ;  114   757 strcpy
2F52                ;  115   764 toupper
2F52                ;  116   772 eqstr
2F52                ;  117   778 errorexit
2F52                ;  118   788 genCode8
2F52                ;  119   797 genCode8
2F52                ;  120   806 genCode8
2F52                ;  121   815 genCode8
2F52                ;  122   824 genCode8
2F52                ;  123   833 genCode16
2F52                ;  124   843 genCode16
2F52                ;  125   853 genCode8
2F52                ;  126   862 genCode8
2F52                ;  127   871 genCode16
2F52                ;  128   881 genCode32
2F52                ;  129   891 genCode16
2F52                ;  130   901 genCode8
2F52                ;  131   910 gen66h
2F52                ;  132   917 error1
2F52                ;  133   924 skipBlank
2F52                ;  134   934 digit
2F52                ;  135   940 getDigit
2F52                ;  136   949 letterE
2F52                ;  137   957 getName
2F52                ;  138   965 skipBlank
2F52                ;  139   975 isToken
2F52                ;  140   983 getTokeType
2F52                ;  141   995 error1
2F52                ;  142  1002 prs
2F52                ;  143  1006 prc
2F52                ;  144  1010 getTokeType
2F52                ;  145  1022 error1
2F52                ;  146  1029 implerror
2F52                ;  147  1039 segregerror
2F52                ;  148  1051 setwflag
2F52                ;  149  1060 error1
2F52                ;  150  1067 error1
2F52                ;  151  1074 eqstr
2F52                ;  152  1080 strlen
2F52                ;  153  1087 testReg
2F52                ;  154  1095 searchLabel
2F52                ;  155  1107 indexerror
2F52                ;  156  1118 indexerror
2F52                ;  157  1129 indexerror
2F52                ;  158  1140 indexerror
2F52                ;  159  1151 getTokeType
2F52                ;  160  1163 getOp1
2F52                ;  161  1170 syntaxerror
2F52                ;  162  1182 getIndReg2
2F52                ;  163  1193 getIndReg1
2F52                ;  164  1204 notfounderror
2F52                ;  165  1218 isToken
2F52                ;  166  1226 getTokeType
2F52                ;  167  1238 numbererror
2F52                ;  168  1250 isToken
2F52                ;  169  1258 isToken
2F52                ;  170  1266 errorexit
2F52                ;  171  1276 getOp1
2F52                ;  172  1283 isToken
2F52                ;  173  1291 getMEM
2F52                ;  174  1298 invaloperror
2F52                ;  175  1311 error1
2F52                ;  176  1318 getOpR
2F52                ;  177  1325 getOpL
2F52                ;  178  1332 need
2F52                ;  179  1337 getOpR
2F52                ;  180  1344 get2Ops
2F52                ;  181  1352 addrerror
2F52                ;  182  1362 invaloperror
2F52                ;  183  1375 immeerror
2F52                ;  184  1385 addrerror
2F52                ;  185  1395 setwflag
2F52                ;  186  1404 errorexit
2F52                ;  187  1414 strcpy
2F52                ;  188  1421 errorexit
2F52                ;  189  1431 searchLabel
2F52                ;  190  1443 error1
2F52                ;  191  1450 errorexit
2F52                ;  192  1460 strcpy
2F52                ;  193  1467 errorexit
2F52                ;  194  1477 getTokeType
2F52                ;  195  1489 genCode8
2F52                ;  196  1498 skipBlank
2F52                ;  197  1508 isToken
2F52                ;  198  1516 genCode8
2F52                ;  199  1525 isToken
2F52                ;  200  1533 storeLabel
2F52                ;  201  1544 getTokeType
2F52                ;  202  1556 lookCode
2F52                ;  203  1565 dataexit
2F52                ;  204  1574 dataexit
2F52                ;  205  1583 getTokeType
2F52                ;  206  1595 genCode8
2F52                ;  207  1604 skipBlank
2F52                ;  208  1614 isToken
2F52                ;  209  1622 genCode8
2F52                ;  210  1631 isToken
2F52                ;  211  1639 getTokeType
2F52                ;  212  1651 genCode16
2F52                ;  213  1661 isToken
2F52                ;  214  1669 getTokeType
2F52                ;  215  1681 genCode16
2F52                ;  216  1691 genCode16
2F52                ;  217  1701 isToken
2F52                ;  218  1709 getTokeType
2F52                ;  219  1721 syntaxerror
2F52                ;  220  1733 error1
2F52                ;  221  1740 numbererror
2F52                ;  222  1752 dataexit
2F52                ;  223  1761 eqstr
2F52                ;  224  1767 getTokeType
2F52                ;  225  1779 eqstr
2F52                ;  226  1785 getTokeType
2F52                ;  227  1797 eqstr
2F52                ;  228  1803 getTokeType
2F52                ;  229  1815 cputs
2F52                ;  230  1821 cputs
2F52                ;  231  1827 exitR
2F52                ;  232  1833 toupper
2F52                ;  233  1841 strcpy
2F52                ;  234  1848 strcat1
2F52                ;  235  1856 strcpy
2F52                ;  236  1863 strcat1
2F52                ;  237  1871 strcpy
2F52                ;  238  1878 strcat1
2F52                ;  239  1886 openR
2F52                ;  240  1892 cputs
2F52                ;  241  1898 cputs
2F52                ;  242  1904 exitR
2F52                ;  243  1910 creatR
2F52                ;  244  1917 cputs
2F52                ;  245  1923 cputs
2F52                ;  246  1929 exitR
2F52                ;  247  1935 creatR
2F52                ;  248  1942 cputs
2F52                ;  249  1948 cputs
2F52                ;  250  1954 exitR
2F52                ;  251  1960 prs
2F52                ;  252  1964 prs
2F52                ;  253  1968 prs
2F52                ;  254  1972 prs
2F52                ;  255  1976 prs
2F52                ;  256  1980 prs
2F52                ;  257  1984 prs
2F52                ;  258  1988 prs
2F52                ;  259  1992 prs
2F52                ;  260  1996 strcpy
2F52                ;  261  2003 strlen
2F52                ;  262  2010 searchLabel
2F52                ;  263  2022 notfounderror
2F52                ;  264  2036 prs
2F52                ;  265  2040 printIntU
2F52                ;  266  2050 error1
2F52                ;  267  2057 strcpy
2F52                ;  268  2064 searchLabel
2F52                ;  269  2076 notfounderror
2F52                ;  270  2090 prs
2F52                ;  271  2094 printhex16
2F52                ;  272  2105 prs
2F52                ;  273  2109 printhex16
2F52                ;  274  2120 getTokeType
2F52                ;  275  2132 getCodeSize
2F52                ;  276  2144 getCodes
2F52                ;  277  2153 genCode8
2F52                ;  278  2162 getOpL
2F52                ;  279  2169 checkOpL
2F52                ;  280  2178 genCode2
2F52                ;  281  2187 getTokeType
2F52                ;  282  2199 implerror
2F52                ;  283  2209 genCodeW
2F52                ;  284  2218 writeEA
2F52                ;  285  2226 check2Ops
2F52                ;  286  2236 reg16error
2F52                ;  287  2247 addrerror
2F52                ;  288  2257 genCode8
2F52                ;  289  2266 genCode8
2F52                ;  290  2275 writeEA
2F52                ;  291  2283 check2Ops
2F52                ;  292  2293 notfounderror
2F52                ;  293  2307 setsflag
2F52                ;  294  2316 genCodeW
2F52                ;  295  2325 genImmediate
2F52                ;  296  2338 genCodeW
2F52                ;  297  2347 writeEA
2F52                ;  298  2355 genCode8
2F52                ;  299  2364 genImmediate
2F52                ;  300  2377 genCodeW
2F52                ;  301  2386 writeEA
2F52                ;  302  2394 genCodeW
2F52                ;  303  2403 writeEA
2F52                ;  304  2411 syntaxerror
2F52                ;  305  2423 check2Ops
2F52                ;  306  2433 notfounderror
2F52                ;  307  2447 genCode2
2F52                ;  308  2456 genImmediate
2F52                ;  309  2469 genCodeW
2F52                ;  310  2478 writeEA
2F52                ;  311  2486 genImmediate
2F52                ;  312  2499 regmemerror
2F52                ;  313  2511 ChangeDirection
2F52                ;  314  2527 reg16error
2F52                ;  315  2538 genCode2
2F52                ;  316  2547 writeEA
2F52                ;  317  2555 genCodeW
2F52                ;  318  2564 genCode16
2F52                ;  319  2574 genCodeW
2F52                ;  320  2583 genCode16
2F52                ;  321  2593 genCodeW
2F52                ;  322  2602 writeEA
2F52                ;  323  2610 ChangeDirection
2F52                ;  324  2626 genCodeW
2F52                ;  325  2635 writeEA
2F52                ;  326  2643 syntaxerror
2F52                ;  327  2655 searchLabel
2F52                ;  328  2667 checkConstSize
2F52                ;  329  2682 genCode2
2F52                ;  330  2691 genCode8
2F52                ;  331  2700 genCode8
2F52                ;  332  2709 genCode2
2F52                ;  333  2718 genCode16
2F52                ;  334  2728 genCode8
2F52                ;  335  2737 genCode2
2F52                ;  336  2746 storeJmp
2F52                ;  337  2755 genCode16
2F52                ;  338  2765 searchLabel
2F52                ;  339  2777 checkConstSize
2F52                ;  340  2792 genCode8
2F52                ;  341  2801 genCode8
2F52                ;  342  2810 genCode8
2F52                ;  343  2819 genCode16
2F52                ;  344  2829 genCode8
2F52                ;  345  2838 genCode16
2F52                ;  346  2848 genCode8
2F52                ;  347  2857 storeJmp
2F52                ;  348  2866 genCode16
2F52                ;  349  2876 genCode8
2F52                ;  350  2885 genCode16
2F52                ;  351  2895 genCode8
2F52                ;  352  2904 getOpL
2F52                ;  353  2911 setsflag
2F52                ;  354  2920 genCode2
2F52                ;  355  2929 genCode8
2F52                ;  356  2938 genCode16
2F52                ;  357  2948 genCode8
2F52                ;  358  2957 genCode16
2F52                ;  359  2967 genCode8
2F52                ;  360  2976 storeJmp
2F52                ;  361  2985 genCode16
2F52                ;  362  2995 error1
2F52                ;  363  3002 genCode8
2F52                ;  364  3011 genCode8
2F52                ;  365  3020 checkOpL
2F52                ;  366  3029 genCode8
2F52                ;  367  3038 writeEA
2F52                ;  368  3046 genCode8
2F52                ;  369  3055 writeEA
2F52                ;  370  3063 reg16error
2F52                ;  371  3074 genCode2
2F52                ;  372  3083 syntaxerror
2F52                ;  373  3095 check2Ops
2F52                ;  374  3105 genCodeW
2F52                ;  375  3114 writeEA
2F52                ;  376  3122 genCodeW
2F52                ;  377  3131 writeEA
2F52                ;  378  3139 genCode8
2F52                ;  379  3148 genCodeW
2F52                ;  380  3157 writeEA
2F52                ;  381  3165 genCode8
2F52                ;  382  3174 genCode8
2F52                ;  383  3183 genCode8
2F52                ;  384  3192 getOp1
2F52                ;  385  3199 genCode16
2F52                ;  386  3209 numbererror
2F52                ;  387  3221 need
2F52                ;  388  3226 getOp1
2F52                ;  389  3233 genCode8
2F52                ;  390  3242 numbererror
2F52                ;  391  3254 implerror
2F52                ;  392  3264 numbererror
2F52                ;  393  3276 numbererror
2F52                ;  394  3288 prs
2F52                ;  395  3292 prs
2F52                ;  396  3296 error1
2F52                ;  397  3303 error1
2F52                ;  398  3310 prs
2F52                ;  399  3314 prs
2F52                ;  400  3318 prs
2F52                ;  401  3322 printIntU
2F52                ;  402  3332 prs
2F52                ;  403  3336 printIntU
2F52                ;  404  3346 fixJmp
2F52                ;  405  3353 genDB
2F52                ;  406  3359 error1
2F52                ;  407  3366 getLine
2F52                ;  408  3374 getTokeType
2F52                ;  409  3386 strcpy
2F52                ;  410  3393 storeLabel
2F52                ;  411  3404 getTokeType
2F52                ;  412  3416 lookCode
2F52                ;  413  3425 process
2F52                ;  414  3433 getVariable
2F52                ;  415  3445 skipRest
2F52                ;  416  3454 error1
2F52                ;  417  3461 error1
2F52                ;  418  3468 printLine
2F52                ;  419  3478 getarg
2F52                ;  420  3485 parse
2F52                ;  421  3491 fixJmpMain
2F52                ;  422  3502 epilog
2F52                ;  423  3509 end1
2F52                ;Input: AS.C, List: AS.S,  Lines: 1521
2F52                ;Glob. variables:  189 max.:  200
2F52                ;Functions      :   91 max.:  300
2F52                ;Calls          :  424 max.: 2000, NameField: 3514 max.:    65535
2F52                ;Code until     :21667 max.: 30000, free: 8333
2F52                ;Data (HeapEnd) :59154, resting stacksize:  6381
2F52                ;Max. Const in 'testReg' :  658 max. 3000, free: 2342x.:    65535
fix jmp to main. resting global jmp: 0
main ,Label+ORG:303F,rel:2F3C
 Errors: 1 *** ERRORS *** , Out: TE.LST, TE.COM= 12114 bytes. Labels: 260