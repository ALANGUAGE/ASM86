;AS.C V0.2, Source: TE.S, Output: TE.LST, TE.COM

0000                
0000                ; A.COM V0.9, Source: AS.C, Output asm: AS.S
0000                org  256 
0000 E9 00 00      Rjmp main
0003                
0003                ;-1 char Version1[]="AS.C V0.2";//BAS.BAT, AS TE, NAS.BAT
0003                
0003 41 53 2E 43 20 Version1 db "AS.C V0.2",0
000D                
000D                ;-2 //#include "DECL.C"
000D                
000D                
000D                ;-3 #define SYMBOLMAX    31
000D                
000D                
000D                ;-4 char Symbol[SYMBOLMAX]; //next symbol to decode
000D                
000D                section .bss
000D                absolute 30000
000D                Symbol resb 31
000D                section .text
000D                
000D                ;-5 char SymbolUpper[SYMBOLMAX];//set toupper in getName
000D                
000D                section .bss
000D                absolute 30031
000D                SymbolUpper resb 31
000D                section .text
000D                
000D                ;-6 char ProcName[SYMBOLMAX];//name of actual proc
000D                
000D                section .bss
000D                absolute 30062
000D                ProcName resb 31
000D                section .text
000D                
000D                ;-7 char isInProc=0;        //is inside a procedure
000D                
000D 00             isInProc db 0
000E                
000E                ;-8 unsigned int SymbolInt; //integer value set in getDigit
000E                
000E 00 00          SymbolInt dw 0
0010                
0010                ;-9 unsigned long SymbolLong;//integer value set in getDigit
0010                
0010 00 00 00 00    SymbolLong dd 0
0014                
0014                ;-10 #define INPUTBUFMAX 255
0014                
0014                
0014                ;-11 char InputBuf[INPUTBUFMAX];//filled in getLine, no overflow test
0014                
0014                section .bss
0014                absolute 30093
0014                InputBuf resb 255
0014                section .text
0014                
0014                ;-12 unsigned char *InputPtr;//position in InputBuf
0014                
0014 00 00          InputPtr dw 0
0016                
0016                ;-13 char namein [67];       //input file name  .S
0016                
0016                section .bss
0016                absolute 30348
0016                namein resb 67
0016                section .text
0016                
0016                ;-14 char namelst[67];       //list file name   .LST
0016                
0016                section .bss
0016                absolute 30415
0016                namelst resb 67
0016                section .text
0016                
0016                ;-15 char namebin[67];       //output file name .COM
0016                
0016                section .bss
0016                absolute 30482
0016                namebin resb 67
0016                section .text
0016                
0016                ;-16 int  asm_fd;            //input file descriptor
0016                
0016 00 00          asm_fd dw 0
0018                
0018                ;-17 int lst_fd;             //list file descriptor
0018                
0018 00 00          lst_fd dw 0
001A                
001A                ;-18 int bin_fd;             //output file descriptor
001A                
001A 00 00          bin_fd dw 0
001C                
001C                ;-19 int DOS_ERR=0;          //global var
001C                
001C 00 00          DOS_ERR dw 0
001E                
001E                ;-20 int ErrorCount=0;       //number of errors
001E                
001E 00 00          ErrorCount dw 0
0020                
0020                ;-21 int DOS_NoBytes;        //number of bytes read (0 or 1)
0020                
0020 00 00          DOS_NoBytes dw 0
0022                
0022                ;-22 char DOS_ByteRead;      //the byte just read by DOS
0022                
0022 00             DOS_ByteRead db 0
0023                
0023                ;-23 
0023                
0023                
0023                ;-24 unsigned int PC=0;      //program counter
0023                
0023 00 00          PC dw 0
0025                
0025                ;-25 unsigned int Origin=0;  //ORG nn
0025                
0025 00 00          Origin dw 0
0027                
0027                ;-26 unsigned int AbsoluteLab=0;//uninitialised data
0027                
0027 00 00          AbsoluteLab dw 0
0029                
0029                ;-27 unsigned int PCStart;   //PC at start of line by PrintLine()
0029                
0029 00 00          PCStart dw 0
002B                
002B                ;-28 char isLabel;           //by getName()
002B                
002B 00             isLabel db 0
002C                
002C                ;-29 #define DIGIT    1      //0-9
002C                
002C                
002C                ;-30 #define LETTERE  2      //a-z A-Z @ . _
002C                
002C                
002C                ;-31 #define ALNUME   3      //a-z A-Z @ . _  0-9
002C                
002C                
002C                ;-32 #define NOALNUME 4      //other char
002C                
002C                
002C                ;-33 char TokeType;          //0, DIGIT, LETTERE, ALNUME, NOALNUME
002C                
002C 00             TokeType db 0
002D                
002D                ;-34 #define BYTE     1
002D                
002D                
002D                ;-35 #define WORD     2
002D                
002D                
002D                ;-36 #define DWORD    3
002D                
002D                
002D                ;-37 #define SEGREG   4
002D                
002D                
002D                ;-38 #define IMM      1      //const  ,123
002D                
002D                
002D                ;-39 #define REG      2      //       ,BX    mode=11
002D                
002D                
002D                ;-40 #define ADR      3      //DIRECT: VALUE  ,var1  mod=00, r/m=110
002D                
002D                
002D                ;-41 #define MEM      4      //[var1],[BX+SI],[table+BX],[bp-4] disp0,8,16
002D                
002D                
002D                ;-42 char Op;                //1. operand: 0, IMM, REG, ADR, MEM
002D                
002D 00             Op db 0
002E                
002E                ;-43 char Op2;               //2. operand
002E                
002E 00             Op2 db 0
002F                
002F                ;-44 char CodeType;          //1-207 by searchSymbol(), must be byte size
002F                
002F 00             CodeType db 0
0030                
0030                ;-45 char Code1;             //1. Opcode
0030                
0030 00             Code1 db 0
0031                
0031                ;-46 char Code2;             //2. Opcode
0031                
0031 00             Code2 db 0
0032                
0032                ;-47 char Code3;             //3. Opcode
0032                
0032 00             Code3 db 0
0033                
0033                ;-48 char R2No;              //0 - 7 AL, CL, ...  set in testReg()
0033                
0033 00             R2No db 0
0034                
0034                ;-49 char R1No;              //temp for 1. register
0034                
0034 00             R1No db 0
0035                
0035                ;-50 char R2Type;            //0=no reg, BYTE, WORD, DWORD, SEGREG
0035                
0035 00             R2Type db 0
0036                
0036                ;-51 char R1Type;            //temp for 1. register
0036                
0036 00             R1Type db 0
0037                
0037                ;-52 char OpSize;            //0, BYTE, WORD, DWORD by getCodeSize()
0037                
0037 00             OpSize db 0
0038                
0038                ;-53 char wflag;             //wordflag: 0=byte, 1=word/dword
0038                
0038 00             wflag db 0
0039                
0039                ;-54 char dflag;             //directionflag: 1=to reg MOV,ALU
0039                
0039 00             dflag db 0
003A                
003A                ;-55 char sflag;             //sign extended, imm8 to word PUSH,ALU,IMUL3
003A                
003A 00             sflag db 0
003B                
003B                ;-56 char rm;                //combination of index and base reg
003B                
003B 00             rm db 0
003C                
003C                ;-57 char isDirect;          //set in process and getMeM, need in WriteEA
003C                
003C 00             isDirect db 0
003D                
003D                ;-58 int disp;               //displacement      0-8 bytes
003D                
003D 00 00          disp dw 0
003F                
003F                ;-59 unsigned int imme;      //immediate         0-8 bytes
003F                
003F 00 00          imme dw 0
0041                
0041                ;-60 
0041                
0041                
0041                ;-61 #define OPMAXLEN 5
0041                
0041                
0041                ;-62 char OpPos[OPMAXLEN];   //array for one opcode to list
0041                
0041                section .bss
0041                absolute 30549
0041                OpPos resb 5
0041                section .text
0041                
0041                ;-63 int OpPrintIndex;       //0-OPMAXLEN, pos to print opcode, by genCode8
0041                
0041 00 00          OpPrintIndex dw 0
0043                
0043                ;-64 char *OpCodePtr;        //position in OpCodeTable by searchSymbol
0043                
0043 00 00          OpCodePtr dw 0
0045                
0045                ;-65 char PrintRA;           //print * for forward relocative jmp
0045                
0045 00             PrintRA db 0
0046                
0046                ;-66 
0046                
0046                
0046                ;-67 #define LABELNAMESMAX 5969//next number - SYMBOLMAX
0046                
0046                
0046                ;-68 char LabelNames[6000];  //space for names of all labels
0046                
0046                section .bss
0046                absolute 30554
0046                LabelNames resb 6000
0046                section .text
0046                
0046                ;-69 char *LabelNamePtr;     //first free position
0046                
0046 00 00          LabelNamePtr dw 0
0048                
0048                ;-70 char *tmpLabelNamePtr;  //set after PROC to LabelNamePtr
0048                
0048 00 00          tmpLabelNamePtr dw 0
004A                
004A                ;-71 
004A                
004A                
004A                ;-72 #define LABELADRMAX 600
004A                
004A                
004A                ;-73 unsigned int LabelAddr[LABELADRMAX];//addr of each label
004A                
004A                section .bss
004A                absolute 36554
004A                LabelAddr resw 600
004A                section .text
004A                
004A                ;-74 int LabelMaxIx=0;       //actual # of stored labels. 1 to LABELADRMAX-1
004A                
004A 00 00          LabelMaxIx dw 0
004C                
004C                ;-75 int tmpLabelMaxIx;      //set after PROC to LabelMaxIx
004C                
004C 00 00          tmpLabelMaxIx dw 0
004E                
004E                ;-76 int LabelIx;            //actual # of just searched label
004E                
004E 00 00          LabelIx dw 0
0050                
0050                ;-77 
0050                
0050                
0050                ;-78 #define JMPNAMESMAX 3969//next number - SYMBOLMAX
0050                
0050                
0050                ;-79 char JmpNames[4000];    //space for names of jmp, call
0050                
0050                section .bss
0050                absolute 37754
0050                JmpNames resb 4000
0050                section .text
0050                
0050                ;-80 char *JmpNamePtr;       //first free position
0050                
0050 00 00          JmpNamePtr dw 0
0052                
0052                ;-81 char *tmpJmpNamePtr;    //set after PROC to JmpNamePtr
0052                
0052 00 00          tmpJmpNamePtr dw 0
0054                
0054                ;-82 
0054                
0054                
0054                ;-83 #define JMPMAX 200      //max. jmp and call
0054                
0054                
0054                ;-84 unsigned int JmpAddr[JMPMAX];//addr to be fixed
0054                
0054                section .bss
0054                absolute 41754
0054                JmpAddr resw 200
0054                section .text
0054                
0054                ;-85 int JmpMaxIx=0;         //actual # of jmp, call. 1 to JMPMAX-1
0054                
0054 00 00          JmpMaxIx dw 0
0056                
0056                ;-86 int tmpJmpMaxIx=0;      //set after PROC to JmpMaxIx
0056                
0056 00 00          tmpJmpMaxIx dw 0
0058                
0058                ;-87 
0058                
0058                
0058                ;-88 #define FILEBINMAX 17000
0058                
0058                
0058                ;-89 char FileBin  [FILEBINMAX];//output binary file
0058                
0058                section .bss
0058                absolute 42154
0058                FileBin resb 17000
0058                section .text
0058                
0058                ;-90 unsigned int BinLen=0;  //length of binary file
0058                
0058 00 00          BinLen dw 0
005A                
005A                ;-91 
005A                
005A                
005A                ;-92 char *arglen=0x80;      // for main only
005A                
005A 80 00          arglen dw 128
005C                
005C                ;-93 char *argv=0x82;        // for main only
005C                
005C 82 00          argv dw 130
005E                
005E                ;-94 
005E                
005E                
005E                ;-95 
005E                
005E                
005E                ;-96 //#include "HELPER.C"
005E                
005E                
005E                ;-97 int writetty()     { ah=0x0E; bx=0; __emit__(0xCD,0x10); }
005E                
005E                
;entering: writetty
005E                writetty: PROC
005E B4 0E           mov  ah, 14
0060 BB 00 00        mov  bx, 0
;***** next line ERROR: Command not implemented or syntax error, Symbol: db
;***** next line ERROR: extra char ignored, Symbol: db
0063                 db 205,16
0063                
0063                ;-98 int putch(char c)  {if (_ c==10) {al=13; writetty();} al=c; writetty(); }
0063                
0063 C3              ret
;leaving: writetty. loc labels:0,loc jmp forward:0
;jmp to fix:0
0064                ENDP
0064                
;entering: putch
0064                putch: PROC
0064                ;Function : putch, Number of local variables: 1
0064                ;   # type sign width addr used name   list of local variables
0064                ;  200 var sign byte    98 NULL c = bp+4;
0064 C8 00 00 00     ENTER  0,0 ; constant expression
0068 80 7E 04 0A    cmp byte[bp+4], 10
006C 0F 85 00 00   r jne .putch1
0070 B0 0D           mov  al, 13
0072 E8 E9 FF        call writetty
0075                .putch1:
0075 8A 46 04        mov  al, [bp+4]
0078 E8 E3 FF        call writetty
007B                
007B                ;-99 int cputs(char *s) {char c;  while(*s) { c=*s; putch(c); s++; } }
007B C9              LEAVE
007C C3              ret
;leaving: putch. loc labels:1,loc jmp forward:1
;jmp to fix:1
1. .putch1,from:006E,Label+ORG:0175,rel:0005
007D                ENDP
007D                
;entering: cputs
007D                cputs: PROC
007D                ;Function : cputs, Number of local variables: 2
007D                ;   # type sign width addr used name   list of local variables
007D                ;  200 ptr sign byte    99 NULL s = bp+4
007D                ;  201 var sign byte    99 NULL c = bp-2;
007D C8 02 00 00     ENTER  2,0
0081                .cputs2:
0081 8B 5E 04        mov bx, [bp+4]
0084 8A 07           mov al, [bx]
0086 B4 00           mov ah, 0
0088 08 C0           or  al, al
008A 0F 84 00 00   r je .cputs3
008E 8B 5E 04        mov bx, [bp+4]
0091 8A 07           mov al, [bx]
0093 B4 00           mov ah, 0
0095 88 46 FE        mov [bp-2], al
0098 8A 46 FE        mov al, byte [bp-2]
009B B4 00           mov ah, 0
009D 50              push ax
009E E8 C3 FF        call putch
00A1 83 C4 02        add  sp, 2
00A4 FF 46 04        inc  word[bp+4]
00A7 EB D8           jmp .cputs2
00A9                .cputs3:
00A9                
00A9                ;-100 
00A9                
00A9                
00A9                ;-101 int DosInt() {
00A9 C9              LEAVE
00AA C3              ret
;leaving: cputs. loc labels:2,loc jmp forward:1
;jmp to fix:1
1. .cputs3,from:008C,Label+ORG:01A9,rel:001B
00AB                ENDP
00AB                
;entering: DosInt
00AB                DosInt: PROC
00AB                
00AB                ;-102     __emit__(0xCD,0x21);//inth 0x21;
00AB                
;***** next line ERROR: Command not implemented or syntax error, Symbol: db
;***** next line ERROR: extra char ignored, Symbol: db
00AB                 db 205,33
00AB                
00AB                ;-103     __emit__(0x73, 04); //ifcarry DOS_ERR++;
00AB                
;***** next line ERROR: Command not implemented or syntax error, Symbol: db
;***** next line ERROR: extra char ignored, Symbol: db
00AB                 db 115,4
00AB                
00AB                ;-104     DOS_ERR++;
00AB                
00AB FF 06 1C 01     inc  word[DOS_ERR]
00AF                
00AF                ;-105 }
00AF                
00AF                
00AF                ;-106 int openR (char *s) { dx=s;       ax=0x3D02; DosInt(); }
00AF                
00AF C3              ret
;leaving: DosInt. loc labels:0,loc jmp forward:0
;jmp to fix:0
00B0                ENDP
00B0                
;entering: openR
00B0                openR: PROC
00B0                ;Function : openR, Number of local variables: 1
00B0                ;   # type sign width addr used name   list of local variables
00B0                ;  200 ptr sign byte   106 NULL s = bp+4;
00B0 C8 00 00 00     ENTER  0,0
00B4 8B 56 04        mov  dx, [bp+4]
00B7 B8 02 3D        mov  ax, 15618
00BA E8 EE FF        call DosInt
00BD                
00BD                ;-107 int creatR(char *s) { dx=s; cx=0; ax=0x3C00; DosInt(); }
00BD C9              LEAVE
00BE C3              ret
;leaving: openR. loc labels:0,loc jmp forward:0
;jmp to fix:0
00BF                ENDP
00BF                
;entering: creatR
00BF                creatR: PROC
00BF                ;Function : creatR, Number of local variables: 1
00BF                ;   # type sign width addr used name   list of local variables
00BF                ;  200 ptr sign byte   107 NULL s = bp+4;
00BF C8 00 00 00     ENTER  0,0
00C3 8B 56 04        mov  dx, [bp+4]
00C6 B9 00 00        mov  cx, 0
00C9 B8 00 3C        mov  ax, 15360
00CC E8 DC FF        call DosInt
00CF                
00CF                ;-108 int fcloseR(int fd) {bx=fd;       ax=0x3E00; DosInt(); }
00CF C9              LEAVE
00D0 C3              ret
;leaving: creatR. loc labels:0,loc jmp forward:0
;jmp to fix:0
00D1                ENDP
00D1                
;entering: fcloseR
00D1                fcloseR: PROC
00D1                ;Function : fcloseR, Number of local variables: 1
00D1                ;   # type sign width addr used name   list of local variables
00D1                ;  200 var sign word   108 NULL fd = bp+4;
00D1 C8 00 00 00     ENTER  0,0
00D5 8B 5E 04        mov  bx, [bp+4]
00D8 B8 00 3E        mov  ax, 15872
00DB E8 CD FF        call DosInt
00DE                
00DE                ;-109 int exitR  (char c) {ah=0x4C; al=c;          DosInt(); }
00DE C9              LEAVE
00DF C3              ret
;leaving: fcloseR. loc labels:0,loc jmp forward:0
;jmp to fix:0
00E0                ENDP
00E0                
;entering: exitR
00E0                exitR: PROC
00E0                ;Function : exitR, Number of local variables: 1
00E0                ;   # type sign width addr used name   list of local variables
00E0                ;  200 var sign byte   109 NULL c = bp+4;
00E0 C8 00 00 00     ENTER  0,0
00E4 B4 4C           mov  ah, 76
00E6 8A 46 04        mov  al, [bp+4]
00E9 E8 BF FF        call DosInt
00EC                
00EC                ;-110 int readRL(char *s, int fd, int len){dx=s; cx=len; bx=fd; ax=0x3F00; DosInt();}
00EC C9              LEAVE
00ED C3              ret
;leaving: exitR. loc labels:0,loc jmp forward:0
;jmp to fix:0
00EE                ENDP
00EE                
;entering: readRL
00EE                readRL: PROC
00EE                ;Function : readRL, Number of local variables: 3
00EE                ;   # type sign width addr used name   list of local variables
00EE                ;  200 ptr sign byte   110 NULL s = bp+4
00EE                ;  201 var sign word   110 NULL fd = bp+6
00EE                ;  202 var sign word   110 NULL len = bp+8;
00EE C8 00 00 00     ENTER  0,0
00F2 8B 56 04        mov  dx, [bp+4]
00F5 8B 4E 08        mov  cx, [bp+8]
00F8 8B 5E 06        mov  bx, [bp+6]
00FB B8 00 3F        mov  ax, 16128
00FE E8 AA FF        call DosInt
0101                
0101                ;-111 int fputcR(char *n, int fd) { __asm{lea dx, [bp+4]}; /* = *n */
0101 C9              LEAVE
0102 C3              ret
;leaving: readRL. loc labels:0,loc jmp forward:0
;jmp to fix:0
0103                ENDP
0103                
;entering: fputcR
0103                fputcR: PROC
0103                ;Function : fputcR, Number of local variables: 2
0103                ;   # type sign width addr used name   list of local variables
0103                ;  200 ptr sign byte   111 NULL n = bp+4
0103                ;  201 var sign word   111 NULL fd = bp+6;
0103 C8 00 00 00     ENTER  0,0
0107 8D 56 04       lea dx, [bp+4]
010A                
010A                ;-112   cx=1; bx=fd; ax=0x4000; DosInt(); }
010A                
010A B9 01 00        mov  cx, 1
010D 8B 5E 06        mov  bx, [bp+6]
0110 B8 00 40        mov  ax, 16384
0113 E8 95 FF        call DosInt
0116                
0116                ;-113 
0116                
0116                
0116                ;-114 int getLine() {// make ASCIIZ, skip LF=10 and CR=13
0116 C9              LEAVE
0117 C3              ret
;leaving: fputcR. loc labels:0,loc jmp forward:0
;jmp to fix:0
0118                ENDP
0118                
;entering: getLine
0118                getLine: PROC
0118                
0118                ;-115   unsigned int i;
0118                
0118                
0118                ;-116   InputPtr= &InputBuf;
0118                
0118                ;Function : getLine, Number of local variables: 1
0118                ;   # type sign width addr used name   list of local variables
0118                ;  200 var unsg word   115 NULL i = bp-2;
0118 C8 02 00 00     ENTER  2,0
011C B8 8D 75        mov ax, InputBuf
011F A3 14 01        mov word [InputPtr], ax
0122                
0122                ;-117   *InputPtr=0;//if last line is empty
0122                
0122 B8 00 00        mov ax, 0
0125 8B 1E 14 01     mov  bx, [InputPtr]
0129 88 07           mov  [bx], al
012B                
012B                ;-118   do {
012B                
012B                .getLine4:
012B                
012B                ;-119     DOS_NoBytes=readRL(&DOS_ByteRead, asm_fd, 1);
012B                
012B 6A 01           push 1
012D FF 36 16 01     push word [asm_fd]
0131 8D 06 22 01     lea  ax, [DOS_ByteRead]
0135 50              push ax
0136 E8 B5 FF        call readRL
0139 83 C4 06        add  sp, 6
013C A3 20 01        mov word [DOS_NoBytes], ax
013F                
013F                ;-120     if (DOS_ERR) errorexit("Reading Source");
013F                
013F A1 1C 01        mov ax, [DOS_ERR]
0142 08 C0           or  al, al
0144 0F 84 00 00   r je .getLine5
0148 68 AA AA      A push getLine_0
014B E8 00 00      R call errorexit
014E 83 C4 02        add  sp, 2
0151                
0151                ;-121     if (DOS_NoBytes == 0) return;
0151                
0151                .getLine5:
0151 A1 20 01        mov ax, [DOS_NoBytes]
0154 83 F8 00        cmp ax, 0
0157 0F 85 00 00   r jne .getLine6
015B E9 00 00      R jmp .retngetLine
015E                
015E                ;-122     *InputPtr = DOS_ByteRead;
015E                
015E                .getLine6:
015E A0 22 01        mov al, [DOS_ByteRead]
0161 8B 1E 14 01     mov  bx, [InputPtr]
0165 88 07           mov  [bx], al
0167                
0167                ;-123     InputPtr++;
0167                
0167 FF 06 14 01     inc  word[InputPtr]
016B                
016B                ;-124     i = InputPtr - &InputBuf;
016B                
016B A1 14 01        mov ax, [InputPtr]
;***** next line ERROR: invalid or no operands, Symbol: InputBuf
;***** next line ERROR: syntax, Symbol: InputBuf
016E                 sub ax, InputBuf
016E 89 46 FE        mov [bp-2], ax
0171                
0171                ;-125     if (i >= INPUTBUFMAX) errorexit("input line too long");
0171                
0171 8B 46 FE        mov ax, [bp-2]
0174 3D FF 00        cmp ax, 255 ;unsigned : 0
0177 0F 82 00 00   r jb  .getLine7
017B 68 AA AA      A push getLine_1
017E E8 00 00      R call errorexit
0181 83 C4 02        add  sp, 2
0184                
0184                ;-126   } while (ifEOL(DOS_ByteRead) == 0);
0184                
0184                .getLine7:
0184 A0 22 01        mov al, byte [DOS_ByteRead]
0187 B4 00           mov ah, 0
0189 50              push ax
018A E8 00 00      R call ifEOL
018D 83 C4 02        add  sp, 2
0190 3C 00           cmp al, 0
0192 0F 85 00 00   r jne .getLine8
0196 EB 93           jmp .getLine4
0198                .getLine8:
0198                
0198                ;-127   InputPtr--;
0198                
0198 FF 0E 14 01     dec  word[InputPtr]
019C                
019C                ;-128   *InputPtr=0;
019C                
019C B8 00 00        mov ax, 0
019F 8B 1E 14 01     mov  bx, [InputPtr]
01A3 88 07           mov  [bx], al
01A5                
01A5                ;-129 }
01A5                
01A5                
01A5                ;-130 int ifEOL(char c) {//unix LF, win CRLF= 13/10, mac CR
01A5                
01A5 C9              .retngetLine: LEAVE
01A6 C3              ret
01A7 52 65 61 64 69 getLine_0 db "Reading Source",0
01B6 69 6E 70 75 74 getLine_1 db "input line too long",0
;leaving: getLine. loc labels:8,loc jmp forward:10
;jmp to fix:10
1. .getLine5,from:0146,Label+ORG:0251,rel:0009
2. getLine_0,from:0149,Label+ORG:02A7
3. errorexit,from:014C
;***** ERROR: label not found: errorexit ,Label+ORG:0447,rel:01F9
4. .getLine6,from:0159,Label+ORG:025E,rel:0003
5. .retngetLine,from:015C,Label+ORG:02A5,rel:0047
6. .getLine7,from:0179,Label+ORG:0284,rel:0009
7. getLine_1,from:017C,Label+ORG:02B6
8. errorexit,from:017F
;***** ERROR: label not found: errorexit ,Label+ORG:0447,rel:01C6
9. ifEOL,from:018B
;***** ERROR: label not found: ifEOL ,Label+ORG:0447,rel:01BA
10. .getLine8,from:0194,Label+ORG:0298,rel:0002
01CA                ENDP
01CA                
;entering: ifEOL
01CA                ifEOL: PROC
01CA                
01CA                ;-131   if (c == 10) return 1;//LF
01CA                
01CA                ;Function : ifEOL, Number of local variables: 1
01CA                ;   # type sign width addr used name   list of local variables
01CA                ;  200 var sign byte   130 NULL c = bp+4;
01CA C8 00 00 00     ENTER  0,0
01CE 8A 46 04        mov al, [bp+4]
01D1 3C 0A           cmp al, 10
01D3 0F 85 00 00   r jne .ifEOL9
01D7 B8 01 00        mov ax, 1
01DA E9 00 00      R jmp .retnifEOL
01DD                
01DD                ;-132   if (c == 13) {//CR
01DD                
01DD                .ifEOL9:
01DD 8A 46 04        mov al, [bp+4]
01E0 3C 0D           cmp al, 13
01E2 0F 85 00 00   r jne .ifEOL10
01E6                
01E6                ;-133     DOS_NoBytes=readRL(&DOS_ByteRead, asm_fd, 1);
01E6                
01E6 6A 01           push 1
01E8 FF 36 16 01     push word [asm_fd]
01EC 8D 06 22 01     lea  ax, [DOS_ByteRead]
01F0 50              push ax
01F1 E8 FA FE        call readRL
01F4 83 C4 06        add  sp, 6
01F7 A3 20 01        mov word [DOS_NoBytes], ax
01FA                
01FA                ;-134     if (DOS_ByteRead != 10) errorexit("missing LF(10) after CR(13)");
01FA                
01FA A0 22 01        mov al, [DOS_ByteRead]
01FD 3C 0A           cmp al, 10
01FF 0F 84 00 00   r je  .ifEOL11
0203 68 AA AA      A push ifEOL_0
0206 E8 00 00      R call errorexit
0209 83 C4 02        add  sp, 2
020C                
020C                ;-135     return 1;
020C                
020C                .ifEOL11:
020C B8 01 00        mov ax, 1
020F E9 00 00      R jmp .retnifEOL
0212                
0212                ;-136   }
0212                
0212                
0212                ;-137   return 0;
0212                
0212                .ifEOL10:
0212 B8 00 00        mov ax, 0
0215 E9 00 00      R jmp .retnifEOL
0218                
0218                ;-138 }
0218                
0218                
0218                ;-139 int skipBlank() {
0218                
0218 C9              .retnifEOL: LEAVE
0219 C3              ret
021A 6D 69 73 73 69 ifEOL_0 db "missing LF(10) after CR(13)",0
;leaving: ifEOL. loc labels:5,loc jmp forward:8
;jmp to fix:8
1. .ifEOL9,from:01D5,Label+ORG:02DD,rel:0006
2. .retnifEOL,from:01DB,Label+ORG:0318,rel:003B
3. .ifEOL10,from:01E4,Label+ORG:0312,rel:002C
4. .ifEOL11,from:0201,Label+ORG:030C,rel:0009
5. ifEOL_0,from:0204,Label+ORG:031A
6. errorexit,from:0207
;***** ERROR: label not found: errorexit ,Label+ORG:0447,rel:013E
7. .retnifEOL,from:0210,Label+ORG:0318,rel:0006
8. .retnifEOL,from:0216,Label+ORG:0318,rel:0000
0236                ENDP
0236                
;entering: skipBlank
0236                skipBlank: PROC
0236                
0236                ;-140   skipblank1:
0236                
0236                .skipblank1:
0236                
0236                ;-141     if (*InputPtr == ' ') { InputPtr++; goto skipblank1; }
0236                
0236 8B 1E 14 01     mov bx, [InputPtr]
023A 8A 07           mov al, [bx]
023C B4 00           mov ah, 0
023E 83 F8 20        cmp ax, 32
0241 0F 85 00 00   r jne .skipBlank12
0245 FF 06 14 01     inc  word[InputPtr]
0249 EB EB           jmp .skipblank1
024B                
024B                ;-142     if (*InputPtr == 9  ) { InputPtr++; goto skipblank1; }
024B                
024B                .skipBlank12:
024B 8B 1E 14 01     mov bx, [InputPtr]
024F 8A 07           mov al, [bx]
0251 B4 00           mov ah, 0
0253 83 F8 09        cmp ax, 9
0256 0F 85 00 00   r jne .skipBlank13
025A FF 06 14 01     inc  word[InputPtr]
025E EB D6           jmp .skipblank1
0260                
0260                ;-143 }
0260                
0260                .skipBlank13:
0260                
0260                ;-144 int letterE(char c) {
0260                
0260 C3              ret
;leaving: skipBlank. loc labels:3,loc jmp forward:2
;jmp to fix:2
1. .skipBlank12,from:0243,Label+ORG:034B,rel:0006
2. .skipBlank13,from:0258,Label+ORG:0360,rel:0006
0261                ENDP
0261                
;entering: letterE
0261                letterE: PROC
0261                
0261                ;-145   if (c=='_') return 1;
0261                
0261                ;Function : letterE, Number of local variables: 1
0261                ;   # type sign width addr used name   list of local variables
0261                ;  200 var sign byte   144 NULL c = bp+4;
0261 C8 00 00 00     ENTER  0,0
0265 8A 46 04        mov al, [bp+4]
0268 3C 5F           cmp al, 95
026A 0F 85 00 00   r jne .letterE14
026E B8 01 00        mov ax, 1
0271 E9 00 00      R jmp .retnletterE
0274                
0274                ;-146   if (c=='.') return 1;
0274                
0274                .letterE14:
0274 8A 46 04        mov al, [bp+4]
0277 3C 2E           cmp al, 46
0279 0F 85 00 00   r jne .letterE15
027D B8 01 00        mov ax, 1
0280 E9 00 00      R jmp .retnletterE
0283                
0283                ;-147   if (c=='?') return 1;
0283                
0283                .letterE15:
0283 8A 46 04        mov al, [bp+4]
0286 3C 3F           cmp al, 63
0288 0F 85 00 00   r jne .letterE16
028C B8 01 00        mov ax, 1
028F E9 00 00      R jmp .retnletterE
0292                
0292                ;-148   if (c=='$') return 1;
0292                
0292                .letterE16:
0292 8A 46 04        mov al, [bp+4]
0295 3C 24           cmp al, 36
0297 0F 85 00 00   r jne .letterE17
029B B8 01 00        mov ax, 1
029E E9 00 00      R jmp .retnletterE
02A1                
02A1                ;-149   if (c> 'z') return 0;
02A1                
02A1                .letterE17:
02A1 8A 46 04        mov al, [bp+4]
02A4 3C 7A           cmp al, 122
02A6 0F 8E 00 00   r jle .letterE18
02AA B8 00 00        mov ax, 0
02AD E9 00 00      R jmp .retnletterE
02B0                
02B0                ;-150   if (c< '@') return 0; // at included
02B0                
02B0                .letterE18:
02B0 8A 46 04        mov al, [bp+4]
02B3 3C 40           cmp al, 64
02B5 0F 8D 00 00   r jge .letterE19
02B9 B8 00 00        mov ax, 0
02BC E9 00 00      R jmp .retnletterE
02BF                
02BF                ;-151   if (c> 'Z') { if (c< 'a') return 0; }
02BF                
02BF                .letterE19:
02BF 8A 46 04        mov al, [bp+4]
02C2 3C 5A           cmp al, 90
02C4 0F 8E 00 00   r jle .letterE20
02C8 8A 46 04        mov al, [bp+4]
02CB 3C 61           cmp al, 97
02CD 0F 8D 00 00   r jge .letterE21
02D1 B8 00 00        mov ax, 0
02D4 E9 00 00      R jmp .retnletterE
02D7                .letterE21:
02D7                
02D7                ;-152   return 1;
02D7                
02D7                .letterE20:
02D7 B8 01 00        mov ax, 1
02DA E9 00 00      R jmp .retnletterE
02DD                
02DD                ;-153 }
02DD                
02DD                
02DD                ;-154 int alnumE(char c) {
02DD                
02DD C9              .retnletterE: LEAVE
02DE C3              ret
;leaving: letterE. loc labels:9,loc jmp forward:16
;jmp to fix:16
1. .letterE14,from:026C,Label+ORG:0374,rel:0006
2. .retnletterE,from:0272,Label+ORG:03DD,rel:0069
3. .letterE15,from:027B,Label+ORG:0383,rel:0006
4. .retnletterE,from:0281,Label+ORG:03DD,rel:005A
5. .letterE16,from:028A,Label+ORG:0392,rel:0006
6. .retnletterE,from:0290,Label+ORG:03DD,rel:004B
7. .letterE17,from:0299,Label+ORG:03A1,rel:0006
8. .retnletterE,from:029F,Label+ORG:03DD,rel:003C
9. .letterE18,from:02A8,Label+ORG:03B0,rel:0006
10. .retnletterE,from:02AE,Label+ORG:03DD,rel:002D
11. .letterE19,from:02B7,Label+ORG:03BF,rel:0006
12. .retnletterE,from:02BD,Label+ORG:03DD,rel:001E
13. .letterE20,from:02C6,Label+ORG:03D7,rel:000F
14. .letterE21,from:02CF,Label+ORG:03D7,rel:0006
15. .retnletterE,from:02D5,Label+ORG:03DD,rel:0006
16. .retnletterE,from:02DB,Label+ORG:03DD,rel:0000
02DF                ENDP
02DF                
;entering: alnumE
02DF                alnumE: PROC
02DF                
02DF                ;-155   if (digit(c)) return 1;
02DF                
02DF                ;Function : alnumE, Number of local variables: 1
02DF                ;   # type sign width addr used name   list of local variables
02DF                ;  200 var sign byte   154 NULL c = bp+4;
02DF C8 00 00 00     ENTER  0,0
02E3 8A 46 04        mov al, byte [bp+4]
02E6 B4 00           mov ah, 0
02E8 50              push ax
02E9 E8 00 00      R call digit
02EC 83 C4 02        add  sp, 2
02EF 08 C0           or  al, al
02F1 0F 84 00 00   r je .alnumE22
02F5 B8 01 00        mov ax, 1
02F8 E9 00 00      R jmp .retnalnumE
02FB                
02FB                ;-156   if (letterE(c)) return 1;
02FB                
02FB                .alnumE22:
02FB 8A 46 04        mov al, byte [bp+4]
02FE B4 00           mov ah, 0
0300 50              push ax
0301 E8 5D FF        call letterE
0304 83 C4 02        add  sp, 2
0307 08 C0           or  al, al
0309 0F 84 00 00   r je .alnumE23
030D B8 01 00        mov ax, 1
0310 E9 00 00      R jmp .retnalnumE
0313                
0313                ;-157   return 0;
0313                
0313                .alnumE23:
0313 B8 00 00        mov ax, 0
0316 E9 00 00      R jmp .retnalnumE
0319                
0319                ;-158 }
0319                
0319                
0319                ;-159 int digit(char c){
0319                
0319 C9              .retnalnumE: LEAVE
031A C3              ret
;leaving: alnumE. loc labels:3,loc jmp forward:6
;jmp to fix:6
1. digit,from:02EA
;***** ERROR: label not found: digit ,Label+ORG:0447,rel:005B
2. .alnumE22,from:02F3,Label+ORG:03FB,rel:0006
3. .retnalnumE,from:02F9,Label+ORG:0419,rel:001E
4. .alnumE23,from:030B,Label+ORG:0413,rel:0006
5. .retnalnumE,from:0311,Label+ORG:0419,rel:0006
6. .retnalnumE,from:0317,Label+ORG:0419,rel:0000
031B                ENDP
031B                
;entering: digit
031B                digit: PROC
031B                
031B                ;-160     if(c<'0') return 0;
031B                
031B                ;Function : digit, Number of local variables: 1
031B                ;   # type sign width addr used name   list of local variables
031B                ;  200 var sign byte   159 NULL c = bp+4;
031B C8 00 00 00     ENTER  0,0
031F 8A 46 04        mov al, [bp+4]
0322 3C 30           cmp al, 48
0324 0F 8D 00 00   r jge .digit24
0328 B8 00 00        mov ax, 0
032B E9 00 00      R jmp .retndigit
032E                
032E                ;-161     if(c>'9') return 0;
032E                
032E                .digit24:
032E 8A 46 04        mov al, [bp+4]
0331 3C 39           cmp al, 57
0333 0F 8E 00 00   r jle .digit25
0337 B8 00 00        mov ax, 0
033A E9 00 00      R jmp .retndigit
033D                
033D                ;-162     return 1;
033D                
033D                .digit25:
033D B8 01 00        mov ax, 1
0340 E9 00 00      R jmp .retndigit
0343                
0343                ;-163 }
0343                
0343                
0343                ;-164 int strlen(char *s) { int c;
0343                
0343 C9              .retndigit: LEAVE
0344 C3              ret
;leaving: digit. loc labels:3,loc jmp forward:5
;jmp to fix:5
1. .digit24,from:0326,Label+ORG:042E,rel:0006
2. .retndigit,from:032C,Label+ORG:0443,rel:0015
3. .digit25,from:0335,Label+ORG:043D,rel:0006
4. .retndigit,from:033B,Label+ORG:0443,rel:0006
5. .retndigit,from:0341,Label+ORG:0443,rel:0000
0345                ENDP
0345                
;entering: strlen
0345                strlen: PROC
0345                
0345                ;-165     c=0;
0345                
0345                ;Function : strlen, Number of local variables: 2
0345                ;   # type sign width addr used name   list of local variables
0345                ;  200 ptr sign byte   164 NULL s = bp+4
0345                ;  201 var sign word   164 NULL c = bp-2;
0345 C8 02 00 00     ENTER  2,0
0349 B8 00 00        mov ax, 0
034C 89 46 FE        mov [bp-2], ax
034F                
034F                ;-166     while (*s!=0) {s++; c++;}
034F                
034F                .strlen26:
034F 8B 5E 04        mov bx, [bp+4]
0352 8A 07           mov al, [bx]
0354 B4 00           mov ah, 0
0356 83 F8 00        cmp ax, 0
0359 0F 84 00 00   r je  .strlen27
035D FF 46 04        inc  word[bp+4]
0360 FF 46 FE        inc  word[bp-2]
0363                
0363                ;-167     return c;
0363                
0363 EB EA           jmp .strlen26
0365                .strlen27:
0365 8B 46 FE        mov ax, [bp-2]
0368 E9 00 00      R jmp .retnstrlen
036B                
036B                ;-168     }
036B                
036B                
036B                ;-169 int strcpy(char *s, char *t) {
036B                
036B C9              .retnstrlen: LEAVE
036C C3              ret
;leaving: strlen. loc labels:3,loc jmp forward:2
;jmp to fix:2
1. .strlen27,from:035B,Label+ORG:0465,rel:0008
2. .retnstrlen,from:0369,Label+ORG:046B,rel:0000
036D                ENDP
036D                
;entering: strcpy
036D                strcpy: PROC
036D                
036D                ;-170     do { *s=*t; s++; t++; }
036D                
036D                ;Function : strcpy, Number of local variables: 2
036D                ;   # type sign width addr used name   list of local variables
036D                ;  200 ptr sign byte   169 NULL s = bp+4
036D                ;  201 ptr sign byte   169 NULL t = bp+6;
036D C8 00 00 00     ENTER  0,0
0371                .strcpy28:
0371 8B 5E 06        mov bx, [bp+6]
0374 8A 07           mov al, [bx]
0376 B4 00           mov ah, 0
0378 8B 5E 04        mov  bx, [bp+4]
037B 88 07           mov  [bx], al
037D FF 46 04        inc  word[bp+4]
0380 FF 46 06        inc  word[bp+6]
0383                
0383                ;-171     while (*t!=0);
0383                
0383 8B 5E 06        mov bx, [bp+6]
0386 8A 07           mov al, [bx]
0388 B4 00           mov ah, 0
038A 83 F8 00        cmp ax, 0
038D 0F 84 00 00   r je  .strcpy29
0391 EB DE           jmp .strcpy28
0393                .strcpy29:
0393                
0393                ;-172     *s=0;
0393                
0393 B8 00 00        mov ax, 0
0396 8B 5E 04        mov  bx, [bp+4]
0399 88 07           mov  [bx], al
039B                
039B                ;-173     return s;
039B                
039B 8B 46 04        mov ax, [bp+4]
039E E9 00 00      R jmp .retnstrcpy
03A1                
03A1                ;-174     }
03A1                
03A1                
03A1                ;-175 int eqstr(char *p, char *q) {
03A1                
03A1 C9              .retnstrcpy: LEAVE
03A2 C3              ret
;leaving: strcpy. loc labels:3,loc jmp forward:2
;jmp to fix:2
1. .strcpy29,from:038F,Label+ORG:0493,rel:0002
2. .retnstrcpy,from:039F,Label+ORG:04A1,rel:0000
03A3                ENDP
03A3                
;entering: eqstr
03A3                eqstr: PROC
03A3                
03A3                ;-176     while(*p) {
03A3                
03A3                ;Function : eqstr, Number of local variables: 2
03A3                ;   # type sign width addr used name   list of local variables
03A3                ;  200 ptr sign byte   175 NULL p = bp+4
03A3                ;  201 ptr sign byte   175 NULL q = bp+6;
03A3 C8 00 00 00     ENTER  0,0
03A7                .eqstr30:
03A7 8B 5E 04        mov bx, [bp+4]
03AA 8A 07           mov al, [bx]
03AC B4 00           mov ah, 0
03AE 08 C0           or  al, al
03B0 0F 84 00 00   r je .eqstr31
03B4                
03B4                ;-177         if (*p != *q) return 0;
03B4                
03B4 8B 5E 04        mov bx, [bp+4]
03B7 8A 07           mov al, [bx]
03B9 B4 00           mov ah, 0
03BB 8B 5E 06        mov bx, [bp+6]
03BE 3A 07           cmp al, [bx]
03C0 B4 00           mov ah, 0
03C2 0F 84 00 00   r je  .eqstr32
03C6 B8 00 00        mov ax, 0
03C9 E9 00 00      R jmp .retneqstr
03CC                
03CC                ;-178             p++;
03CC                
03CC                .eqstr32:
03CC FF 46 04        inc  word[bp+4]
03CF                
03CF                ;-179             q++;
03CF                
03CF FF 46 06        inc  word[bp+6]
03D2                
03D2                ;-180             }
03D2                
03D2                
03D2                ;-181     if(*q) return 0;
03D2                
03D2 EB D3           jmp .eqstr30
03D4                .eqstr31:
03D4 8B 5E 06        mov bx, [bp+6]
03D7 8A 07           mov al, [bx]
03D9 B4 00           mov ah, 0
03DB 08 C0           or  al, al
03DD 0F 84 00 00   r je .eqstr33
03E1 B8 00 00        mov ax, 0
03E4 E9 00 00      R jmp .retneqstr
03E7                
03E7                ;-182     return 1;
03E7                
03E7                .eqstr33:
03E7 B8 01 00        mov ax, 1
03EA E9 00 00      R jmp .retneqstr
03ED                
03ED                ;-183     }
03ED                
03ED                
03ED                ;-184 int strcat1(char *s, char *t) {
03ED                
03ED C9              .retneqstr: LEAVE
03EE C3              ret
;leaving: eqstr. loc labels:5,loc jmp forward:6
;jmp to fix:6
1. .eqstr31,from:03B2,Label+ORG:04D4,rel:0020
2. .eqstr32,from:03C4,Label+ORG:04CC,rel:0006
3. .retneqstr,from:03CA,Label+ORG:04ED,rel:0021
4. .eqstr33,from:03DF,Label+ORG:04E7,rel:0006
5. .retneqstr,from:03E5,Label+ORG:04ED,rel:0006
6. .retneqstr,from:03EB,Label+ORG:04ED,rel:0000
03EF                ENDP
03EF                
;entering: strcat1
03EF                strcat1: PROC
03EF                
03EF                ;-185     while (*s != 0) s++;
03EF                
03EF                ;Function : strcat1, Number of local variables: 2
03EF                ;   # type sign width addr used name   list of local variables
03EF                ;  200 ptr sign byte   184 NULL s = bp+4
03EF                ;  201 ptr sign byte   184 NULL t = bp+6;
03EF C8 00 00 00     ENTER  0,0
03F3                .strcat134:
03F3 8B 5E 04        mov bx, [bp+4]
03F6 8A 07           mov al, [bx]
03F8 B4 00           mov ah, 0
03FA 83 F8 00        cmp ax, 0
03FD 0F 84 00 00   r je  .strcat135
0401 FF 46 04        inc  word[bp+4]
0404                
0404                ;-186     strcpy(s, t);
0404                
0404 EB ED           jmp .strcat134
0406                .strcat135:
0406 55              push word [bp+6]
0407 55              push word [bp+4]
0408 E8 62 FF        call strcpy
040B 83 C4 04        add  sp, 4
040E                
040E                ;-187     }
040E                
040E                
040E                ;-188 int toupper(char *s) {
040E C9              LEAVE
040F C3              ret
;leaving: strcat1. loc labels:2,loc jmp forward:1
;jmp to fix:1
1. .strcat135,from:03FF,Label+ORG:0506,rel:0005
0410                ENDP
0410                
;entering: toupper
0410                toupper: PROC
0410                
0410                ;-189     while(*s) {
0410                
0410                ;Function : toupper, Number of local variables: 1
0410                ;   # type sign width addr used name   list of local variables
0410                ;  200 ptr sign byte   188 NULL s = bp+4;
0410 C8 00 00 00     ENTER  0,0
0414                .toupper36:
0414 8B 5E 04        mov bx, [bp+4]
0417 8A 07           mov al, [bx]
0419 B4 00           mov ah, 0
041B 08 C0           or  al, al
041D 0F 84 00 00   r je .toupper37
0421                
0421                ;-190         if (*s >= 'a') if (*s <= 'z') *s=*s-32;
0421                
0421 8B 5E 04        mov bx, [bp+4]
0424 8A 07           mov al, [bx]
0426 B4 00           mov ah, 0
0428 83 F8 61        cmp ax, 97 ;unsigned : 1
042B 0F 8C 00 00   r jl  .toupper38
042F 8B 5E 04        mov bx, [bp+4]
0432 8A 07           mov al, [bx]
0434 B4 00           mov ah, 0
0436 83 F8 7A        cmp ax, 122
0439 0F 8F 00 00   r jg  .toupper39
043D 8B 5E 04        mov bx, [bp+4]
0440 8A 07           mov al, [bx]
0442 B4 00           mov ah, 0
0444 83 E8 20        sub ax, 32
0447 8B 5E 04        mov  bx, [bp+4]
044A 88 07           mov  [bx], al
044C                
044C                ;-191             s++;
044C                
044C                .toupper39:
044C                .toupper38:
044C FF 46 04        inc  word[bp+4]
044F                
044F                ;-192               }
044F                
044F                
044F                ;-193     }
044F                
044F EB C3           jmp .toupper36
0451                .toupper37:
0451                
0451                ;-194 
0451                
0451                
0451                ;-195 int getDigit(unsigned char c) {//ret: SymbolInt
0451 C9              LEAVE
0452 C3              ret
;leaving: toupper. loc labels:4,loc jmp forward:3
;jmp to fix:3
1. .toupper37,from:041F,Label+ORG:0551,rel:0030
2. .toupper38,from:042D,Label+ORG:054C,rel:001D
3. .toupper39,from:043B,Label+ORG:054C,rel:000F
0453                ENDP
0453                
;entering: getDigit
0453                getDigit: PROC
0453                
0453                ;-196   unsigned int CastInt;
0453                
0453                
0453                ;-197   SymbolInt=0;
0453                
0453                ;Function : getDigit, Number of local variables: 2
0453                ;   # type sign width addr used name   list of local variables
0453                ;  200 var unsg byte   195 NULL c = bp+4
0453                ;  201 var unsg word   196 NULL CastInt = bp-2;
0453 C8 02 00 00     ENTER  2,0
0457 B8 00 00        mov ax, 0
045A A3 0E 01        mov word [SymbolInt], ax
045D                
045D                ;-198   do {
045D                
045D                .getDigit40:
045D                
045D                ;-199     c-='0';
045D                
045D 80 6E 04 30     sub  byte[bp+4], 48
0461                
0461                ;-200     SymbolInt=SymbolInt*10;
0461                
0461 A1 0E 01        mov ax, [SymbolInt]
0464 BB 0A 00        mov bx, 10
0467 F7 E3           mul bx
0469 A3 0E 01        mov word [SymbolInt], ax
046C                
046C                ;-201     ax=0; CastInt=c; //cast b2w
046C                
046C B8 00 00        mov  ax, 0
046F 8A 46 04        mov al, [bp+4]
0472 89 46 FE        mov [bp-2], ax
0475                
0475                ;-202     SymbolInt=SymbolInt+CastInt;
0475                
0475 A1 0E 01        mov ax, [SymbolInt]
0478 03 46 FE        add ax, [bp-2]
047B A3 0E 01        mov word [SymbolInt], ax
047E                
047E                ;-203     InputPtr++;
047E                
047E FF 06 14 01     inc  word[InputPtr]
0482                
0482                ;-204     c = *InputPtr;
0482                
0482 8B 1E 14 01     mov bx, [InputPtr]
0486 8A 07           mov al, [bx]
0488 B4 00           mov ah, 0
048A 88 46 04        mov [bp+4], al
048D                
048D                ;-205   } while(digit(c));
048D                
048D 8A 46 04        mov al, byte [bp+4]
0490 B4 00           mov ah, 0
0492 50              push ax
0493 E8 85 FE        call digit
0496 83 C4 02        add  sp, 2
0499 08 C0           or  al, al
049B 0F 84 00 00   r je .getDigit41
049F EB BC           jmp .getDigit40
04A1                .getDigit41:
04A1                
04A1                ;-206 }
04A1                
04A1                
04A1                ;-207 int getName(unsigned char c) {//ret: Symbol, SymbolUpper, isLabel
04A1 C9              LEAVE
04A2 C3              ret
;leaving: getDigit. loc labels:2,loc jmp forward:1
;jmp to fix:1
1. .getDigit41,from:049D,Label+ORG:05A1,rel:0002
04A3                ENDP
04A3                
;entering: getName
04A3                getName: PROC
04A3                
04A3                ;-208   char *p; unsigned int i;
04A3                
04A3                
04A3                ;-209   p = &Symbol;
04A3                
04A3                ;Function : getName, Number of local variables: 3
04A3                ;   # type sign width addr used name   list of local variables
04A3                ;  200 var unsg byte   207 NULL c = bp+4
04A3                ;  201 ptr sign byte   208 NULL p = bp-2
04A3                ;  202 var unsg word   208 NULL i = bp-4;
04A3 C8 04 00 00     ENTER  4,0
04A7 B8 30 75        mov ax, Symbol
04AA 89 46 FE        mov [bp-2], ax
04AD                
04AD                ;-210   *p = c;
04AD                
04AD 8A 46 04        mov al, [bp+4]
04B0 8B 5E FE        mov  bx, [bp-2]
04B3 88 07           mov  [bx], al
04B5                
04B5                ;-211   p++;
04B5                
04B5 FF 46 FE        inc  word[bp-2]
04B8                
04B8                ;-212   while (alnumE(c)) {
04B8                
04B8                .getName42:
04B8 8A 46 04        mov al, byte [bp+4]
04BB B4 00           mov ah, 0
04BD 50              push ax
04BE E8 1E FE        call alnumE
04C1 83 C4 02        add  sp, 2
04C4 08 C0           or  al, al
04C6 0F 84 00 00   r je .getName43
04CA                
04CA                ;-213     InputPtr++;
04CA                
04CA FF 06 14 01     inc  word[InputPtr]
04CE                
04CE                ;-214     c = *InputPtr;
04CE                
04CE 8B 1E 14 01     mov bx, [InputPtr]
04D2 8A 07           mov al, [bx]
04D4 B4 00           mov ah, 0
04D6 88 46 04        mov [bp+4], al
04D9                
04D9                ;-215     *p = c;
04D9                
04D9 8A 46 04        mov al, [bp+4]
04DC 8B 5E FE        mov  bx, [bp-2]
04DF 88 07           mov  [bx], al
04E1                
04E1                ;-216     p++;
04E1                
04E1 FF 46 FE        inc  word[bp-2]
04E4                
04E4                ;-217     i = p - &Symbol;
04E4                
04E4 8B 46 FE        mov ax, [bp-2]
;***** next line ERROR: invalid or no operands, Symbol: Symbol
;***** next line ERROR: syntax, Symbol: Symbol
04E7                 sub ax, Symbol
04E7 89 46 FC        mov [bp-4], ax
04EA                
04EA                ;-218     if (i >= SYMBOLMAX) errorexit("symbol too long");
04EA                
04EA 8B 46 FC        mov ax, [bp-4]
04ED 83 F8 1F        cmp ax, 31 ;unsigned : 0
04F0 0F 82 00 00   r jb  .getName44
04F4 68 AA AA      A push getName_0
04F7 E8 00 00      R call errorexit
04FA 83 C4 02        add  sp, 2
04FD                
04FD                ;-219   }
04FD                
04FD                .getName44:
04FD                
04FD                ;-220   if (c == ':') isLabel=1; else isLabel=0;
04FD                
04FD EB B9           jmp .getName42
04FF                .getName43:
04FF 8A 46 04        mov al, [bp+4]
0502 3C 3A           cmp al, 58
0504 0F 85 00 00   r jne .getName45
0508 B8 01 00        mov ax, 1
050B A2 2B 01        mov byte [isLabel], al
050E E9 00 00      R jmp .getName46
0511                .getName45:
0511 B8 00 00        mov ax, 0
0514 A2 2B 01        mov byte [isLabel], al
0517                
0517                ;-221   p--;
0517                
0517                .getName46:
0517 FF 4E FE        dec  word[bp-2]
051A                
051A                ;-222   *p = 0;
051A                
051A B8 00 00        mov ax, 0
051D 8B 5E FE        mov  bx, [bp-2]
0520 88 07           mov  [bx], al
0522                
0522                ;-223   strcpy(SymbolUpper, Symbol);
0522                
0522 8D 06 30 75     lea  ax, [Symbol]
0526 50              push ax
0527 8D 06 4F 75     lea  ax, [SymbolUpper]
052B 50              push ax
052C E8 3E FE        call strcpy
052F 83 C4 04        add  sp, 4
0532                
0532                ;-224   toupper(SymbolUpper);
0532                
0532 8D 06 4F 75     lea  ax, [SymbolUpper]
0536 50              push ax
0537 E8 D6 FE        call toupper
053A 83 C4 02        add  sp, 2
053D                
053D                ;-225 }
053D                
053D                
053D                ;-226 int testReg() {
053D C9              LEAVE
053E C3              ret
053F 73 79 6D 62 6F getName_0 db "symbol too long",0
;leaving: getName. loc labels:6,loc jmp forward:6
;jmp to fix:6
1. .getName43,from:04C8,Label+ORG:05FF,rel:0035
2. .getName44,from:04F2,Label+ORG:05FD,rel:0009
3. getName_0,from:04F5,Label+ORG:063F
4. errorexit,from:04F8
;***** ERROR: label not found: errorexit ,Label+ORG:0447,rel:FE4D
5. .getName45,from:0506,Label+ORG:0611,rel:0009
6. .getName46,from:050F,Label+ORG:0617,rel:0006
054F                ENDP
054F                
;entering: testReg
054F                testReg: PROC
054F                
054F                ;-227 //ret:RegNo: 0 - 7 AL, CL  set:R2Type: 0=no reg,BYTE,WORD,SEGREG,DWORD
054F                
054F                
054F                ;-228   R2Type=0;
054F                
054F B8 00 00        mov ax, 0
0552 A2 35 01        mov byte [R2Type], al
0555                
0555                ;-229   if (strlen(Symbol) < 2) return 0;
0555                
0555 8D 06 30 75     lea  ax, [Symbol]
0559 50              push ax
055A E8 E8 FD        call strlen
055D 83 C4 02        add  sp, 2
0560 3C 02           cmp al, 2
0562 0F 8D 00 00   r jge .testReg47
0566 B8 00 00        mov ax, 0
0569 E9 00 00      R jmp .retntestReg
056C                
056C                ;-230   if (strlen(Symbol) > 3) return 0;
056C                
056C                .testReg47:
056C 8D 06 30 75     lea  ax, [Symbol]
0570 50              push ax
0571 E8 D1 FD        call strlen
0574 83 C4 02        add  sp, 2
0577 3C 03           cmp al, 3
0579 0F 8E 00 00   r jle .testReg48
057D B8 00 00        mov ax, 0
0580 E9 00 00      R jmp .retntestReg
0583                
0583                ;-231   R2Type=BYTE;
0583                
0583                .testReg48:
0583 B8 01 00        mov ax, 1
0586 A2 35 01        mov byte [R2Type], al
0589                
0589                ;-232   if (eqstr(SymbolUpper, "AL")) return 0;
0589                
0589 68 AA AA      A push testReg_0
058C 8D 06 4F 75     lea  ax, [SymbolUpper]
0590 50              push ax
0591 E8 0F FE        call eqstr
0594 83 C4 04        add  sp, 4
0597 08 C0           or  al, al
0599 0F 84 00 00   r je .testReg49
059D B8 00 00        mov ax, 0
05A0 E9 00 00      R jmp .retntestReg
05A3                
05A3                ;-233   if (eqstr(SymbolUpper, "CL")) return 1;
05A3                
05A3                .testReg49:
05A3 68 AA AA      A push testReg_1
05A6 8D 06 4F 75     lea  ax, [SymbolUpper]
05AA 50              push ax
05AB E8 F5 FD        call eqstr
05AE 83 C4 04        add  sp, 4
05B1 08 C0           or  al, al
05B3 0F 84 00 00   r je .testReg50
05B7 B8 01 00        mov ax, 1
05BA E9 00 00      R jmp .retntestReg
05BD                
05BD                ;-234   if (eqstr(SymbolUpper, "DL")) return 2;
05BD                
05BD                .testReg50:
05BD 68 AA AA      A push testReg_2
05C0 8D 06 4F 75     lea  ax, [SymbolUpper]
05C4 50              push ax
05C5 E8 DB FD        call eqstr
05C8 83 C4 04        add  sp, 4
05CB 08 C0           or  al, al
05CD 0F 84 00 00   r je .testReg51
05D1 B8 02 00        mov ax, 2
05D4 E9 00 00      R jmp .retntestReg
05D7                
05D7                ;-235   if (eqstr(SymbolUpper, "BL")) return 3;
05D7                
05D7                .testReg51:
05D7 68 AA AA      A push testReg_3
05DA 8D 06 4F 75     lea  ax, [SymbolUpper]
05DE 50              push ax
05DF E8 C1 FD        call eqstr
05E2 83 C4 04        add  sp, 4
05E5 08 C0           or  al, al
05E7 0F 84 00 00   r je .testReg52
05EB B8 03 00        mov ax, 3
05EE E9 00 00      R jmp .retntestReg
05F1                
05F1                ;-236   if (eqstr(SymbolUpper, "AH")) return 4;
05F1                
05F1                .testReg52:
05F1 68 AA AA      A push testReg_4
05F4 8D 06 4F 75     lea  ax, [SymbolUpper]
05F8 50              push ax
05F9 E8 A7 FD        call eqstr
05FC 83 C4 04        add  sp, 4
05FF 08 C0           or  al, al
0601 0F 84 00 00   r je .testReg53
0605 B8 04 00        mov ax, 4
0608 E9 00 00      R jmp .retntestReg
060B                
060B                ;-237   if (eqstr(SymbolUpper, "CH")) return 5;
060B                
060B                .testReg53:
060B 68 AA AA      A push testReg_5
060E 8D 06 4F 75     lea  ax, [SymbolUpper]
0612 50              push ax
0613 E8 8D FD        call eqstr
0616 83 C4 04        add  sp, 4
0619 08 C0           or  al, al
061B 0F 84 00 00   r je .testReg54
061F B8 05 00        mov ax, 5
0622 E9 00 00      R jmp .retntestReg
0625                
0625                ;-238   if (eqstr(SymbolUpper, "DH")) return 6;
0625                
0625                .testReg54:
0625 68 AA AA      A push testReg_6
0628 8D 06 4F 75     lea  ax, [SymbolUpper]
062C 50              push ax
062D E8 73 FD        call eqstr
0630 83 C4 04        add  sp, 4
0633 08 C0           or  al, al
0635 0F 84 00 00   r je .testReg55
0639 B8 06 00        mov ax, 6
063C E9 00 00      R jmp .retntestReg
063F                
063F                ;-239   if (eqstr(SymbolUpper, "BH")) return 7;
063F                
063F                .testReg55:
063F 68 AA AA      A push testReg_7
0642 8D 06 4F 75     lea  ax, [SymbolUpper]
0646 50              push ax
0647 E8 59 FD        call eqstr
064A 83 C4 04        add  sp, 4
064D 08 C0           or  al, al
064F 0F 84 00 00   r je .testReg56
0653 B8 07 00        mov ax, 7
0656 E9 00 00      R jmp .retntestReg
0659                
0659                ;-240   R2Type=WORD;
0659                
0659                .testReg56:
0659 B8 02 00        mov ax, 2
065C A2 35 01        mov byte [R2Type], al
065F                
065F                ;-241   if (eqstr(SymbolUpper, "AX")) return 0;
065F                
065F 68 AA AA      A push testReg_8
0662 8D 06 4F 75     lea  ax, [SymbolUpper]
0666 50              push ax
0667 E8 39 FD        call eqstr
066A 83 C4 04        add  sp, 4
066D 08 C0           or  al, al
066F 0F 84 00 00   r je .testReg57
0673 B8 00 00        mov ax, 0
0676 E9 00 00      R jmp .retntestReg
0679                
0679                ;-242   if (eqstr(SymbolUpper, "CX")) return 1;
0679                
0679                .testReg57:
0679 68 AA AA      A push testReg_9
067C 8D 06 4F 75     lea  ax, [SymbolUpper]
0680 50              push ax
0681 E8 1F FD        call eqstr
0684 83 C4 04        add  sp, 4
0687 08 C0           or  al, al
0689 0F 84 00 00   r je .testReg58
068D B8 01 00        mov ax, 1
0690 E9 00 00      R jmp .retntestReg
0693                
0693                ;-243   if (eqstr(SymbolUpper, "DX")) return 2;
0693                
0693                .testReg58:
0693 68 AA AA      A push testReg_10
0696 8D 06 4F 75     lea  ax, [SymbolUpper]
069A 50              push ax
069B E8 05 FD        call eqstr
069E 83 C4 04        add  sp, 4
06A1 08 C0           or  al, al
06A3 0F 84 00 00   r je .testReg59
06A7 B8 02 00        mov ax, 2
06AA E9 00 00      R jmp .retntestReg
06AD                
06AD                ;-244   if (eqstr(SymbolUpper, "BX")) return 3;
06AD                
06AD                .testReg59:
06AD 68 AA AA      A push testReg_11
06B0 8D 06 4F 75     lea  ax, [SymbolUpper]
06B4 50              push ax
06B5 E8 EB FC        call eqstr
06B8 83 C4 04        add  sp, 4
06BB 08 C0           or  al, al
06BD 0F 84 00 00   r je .testReg60
06C1 B8 03 00        mov ax, 3
06C4 E9 00 00      R jmp .retntestReg
06C7                
06C7                ;-245   if (eqstr(SymbolUpper, "SP")) return 4;
06C7                
06C7                .testReg60:
06C7 68 AA AA      A push testReg_12
06CA 8D 06 4F 75     lea  ax, [SymbolUpper]
06CE 50              push ax
06CF E8 D1 FC        call eqstr
06D2 83 C4 04        add  sp, 4
06D5 08 C0           or  al, al
06D7 0F 84 00 00   r je .testReg61
06DB B8 04 00        mov ax, 4
06DE E9 00 00      R jmp .retntestReg
06E1                
06E1                ;-246   if (eqstr(SymbolUpper, "BP")) return 5;
06E1                
06E1                .testReg61:
06E1 68 AA AA      A push testReg_13
06E4 8D 06 4F 75     lea  ax, [SymbolUpper]
06E8 50              push ax
06E9 E8 B7 FC        call eqstr
06EC 83 C4 04        add  sp, 4
06EF 08 C0           or  al, al
06F1 0F 84 00 00   r je .testReg62
06F5 B8 05 00        mov ax, 5
06F8 E9 00 00      R jmp .retntestReg
06FB                
06FB                ;-247   if (eqstr(SymbolUpper, "SI")) return 6;
06FB                
06FB                .testReg62:
06FB 68 AA AA      A push testReg_14
06FE 8D 06 4F 75     lea  ax, [SymbolUpper]
0702 50              push ax
0703 E8 9D FC        call eqstr
0706 83 C4 04        add  sp, 4
0709 08 C0           or  al, al
070B 0F 84 00 00   r je .testReg63
070F B8 06 00        mov ax, 6
0712 E9 00 00      R jmp .retntestReg
0715                
0715                ;-248   if (eqstr(SymbolUpper, "DI")) return 7;
0715                
0715                .testReg63:
0715 68 AA AA      A push testReg_15
0718 8D 06 4F 75     lea  ax, [SymbolUpper]
071C 50              push ax
071D E8 83 FC        call eqstr
0720 83 C4 04        add  sp, 4
0723 08 C0           or  al, al
0725 0F 84 00 00   r je .testReg64
0729 B8 07 00        mov ax, 7
072C E9 00 00      R jmp .retntestReg
072F                
072F                ;-249   R2Type=SEGREG;
072F                
072F                .testReg64:
072F B8 04 00        mov ax, 4
0732 A2 35 01        mov byte [R2Type], al
0735                
0735                ;-250   if (eqstr(SymbolUpper, "ES")) return 0;
0735                
0735 68 AA AA      A push testReg_16
0738 8D 06 4F 75     lea  ax, [SymbolUpper]
073C 50              push ax
073D E8 63 FC        call eqstr
0740 83 C4 04        add  sp, 4
0743 08 C0           or  al, al
0745 0F 84 00 00   r je .testReg65
0749 B8 00 00        mov ax, 0
074C E9 00 00      R jmp .retntestReg
074F                
074F                ;-251   if (eqstr(SymbolUpper, "CS")) return 1;
074F                
074F                .testReg65:
074F 68 AA AA      A push testReg_17
0752 8D 06 4F 75     lea  ax, [SymbolUpper]
0756 50              push ax
0757 E8 49 FC        call eqstr
075A 83 C4 04        add  sp, 4
075D 08 C0           or  al, al
075F 0F 84 00 00   r je .testReg66
0763 B8 01 00        mov ax, 1
0766 E9 00 00      R jmp .retntestReg
0769                
0769                ;-252   if (eqstr(SymbolUpper, "SS")) return 2;
0769                
0769                .testReg66:
0769 68 AA AA      A push testReg_18
076C 8D 06 4F 75     lea  ax, [SymbolUpper]
0770 50              push ax
0771 E8 2F FC        call eqstr
0774 83 C4 04        add  sp, 4
0777 08 C0           or  al, al
0779 0F 84 00 00   r je .testReg67
077D B8 02 00        mov ax, 2
0780 E9 00 00      R jmp .retntestReg
0783                
0783                ;-253   if (eqstr(SymbolUpper, "DS")) return 3;
0783                
0783                .testReg67:
0783 68 AA AA      A push testReg_19
0786 8D 06 4F 75     lea  ax, [SymbolUpper]
078A 50              push ax
078B E8 15 FC        call eqstr
078E 83 C4 04        add  sp, 4
0791 08 C0           or  al, al
0793 0F 84 00 00   r je .testReg68
0797 B8 03 00        mov ax, 3
079A E9 00 00      R jmp .retntestReg
079D                
079D                ;-254   if (eqstr(SymbolUpper, "FS")) return 4;
079D                
079D                .testReg68:
079D 68 AA AA      A push testReg_20
07A0 8D 06 4F 75     lea  ax, [SymbolUpper]
07A4 50              push ax
07A5 E8 FB FB        call eqstr
07A8 83 C4 04        add  sp, 4
07AB 08 C0           or  al, al
07AD 0F 84 00 00   r je .testReg69
07B1 B8 04 00        mov ax, 4
07B4 E9 00 00      R jmp .retntestReg
07B7                
07B7                ;-255   if (eqstr(SymbolUpper, "GS")) return 5;
07B7                
07B7                .testReg69:
07B7 68 AA AA      A push testReg_21
07BA 8D 06 4F 75     lea  ax, [SymbolUpper]
07BE 50              push ax
07BF E8 E1 FB        call eqstr
07C2 83 C4 04        add  sp, 4
07C5 08 C0           or  al, al
07C7 0F 84 00 00   r je .testReg70
07CB B8 05 00        mov ax, 5
07CE E9 00 00      R jmp .retntestReg
07D1                
07D1                ;-256   R2Type=DWORD;
07D1                
07D1                .testReg70:
07D1 B8 03 00        mov ax, 3
07D4 A2 35 01        mov byte [R2Type], al
07D7                
07D7                ;-257   if (eqstr(SymbolUpper, "EAX"))return 0;
07D7                
07D7 68 AA AA      A push testReg_22
07DA 8D 06 4F 75     lea  ax, [SymbolUpper]
07DE 50              push ax
07DF E8 C1 FB        call eqstr
07E2 83 C4 04        add  sp, 4
07E5 08 C0           or  al, al
07E7 0F 84 00 00   r je .testReg71
07EB B8 00 00        mov ax, 0
07EE E9 00 00      R jmp .retntestReg
07F1                
07F1                ;-258   if (eqstr(SymbolUpper, "ECX"))return 1;
07F1                
07F1                .testReg71:
07F1 68 AA AA      A push testReg_23
07F4 8D 06 4F 75     lea  ax, [SymbolUpper]
07F8 50              push ax
07F9 E8 A7 FB        call eqstr
07FC 83 C4 04        add  sp, 4
07FF 08 C0           or  al, al
0801 0F 84 00 00   r je .testReg72
0805 B8 01 00        mov ax, 1
0808 E9 00 00      R jmp .retntestReg
080B                
080B                ;-259   if (eqstr(SymbolUpper, "EDX"))return 2;
080B                
080B                .testReg72:
080B 68 AA AA      A push testReg_24
080E 8D 06 4F 75     lea  ax, [SymbolUpper]
0812 50              push ax
0813 E8 8D FB        call eqstr
0816 83 C4 04        add  sp, 4
0819 08 C0           or  al, al
081B 0F 84 00 00   r je .testReg73
081F B8 02 00        mov ax, 2
0822 E9 00 00      R jmp .retntestReg
0825                
0825                ;-260   if (eqstr(SymbolUpper, "EBX"))return 3;
0825                
0825                .testReg73:
0825 68 AA AA      A push testReg_25
0828 8D 06 4F 75     lea  ax, [SymbolUpper]
082C 50              push ax
082D E8 73 FB        call eqstr
0830 83 C4 04        add  sp, 4
0833 08 C0           or  al, al
0835 0F 84 00 00   r je .testReg74
0839 B8 03 00        mov ax, 3
083C E9 00 00      R jmp .retntestReg
083F                
083F                ;-261   if (eqstr(SymbolUpper, "ESP"))return 4;
083F                
083F                .testReg74:
083F 68 AA AA      A push testReg_26
0842 8D 06 4F 75     lea  ax, [SymbolUpper]
0846 50              push ax
0847 E8 59 FB        call eqstr
084A 83 C4 04        add  sp, 4
084D 08 C0           or  al, al
084F 0F 84 00 00   r je .testReg75
0853 B8 04 00        mov ax, 4
0856 E9 00 00      R jmp .retntestReg
0859                
0859                ;-262   if (eqstr(SymbolUpper, "EBP"))return 5;
0859                
0859                .testReg75:
0859 68 AA AA      A push testReg_27
085C 8D 06 4F 75     lea  ax, [SymbolUpper]
0860 50              push ax
0861 E8 3F FB        call eqstr
0864 83 C4 04        add  sp, 4
0867 08 C0           or  al, al
0869 0F 84 00 00   r je .testReg76
086D B8 05 00        mov ax, 5
0870 E9 00 00      R jmp .retntestReg
0873                
0873                ;-263   if (eqstr(SymbolUpper, "ESI"))return 6;
0873                
0873                .testReg76:
0873 68 AA AA      A push testReg_28
0876 8D 06 4F 75     lea  ax, [SymbolUpper]
087A 50              push ax
087B E8 25 FB        call eqstr
087E 83 C4 04        add  sp, 4
0881 08 C0           or  al, al
0883 0F 84 00 00   r je .testReg77
0887 B8 06 00        mov ax, 6
088A E9 00 00      R jmp .retntestReg
088D                
088D                ;-264   if (eqstr(SymbolUpper, "EDI"))return 7;
088D                
088D                .testReg77:
088D 68 AA AA      A push testReg_29
0890 8D 06 4F 75     lea  ax, [SymbolUpper]
0894 50              push ax
0895 E8 0B FB        call eqstr
0898 83 C4 04        add  sp, 4
089B 08 C0           or  al, al
089D 0F 84 00 00   r je .testReg78
08A1 B8 07 00        mov ax, 7
08A4 E9 00 00      R jmp .retntestReg
08A7                
08A7                ;-265   R2Type=0; return 0;
08A7                
08A7                .testReg78:
08A7 B8 00 00        mov ax, 0
08AA A2 35 01        mov byte [R2Type], al
08AD B8 00 00        mov ax, 0
08B0 E9 00 00      R jmp .retntestReg
08B3                
08B3                ;-266 }
08B3                
08B3                
08B3                ;-267 
08B3                
08B3                
08B3                ;-268 
08B3                
08B3                
08B3                ;-269 //#include "OUTPUT.C"
08B3                
08B3                
08B3                ;-270 int printLine() {
08B3                
08B3                 .retntestReg:
08B3 C3              ret
08B4 41 4C 00       testReg_0 db "AL",0
08B7 43 4C 00       testReg_1 db "CL",0
08BA 44 4C 00       testReg_2 db "DL",0
08BD 42 4C 00       testReg_3 db "BL",0
08C0 41 48 00       testReg_4 db "AH",0
08C3 43 48 00       testReg_5 db "CH",0
08C6 44 48 00       testReg_6 db "DH",0
08C9 42 48 00       testReg_7 db "BH",0
08CC 41 58 00       testReg_8 db "AX",0
08CF 43 58 00       testReg_9 db "CX",0
08D2 44 58 00       testReg_10 db "DX",0
08D5 42 58 00       testReg_11 db "BX",0
08D8 53 50 00       testReg_12 db "SP",0
08DB 42 50 00       testReg_13 db "BP",0
08DE 53 49 00       testReg_14 db "SI",0
08E1 44 49 00       testReg_15 db "DI",0
08E4 45 53 00       testReg_16 db "ES",0
08E7 43 53 00       testReg_17 db "CS",0
08EA 53 53 00       testReg_18 db "SS",0
08ED 44 53 00       testReg_19 db "DS",0
08F0 46 53 00       testReg_20 db "FS",0
08F3 47 53 00       testReg_21 db "GS",0
08F6 45 41 58 00    testReg_22 db "EAX",0
08FA 45 43 58 00    testReg_23 db "ECX",0
08FE 45 44 58 00    testReg_24 db "EDX",0
0902 45 42 58 00    testReg_25 db "EBX",0
0906 45 53 50 00    testReg_26 db "ESP",0
090A 45 42 50 00    testReg_27 db "EBP",0
090E 45 53 49 00    testReg_28 db "ESI",0
0912 45 44 49 00    testReg_29 db "EDI",0
;leaving: testReg. loc labels:63,loc jmp forward:95
;jmp to fix:95
1. .testReg47,from:0564,Label+ORG:066C,rel:0006
2. .retntestReg,from:056A,Label+ORG:09B3,rel:0347
3. .testReg48,from:057B,Label+ORG:0683,rel:0006
4. .retntestReg,from:0581,Label+ORG:09B3,rel:0330
5. testReg_0,from:058A,Label+ORG:09B4
6. .testReg49,from:059B,Label+ORG:06A3,rel:0006
7. .retntestReg,from:05A1,Label+ORG:09B3,rel:0310
8. testReg_1,from:05A4,Label+ORG:09B7
9. .testReg50,from:05B5,Label+ORG:06BD,rel:0006
10. .retntestReg,from:05BB,Label+ORG:09B3,rel:02F6
11. testReg_2,from:05BE,Label+ORG:09BA
12. .testReg51,from:05CF,Label+ORG:06D7,rel:0006
13. .retntestReg,from:05D5,Label+ORG:09B3,rel:02DC
14. testReg_3,from:05D8,Label+ORG:09BD
15. .testReg52,from:05E9,Label+ORG:06F1,rel:0006
16. .retntestReg,from:05EF,Label+ORG:09B3,rel:02C2
17. testReg_4,from:05F2,Label+ORG:09C0
18. .testReg53,from:0603,Label+ORG:070B,rel:0006
19. .retntestReg,from:0609,Label+ORG:09B3,rel:02A8
20. testReg_5,from:060C,Label+ORG:09C3
21. .testReg54,from:061D,Label+ORG:0725,rel:0006
22. .retntestReg,from:0623,Label+ORG:09B3,rel:028E
23. testReg_6,from:0626,Label+ORG:09C6
24. .testReg55,from:0637,Label+ORG:073F,rel:0006
25. .retntestReg,from:063D,Label+ORG:09B3,rel:0274
26. testReg_7,from:0640,Label+ORG:09C9
27. .testReg56,from:0651,Label+ORG:0759,rel:0006
28. .retntestReg,from:0657,Label+ORG:09B3,rel:025A
29. testReg_8,from:0660,Label+ORG:09CC
30. .testReg57,from:0671,Label+ORG:0779,rel:0006
31. .retntestReg,from:0677,Label+ORG:09B3,rel:023A
32. testReg_9,from:067A,Label+ORG:09CF
33. .testReg58,from:068B,Label+ORG:0793,rel:0006
34. .retntestReg,from:0691,Label+ORG:09B3,rel:0220
35. testReg_10,from:0694,Label+ORG:09D2
36. .testReg59,from:06A5,Label+ORG:07AD,rel:0006
37. .retntestReg,from:06AB,Label+ORG:09B3,rel:0206
38. testReg_11,from:06AE,Label+ORG:09D5
39. .testReg60,from:06BF,Label+ORG:07C7,rel:0006
40. .retntestReg,from:06C5,Label+ORG:09B3,rel:01EC
41. testReg_12,from:06C8,Label+ORG:09D8
42. .testReg61,from:06D9,Label+ORG:07E1,rel:0006
43. .retntestReg,from:06DF,Label+ORG:09B3,rel:01D2
44. testReg_13,from:06E2,Label+ORG:09DB
45. .testReg62,from:06F3,Label+ORG:07FB,rel:0006
46. .retntestReg,from:06F9,Label+ORG:09B3,rel:01B8
47. testReg_14,from:06FC,Label+ORG:09DE
48. .testReg63,from:070D,Label+ORG:0815,rel:0006
49. .retntestReg,from:0713,Label+ORG:09B3,rel:019E
50. testReg_15,from:0716,Label+ORG:09E1
51. .testReg64,from:0727,Label+ORG:082F,rel:0006
52. .retntestReg,from:072D,Label+ORG:09B3,rel:0184
53. testReg_16,from:0736,Label+ORG:09E4
54. .testReg65,from:0747,Label+ORG:084F,rel:0006
55. .retntestReg,from:074D,Label+ORG:09B3,rel:0164
56. testReg_17,from:0750,Label+ORG:09E7
57. .testReg66,from:0761,Label+ORG:0869,rel:0006
58. .retntestReg,from:0767,Label+ORG:09B3,rel:014A
59. testReg_18,from:076A,Label+ORG:09EA
60. .testReg67,from:077B,Label+ORG:0883,rel:0006
61. .retntestReg,from:0781,Label+ORG:09B3,rel:0130
62. testReg_19,from:0784,Label+ORG:09ED
63. .testReg68,from:0795,Label+ORG:089D,rel:0006
64. .retntestReg,from:079B,Label+ORG:09B3,rel:0116
65. testReg_20,from:079E,Label+ORG:09F0
66. .testReg69,from:07AF,Label+ORG:08B7,rel:0006
67. .retntestReg,from:07B5,Label+ORG:09B3,rel:00FC
68. testReg_21,from:07B8,Label+ORG:09F3
69. .testReg70,from:07C9,Label+ORG:08D1,rel:0006
70. .retntestReg,from:07CF,Label+ORG:09B3,rel:00E2
71. testReg_22,from:07D8,Label+ORG:09F6
72. .testReg71,from:07E9,Label+ORG:08F1,rel:0006
73. .retntestReg,from:07EF,Label+ORG:09B3,rel:00C2
74. testReg_23,from:07F2,Label+ORG:09FA
75. .testReg72,from:0803,Label+ORG:090B,rel:0006
76. .retntestReg,from:0809,Label+ORG:09B3,rel:00A8
77. testReg_24,from:080C,Label+ORG:09FE
78. .testReg73,from:081D,Label+ORG:0925,rel:0006
79. .retntestReg,from:0823,Label+ORG:09B3,rel:008E
80. testReg_25,from:0826,Label+ORG:0A02
81. .testReg74,from:0837,Label+ORG:093F,rel:0006
82. .retntestReg,from:083D,Label+ORG:09B3,rel:0074
83. testReg_26,from:0840,Label+ORG:0A06
84. .testReg75,from:0851,Label+ORG:0959,rel:0006
85. .retntestReg,from:0857,Label+ORG:09B3,rel:005A
86. testReg_27,from:085A,Label+ORG:0A0A
87. .testReg76,from:086B,Label+ORG:0973,rel:0006
88. .retntestReg,from:0871,Label+ORG:09B3,rel:0040
89. testReg_28,from:0874,Label+ORG:0A0E
90. .testReg77,from:0885,Label+ORG:098D,rel:0006
91. .retntestReg,from:088B,Label+ORG:09B3,rel:0026
92. testReg_29,from:088E,Label+ORG:0A12
93. .testReg78,from:089F,Label+ORG:09A7,rel:0006
94. .retntestReg,from:08A5,Label+ORG:09B3,rel:000C
95. .retntestReg,from:08B1,Label+ORG:09B3,rel:0000
0916                ENDP
0916                
;entering: printLine
0916                printLine: PROC
0916                
0916                ;-271     int i; char c;
0916                
0916                
0916                ;-272     prs("\n");
0916                
0916                ;Function : printLine, Number of local variables: 2
0916                ;   # type sign width addr used name   list of local variables
0916                ;  200 var sign word   271 NULL i = bp-2
0916                ;  201 var sign byte   271 NULL c = bp-4;
0916 C8 04 00 00     ENTER  4,0
091A 68 AA AA      A push printLine_0
091D E8 00 00      R call prs
0920 83 C4 02        add  sp, 2
0923                
0923                ;-273     printhex16(PCStart);
0923                
0923 FF 36 29 01     push word [PCStart]
0927 E8 00 00      R call printhex16
092A 83 C4 02        add  sp, 2
092D                
092D                ;-274     if (OpPrintIndex == 0) prs("               ");
092D                
092D A1 41 01        mov ax, [OpPrintIndex]
0930 83 F8 00        cmp ax, 0
0933 0F 85 00 00   r jne .printLine79
0937 68 AA AA      A push printLine_1
093A E8 00 00      R call prs
093D 83 C4 02        add  sp, 2
0940                
0940                ;-275     else {
0940                
0940 E9 00 00      R jmp .printLine80
0943                .printLine79:
0943                
0943                ;-276 //        prc(' ');
0943                
0943                
0943                ;-277         i=0;
0943                
0943 B8 00 00        mov ax, 0
0946 89 46 FE        mov [bp-2], ax
0949                
0949                ;-278         do {
0949                
0949                .printLine81:
0949                
0949                ;-279             c=OpPos[i];
0949                
0949 8B 5E FE        mov bx, [bp-2]
094C 8A 87 55 77     mov al, [OpPos + bx]
0950 88 46 FC        mov [bp-4], al
0953                
0953                ;-280             prc(' ');
0953                
0953 6A 20           push 32
0955 E8 00 00      R call prc
0958 83 C4 02        add  sp, 2
095B                
095B                ;-281             printhex8a(c);
095B                
095B 8A 46 FC        mov al, byte [bp-4]
095E B4 00           mov ah, 0
0960 50              push ax
0961 E8 00 00      R call printhex8a
0964 83 C4 02        add  sp, 2
0967                
0967                ;-282             i++;
0967                
0967 FF 46 FE        inc  word[bp-2]
096A                
096A                ;-283         } while (i < OpPrintIndex);
096A                
096A 8B 46 FE        mov ax, [bp-2]
096D 3B 06 41 01     cmp ax, [OpPrintIndex]
0971 0F 8D 00 00   r jge .printLine82
0975 EB D2           jmp .printLine81
0977                .printLine82:
0977                
0977                ;-284         while (i < OPMAXLEN) {// fill rest with blank
0977                
0977                .printLine83:
0977 8B 46 FE        mov ax, [bp-2]
097A 83 F8 05        cmp ax, 5
097D 0F 8D 00 00   r jge .printLine84
0981                
0981                ;-285             prs("   ");
0981                
0981 68 AA AA      A push printLine_2
0984 E8 00 00      R call prs
0987 83 C4 02        add  sp, 2
098A                
098A                ;-286             i++;
098A                
098A FF 46 FE        inc  word[bp-2]
098D                
098D                ;-287         }
098D                
098D                
098D                ;-288     }
098D                
098D EB E8           jmp .printLine83
098F                .printLine84:
098F                
098F                ;-289     prc(PrintRA);
098F                
098F                .printLine80:
098F A0 45 01        mov al, byte [PrintRA]
0992 B4 00           mov ah, 0
0994 50              push ax
0995 E8 00 00      R call prc
0998 83 C4 02        add  sp, 2
099B                
099B                ;-290     prscomment(InputBuf);
099B                
099B 8D 06 8D 75     lea  ax, [InputBuf]
099F 50              push ax
09A0 E8 00 00      R call prscomment
09A3 83 C4 02        add  sp, 2
09A6                
09A6                ;-291 }
09A6                
09A6                
09A6                ;-292 int prc(unsigned char c) {//print char
09A6 C9              LEAVE
09A7 C3              ret
09A8 5C 6E 00       printLine_0 db "\n",0
09AB 20 20 20 20 20 printLine_1 db "               ",0
09BB 20 20 20 00    printLine_2 db "   ",0
;leaving: printLine. loc labels:9,loc jmp forward:15
;jmp to fix:15
1. printLine_0,from:091B,Label+ORG:0AA8
2. prs,from:091E
;***** ERROR: label not found: prs ,Label+ORG:0447,rel:FA27
3. printhex16,from:0928
;***** ERROR: label not found: printhex16 ,Label+ORG:0447,rel:FA1D
4. .printLine79,from:0935,Label+ORG:0A43,rel:000C
5. printLine_1,from:0938,Label+ORG:0AAB
6. prs,from:093B
;***** ERROR: label not found: prs ,Label+ORG:0447,rel:FA0A
7. .printLine80,from:0941,Label+ORG:0A8F,rel:004C
8. prc,from:0956
;***** ERROR: label not found: prc ,Label+ORG:0447,rel:F9EF
9. printhex8a,from:0962
;***** ERROR: label not found: printhex8a ,Label+ORG:0447,rel:F9E3
10. .printLine82,from:0973,Label+ORG:0A77,rel:0002
11. .printLine84,from:097F,Label+ORG:0A8F,rel:000E
12. printLine_2,from:0982,Label+ORG:0ABB
13. prs,from:0985
;***** ERROR: label not found: prs ,Label+ORG:0447,rel:F9C0
14. prc,from:0996
;***** ERROR: label not found: prc ,Label+ORG:0447,rel:F9AF
15. prscomment,from:09A1
;***** ERROR: label not found: prscomment ,Label+ORG:0447,rel:F9A4
09BF                ENDP
09BF                
;entering: prc
09BF                prc: PROC
09BF                
09BF                ;-293         if ( _ c==10) {
09BF                
09BF                ;Function : prc, Number of local variables: 1
09BF                ;   # type sign width addr used name   list of local variables
09BF                ;  200 var unsg byte   292 NULL c = bp+4;
09BF C8 00 00 00     ENTER  0,0 ; constant expression
09C3 80 7E 04 0A    cmp byte[bp+4], 10
09C7 0F 85 00 00   r jne .prc85
09CB                
09CB                ;-294             ax=13;
09CB                
09CB B8 0D 00        mov  ax, 13
09CE                
09CE                ;-295             writetty();
09CE                
09CE E8 8D F6        call writetty
09D1                
09D1                ;-296             }
09D1                
09D1                
09D1                ;-297         al=c;
09D1                
09D1                .prc85:
09D1 8A 46 04        mov  al, [bp+4]
09D4                
09D4                ;-298         writetty();
09D4                
09D4 E8 87 F6        call writetty
09D7                
09D7                ;-299     fputcR(c,lst_fd);
09D7                
09D7 FF 36 18 01     push word [lst_fd]
09DB 8A 46 04        mov al, byte [bp+4]
09DE B4 00           mov ah, 0
09E0 50              push ax
09E1 E8 1F F7        call fputcR
09E4 83 C4 04        add  sp, 4
09E7                
09E7                ;-300 }
09E7                
09E7                
09E7                ;-301 
09E7                
09E7                
09E7                ;-302 int prscomment(unsigned char *s) {
09E7 C9              LEAVE
09E8 C3              ret
;leaving: prc. loc labels:1,loc jmp forward:1
;jmp to fix:1
1. .prc85,from:09C9,Label+ORG:0AD1,rel:0006
09E9                ENDP
09E9                
;entering: prscomment
09E9                prscomment: PROC
09E9                
09E9                ;-303     unsigned char c;
09E9                
09E9                
09E9                ;-304     while (*s){
09E9                
09E9                ;Function : prscomment, Number of local variables: 2
09E9                ;   # type sign width addr used name   list of local variables
09E9                ;  200 ptr unsg byte   302 NULL s = bp+4
09E9                ;  201 var unsg byte   303 NULL c = bp-2;
09E9 C8 02 00 00     ENTER  2,0
09ED                .prscomment86:
09ED 8B 5E 04        mov bx, [bp+4]
09F0 8A 07           mov al, [bx]
09F2 B4 00           mov ah, 0
09F4 08 C0           or  al, al
09F6 0F 84 00 00   r je .prscomment87
09FA                
09FA                ;-305         c=*s;
09FA                
09FA 8B 5E 04        mov bx, [bp+4]
09FD 8A 07           mov al, [bx]
09FF B4 00           mov ah, 0
0A01 88 46 FE        mov [bp-2], al
0A04                
0A04                ;-306         prc(c);
0A04                
0A04 8A 46 FE        mov al, byte [bp-2]
0A07 B4 00           mov ah, 0
0A09 50              push ax
0A0A E8 B2 FF        call prc
0A0D 83 C4 02        add  sp, 2
0A10                
0A10                ;-307         s++;
0A10                
0A10 FF 46 04        inc  word[bp+4]
0A13                
0A13                ;-308     }
0A13                
0A13                
0A13                ;-309 }
0A13                
0A13 EB D8           jmp .prscomment86
0A15                .prscomment87:
0A15                
0A15                ;-310 int prs(unsigned char *s) {
0A15 C9              LEAVE
0A16 C3              ret
;leaving: prscomment. loc labels:2,loc jmp forward:1
;jmp to fix:1
1. .prscomment87,from:09F8,Label+ORG:0B15,rel:001B
0A17                ENDP
0A17                
;entering: prs
0A17                prs: PROC
0A17                
0A17                ;-311     unsigned char c;
0A17                
0A17                
0A17                ;-312     int com;
0A17                
0A17                
0A17                ;-313     com=0;
0A17                
0A17                ;Function : prs, Number of local variables: 3
0A17                ;   # type sign width addr used name   list of local variables
0A17                ;  200 ptr unsg byte   310 NULL s = bp+4
0A17                ;  201 var unsg byte   311 NULL c = bp-2
0A17                ;  202 var sign word   312 NULL com = bp-4;
0A17 C8 04 00 00     ENTER  4,0
0A1B B8 00 00        mov ax, 0
0A1E 89 46 FC        mov [bp-4], ax
0A21                
0A21                ;-314     while (*s) {
0A21                
0A21                .prs88:
0A21 8B 5E 04        mov bx, [bp+4]
0A24 8A 07           mov al, [bx]
0A26 B4 00           mov ah, 0
0A28 08 C0           or  al, al
0A2A 0F 84 00 00   r je .prs89
0A2E                
0A2E                ;-315         c=*s;
0A2E                
0A2E 8B 5E 04        mov bx, [bp+4]
0A31 8A 07           mov al, [bx]
0A33 B4 00           mov ah, 0
0A35 88 46 FE        mov [bp-2], al
0A38                
0A38                ;-316         if (c==34) {
0A38                
0A38 8A 46 FE        mov al, [bp-2]
0A3B 3C 22           cmp al, 34
0A3D 0F 85 00 00   r jne .prs90
0A41                
0A41                ;-317             if (com) com=0;
0A41                
0A41 8B 46 FC        mov ax, [bp-4]
0A44 08 C0           or  al, al
0A46 0F 84 00 00   r je .prs91
0A4A B8 00 00        mov ax, 0
0A4D 89 46 FC        mov [bp-4], ax
0A50                
0A50                ;-318                 else com=1;
0A50                
0A50 E9 00 00      R jmp .prs92
0A53                .prs91:
0A53 B8 01 00        mov ax, 1
0A56 89 46 FC        mov [bp-4], ax
0A59                
0A59                ;-319         }
0A59                
0A59                .prs92:
0A59                
0A59                ;-320         if (c==92) {
0A59                
0A59                .prs90:
0A59 8A 46 FE        mov al, [bp-2]
0A5C 3C 5C           cmp al, 92
0A5E 0F 85 00 00   r jne .prs93
0A62                
0A62                ;-321             if (com==0) {
0A62                
0A62 8B 46 FC        mov ax, [bp-4]
0A65 83 F8 00        cmp ax, 0
0A68 0F 85 00 00   r jne .prs94
0A6C                
0A6C                ;-322                 s++;
0A6C                
0A6C FF 46 04        inc  word[bp+4]
0A6F                
0A6F                ;-323                 c=*s;
0A6F                
0A6F 8B 5E 04        mov bx, [bp+4]
0A72 8A 07           mov al, [bx]
0A74 B4 00           mov ah, 0
0A76 88 46 FE        mov [bp-2], al
0A79                
0A79                ;-324                 if (c=='n') c=10;
0A79                
0A79 8A 46 FE        mov al, [bp-2]
0A7C 3C 6E           cmp al, 110
0A7E 0F 85 00 00   r jne .prs95
0A82 B8 0A 00        mov ax, 10
0A85 88 46 FE        mov [bp-2], al
0A88                
0A88                ;-325                 if (c=='t') c= 9;
0A88                
0A88                .prs95:
0A88 8A 46 FE        mov al, [bp-2]
0A8B 3C 74           cmp al, 116
0A8D 0F 85 00 00   r jne .prs96
0A91 B8 09 00        mov ax, 9
0A94 88 46 FE        mov [bp-2], al
0A97                
0A97                ;-326             }
0A97                
0A97                .prs96:
0A97                
0A97                ;-327         }
0A97                
0A97                .prs94:
0A97                
0A97                ;-328         prc(c);
0A97                
0A97                .prs93:
0A97 8A 46 FE        mov al, byte [bp-2]
0A9A B4 00           mov ah, 0
0A9C 50              push ax
0A9D E8 1F FF        call prc
0AA0 83 C4 02        add  sp, 2
0AA3                
0AA3                ;-329         s++;
0AA3                
0AA3 FF 46 04        inc  word[bp+4]
0AA6                
0AA6                ;-330     }
0AA6                
0AA6                
0AA6                ;-331 }
0AA6                
0AA6 E9 78 FF        jmp .prs88
0AA9                .prs89:
0AA9                
0AA9                ;-332 int printhex8a(unsigned char c) {
0AA9 C9              LEAVE
0AAA C3              ret
;leaving: prs. loc labels:9,loc jmp forward:8
;jmp to fix:8
1. .prs89,from:0A2C,Label+ORG:0BA9,rel:007B
2. .prs90,from:0A3F,Label+ORG:0B59,rel:0018
3. .prs91,from:0A48,Label+ORG:0B53,rel:0009
4. .prs92,from:0A51,Label+ORG:0B59,rel:0006
5. .prs93,from:0A60,Label+ORG:0B97,rel:0035
6. .prs94,from:0A6A,Label+ORG:0B97,rel:002B
7. .prs95,from:0A80,Label+ORG:0B88,rel:0006
8. .prs96,from:0A8F,Label+ORG:0B97,rel:0006
0AAB                ENDP
0AAB                
;entering: printhex8a
0AAB                printhex8a: PROC
0AAB                
0AAB                ;-333     unsigned char nib;
0AAB                
0AAB                
0AAB                ;-334     nib = c >> 4; printhex4(nib);
0AAB                
0AAB                ;Function : printhex8a, Number of local variables: 2
0AAB                ;   # type sign width addr used name   list of local variables
0AAB                ;  200 var unsg byte   332 NULL c = bp+4
0AAB                ;  201 var unsg byte   333 NULL nib = bp-2;
0AAB C8 02 00 00     ENTER  2,0
0AAF 8A 46 04        mov al, [bp+4]
0AB2 C0 E8 04        shr al, 4
0AB5 88 46 FE        mov [bp-2], al
0AB8 8A 46 FE        mov al, byte [bp-2]
0ABB B4 00           mov ah, 0
0ABD 50              push ax
0ABE E8 00 00      R call printhex4
0AC1 83 C4 02        add  sp, 2
0AC4                
0AC4                ;-335     nib = c & 15; printhex4(nib);
0AC4                
0AC4 8A 46 04        mov al, [bp+4]
0AC7 24 0F           and al, 15
0AC9 88 46 FE        mov [bp-2], al
0ACC 8A 46 FE        mov al, byte [bp-2]
0ACF B4 00           mov ah, 0
0AD1 50              push ax
0AD2 E8 00 00      R call printhex4
0AD5 83 C4 02        add  sp, 2
0AD8                
0AD8                ;-336 }
0AD8                
0AD8                
0AD8                ;-337 int printhex4(unsigned char c) {
0AD8 C9              LEAVE
0AD9 C3              ret
;leaving: printhex8a. loc labels:0,loc jmp forward:2
;jmp to fix:2
1. printhex4,from:0ABF
;***** ERROR: label not found: printhex4 ,Label+ORG:0447,rel:F886
2. printhex4,from:0AD3
;***** ERROR: label not found: printhex4 ,Label+ORG:0447,rel:F872
0ADA                ENDP
0ADA                
;entering: printhex4
0ADA                printhex4: PROC
0ADA                
0ADA                ;-338     c += 48;
0ADA                
0ADA                ;Function : printhex4, Number of local variables: 1
0ADA                ;   # type sign width addr used name   list of local variables
0ADA                ;  200 var unsg byte   337 NULL c = bp+4;
0ADA C8 00 00 00     ENTER  0,0
0ADE 80 46 04 30     add  byte[bp+4], 48
0AE2                
0AE2                ;-339     if (c > 57) c += 7;
0AE2                
0AE2 8A 46 04        mov al, [bp+4]
0AE5 3C 39           cmp al, 57
0AE7 0F 8E 00 00   r jle .printhex497
0AEB 80 46 04 07     add  byte[bp+4], 7
0AEF                
0AEF                ;-340     prc(c);
0AEF                
0AEF                .printhex497:
0AEF 8A 46 04        mov al, byte [bp+4]
0AF2 B4 00           mov ah, 0
0AF4 50              push ax
0AF5 E8 C7 FE        call prc
0AF8 83 C4 02        add  sp, 2
0AFB                
0AFB                ;-341 }
0AFB                
0AFB                
0AFB                ;-342 int printhex16(unsigned int i) {
0AFB C9              LEAVE
0AFC C3              ret
;leaving: printhex4. loc labels:1,loc jmp forward:1
;jmp to fix:1
1. .printhex497,from:0AE9,Label+ORG:0BEF,rel:0004
0AFD                ENDP
0AFD                
;entering: printhex16
0AFD                printhex16: PROC
0AFD                
0AFD                ;-343     unsigned int half;
0AFD                
0AFD                
0AFD                ;-344     half = i >>  8; printhex8a(half);
0AFD                
0AFD                ;Function : printhex16, Number of local variables: 2
0AFD                ;   # type sign width addr used name   list of local variables
0AFD                ;  200 var unsg word   342 NULL i = bp+4
0AFD                ;  201 var unsg word   343 NULL half = bp-2;
0AFD C8 02 00 00     ENTER  2,0
0B01 8B 46 04        mov ax, [bp+4]
0B04 C1 E8 08        shr ax, 8
0B07 89 46 FE        mov [bp-2], ax
0B0A 55              push word [bp-2]
0B0B E8 9D FF        call printhex8a
0B0E 83 C4 02        add  sp, 2
0B11                
0B11                ;-345     half = i & 255; printhex8a(half);
0B11                
0B11 8B 46 04        mov ax, [bp+4]
0B14 25 FF 00        and ax, 255
0B17 89 46 FE        mov [bp-2], ax
0B1A 55              push word [bp-2]
0B1B E8 8D FF        call printhex8a
0B1E 83 C4 02        add  sp, 2
0B21                
0B21                ;-346 }
0B21                
0B21                
0B21                ;-347 int printIntU(unsigned int n) {
0B21 C9              LEAVE
0B22 C3              ret
;leaving: printhex16. loc labels:0,loc jmp forward:0
;jmp to fix:0
0B23                ENDP
0B23                
;entering: printIntU
0B23                printIntU: PROC
0B23                
0B23                ;-348     unsigned int e;
0B23                
0B23                
0B23                ;-349     if ( _ n >= 10) {
0B23                
0B23                ;Function : printIntU, Number of local variables: 2
0B23                ;   # type sign width addr used name   list of local variables
0B23                ;  200 var unsg word   347 NULL n = bp+4
0B23                ;  201 var unsg word   348 NULL e = bp-2;
0B23 C8 02 00 00     ENTER  2,0 ; constant expression
0B27 83 7E 04 0A    cmp word[bp+4], 10 ;unsigned : 0
0B2B 0F 82 00 00   r jb  .printIntU98
0B2F                
0B2F                ;-350         e=n/10; //DIV
0B2F                
0B2F 8B 46 04        mov ax, [bp+4]
0B32 BB 0A 00        mov bx, 10
0B35 BA 00 00        mov dx, 0
0B38 F7 F3           div bx
0B3A 89 46 FE        mov [bp-2], ax
0B3D                
0B3D                ;-351         printIntU(e);
0B3D                
0B3D 55              push word [bp-2]
0B3E E8 E2 FF        call printIntU
0B41 83 C4 02        add  sp, 2
0B44                
0B44                ;-352     }
0B44                
0B44                
0B44                ;-353     n = n % 10; //unsigned mod
0B44                
0B44                .printIntU98:
0B44 8B 46 04        mov ax, [bp+4]
0B47 BB 0A 00        mov bx, 10
0B4A BA 00 00        mov dx, 0
0B4D F7 F3           div bx
0B4F 89 D0           mov ax, dx
0B51 89 46 04        mov [bp+4], ax
0B54                
0B54                ;-354     n += '0';
0B54                
0B54 83 46 04 30     add  word[bp+4], 48
0B58                
0B58                ;-355     prc(n);
0B58                
0B58 55              push word [bp+4]
0B59 E8 63 FE        call prc
0B5C 83 C4 02        add  sp, 2
0B5F                
0B5F                ;-356 }
0B5F                
0B5F                
0B5F                ;-357 
0B5F                
0B5F                
0B5F                ;-358 int error1(char *s) {
0B5F C9              LEAVE
0B60 C3              ret
;leaving: printIntU. loc labels:1,loc jmp forward:1
;jmp to fix:1
1. .printIntU98,from:0B2D,Label+ORG:0C44,rel:0015
0B61                ENDP
0B61                
;entering: error1
0B61                error1: PROC
0B61                
0B61                ;-359     ErrorCount++;
0B61                
0B61                ;Function : error1, Number of local variables: 1
0B61                ;   # type sign width addr used name   list of local variables
0B61                ;  200 ptr sign byte   358 NULL s = bp+4;
0B61 C8 00 00 00     ENTER  0,0
0B65 FF 06 1E 01     inc  word[ErrorCount]
0B69                
0B69                ;-360     prs("\n;***** next line ERROR: ");
0B69                
0B69 68 AA AA      A push error1_0
0B6C E8 A8 FE        call prs
0B6F 83 C4 02        add  sp, 2
0B72                
0B72                ;-361     prs(s);
0B72                
0B72 55              push word [bp+4]
0B73 E8 A1 FE        call prs
0B76 83 C4 02        add  sp, 2
0B79                
0B79                ;-362     prs(", Symbol: ");
0B79                
0B79 68 AA AA      A push error1_1
0B7C E8 98 FE        call prs
0B7F 83 C4 02        add  sp, 2
0B82                
0B82                ;-363     prs(Symbol);
0B82                
0B82 8D 06 30 75     lea  ax, [Symbol]
0B86 50              push ax
0B87 E8 8D FE        call prs
0B8A 83 C4 02        add  sp, 2
0B8D                
0B8D                ;-364 }
0B8D                
0B8D                
0B8D                ;-365 int errorexit(char *s) {
0B8D C9              LEAVE
0B8E C3              ret
0B8F 5C 6E 3B 2A 2A error1_0 db "\n;***** next line ERROR: ",0
0BAA 2C 20 53 79 6D error1_1 db ", Symbol: ",0
;leaving: error1. loc labels:2,loc jmp forward:2
;jmp to fix:2
1. error1_0,from:0B6A,Label+ORG:0C8F
2. error1_1,from:0B7A,Label+ORG:0CAA
0BB5                ENDP
0BB5                
;entering: errorexit
0BB5                errorexit: PROC
0BB5                
0BB5                ;-366     error1(s);
0BB5                
0BB5                ;Function : errorexit, Number of local variables: 1
0BB5                ;   # type sign width addr used name   list of local variables
0BB5                ;  200 ptr sign byte   365 NULL s = bp+4;
0BB5 C8 00 00 00     ENTER  0,0
0BB9 55              push word [bp+4]
0BBA E8 A4 FF        call error1
0BBD 83 C4 02        add  sp, 2
0BC0                
0BC0                ;-367     epilog();
0BC0                
0BC0 E8 00 00      R call epilog
0BC3                
0BC3                ;-368     end1(1);
0BC3                
0BC3 6A 01           push 1
0BC5 E8 00 00      R call end1
0BC8 83 C4 02        add  sp, 2
0BCB                
0BCB                ;-369 }
0BCB                
0BCB                
0BCB                ;-370 int notfounderror(){
0BCB C9              LEAVE
0BCC C3              ret
;leaving: errorexit. loc labels:0,loc jmp forward:2
;jmp to fix:2
1. epilog,from:0BC1
;***** ERROR: label not found: epilog ,Label+ORG:0447,rel:F784
2. end1,from:0BC6
;***** ERROR: label not found: end1 ,Label+ORG:0447,rel:F77F
0BCD                ENDP
0BCD                
;entering: notfounderror
0BCD                notfounderror: PROC
0BCD                
0BCD                ;-371     ErrorCount++;
0BCD                
0BCD FF 06 1E 01     inc  word[ErrorCount]
0BD1                
0BD1                ;-372     prs("\n;***** ERROR: label not found: ");
0BD1                
0BD1 68 AA AA      A push notfounderror_0
0BD4 E8 40 FE        call prs
0BD7 83 C4 02        add  sp, 2
0BDA                
0BDA                ;-373     prs(Symbol);
0BDA                
0BDA 8D 06 30 75     lea  ax, [Symbol]
0BDE 50              push ax
0BDF E8 35 FE        call prs
0BE2 83 C4 02        add  sp, 2
0BE5                
0BE5                ;-374 }
0BE5                
0BE5                
0BE5                ;-375 int allowederror() {error1("not allowed here"); }
0BE5                
0BE5 C3              ret
0BE6 5C 6E 3B 2A 2A notfounderror_0 db "\n;***** ERROR: label not found: ",0
;leaving: notfounderror. loc labels:1,loc jmp forward:1
;jmp to fix:1
1. notfounderror_0,from:0BD2,Label+ORG:0CE6
0C08                ENDP
0C08                
;entering: allowederror
0C08                allowederror: PROC
0C08 68 AA AA      A push allowederror_0
0C0B E8 53 FF        call error1
0C0E 83 C4 02        add  sp, 2
0C11                
0C11                ;-376 int addrerror()    {error1("address missing");}
0C11                
0C11 C3              ret
0C12 6E 6F 74 20 61 allowederror_0 db "not allowed here",0
;leaving: allowederror. loc labels:1,loc jmp forward:1
;jmp to fix:1
1. allowederror_0,from:0C09,Label+ORG:0D12
0C23                ENDP
0C23                
;entering: addrerror
0C23                addrerror: PROC
0C23 68 AA AA      A push addrerror_0
0C26 E8 38 FF        call error1
0C29 83 C4 02        add  sp, 2
0C2C                
0C2C                ;-377 int immeerror()    {error1("immediate not allowed here");}
0C2C                
0C2C C3              ret
0C2D 61 64 64 72 65 addrerror_0 db "address missing",0
;leaving: addrerror. loc labels:1,loc jmp forward:1
;jmp to fix:1
1. addrerror_0,from:0C24,Label+ORG:0D2D
0C3D                ENDP
0C3D                
;entering: immeerror
0C3D                immeerror: PROC
0C3D 68 AA AA      A push immeerror_0
0C40 E8 1E FF        call error1
0C43 83 C4 02        add  sp, 2
0C46                
0C46                ;-378 int implerror()    {error1("not implemented");}
0C46                
0C46 C3              ret
0C47 69 6D 6D 65 64 immeerror_0 db "immediate not allowed here",0
;leaving: immeerror. loc labels:1,loc jmp forward:1
;jmp to fix:1
1. immeerror_0,from:0C3E,Label+ORG:0D47
0C62                ENDP
0C62                
;entering: implerror
0C62                implerror: PROC
0C62 68 AA AA      A push implerror_0
0C65 E8 F9 FE        call error1
0C68 83 C4 02        add  sp, 2
0C6B                
0C6B                ;-379 int indexerror()   {error1("invalid index register");}
0C6B                
0C6B C3              ret
0C6C 6E 6F 74 20 69 implerror_0 db "not implemented",0
;leaving: implerror. loc labels:1,loc jmp forward:1
;jmp to fix:1
1. implerror_0,from:0C63,Label+ORG:0D6C
0C7C                ENDP
0C7C                
;entering: indexerror
0C7C                indexerror: PROC
0C7C 68 AA AA      A push indexerror_0
0C7F E8 DF FE        call error1
0C82 83 C4 02        add  sp, 2
0C85                
0C85                ;-380 int invaloperror() {error1("invalid or no operands");}
0C85                
0C85 C3              ret
0C86 69 6E 76 61 6C indexerror_0 db "invalid index register",0
;leaving: indexerror. loc labels:1,loc jmp forward:1
;jmp to fix:1
1. indexerror_0,from:0C7D,Label+ORG:0D86
0C9D                ENDP
0C9D                
;entering: invaloperror
0C9D                invaloperror: PROC
0C9D 68 AA AA      A push invaloperror_0
0CA0 E8 BE FE        call error1
0CA3 83 C4 02        add  sp, 2
0CA6                
0CA6                ;-381 int numbererror()  {error1("number expected");}
0CA6                
0CA6 C3              ret
0CA7 69 6E 76 61 6C invaloperror_0 db "invalid or no operands",0
;leaving: invaloperror. loc labels:1,loc jmp forward:1
;jmp to fix:1
1. invaloperror_0,from:0C9E,Label+ORG:0DA7
0CBE                ENDP
0CBE                
;entering: numbererror
0CBE                numbererror: PROC
0CBE 68 AA AA      A push numbererror_0
0CC1 E8 9D FE        call error1
0CC4 83 C4 02        add  sp, 2
0CC7                
0CC7                ;-382 int regmemerror()  {error1("only register or memory allowed");}
0CC7                
0CC7 C3              ret
0CC8 6E 75 6D 62 65 numbererror_0 db "number expected",0
;leaving: numbererror. loc labels:1,loc jmp forward:1
;jmp to fix:1
1. numbererror_0,from:0CBF,Label+ORG:0DC8
0CD8                ENDP
0CD8                
;entering: regmemerror
0CD8                regmemerror: PROC
0CD8 68 AA AA      A push regmemerror_0
0CDB E8 83 FE        call error1
0CDE 83 C4 02        add  sp, 2
0CE1                
0CE1                ;-383 int reg16error()   {error1("only reg16, no segreg allowed");}
0CE1                
0CE1 C3              ret
0CE2 6F 6E 6C 79 20 regmemerror_0 db "only register or memory allowed",0
;leaving: regmemerror. loc labels:1,loc jmp forward:1
;jmp to fix:1
1. regmemerror_0,from:0CD9,Label+ORG:0DE2
0D02                ENDP
0D02                
;entering: reg16error
0D02                reg16error: PROC
0D02 68 AA AA      A push reg16error_0
0D05 E8 59 FE        call error1
0D08 83 C4 02        add  sp, 2
0D0B                
0D0B                ;-384 int segregerror()  {error1("segment register not allowed");}
0D0B                
0D0B C3              ret
0D0C 6F 6E 6C 79 20 reg16error_0 db "only reg16, no segreg allowed",0
;leaving: reg16error. loc labels:1,loc jmp forward:1
;jmp to fix:1
1. reg16error_0,from:0D03,Label+ORG:0E0C
0D2A                ENDP
0D2A                
;entering: segregerror
0D2A                segregerror: PROC
0D2A 68 AA AA      A push segregerror_0
0D2D E8 31 FE        call error1
0D30 83 C4 02        add  sp, 2
0D33                
0D33                ;-385 int syntaxerror()  {error1("syntax");}
0D33                
0D33 C3              ret
0D34 73 65 67 6D 65 segregerror_0 db "segment register not allowed",0
;leaving: segregerror. loc labels:1,loc jmp forward:1
;jmp to fix:1
1. segregerror_0,from:0D2B,Label+ORG:0E34
0D51                ENDP
0D51                
;entering: syntaxerror
0D51                syntaxerror: PROC
0D51 68 AA AA      A push syntaxerror_0
0D54 E8 0A FE        call error1
0D57 83 C4 02        add  sp, 2
0D5A                
0D5A                ;-386 
0D5A                
0D5A                
0D5A                ;-387 int addrexit()     {errorexit("illegal address");}
0D5A                
0D5A C3              ret
0D5B 73 79 6E 74 61 syntaxerror_0 db "syntax",0
;leaving: syntaxerror. loc labels:1,loc jmp forward:1
;jmp to fix:1
1. syntaxerror_0,from:0D52,Label+ORG:0E5B
0D62                ENDP
0D62                
;entering: addrexit
0D62                addrexit: PROC
0D62 68 AA AA      A push addrexit_0
0D65 E8 4D FE        call errorexit
0D68 83 C4 02        add  sp, 2
0D6B                
0D6B                ;-388 int dataexit()     {errorexit("DB,DW,DD or RESB,W,D expected");}
0D6B                
0D6B C3              ret
0D6C 69 6C 6C 65 67 addrexit_0 db "illegal address",0
;leaving: addrexit. loc labels:1,loc jmp forward:1
;jmp to fix:1
1. addrexit_0,from:0D63,Label+ORG:0E6C
0D7C                ENDP
0D7C                
;entering: dataexit
0D7C                dataexit: PROC
0D7C 68 AA AA      A push dataexit_0
0D7F E8 33 FE        call errorexit
0D82 83 C4 02        add  sp, 2
0D85                
0D85                ;-389 int internexit()   {errorexit("intern compiler error");}
0D85                
0D85 C3              ret
0D86 44 42 2C 44 57 dataexit_0 db "DB,DW,DD or RESB,W,D expected",0
;leaving: dataexit. loc labels:1,loc jmp forward:1
;jmp to fix:1
1. dataexit_0,from:0D7D,Label+ORG:0E86
0DA4                ENDP
0DA4                
;entering: internexit
0DA4                internexit: PROC
0DA4 68 AA AA      A push internexit_0
0DA7 E8 0B FE        call errorexit
0DAA 83 C4 02        add  sp, 2
0DAD                
0DAD                ;-390 
0DAD                
0DAD                
0DAD                ;-391 
0DAD                
0DAD                
0DAD                ;-392 //#include "OPTABL.C"
0DAD                
0DAD                
0DAD                ;-393 char I_START=0xF1;
0DAD                
0DAD C3              ret
0DAE 69 6E 74 65 72 internexit_0 db "intern compiler error",0
;leaving: internexit. loc labels:1,loc jmp forward:1
;jmp to fix:1
1. internexit_0,from:0DA5,Label+ORG:0EAE
0DC4                ENDP
0DC4 F1             I_START db 241
0DC5                
0DC5                ;-394 //OpName, 0, CodeType, OpCode1-n, F1h
0DC5                
0DC5                
0DC5                ;-395 //  1:   1 byte opcode
0DC5                
0DC5                
0DC5                ;-396 char I_PUSHA[]={'P','U','S','H','A',0,1,0x60,0xF1, 'P','O','P','A',0,    1,0x61,0xF1};
0DC5                
0DC5 50 55 53 48 41 I_PUSHA db 80,85,83,72,65,0,1,96,241,80,79,80,65,0,1,97,241
0DD6                
0DD6                ;-397 char I_NOP[]=  {'N','O','P',0,        1,0x90,0xF1, 'C','B','W',0,        1,0x98,0xF1};
0DD6                
0DD6 4E 4F 50 00 01 I_NOP db 78,79,80,0,1,144,241,67,66,87,0,1,152,241
0DE4                
0DE4                ;-398 char I_CWDE[]= {'C','W','D','E',0,    1,0x98,0xF1, 'C','W','D',0,        1,0x99,0xF1};
0DE4                
0DE4 43 57 44 45 00 I_CWDE db 67,87,68,69,0,1,152,241,67,87,68,0,1,153,241
0DF3                
0DF3                ;-399 char I_CDQ[]=  {'C','D','Q',0,        1,0x99,0xF1, 'W','A','I','T',0,    1,0x9B,0xF1};
0DF3                
0DF3 43 44 51 00 01 I_CDQ db 67,68,81,0,1,153,241,87,65,73,84,0,1,155,241
0E02                
0E02                ;-400 char I_PUSHF[]={'P','U','S','H','F',0,1,0x9C,0xF1, 'P','O','P','F',0,    1,0x9D,0xF1};
0E02                
0E02 50 55 53 48 46 I_PUSHF db 80,85,83,72,70,0,1,156,241,80,79,80,70,0,1,157,241
0E13                
0E13                ;-401 char I_SAHF[]= {'S','A','H','F',0,    1,0x9E,0xF1, 'L','A','H','F',0,    1,0x9F,0xF1};
0E13                
0E13 53 41 48 46 00 I_SAHF db 83,65,72,70,0,1,158,241,76,65,72,70,0,1,159,241
0E23                
0E23                ;-402 char I_MOVSB[]={'M','O','V','S','B',0,1,0xA4,0xF1, 'M','O','V','S','W',0,1,0xA5,0xF1};
0E23                
0E23 4D 4F 56 53 42 I_MOVSB db 77,79,86,83,66,0,1,164,241,77,79,86,83,87,0,1,165,241
0E35                
0E35                ;-403 char I_CMPSB[]={'C','M','P','S','B',0,1,0xA6,0xF1, 'C','M','P','S','W',0,1,0xA7,0xF1};
0E35                
0E35 43 4D 50 53 42 I_CMPSB db 67,77,80,83,66,0,1,166,241,67,77,80,83,87,0,1,167,241
0E47                
0E47                ;-404 char I_STOSB[]={'S','T','O','S','B',0,1,0xAA,0xF1, 'S','T','O','S','W',0,1,0xAB,0xF1};
0E47                
0E47 53 54 4F 53 42 I_STOSB db 83,84,79,83,66,0,1,170,241,83,84,79,83,87,0,1,171,241
0E59                
0E59                ;-405 char I_LODSB[]={'L','O','D','S','B',0,1,0xAC,0xF1, 'L','O','D','S','W',0,1,0xAD,0xF1};
0E59                
0E59 4C 4F 44 53 42 I_LODSB db 76,79,68,83,66,0,1,172,241,76,79,68,83,87,0,1,173,241
0E6B                
0E6B                ;-406 char I_SCASB[]={'S','C','A','S','B',0,1,0xAE,0xF1, 'S','C','A','S','W',0,1,0xAF,0xF1};
0E6B                
0E6B 53 43 41 53 42 I_SCASB db 83,67,65,83,66,0,1,174,241,83,67,65,83,87,0,1,175,241
0E7D                
0E7D                ;-407 char I_LEAVE[]={'L','E','A','V','E',0,1,0xC9,0xF1, 'I','N','T','3',0,    1,0xCC,0xF1};
0E7D                
0E7D 4C 45 41 56 45 I_LEAVE db 76,69,65,86,69,0,1,201,241,73,78,84,51,0,1,204,241
0E8E                
0E8E                ;-408 char I_INTO[]= {'I','N','T','O',0,    1,0xCE,0xF1, 'I','R','E','T',0,    1,0xCF,0xF1};
0E8E                
0E8E 49 4E 54 4F 00 I_INTO db 73,78,84,79,0,1,206,241,73,82,69,84,0,1,207,241
0E9E                
0E9E                ;-409 char I_XLAT[]= {'X','L','A','T',0,    1,0xD7,0xF1, 'L','O','C','K',0,    1,0xF0,0xF1};
0E9E                
0E9E 58 4C 41 54 00 I_XLAT db 88,76,65,84,0,1,215,241,76,79,67,75,0,1,240,241
0EAE                
0EAE                ;-410 char I_REPNE[]={'R','E','P','N','E',0,1,0xF2,0xF1, 'R','E','P','N','Z',0,1,0xF2,0xF1};
0EAE                
0EAE 52 45 50 4E 45 I_REPNE db 82,69,80,78,69,0,1,242,241,82,69,80,78,90,0,1,242,241
0EC0                
0EC0                ;-411 char I_REPE[]= {'R','E','P','E',0,    1,0xF3,0xF1, 'R','E','P','Z',0,    1,0xF3,0xF1};
0EC0                
0EC0 52 45 50 45 00 I_REPE db 82,69,80,69,0,1,243,241,82,69,80,90,0,1,243,241
0ED0                
0ED0                ;-412 char I_HLT[]=  {'H','L','T',0,        1,0xF4,0xF1, 'C','L','C',0,        1,0xF8,0xF1};
0ED0                
0ED0 48 4C 54 00 01 I_HLT db 72,76,84,0,1,244,241,67,76,67,0,1,248,241
0EDE                
0EDE                ;-413 char I_STC[]=  {'S','T','C',0,        1,0xF9,0xF1, 'C','L','I',0,        1,0xFA,0xF1};
0EDE                
0EDE 53 54 43 00 01 I_STC db 83,84,67,0,1,249,241,67,76,73,0,1,250,241
0EEC                
0EEC                ;-414 char I_STI[]=  {'S','T','I',0,        1,0xFB,0xF1, 'C','L','D',0,        1,0xFC,0xF1};
0EEC                
0EEC 53 54 49 00 01 I_STI db 83,84,73,0,1,251,241,67,76,68,0,1,252,241
0EFA                
0EFA                ;-415 char I_STD[]=  {'S','T','D',0,        1,0xFD,0xF1};
0EFA                
0EFA 53 54 44 00 01 I_STD db 83,84,68,0,1,253,241
0F01                
0F01                ;-416 // 2: mem reg 16 bit
0F01                
0F01                
0F01                ;-417 char I_INC[]=  {'I','N','C',0,          2,0xFE, 0,0x40,0xF1};
0F01                
0F01 49 4E 43 00 02 I_INC db 73,78,67,0,2,254,0,64,241
0F0A                
0F0A                ;-418 char I_DEC[]=  {'D','E','C',0,          2,0xFE, 1,0x48,0xF1};
0F0A                
0F0A 44 45 43 00 02 I_DEC db 68,69,67,0,2,254,1,72,241
0F13                
0F13                ;-419 char I_NOT[]=  {'N','O','T',0,          2,0xF6, 2,     0xF1};
0F13                
0F13 4E 4F 54 00 02 I_NOT db 78,79,84,0,2,246,2,241
0F1B                
0F1B                ;-420 char I_NEG[]=  {'N','E','G',0,          2,0xF6, 3,     0xF1};
0F1B                
0F1B 4E 45 47 00 02 I_NEG db 78,69,71,0,2,246,3,241
0F23                
0F23                ;-421 char I_MUL[]=  {'M','U','L',0,          2,0xF6, 4,     0xF1};
0F23                
0F23 4D 55 4C 00 02 I_MUL db 77,85,76,0,2,246,4,241
0F2B                
0F2B                ;-422 char I_IMUL[]= {'I','M','U','L',0,      2,0xF6, 5,     0xF1};//only acc
0F2B                
0F2B 49 4D 55 4C 00 I_IMUL db 73,77,85,76,0,2,246,5,241
0F34                
0F34                ;-423 char I_DIV[]=  {'D','I','V',0,          2,0xF6, 6,     0xF1};
0F34                
0F34 44 49 56 00 02 I_DIV db 68,73,86,0,2,246,6,241
0F3C                
0F3C                ;-424 char I_IDIV[]= {'I','D','I','V',0,      2,0xF6, 7,     0xF1};
0F3C                
0F3C 49 44 49 56 00 I_IDIV db 73,68,73,86,0,2,246,7,241
0F45                
0F45                ;-425 //  3: les, lda, lea, lss, lfs, lgs
0F45                
0F45                
0F45                ;-426 char I_LES[]=  {'L','E','S',0,          3,0xC4,     0xF1};
0F45                
0F45 4C 45 53 00 03 I_LES db 76,69,83,0,3,196,241
0F4C                
0F4C                ;-427 char I_LDS[]=  {'L','D','S',0,          3,0xC5,     0xF1};
0F4C                
0F4C 4C 44 53 00 03 I_LDS db 76,68,83,0,3,197,241
0F53                
0F53                ;-428 char I_LEA[]=  {'L','E','A',0,          3,0x8D,     0xF1};//r, m16
0F53                
0F53 4C 45 41 00 03 I_LEA db 76,69,65,0,3,141,241
0F5A                
0F5A                ;-429 char I_LSS[]=  {'L','S','S',0,          3,0x0F,0xB2,0xF1};
0F5A                
0F5A 4C 53 53 00 03 I_LSS db 76,83,83,0,3,15,178,241
0F62                
0F62                ;-430 char I_LFS[]=  {'L','F','S',0,          3,0x0F,0xB4,0xF1};
0F62                
0F62 4C 46 53 00 03 I_LFS db 76,70,83,0,3,15,180,241
0F6A                
0F6A                ;-431 char I_LGS[]=  {'L','G','S',0,          3,0x0F,0xB5,0xF1};
0F6A                
0F6A 4C 47 53 00 03 I_LGS db 76,71,83,0,3,15,181,241
0F72                
0F72                ;-432 //  4: acc,imm  reg,imm  index,reg
0F72                
0F72                
0F72                ;-433 char I_ADD[]=  {'A','D','D',0,          4, 0,     0xF1};
0F72                
0F72 41 44 44 00 04 I_ADD db 65,68,68,0,4,0,241
0F79                
0F79                ;-434 char I_OR []=  {'O','R',0,              4, 1,     0xF1};
0F79                
0F79 4F 52 00 04 01 I_OR db 79,82,0,4,1,241
0F7F                
0F7F                ;-435 char I_ADC[]=  {'A','D','C',0,          4, 2,     0xF1};
0F7F                
0F7F 41 44 43 00 04 I_ADC db 65,68,67,0,4,2,241
0F86                
0F86                ;-436 char I_SBB[]=  {'S','B','B',0,          4, 3,     0xF1};
0F86                
0F86 53 42 42 00 04 I_SBB db 83,66,66,0,4,3,241
0F8D                
0F8D                ;-437 char I_AND[]=  {'A','N','D',0,          4, 4,     0xF1};
0F8D                
0F8D 41 4E 44 00 04 I_AND db 65,78,68,0,4,4,241
0F94                
0F94                ;-438 char I_SUB[]=  {'S','U','B',0,          4, 5,     0xF1};
0F94                
0F94 53 55 42 00 04 I_SUB db 83,85,66,0,4,5,241
0F9B                
0F9B                ;-439 char I_XOR[]=  {'X','O','R',0,          4, 6,     0xF1};
0F9B                
0F9B 58 4F 52 00 04 I_XOR db 88,79,82,0,4,6,241
0FA2                
0FA2                ;-440 char I_CMP[]=  {'C','M','P',0,          4, 7,     0xF1};
0FA2                
0FA2 43 4D 50 00 04 I_CMP db 67,77,80,0,4,7,241
0FA9                
0FA9                ;-441 char I_TEST[]= {'T','E','S','T',0,     41,0xA8,0x84,0xF6,0,0xF1};
0FA9                
0FA9 54 45 53 54 00 I_TEST db 84,69,83,84,0,41,168,132,246,0,241
0FB4                
0FB4                ;-442 //  5: mov
0FB4                
0FB4                
0FB4                ;-443 char I_MOV[]=  {'M','O','V',0,          5,        0xF1};
0FB4                
0FB4 4D 4F 56 00 05 I_MOV db 77,79,86,0,5,241
0FBA                
0FBA                ;-444 char I_MOVSX[]={'M','O','V','S','X',0, 51,0xBE,   0xF1};
0FBA                
0FBA 4D 4F 56 53 58 I_MOVSX db 77,79,86,83,88,0,51,190,241
0FC3                
0FC3                ;-445 char I_MOVZX[]={'M','O','V','Z','X',0, 51,0xB6,   0xF1};
0FC3                
0FC3 4D 4F 56 5A 58 I_MOVZX db 77,79,86,90,88,0,51,182,241
0FCC                
0FCC                ;-446 //  6: single byte relative jump
0FCC                
0FCC                
0FCC                ;-447 char I_JO []=  {'J','O',0,     6, 0,0xF1};
0FCC                
0FCC 4A 4F 00 06 00 I_JO db 74,79,0,6,0,241
0FD2                
0FD2                ;-448 char I_JNO[]=  {'J','N','O',0, 6, 1,0xF1};
0FD2                
0FD2 4A 4E 4F 00 06 I_JNO db 74,78,79,0,6,1,241
0FD9                
0FD9                ;-449 char I_JB []=  {'J','B',0,     6, 2,0xF1, 'J','C',0,     6, 2,0xF1};
0FD9                
0FD9 4A 42 00 06 02 I_JB db 74,66,0,6,2,241,74,67,0,6,2,241
0FE5                
0FE5                ;-450 char I_JNB[]=  {'J','N','B',0, 6, 3,0xF1};
0FE5                
0FE5 4A 4E 42 00 06 I_JNB db 74,78,66,0,6,3,241
0FEC                
0FEC                ;-451 char I_JAE[]=  {'J','A','E',0, 6, 3,0xF1, 'J','N','C',0, 6, 3,0xF1};
0FEC                
0FEC 4A 41 45 00 06 I_JAE db 74,65,69,0,6,3,241,74,78,67,0,6,3,241
0FFA                
0FFA                ;-452 char I_JE []=  {'J','E',0,     6, 4,0xF1, 'J','Z',0,     6, 4,0xF1};
0FFA                
0FFA 4A 45 00 06 04 I_JE db 74,69,0,6,4,241,74,90,0,6,4,241
1006                
1006                ;-453 char I_JNE[]=  {'J','N','E',0, 6, 5,0xF1, 'J','N','Z',0, 6, 5,0xF1};
1006                
1006 4A 4E 45 00 06 I_JNE db 74,78,69,0,6,5,241,74,78,90,0,6,5,241
1014                
1014                ;-454 char I_JBE[]=  {'J','B','E',0, 6, 6,0xF1, 'J','N','A',0, 6, 6,0xF1};
1014                
1014 4A 42 45 00 06 I_JBE db 74,66,69,0,6,6,241,74,78,65,0,6,6,241
1022                
1022                ;-455 char I_JA []=  {'J','A',0,     6, 7,0xF1};
1022                
1022 4A 41 00 06 07 I_JA db 74,65,0,6,7,241
1028                
1028                ;-456 char I_JS []=  {'J','S',0,     6, 8,0xF1};
1028                
1028 4A 53 00 06 08 I_JS db 74,83,0,6,8,241
102E                
102E                ;-457 char I_JNS[]=  {'J','N','S',0, 6, 9,0xF1};
102E                
102E 4A 4E 53 00 06 I_JNS db 74,78,83,0,6,9,241
1035                
1035                ;-458 char I_JP []=  {'J','P',0,     6,10,0xF1, 'J','P','E',0, 6,10,0xF1};
1035                
1035 4A 50 00 06 0A I_JP db 74,80,0,6,10,241,74,80,69,0,6,10,241
1042                
1042                ;-459 char I_JNP[]=  {'J','N','P',0, 6,11,0xF1, 'J','P','O',0, 6,11,0xF1};
1042                
1042 4A 4E 50 00 06 I_JNP db 74,78,80,0,6,11,241,74,80,79,0,6,11,241
1050                
1050                ;-460 char I_JL []=  {'J','L',0,     6,12,0xF1};
1050                
1050 4A 4C 00 06 0C I_JL db 74,76,0,6,12,241
1056                
1056                ;-461 char I_JNL[]=  {'J','N','L',0, 6,13,0xF1, 'J','G','E',0, 6,13,0xF1};
1056                
1056 4A 4E 4C 00 06 I_JNL db 74,78,76,0,6,13,241,74,71,69,0,6,13,241
1064                
1064                ;-462 char I_JLE[]=  {'J','L','E',0, 6,14,0xF1, 'J','N','G',0, 6,14,0xF1};
1064                
1064 4A 4C 45 00 06 I_JLE db 74,76,69,0,6,14,241,74,78,71,0,6,14,241
1072                
1072                ;-463 char I_JG []=  {'J','G',0,     6,15,0xF1};
1072                
1072 4A 47 00 06 0F I_JG db 74,71,0,6,15,241
1078                
1078                ;-464 //  7: jmp, call
1078                
1078                
1078                ;-465 char I_JMP[]=  {'J','M','P',0,          7,0xE9, 4,0xF1};
1078                
1078 4A 4D 50 00 07 I_JMP db 74,77,80,0,7,233,4,241
1080                
1080                ;-466 char I_CALL[]= {'C','A','L','L',0,      7,0xE8, 2,0xF1};
1080                
1080 43 41 4C 4C 00 I_CALL db 67,65,76,76,0,7,232,2,241
1089                
1089                ;-467 //  8: ret
1089                
1089                
1089                ;-468 char I_RET[]=  {'R','E','T',0,          8,0xC3,0xC2,0xF1};
1089                
1089 52 45 54 00 08 I_RET db 82,69,84,0,8,195,194,241
1091                
1091                ;-469 char I_RETF[]= {'R','E','T','F',0,      8,0xCB,0xCA,0xF1};
1091                
1091 52 45 54 46 00 I_RETF db 82,69,84,70,0,8,203,202,241
109A                
109A                ;-470 //  9: seg, r/m
109A                
109A                
109A                ;-471 char I_PUSH[]= {'P','U','S','H',0,      9,0x50,0xFF,6,6,0xF1};//r16
109A                
109A 50 55 53 48 00 I_PUSH db 80,85,83,72,0,9,80,255,6,6,241
10A5                
10A5                ;-472 char I_POP[]=  {'P','O','P',0,          9,0x58,0x8F,0,7,0xF1};//r16
10A5                
10A5 50 4F 50 00 09 I_POP db 80,79,80,0,9,88,143,0,7,241
10AF                
10AF                ;-473 //  11: shift, rotates
10AF                
10AF                
10AF                ;-474 char I_ROL[]=  {'R','O','L',0, 11, 0,0xF1, 'R','O','R',0, 11, 1,0xF1};
10AF                
10AF 52 4F 4C 00 0B I_ROL db 82,79,76,0,11,0,241,82,79,82,0,11,1,241
10BD                
10BD                ;-475 char I_RCL[]=  {'R','C','L',0, 11, 2,0xF1, 'R','C','R',0, 11, 3,0xF1};
10BD                
10BD 52 43 4C 00 0B I_RCL db 82,67,76,0,11,2,241,82,67,82,0,11,3,241
10CB                
10CB                ;-476 char I_SHL[]=  {'S','H','L',0, 11, 4,0xF1, 'S','A','L',0, 11, 4,0xF1};
10CB                
10CB 53 48 4C 00 0B I_SHL db 83,72,76,0,11,4,241,83,65,76,0,11,4,241
10D9                
10D9                ;-477 char I_SHR[]=  {'S','H','R',0, 11, 5,0xF1, 'S','A','R',0, 11, 7,0xF1};
10D9                
10D9 53 48 52 00 0B I_SHR db 83,72,82,0,11,5,241,83,65,82,0,11,7,241
10E7                
10E7                ;-478 //  12: int
10E7                
10E7                
10E7                ;-479 char I_INT[]=  {'I','N','T',0,          12,0xCD,0xCC,0xF1};
10E7                
10E7 49 4E 54 00 0C I_INT db 73,78,84,0,12,205,204,241
10EF                
10EF                ;-480 //  14: in/out
10EF                
10EF                
10EF                ;-481 char I_IN[]=   {'I','N',0,              14,0xE4,0xEC,0xF1};
10EF                
10EF 49 4E 00 0E E4 I_IN db 73,78,0,14,228,236,241
10F6                
10F6                ;-482 char I_INSB[]= {'I','N','S','B',0,      14,0x6C,   0xF1};
10F6                
10F6 49 4E 53 42 00 I_INSB db 73,78,83,66,0,14,108,241
10FE                
10FE                ;-483 char I_INSW[]= {'I','N','S','W',0,      14,0x6D,   0xF1};
10FE                
10FE 49 4E 53 57 00 I_INSW db 73,78,83,87,0,14,109,241
1106                
1106                ;-484 char I_INSD[]= {'I','N','S','D',0,      14,0x6D,   0xF1};
1106                
1106 49 4E 53 44 00 I_INSD db 73,78,83,68,0,14,109,241
110E                
110E                ;-485 char I_OUT[]=  {'O','U','T',0,          14,0xE6,0xEE,0xF1};
110E                
110E 4F 55 54 00 0E I_OUT db 79,85,84,0,14,230,238,241
1116                
1116                ;-486 char I_OUTSB[]={'O','U','T','B',0,      14,0x6E,   0xF1};
1116                
1116 4F 55 54 42 00 I_OUTSB db 79,85,84,66,0,14,110,241
111E                
111E                ;-487 char I_OUTSW[]={'O','U','T','W',0,      14,0x6F,   0xF1};
111E                
111E 4F 55 54 57 00 I_OUTSW db 79,85,84,87,0,14,111,241
1126                
1126                ;-488 char I_OUTSD[]={'O','U','T','D',0,      14,0x6F,   0xF1};
1126                
1126 4F 55 54 44 00 I_OUTSD db 79,85,84,68,0,14,111,241
112E                
112E                ;-489 //  15: xchg
112E                
112E                
112E                ;-490 char I_XCHG[]= {'X','C','H','G',0,      15,0x86,0x90,0xF1};
112E                
112E 58 43 48 47 00 I_XCHG db 88,67,72,71,0,15,134,144,241
1137                
1137                ;-491 //  16: loop, jcxz
1137                
1137                
1137                ;-492 char I_LOOPNZ[]={'L','O','O','P','N','Z',0, 16,0xE0,0xF1};
1137                
1137 4C 4F 4F 50 4E I_LOOPNZ db 76,79,79,80,78,90,0,16,224,241
1141                
1141                ;-493 char I_LOOPNE[]={'L','O','O','P','N','E',0, 16,0xE0,0xF1};
1141                
1141 4C 4F 4F 50 4E I_LOOPNE db 76,79,79,80,78,69,0,16,224,241
114B                
114B                ;-494 char I_LOOPZ[]={'L','O','O','P','Z',0,      16,0xE1,0xF1};
114B                
114B 4C 4F 4F 50 5A I_LOOPZ db 76,79,79,80,90,0,16,225,241
1154                
1154                ;-495 char I_LOOPE[]={'L','O','O','P','E',0,      16,0xE1,0xF1};
1154                
1154 4C 4F 4F 50 45 I_LOOPE db 76,79,79,80,69,0,16,225,241
115D                
115D                ;-496 char I_LOOP[]= {'L','O','O','P',0,          16,0xE2,0xF1};
115D                
115D 4C 4F 4F 50 00 I_LOOP db 76,79,79,80,0,16,226,241
1165                
1165                ;-497 char I_JCXZ[]= {'J','C','X','Z',0,          16,0xE3,0xF1};
1165                
1165 4A 43 58 5A 00 I_JCXZ db 74,67,88,90,0,16,227,241
116D                
116D                ;-498 char I_JECXZ[]= {'J','E','C','X','Z',0,     16,0xE3,0xF1};
116D                
116D 4A 45 43 58 5A I_JECXZ db 74,69,67,88,90,0,16,227,241
1176                
1176                ;-499 //  30: enter
1176                
1176                
1176                ;-500 char I_ENTER[]={'E','N','T','E','R',0, 30,        0xF1};
1176                
1176 45 4E 54 45 52 I_ENTER db 69,78,84,69,82,0,30,241
117E                
117E                ;-501 // 100: directives
117E                
117E                
117E                ;-502 char I_ORG[]=  {'O','R','G',0,        101,        0xF1};
117E                
117E 4F 52 47 00 65 I_ORG db 79,82,71,0,101,241
1184                
1184                ;-503 // section, segment .TEXT .DATA .BSS
1184                
1184                
1184                ;-504 char I_SECTION[]={'S','E','C','T','I','O','N',0,      102, 0xF1};
1184                
1184 53 45 43 54 49 I_SECTION db 83,69,67,84,73,79,78,0,102,241
118E                
118E                ;-505 char I_SEGMENT[]={'S','E','G','M','E','N','T',0,      102, 0xF1};
118E                
118E 53 45 47 4D 45 I_SEGMENT db 83,69,71,77,69,78,84,0,102,241
1198                
1198                ;-506 char I_ABSOLUTE[]={'A','B','S','O','L','U','T','E',0, 110, 0xF1};
1198                
1198 41 42 53 4F 4C I_ABSOLUTE db 65,66,83,79,76,85,84,69,0,110,241
11A3                
11A3                ;-507 char I_PROC[]= {'P','R','O','C',0,    111,        0xF1};
11A3                
11A3 50 52 4F 43 00 I_PROC db 80,82,79,67,0,111,241
11AA                
11AA                ;-508 char I_ENDP[]= {'E','N','D','P',0,    112,        0xF1};
11AA                
11AA 45 4E 44 50 00 I_ENDP db 69,78,68,80,0,112,241
11B1                
11B1                ;-509 char I_DB[]=   {'D','B',0,            200,        0xF1};
11B1                
11B1 44 42 00 C8 F1 I_DB db 68,66,0,200,241
11B6                
11B6                ;-510 char I_DW[]=   {'D','W',0,            201,        0xF1};
11B6                
11B6 44 57 00 C9 F1 I_DW db 68,87,0,201,241
11BB                
11BB                ;-511 char I_DD[]=   {'D','D',0,            202,        0xF1};
11BB                
11BB 44 44 00 CA F1 I_DD db 68,68,0,202,241
11C0                
11C0                ;-512 char I_RESB[]= {'R','E','S','B',0,    203,        0xF1};
11C0                
11C0 52 45 53 42 00 I_RESB db 82,69,83,66,0,203,241
11C7                
11C7                ;-513 char I_RESW[]= {'R','E','S','W',0,    204,        0xF1};
11C7                
11C7 52 45 53 57 00 I_RESW db 82,69,83,87,0,204,241
11CE                
11CE                ;-514 char I_RESD[]= {'R','E','S','D',0,    205,        0xF1};
11CE                
11CE 52 45 53 44 00 I_RESD db 82,69,83,68,0,205,241
11D5                
11D5                ;-515 char I_END=0;// end of table char
11D5                
11D5 00             I_END db 0
11D6                
11D6                ;-516 
11D6                
11D6                
11D6                ;-517 int lookCode() {//ret: CodeType, *OpCodePtr
11D6                
11D6                
;entering: lookCode
11D6                lookCode: PROC
11D6                
11D6                ;-518     CodeType=0;
11D6                
11D6 B8 00 00        mov ax, 0
11D9 A2 2F 01        mov byte [CodeType], al
11DC                
11DC                ;-519     OpCodePtr= &I_START;
11DC                
11DC B8 C4 0E        mov ax, I_START
11DF A3 43 01        mov word [OpCodePtr], ax
11E2                
11E2                ;-520     OpCodePtr++;
11E2                
11E2 FF 06 43 01     inc  word[OpCodePtr]
11E6                
11E6                ;-521     do  {
11E6                
11E6                .lookCode99:
11E6                
11E6                ;-522         if (eqstr(SymbolUpper, OpCodePtr))  {
11E6                
11E6 FF 36 43 01     push word [OpCodePtr]
11EA 8D 06 4F 75     lea  ax, [SymbolUpper]
11EE 50              push ax
11EF E8 B1 F1        call eqstr
11F2 83 C4 04        add  sp, 4
11F5 08 C0           or  al, al
11F7 0F 84 00 00   r je .lookCode100
11FB                
11FB                ;-523             while(*OpCodePtr!=0) OpCodePtr++;
11FB                
11FB                .lookCode101:
11FB 8B 1E 43 01     mov bx, [OpCodePtr]
11FF 8A 07           mov al, [bx]
1201 B4 00           mov ah, 0
1203 83 F8 00        cmp ax, 0
1206 0F 84 00 00   r je  .lookCode102
120A FF 06 43 01     inc  word[OpCodePtr]
120E                
120E                ;-524             OpCodePtr++;
120E                
120E EB EB           jmp .lookCode101
1210                .lookCode102:
1210 FF 06 43 01     inc  word[OpCodePtr]
1214                
1214                ;-525             CodeType =*OpCodePtr;
1214                
1214 8B 1E 43 01     mov bx, [OpCodePtr]
1218 8A 07           mov al, [bx]
121A B4 00           mov ah, 0
121C A2 2F 01        mov byte [CodeType], al
121F                
121F                ;-526             return;
121F                
121F E9 00 00      R jmp .retnlookCode
1222                
1222                ;-527         }
1222                
1222                
1222                ;-528     while(*OpCodePtr!=0xF1) OpCodePtr++;
1222                
1222                .lookCode100:
1222                .lookCode103:
1222 8B 1E 43 01     mov bx, [OpCodePtr]
1226 8A 07           mov al, [bx]
1228 B4 00           mov ah, 0
122A 3D F1 00        cmp ax, 241
122D 0F 84 00 00   r je  .lookCode104
1231 FF 06 43 01     inc  word[OpCodePtr]
1235                
1235                ;-529     OpCodePtr++;
1235                
1235 EB EB           jmp .lookCode103
1237                .lookCode104:
1237 FF 06 43 01     inc  word[OpCodePtr]
123B                
123B                ;-530     } while(*OpCodePtr!=0);
123B                
123B 8B 1E 43 01     mov bx, [OpCodePtr]
123F 8A 07           mov al, [bx]
1241 B4 00           mov ah, 0
1243 83 F8 00        cmp ax, 0
1246 0F 84 00 00   r je  .lookCode105
124A EB 9A           jmp .lookCode99
124C                .lookCode105:
124C                
124C                ;-531 }
124C                
124C                
124C                ;-532 
124C                
124C                
124C                ;-533 //#include "OPS.C"
124C                
124C                
124C                ;-534 int ChangeDirection() {
124C                
124C                 .retnlookCode:
124C C3              ret
;leaving: lookCode. loc labels:8,loc jmp forward:5
;jmp to fix:5
1. .lookCode100,from:11F9,Label+ORG:1322,rel:0027
2. .lookCode102,from:1208,Label+ORG:1310,rel:0006
3. .retnlookCode,from:1220,Label+ORG:134C,rel:002A
4. .lookCode104,from:122F,Label+ORG:1337,rel:0006
5. .lookCode105,from:1248,Label+ORG:134C,rel:0002
124D                ENDP
124D                
;entering: ChangeDirection
124D                ChangeDirection: PROC
124D                
124D                ;-535     char c;
124D                
124D                
124D                ;-536     c=Op;     Op    =Op2;    Op2   =c;
124D                
124D                ;Function : ChangeDirection, Number of local variables: 1
124D                ;   # type sign width addr used name   list of local variables
124D                ;  200 var sign byte   535 NULL c = bp-2;
124D C8 02 00 00     ENTER  2,0
1251 A0 2D 01        mov al, [Op]
1254 88 46 FE        mov [bp-2], al
1257 A0 2E 01        mov al, [Op2]
125A A2 2D 01        mov byte [Op], al
125D 8A 46 FE        mov al, [bp-2]
1260 A2 2E 01        mov byte [Op2], al
1263                
1263                ;-537     c=R1Type; R1Type=R2Type; R2Type=c;
1263                
1263 A0 36 01        mov al, [R1Type]
1266 88 46 FE        mov [bp-2], al
1269 A0 35 01        mov al, [R2Type]
126C A2 36 01        mov byte [R1Type], al
126F 8A 46 FE        mov al, [bp-2]
1272 A2 35 01        mov byte [R2Type], al
1275                
1275                ;-538     c=R1No;   R1No  =R2No;   R2No  =c;
1275                
1275 A0 34 01        mov al, [R1No]
1278 88 46 FE        mov [bp-2], al
127B A0 33 01        mov al, [R2No]
127E A2 34 01        mov byte [R1No], al
1281 8A 46 FE        mov al, [bp-2]
1284 A2 33 01        mov byte [R2No], al
1287                
1287                ;-539     dflag=2;
1287                
1287 B8 02 00        mov ax, 2
128A A2 39 01        mov byte [dflag], al
128D                
128D                ;-540 }
128D                
128D                
128D                ;-541 
128D                
128D                
128D                ;-542 int checkOpL() {
128D C9              LEAVE
128E C3              ret
;leaving: ChangeDirection. loc labels:0,loc jmp forward:0
;jmp to fix:0
128F                ENDP
128F                
;entering: checkOpL
128F                checkOpL: PROC
128F                
128F                ;-543     if (Op == ADR) implerror();
128F                
128F A0 2D 01        mov al, [Op]
1292 3C 03           cmp al, 3
1294 0F 85 00 00   r jne .checkOpL106
1298 E8 C7 F9        call implerror
129B                
129B                ;-544     if (R1Type==SEGREG) {segregerror();return;}//only move,push,pop
129B                
129B                .checkOpL106:
129B A0 36 01        mov al, [R1Type]
129E 3C 04           cmp al, 4
12A0 0F 85 00 00   r jne .checkOpL107
12A4 E8 83 FA        call segregerror
12A7 E9 00 00      R jmp .retncheckOpL
12AA                
12AA                ;-545     setwflag();
12AA                
12AA                .checkOpL107:
12AA E8 00 00      R call setwflag
12AD                
12AD                ;-546     if (OpSize == 0) error1("no op size declared");
12AD                
12AD A0 37 01        mov al, [OpSize]
12B0 3C 00           cmp al, 0
12B2 0F 85 00 00   r jne .checkOpL108
12B6 68 AA AA      A push checkOpL_0
12B9 E8 A5 F8        call error1
12BC 83 C4 02        add  sp, 2
12BF                
12BF                ;-547     if (OpSize == R1Type) return;
12BF                
12BF                .checkOpL108:
12BF A0 37 01        mov al, [OpSize]
12C2 3A 06 36 01     cmp al, [R1Type]
12C6 0F 85 00 00   r jne .checkOpL109
12CA E9 00 00      R jmp .retncheckOpL
12CD                
12CD                ;-548     if (Op == REG) if (R1Type==0) error1("no register defined");
12CD                
12CD                .checkOpL109:
12CD A0 2D 01        mov al, [Op]
12D0 3C 02           cmp al, 2
12D2 0F 85 00 00   r jne .checkOpL110
12D6 A0 36 01        mov al, [R1Type]
12D9 3C 00           cmp al, 0
12DB 0F 85 00 00   r jne .checkOpL111
12DF 68 AA AA      A push checkOpL_1
12E2 E8 7C F8        call error1
12E5 83 C4 02        add  sp, 2
12E8                
12E8                ;-549 }
12E8                
12E8                .checkOpL111:
12E8                .checkOpL110:
12E8                
12E8                ;-550 
12E8                
12E8                
12E8                ;-551 int check2Ops() {
12E8                
12E8                 .retncheckOpL:
12E8 C3              ret
12E9 6E 6F 20 6F 70 checkOpL_0 db "no op size declared",0
12FD 6E 6F 20 72 65 checkOpL_1 db "no register defined",0
;leaving: checkOpL. loc labels:9,loc jmp forward:11
;jmp to fix:11
1. .checkOpL106,from:1296,Label+ORG:139B,rel:0003
2. .checkOpL107,from:12A2,Label+ORG:13AA,rel:0006
3. .retncheckOpL,from:12A8,Label+ORG:13E8,rel:003E
4. setwflag,from:12AB
;***** ERROR: label not found: setwflag ,Label+ORG:0447,rel:F09A
5. .checkOpL108,from:12B4,Label+ORG:13BF,rel:0009
6. checkOpL_0,from:12B7,Label+ORG:13E9
7. .checkOpL109,from:12C8,Label+ORG:13CD,rel:0003
8. .retncheckOpL,from:12CB,Label+ORG:13E8,rel:001B
9. .checkOpL110,from:12D4,Label+ORG:13E8,rel:0012
10. .checkOpL111,from:12DD,Label+ORG:13E8,rel:0009
11. checkOpL_1,from:12E0,Label+ORG:13FD
1311                ENDP
1311                
;entering: check2Ops
1311                check2Ops: PROC
1311                
1311                ;-552     get2Ops();
1311                
1311 E8 00 00      R call get2Ops
1314                
1314                ;-553     if (Op ==   0) addrerror();
1314                
1314 A0 2D 01        mov al, [Op]
1317 3C 00           cmp al, 0
1319 0F 85 00 00   r jne .check2Ops112
131D E8 03 F9        call addrerror
1320                
1320                ;-554     if (Op == ADR) invaloperror();
1320                
1320                .check2Ops112:
1320 A0 2D 01        mov al, [Op]
1323 3C 03           cmp al, 3
1325 0F 85 00 00   r jne .check2Ops113
1329 E8 71 F9        call invaloperror
132C                
132C                ;-555     if (Op == IMM) immeerror();
132C                
132C                .check2Ops113:
132C A0 2D 01        mov al, [Op]
132F 3C 01           cmp al, 1
1331 0F 85 00 00   r jne .check2Ops114
1335 E8 05 F9        call immeerror
1338                
1338                ;-556     if (Op2==   0) addrerror();
1338                
1338                .check2Ops114:
1338 A0 2E 01        mov al, [Op2]
133B 3C 00           cmp al, 0
133D 0F 85 00 00   r jne .check2Ops115
1341 E8 DF F8        call addrerror
1344                
1344                ;-557     if (CodeType != 5) if (Op2==ADR) invaloperror();//only mov
1344                
1344                .check2Ops115:
1344 A0 2F 01        mov al, [CodeType]
1347 3C 05           cmp al, 5
1349 0F 84 00 00   r je  .check2Ops116
134D A0 2E 01        mov al, [Op2]
1350 3C 03           cmp al, 3
1352 0F 85 00 00   r jne .check2Ops117
1356 E8 44 F9        call invaloperror
1359                
1359                ;-558     setwflag();
1359                
1359                .check2Ops117:
1359                .check2Ops116:
1359 E8 00 00      R call setwflag
135C                
135C                ;-559 }
135C                
135C                
135C                ;-560 int get2Ops() {
135C                
135C C3              ret
;leaving: check2Ops. loc labels:6,loc jmp forward:8
;jmp to fix:8
1. get2Ops,from:1312
;***** ERROR: label not found: get2Ops ,Label+ORG:0447,rel:F033
2. .check2Ops112,from:131B,Label+ORG:1420,rel:0003
3. .check2Ops113,from:1327,Label+ORG:142C,rel:0003
4. .check2Ops114,from:1333,Label+ORG:1438,rel:0003
5. .check2Ops115,from:133F,Label+ORG:1444,rel:0003
6. .check2Ops116,from:134B,Label+ORG:1459,rel:000C
7. .check2Ops117,from:1354,Label+ORG:1459,rel:0003
8. setwflag,from:135A
;***** ERROR: label not found: setwflag ,Label+ORG:0447,rel:EFEB
135D                ENDP
135D                
;entering: get2Ops
135D                get2Ops: PROC
135D                
135D                ;-561     getOpL();
135D                
135D E8 00 00      R call getOpL
1360                
1360                ;-562     need(',');
1360                
1360 6A 2C           push 44
1362 E8 00 00      R call need
1365 83 C4 02        add  sp, 2
1368                
1368                ;-563     getOpR();
1368                
1368 E8 00 00      R call getOpR
136B                
136B                ;-564 }
136B                
136B                
136B                ;-565 
136B                
136B                
136B                ;-566 int getOpL() {
136B                
136B C3              ret
;leaving: get2Ops. loc labels:0,loc jmp forward:3
;jmp to fix:3
1. getOpL,from:135E
;***** ERROR: label not found: getOpL ,Label+ORG:0447,rel:EFE7
2. need,from:1363
;***** ERROR: label not found: need ,Label+ORG:0447,rel:EFE2
3. getOpR,from:1369
;***** ERROR: label not found: getOpR ,Label+ORG:0447,rel:EFDC
136C                ENDP
136C                
;entering: getOpL
136C                getOpL: PROC
136C                
136C                ;-567 //set: op=0,IMM,REG,ADR,MEM
136C                
136C                
136C                ;-568     getOpR();
136C                
136C E8 00 00      R call getOpR
136F                
136F                ;-569     Op=Op2;         Op2=0;
136F                
136F A0 2E 01        mov al, [Op2]
1372 A2 2D 01        mov byte [Op], al
1375 B8 00 00        mov ax, 0
1378 A2 2E 01        mov byte [Op2], al
137B                
137B                ;-570     R1No=R2No;      R2No=0;
137B                
137B A0 33 01        mov al, [R2No]
137E A2 34 01        mov byte [R1No], al
1381 B8 00 00        mov ax, 0
1384 A2 33 01        mov byte [R2No], al
1387                
1387                ;-571     R1Type=R2Type; R2Type=0;
1387                
1387 A0 35 01        mov al, [R2Type]
138A A2 36 01        mov byte [R1Type], al
138D B8 00 00        mov ax, 0
1390 A2 35 01        mov byte [R2Type], al
1393                
1393                ;-572 }
1393                
1393                
1393                ;-573 
1393                
1393                
1393                ;-574 int getOpR() {
1393                
1393 C3              ret
;leaving: getOpL. loc labels:0,loc jmp forward:1
;jmp to fix:1
1. getOpR,from:136D
;***** ERROR: label not found: getOpR ,Label+ORG:0447,rel:EFD8
1394                ENDP
1394                
;entering: getOpR
1394                getOpR: PROC
1394                
1394                ;-575     Op2=getOp1();
1394                
1394 E8 00 00      R call getOp1
1397 A2 2E 01        mov byte [Op2], al
139A                
139A                ;-576     if (isToken('[')) {Op2 = MEM; getMEM();    return;}
139A                
139A 6A 5B           push 91
139C E8 00 00      R call isToken
139F 83 C4 02        add  sp, 2
13A2 08 C0           or  al, al
13A4 0F 84 00 00   r je .getOpR118
13A8 B8 04 00        mov ax, 4
13AB A2 2E 01        mov byte [Op2], al
13AE E8 00 00      R call getMEM
13B1 E9 00 00      R jmp .retngetOpR
13B4                
13B4                ;-577     if (Op2 == 0)     {invaloperror();         return;}
13B4                
13B4                .getOpR118:
13B4 A0 2E 01        mov al, [Op2]
13B7 3C 00           cmp al, 0
13B9 0F 85 00 00   r jne .getOpR119
13BD E8 DD F8        call invaloperror
13C0 E9 00 00      R jmp .retngetOpR
13C3                
13C3                ;-578     if (Op2 == IMM)   {imme=SymbolInt;         return;}
13C3                
13C3                .getOpR119:
13C3 A0 2E 01        mov al, [Op2]
13C6 3C 01           cmp al, 1
13C8 0F 85 00 00   r jne .getOpR120
13CC A1 0E 01        mov ax, [SymbolInt]
13CF A3 3F 01        mov word [imme], ax
13D2 E9 00 00      R jmp .retngetOpR
13D5                
13D5                ;-579     if (Op2 == REG)                            return;
13D5                
13D5                .getOpR120:
13D5 A0 2E 01        mov al, [Op2]
13D8 3C 02           cmp al, 2
13DA 0F 85 00 00   r jne .getOpR121
13DE E9 00 00      R jmp .retngetOpR
13E1                
13E1                ;-580     if (Op2 == ADR)   {
13E1                
13E1                .getOpR121:
13E1 A0 2E 01        mov al, [Op2]
13E4 3C 03           cmp al, 3
13E6 0F 85 00 00   r jne .getOpR122
13EA                
13EA                ;-581         if (LabelIx == 0) disp=0;
13EA                
13EA A1 4E 01        mov ax, [LabelIx]
13ED 83 F8 00        cmp ax, 0
13F0 0F 85 00 00   r jne .getOpR123
13F4 B8 00 00        mov ax, 0
13F7 A3 3D 01        mov word [disp], ax
13FA                
13FA                ;-582         else disp=LabelAddr[LabelIx];
13FA                
13FA E9 00 00      R jmp .getOpR124
13FD                .getOpR123:
13FD 8B 1E 4E 01     mov bx, [LabelIx]
1401 D1 E3           shl bx, 1
1403 8B 47 CA        mov ax, [LabelAddr + bx]
1406 A3 3D 01        mov word [disp], ax
1409                
1409                ;-583         return;}
1409                
1409                .getOpR124:
1409 E9 00 00      R jmp .retngetOpR
140C                
140C                ;-584     error1("Name of operand expected");
140C                
140C                .getOpR122:
140C 68 AA AA      A push getOpR_0
140F E8 4F F7        call error1
1412 83 C4 02        add  sp, 2
1415                
1415                ;-585 }
1415                
1415                
1415                ;-586 
1415                
1415                
1415                ;-587 int getOp1() {//scan for a single operand
1415                
1415                 .retngetOpR:
1415 C3              ret
1416 4E 61 6D 65 20 getOpR_0 db "Name of operand expected",0
;leaving: getOpR. loc labels:9,loc jmp forward:16
;jmp to fix:16
1. getOp1,from:1395
;***** ERROR: label not found: getOp1 ,Label+ORG:0447,rel:EFB0
2. isToken,from:139D
;***** ERROR: label not found: isToken ,Label+ORG:0447,rel:EFA8
3. .getOpR118,from:13A6,Label+ORG:14B4,rel:000C
4. getMEM,from:13AF
;***** ERROR: label not found: getMEM ,Label+ORG:0447,rel:EF96
5. .retngetOpR,from:13B2,Label+ORG:1515,rel:0061
6. .getOpR119,from:13BB,Label+ORG:14C3,rel:0006
7. .retngetOpR,from:13C1,Label+ORG:1515,rel:0052
8. .getOpR120,from:13CA,Label+ORG:14D5,rel:0009
9. .retngetOpR,from:13D3,Label+ORG:1515,rel:0040
10. .getOpR121,from:13DC,Label+ORG:14E1,rel:0003
11. .retngetOpR,from:13DF,Label+ORG:1515,rel:0034
12. .getOpR122,from:13E8,Label+ORG:150C,rel:0022
13. .getOpR123,from:13F2,Label+ORG:14FD,rel:0009
14. .getOpR124,from:13FB,Label+ORG:1509,rel:000C
15. .retngetOpR,from:140A,Label+ORG:1515,rel:0009
16. getOpR_0,from:140D,Label+ORG:1516
142F                ENDP
142F                
;entering: getOp1
142F                getOp1: PROC
142F                
142F                ;-588 //return:0, IMM, REG, ADR (not MEM)
142F                
142F                
142F                ;-589 //set   :R2Type, R2No by testReg
142F                
142F                
142F                ;-590 //set   :LabelIx by searchLabel
142F                
142F                
142F                ;-591     if (TokeType == 0)      return 0;
142F                
142F A0 2C 01        mov al, [TokeType]
1432 3C 00           cmp al, 0
1434 0F 85 00 00   r jne .getOp1125
1438 B8 00 00        mov ax, 0
143B E9 00 00      R jmp .retngetOp1
143E                
143E                ;-592     if (TokeType == DIGIT)  return IMM;
143E                
143E                .getOp1125:
143E A0 2C 01        mov al, [TokeType]
1441 3C 01           cmp al, 1
1443 0F 85 00 00   r jne .getOp1126
1447 B8 01 00        mov ax, 1
144A E9 00 00      R jmp .retngetOp1
144D                
144D                ;-593     if (TokeType == ALNUME) {
144D                
144D                .getOp1126:
144D A0 2C 01        mov al, [TokeType]
1450 3C 03           cmp al, 3
1452 0F 85 00 00   r jne .getOp1127
1456                
1456                ;-594         R2No=testReg();
1456                
1456 E8 F6 F0        call testReg
1459 A2 33 01        mov byte [R2No], al
145C                
145C                ;-595         if (R2Type)        return REG;
145C                
145C A0 35 01        mov al, [R2Type]
145F 08 C0           or  al, al
1461 0F 84 00 00   r je .getOp1128
1465 B8 02 00        mov ax, 2
1468 E9 00 00      R jmp .retngetOp1
146B                
146B                ;-596         LabelIx=searchLabel();
146B                
146B                .getOp1128:
146B E8 00 00      R call searchLabel
146E A3 4E 01        mov word [LabelIx], ax
1471                
1471                ;-597         return ADR;
1471                
1471 B8 03 00        mov ax, 3
1474 E9 00 00      R jmp .retngetOp1
1477                
1477                ;-598 //        if (LabelIx)        return ADR;
1477                
1477                
1477                ;-599 //        else error1("variable not found");
1477                
1477                
1477                ;-600     }
1477                
1477                
1477                ;-601     return 0;
1477                
1477                .getOp1127:
1477 B8 00 00        mov ax, 0
147A E9 00 00      R jmp .retngetOp1
147D                
147D                ;-602 }
147D                
147D                
147D                ;-603 
147D                
147D                
147D                ;-604 int getMEM() {// e.g. [array+bp+si-4]
147D                
147D                 .retngetOp1:
147D C3              ret
;leaving: getOp1. loc labels:5,loc jmp forward:10
;jmp to fix:10
1. .getOp1125,from:1436,Label+ORG:153E,rel:0006
2. .retngetOp1,from:143C,Label+ORG:157D,rel:003F
3. .getOp1126,from:1445,Label+ORG:154D,rel:0006
4. .retngetOp1,from:144B,Label+ORG:157D,rel:0030
5. .getOp1127,from:1454,Label+ORG:1577,rel:0021
6. .getOp1128,from:1463,Label+ORG:156B,rel:0006
7. .retngetOp1,from:1469,Label+ORG:157D,rel:0012
8. searchLabel,from:146C
;***** ERROR: label not found: searchLabel ,Label+ORG:0447,rel:EED9
9. .retngetOp1,from:1475,Label+ORG:157D,rel:0006
10. .retngetOp1,from:147B,Label+ORG:157D,rel:0000
147E                ENDP
147E                
;entering: getMEM
147E                getMEM: PROC
147E                
147E                ;-605 //set: disp, rm, R2Type
147E                
147E                
147E                ;-606     char c;
147E                
147E                
147E                ;-607     disp=0; rm=0;
147E                
147E                ;Function : getMEM, Number of local variables: 1
147E                ;   # type sign width addr used name   list of local variables
147E                ;  200 var sign byte   606 NULL c = bp-2;
147E C8 02 00 00     ENTER  2,0
1482 B8 00 00        mov ax, 0
1485 A3 3D 01        mov word [disp], ax
1488 B8 00 00        mov ax, 0
148B A2 3B 01        mov byte [rm], al
148E                
148E                ;-608     do {
148E                
148E                .getMEM129:
148E                
148E                ;-609         getTokeType();
148E                
148E E8 00 00      R call getTokeType
1491                
1491                ;-610         c=getOp1();
1491                
1491 E8 9B FF        call getOp1
1494 88 46 FE        mov [bp-2], al
1497                
1497                ;-611         if (c ==   0) syntaxerror();
1497                
1497 8A 46 FE        mov al, [bp-2]
149A 3C 00           cmp al, 0
149C 0F 85 00 00   r jne .getMEM130
14A0 E8 AE F8        call syntaxerror
14A3                
14A3                ;-612         if (c == REG) {
14A3                
14A3                .getMEM130:
14A3 8A 46 FE        mov al, [bp-2]
14A6 3C 02           cmp al, 2
14A8 0F 85 00 00   r jne .getMEM131
14AC                
14AC                ;-613             isDirect=0;
14AC                
14AC B8 00 00        mov ax, 0
14AF A2 3C 01        mov byte [isDirect], al
14B2                
14B2                ;-614             if (rm) rm=getIndReg2();
14B2                
14B2 A0 3B 01        mov al, [rm]
14B5 08 C0           or  al, al
14B7 0F 84 00 00   r je .getMEM132
14BB E8 00 00      R call getIndReg2
14BE A2 3B 01        mov byte [rm], al
14C1                
14C1                ;-615             else getIndReg1();
14C1                
14C1 E9 00 00      R jmp .getMEM133
14C4                .getMEM132:
14C4 E8 00 00      R call getIndReg1
14C7                
14C7                ;-616         }
14C7                
14C7                .getMEM133:
14C7                
14C7                ;-617         if (c == ADR) {
14C7                
14C7                .getMEM131:
14C7 8A 46 FE        mov al, [bp-2]
14CA 3C 03           cmp al, 3
14CC 0F 85 00 00   r jne .getMEM134
14D0                
14D0                ;-618             if (LabelIx)    disp=disp+LabelAddr[LabelIx];
14D0                
14D0 A1 4E 01        mov ax, [LabelIx]
14D3 08 C0           or  al, al
14D5 0F 84 00 00   r je .getMEM135
14D9 A1 3D 01        mov ax, [disp]
14DC 8B 1E 4E 01     mov bx, [LabelIx]
14E0 D1 E3           shl bx, 1
14E2 03 47 CA        add ax, [LabelAddr + bx]
14E5 A3 3D 01        mov word [disp], ax
14E8                
14E8                ;-619             else notfounderror();
14E8                
14E8 E9 00 00      R jmp .getMEM136
14EB                .getMEM135:
14EB E8 DF F6        call notfounderror
14EE                
14EE                ;-620         }
14EE                
14EE                .getMEM136:
14EE                
14EE                ;-621         if (c == IMM) disp=disp+SymbolInt;
14EE                
14EE                .getMEM134:
14EE 8A 46 FE        mov al, [bp-2]
14F1 3C 01           cmp al, 1
14F3 0F 85 00 00   r jne .getMEM137
14F7 A1 3D 01        mov ax, [disp]
14FA 03 06 0E 01     add ax, [SymbolInt]
14FE A3 3D 01        mov word [disp], ax
1501                
1501                ;-622         if (isToken('-')) {
1501                
1501                .getMEM137:
1501 6A 2D           push 45
1503 E8 00 00      R call isToken
1506 83 C4 02        add  sp, 2
1509 08 C0           or  al, al
150B 0F 84 00 00   r je .getMEM138
150F                
150F                ;-623             getTokeType();
150F                
150F E8 00 00      R call getTokeType
1512                
1512                ;-624             if (TokeType != DIGIT) numbererror();
1512                
1512 A0 2C 01        mov al, [TokeType]
1515 3C 01           cmp al, 1
1517 0F 84 00 00   r je  .getMEM139
151B E8 A0 F7        call numbererror
151E                
151E                ;-625             disp = disp - SymbolInt;
151E                
151E                .getMEM139:
151E A1 3D 01        mov ax, [disp]
1521 2B 06 0E 01     sub ax, [SymbolInt]
1525 A3 3D 01        mov word [disp], ax
1528                
1528                ;-626         }
1528                
1528                
1528                ;-627     } while (isToken('+'));
1528                
1528                .getMEM138:
1528 6A 2B           push 43
152A E8 00 00      R call isToken
152D 83 C4 02        add  sp, 2
1530 08 C0           or  al, al
1532 0F 84 00 00   r je .getMEM140
1536 E9 55 FF        jmp .getMEM129
1539                .getMEM140:
1539                
1539                ;-628     if (isToken(']') == 0) errorexit("] expected");
1539                
1539 6A 5D           push 93
153B E8 00 00      R call isToken
153E 83 C4 02        add  sp, 2
1541 83 F8 00        cmp ax, 0
1544 0F 85 00 00   r jne .getMEM141
1548 68 AA AA      A push getMEM_0
154B E8 67 F6        call errorexit
154E 83 C4 02        add  sp, 2
1551                
1551                ;-629 }
1551                
1551                .getMEM141:
1551                
1551                ;-630 int getIndReg1() {
1551 C9              LEAVE
1552 C3              ret
1553 5D 20 65 78 70 getMEM_0 db "] expected",0
;leaving: getMEM. loc labels:14,loc jmp forward:20
;jmp to fix:20
1. getTokeType,from:148F
;***** ERROR: label not found: getTokeType ,Label+ORG:0447,rel:EEB6
2. .getMEM130,from:149E,Label+ORG:15A3,rel:0003
3. .getMEM131,from:14AA,Label+ORG:15C7,rel:001B
4. .getMEM132,from:14B9,Label+ORG:15C4,rel:0009
5. getIndReg2,from:14BC
;***** ERROR: label not found: getIndReg2 ,Label+ORG:0447,rel:EE89
6. .getMEM133,from:14C2,Label+ORG:15C7,rel:0003
7. getIndReg1,from:14C5
;***** ERROR: label not found: getIndReg1 ,Label+ORG:0447,rel:EE80
8. .getMEM134,from:14CE,Label+ORG:15EE,rel:001E
9. .getMEM135,from:14D7,Label+ORG:15EB,rel:0012
10. .getMEM136,from:14E9,Label+ORG:15EE,rel:0003
11. .getMEM137,from:14F5,Label+ORG:1601,rel:000A
12. isToken,from:1504
;***** ERROR: label not found: isToken ,Label+ORG:0447,rel:EE41
13. .getMEM138,from:150D,Label+ORG:1628,rel:0019
14. getTokeType,from:1510
;***** ERROR: label not found: getTokeType ,Label+ORG:0447,rel:EE35
15. .getMEM139,from:1519,Label+ORG:161E,rel:0003
16. isToken,from:152B
;***** ERROR: label not found: isToken ,Label+ORG:0447,rel:EE1A
17. .getMEM140,from:1534,Label+ORG:1639,rel:0003
18. isToken,from:153C
;***** ERROR: label not found: isToken ,Label+ORG:0447,rel:EE09
19. .getMEM141,from:1546,Label+ORG:1651,rel:0009
20. getMEM_0,from:1549,Label+ORG:1653
155E                ENDP
155E                
;entering: getIndReg1
155E                getIndReg1: PROC
155E                
155E                ;-631     if (R2Type !=WORD) indexerror();
155E                
155E A0 35 01        mov al, [R2Type]
1561 3C 02           cmp al, 2
1563 0F 84 00 00   r je  .getIndReg1142
1567 E8 12 F7        call indexerror
156A                
156A                ;-632     if (R2No==3) rm=7;//BX
156A                
156A                .getIndReg1142:
156A A0 33 01        mov al, [R2No]
156D 3C 03           cmp al, 3
156F 0F 85 00 00   r jne .getIndReg1143
1573 B8 07 00        mov ax, 7
1576 A2 3B 01        mov byte [rm], al
1579                
1579                ;-633     if (R2No==5) rm=6;//BP, change to BP+0
1579                
1579                .getIndReg1143:
1579 A0 33 01        mov al, [R2No]
157C 3C 05           cmp al, 5
157E 0F 85 00 00   r jne .getIndReg1144
1582 B8 06 00        mov ax, 6
1585 A2 3B 01        mov byte [rm], al
1588                
1588                ;-634     if (R2No==7) rm=5;//DI
1588                
1588                .getIndReg1144:
1588 A0 33 01        mov al, [R2No]
158B 3C 07           cmp al, 7
158D 0F 85 00 00   r jne .getIndReg1145
1591 B8 05 00        mov ax, 5
1594 A2 3B 01        mov byte [rm], al
1597                
1597                ;-635     if (R2No==6) rm=4;//SI
1597                
1597                .getIndReg1145:
1597 A0 33 01        mov al, [R2No]
159A 3C 06           cmp al, 6
159C 0F 85 00 00   r jne .getIndReg1146
15A0 B8 04 00        mov ax, 4
15A3 A2 3B 01        mov byte [rm], al
15A6                
15A6                ;-636     if (rm==0) indexerror();
15A6                
15A6                .getIndReg1146:
15A6 A0 3B 01        mov al, [rm]
15A9 3C 00           cmp al, 0
15AB 0F 85 00 00   r jne .getIndReg1147
15AF E8 CA F6        call indexerror
15B2                
15B2                ;-637 }
15B2                
15B2                .getIndReg1147:
15B2                
15B2                ;-638 int getIndReg2() {char m; m=4;//because m=0 is BX+DI
15B2                
15B2 C3              ret
;leaving: getIndReg1. loc labels:6,loc jmp forward:6
;jmp to fix:6
1. .getIndReg1142,from:1565,Label+ORG:166A,rel:0003
2. .getIndReg1143,from:1571,Label+ORG:1679,rel:0006
3. .getIndReg1144,from:1580,Label+ORG:1688,rel:0006
4. .getIndReg1145,from:158F,Label+ORG:1697,rel:0006
5. .getIndReg1146,from:159E,Label+ORG:16A6,rel:0006
6. .getIndReg1147,from:15AD,Label+ORG:16B2,rel:0003
15B3                ENDP
15B3                
;entering: getIndReg2
15B3                getIndReg2: PROC
15B3                ;Function : getIndReg2, Number of local variables: 1
15B3                ;   # type sign width addr used name   list of local variables
15B3                ;  200 var sign byte   638 NULL m = bp-2;
15B3 C8 02 00 00     ENTER  2,0
15B7 B8 04 00        mov ax, 4
15BA 88 46 FE        mov [bp-2], al
15BD                
15BD                ;-639     if (R2Type !=WORD) indexerror();
15BD                
15BD A0 35 01        mov al, [R2Type]
15C0 3C 02           cmp al, 2
15C2 0F 84 00 00   r je  .getIndReg2148
15C6 E8 B3 F6        call indexerror
15C9                
15C9                ;-640     if (R2No==7) if (rm==6) m=3;//BP+DI
15C9                
15C9                .getIndReg2148:
15C9 A0 33 01        mov al, [R2No]
15CC 3C 07           cmp al, 7
15CE 0F 85 00 00   r jne .getIndReg2149
15D2 A0 3B 01        mov al, [rm]
15D5 3C 06           cmp al, 6
15D7 0F 85 00 00   r jne .getIndReg2150
15DB B8 03 00        mov ax, 3
15DE 88 46 FE        mov [bp-2], al
15E1                
15E1                ;-641              else if (rm==7) m=1;//BX+DI
15E1                
15E1 E9 00 00      R jmp .getIndReg2151
15E4                .getIndReg2150:
15E4 A0 3B 01        mov al, [rm]
15E7 3C 07           cmp al, 7
15E9 0F 85 00 00   r jne .getIndReg2152
15ED B8 01 00        mov ax, 1
15F0 88 46 FE        mov [bp-2], al
15F3                
15F3                ;-642     if (R2No==6) if (rm==6) m=2;//BP+SI
15F3                
15F3                .getIndReg2152:
15F3                .getIndReg2151:
15F3                .getIndReg2149:
15F3 A0 33 01        mov al, [R2No]
15F6 3C 06           cmp al, 6
15F8 0F 85 00 00   r jne .getIndReg2153
15FC A0 3B 01        mov al, [rm]
15FF 3C 06           cmp al, 6
1601 0F 85 00 00   r jne .getIndReg2154
1605 B8 02 00        mov ax, 2
1608 88 46 FE        mov [bp-2], al
160B                
160B                ;-643              else if (rm==7) m=0;//BX+SI
160B                
160B E9 00 00      R jmp .getIndReg2155
160E                .getIndReg2154:
160E A0 3B 01        mov al, [rm]
1611 3C 07           cmp al, 7
1613 0F 85 00 00   r jne .getIndReg2156
1617 B8 00 00        mov ax, 0
161A 88 46 FE        mov [bp-2], al
161D                
161D                ;-644     if (m > 3) indexerror();
161D                
161D                .getIndReg2156:
161D                .getIndReg2155:
161D                .getIndReg2153:
161D 8A 46 FE        mov al, [bp-2]
1620 3C 03           cmp al, 3
1622 0F 8E 00 00   r jle .getIndReg2157
1626 E8 53 F6        call indexerror
1629                
1629                ;-645     return m;
1629                
1629                .getIndReg2157:
1629 8A 46 FE        mov al, [bp-2]
162C E9 00 00      R jmp .retngetIndReg2
162F                
162F                ;-646 }
162F                
162F                
162F                ;-647 
162F                
162F                
162F                ;-648 int setwflag() {//word size, bit 0
162F                
162F C9              .retngetIndReg2: LEAVE
1630 C3              ret
;leaving: getIndReg2. loc labels:11,loc jmp forward:11
;jmp to fix:11
1. .getIndReg2148,from:15C4,Label+ORG:16C9,rel:0003
2. .getIndReg2149,from:15D0,Label+ORG:16F3,rel:0021
3. .getIndReg2150,from:15D9,Label+ORG:16E4,rel:0009
4. .getIndReg2151,from:15E2,Label+ORG:16F3,rel:000F
5. .getIndReg2152,from:15EB,Label+ORG:16F3,rel:0006
6. .getIndReg2153,from:15FA,Label+ORG:171D,rel:0021
7. .getIndReg2154,from:1603,Label+ORG:170E,rel:0009
8. .getIndReg2155,from:160C,Label+ORG:171D,rel:000F
9. .getIndReg2156,from:1615,Label+ORG:171D,rel:0006
10. .getIndReg2157,from:1624,Label+ORG:1729,rel:0003
11. .retngetIndReg2,from:162D,Label+ORG:172F,rel:0000
1631                ENDP
1631                
;entering: setwflag
1631                setwflag: PROC
1631                
1631                ;-649     wflag=0;
1631                
1631 B8 00 00        mov ax, 0
1634 A2 38 01        mov byte [wflag], al
1637                
1637                ;-650     if (OpSize == 0) {//do not override OpSize
1637                
1637 A0 37 01        mov al, [OpSize]
163A 3C 00           cmp al, 0
163C 0F 85 00 00   r jne .setwflag158
1640                
1640                ;-651         if (Op == REG) OpSize=R1Type;
1640                
1640 A0 2D 01        mov al, [Op]
1643 3C 02           cmp al, 2
1645 0F 85 00 00   r jne .setwflag159
1649 A0 36 01        mov al, [R1Type]
164C A2 37 01        mov byte [OpSize], al
164F                
164F                ;-652         if (Op2== REG) OpSize=R2Type;
164F                
164F                .setwflag159:
164F A0 2E 01        mov al, [Op2]
1652 3C 02           cmp al, 2
1654 0F 85 00 00   r jne .setwflag160
1658 A0 35 01        mov al, [R2Type]
165B A2 37 01        mov byte [OpSize], al
165E                
165E                ;-653         if (R2Type== SEGREG) OpSize=WORD;
165E                
165E                .setwflag160:
165E A0 35 01        mov al, [R2Type]
1661 3C 04           cmp al, 4
1663 0F 85 00 00   r jne .setwflag161
1667 B8 02 00        mov ax, 2
166A A2 37 01        mov byte [OpSize], al
166D                
166D                ;-654         if (R1Type == SEGREG) OpSize=WORD;
166D                
166D                .setwflag161:
166D A0 36 01        mov al, [R1Type]
1670 3C 04           cmp al, 4
1672 0F 85 00 00   r jne .setwflag162
1676 B8 02 00        mov ax, 2
1679 A2 37 01        mov byte [OpSize], al
167C                
167C                ;-655     }
167C                
167C                .setwflag162:
167C                
167C                ;-656     if (OpSize  == DWORD) {gen66h(); wflag=1;}
167C                
167C                .setwflag158:
167C A0 37 01        mov al, [OpSize]
167F 3C 03           cmp al, 3
1681 0F 85 00 00   r jne .setwflag163
1685 E8 00 00      R call gen66h
1688 B8 01 00        mov ax, 1
168B A2 38 01        mov byte [wflag], al
168E                
168E                ;-657     if (OpSize  ==  WORD) wflag=1;
168E                
168E                .setwflag163:
168E A0 37 01        mov al, [OpSize]
1691 3C 02           cmp al, 2
1693 0F 85 00 00   r jne .setwflag164
1697 B8 01 00        mov ax, 1
169A A2 38 01        mov byte [wflag], al
169D                
169D                ;-658 }
169D                
169D                .setwflag164:
169D                
169D                ;-659 int setsflag() {//sign-extend, bit 1, only PUSH, ALU, IMUL3
169D                
169D C3              ret
;leaving: setwflag. loc labels:7,loc jmp forward:8
;jmp to fix:8
1. .setwflag158,from:163E,Label+ORG:177C,rel:003C
2. .setwflag159,from:1647,Label+ORG:174F,rel:0006
3. .setwflag160,from:1656,Label+ORG:175E,rel:0006
4. .setwflag161,from:1665,Label+ORG:176D,rel:0006
5. .setwflag162,from:1674,Label+ORG:177C,rel:0006
6. .setwflag163,from:1683,Label+ORG:178E,rel:0009
7. gen66h,from:1686
;***** ERROR: label not found: gen66h ,Label+ORG:0447,rel:ECBF
8. .setwflag164,from:1695,Label+ORG:179D,rel:0006
169E                ENDP
169E                
;entering: setsflag
169E                setsflag: PROC
169E                
169E                ;-660     unsigned int ui;
169E                
169E                
169E                ;-661     sflag=2;
169E                
169E                ;Function : setsflag, Number of local variables: 1
169E                ;   # type sign width addr used name   list of local variables
169E                ;  200 var unsg word   660 NULL ui = bp-2;
169E C8 02 00 00     ENTER  2,0
16A2 B8 02 00        mov ax, 2
16A5 A2 3A 01        mov byte [sflag], al
16A8                
16A8                ;-662     ui = imme & 0xFF80;//is greater than signed 127?
16A8                
16A8 A1 3F 01        mov ax, [imme]
16AB 25 80 FF        and ax, 65408
16AE 89 46 FE        mov [bp-2], ax
16B1                
16B1                ;-663     if(ui != 0) sflag = 0;
16B1                
16B1 8B 46 FE        mov ax, [bp-2]
16B4 83 F8 00        cmp ax, 0
16B7 0F 84 00 00   r je  .setsflag165
16BB B8 00 00        mov ax, 0
16BE A2 3A 01        mov byte [sflag], al
16C1                
16C1                ;-664     if (OpSize == BYTE) {
16C1                
16C1                .setsflag165:
16C1 A0 37 01        mov al, [OpSize]
16C4 3C 01           cmp al, 1
16C6 0F 85 00 00   r jne .setsflag166
16CA                
16CA                ;-665         if (imme > 255) error1("too big for byte r/m");
16CA                
16CA A1 3F 01        mov ax, [imme]
16CD 3D FF 00        cmp ax, 255
16D0 0F 8E 00 00   r jle .setsflag167
16D4 68 AA AA      A push setsflag_0
16D7 E8 87 F4        call error1
16DA 83 C4 02        add  sp, 2
16DD                
16DD                ;-666         sflag=0;//byte reg does not need sign extended
16DD                
16DD                .setsflag167:
16DD B8 00 00        mov ax, 0
16E0 A2 3A 01        mov byte [sflag], al
16E3                
16E3                ;-667     }
16E3                
16E3                
16E3                ;-668 }
16E3                
16E3                .setsflag166:
16E3                
16E3                ;-669 int checkConstSize(unsigned int ui) {
16E3 C9              LEAVE
16E4 C3              ret
16E5 74 6F 6F 20 62 setsflag_0 db "too big for byte r/m",0
;leaving: setsflag. loc labels:4,loc jmp forward:4
;jmp to fix:4
1. .setsflag165,from:16B9,Label+ORG:17C1,rel:0006
2. .setsflag166,from:16C8,Label+ORG:17E3,rel:0019
3. .setsflag167,from:16D2,Label+ORG:17DD,rel:0009
4. setsflag_0,from:16D5,Label+ORG:17E5
16FA                ENDP
16FA                
;entering: checkConstSize
16FA                checkConstSize: PROC
16FA                
16FA                ;-670     if (ui > 127   ) return 0;//is near; return sflag
16FA                
16FA                ;Function : checkConstSize, Number of local variables: 1
16FA                ;   # type sign width addr used name   list of local variables
16FA                ;  200 var unsg word   669 NULL ui = bp+4;
16FA C8 00 00 00     ENTER  0,0
16FE 8B 46 04        mov ax, [bp+4]
1701 83 F8 7F        cmp ax, 127
1704 0F 8E 00 00   r jle .checkConstSize168
1708 B8 00 00        mov ax, 0
170B E9 00 00      R jmp .retncheckConstSize
170E                
170E                ;-671     if (ui < 0xFF80) return 0;//-128dez
170E                
170E                .checkConstSize168:
170E 8B 46 04        mov ax, [bp+4]
1711 3D 80 FF        cmp ax, 65408
1714 0F 8D 00 00   r jge .checkConstSize169
1718 B8 00 00        mov ax, 0
171B E9 00 00      R jmp .retncheckConstSize
171E                
171E                ;-672     return 2;// is short
171E                
171E                .checkConstSize169:
171E B8 02 00        mov ax, 2
1721 E9 00 00      R jmp .retncheckConstSize
1724                
1724                ;-673 }
1724                
1724                
1724                ;-674 
1724                
1724                
1724                ;-675 
1724                
1724                
1724                ;-676 //#include "PARSE.C"
1724                
1724                
1724                ;-677 int parse() {
1724                
1724 C9              .retncheckConstSize: LEAVE
1725 C3              ret
;leaving: checkConstSize. loc labels:3,loc jmp forward:5
;jmp to fix:5
1. .checkConstSize168,from:1706,Label+ORG:180E,rel:0006
2. .retncheckConstSize,from:170C,Label+ORG:1824,rel:0016
3. .checkConstSize169,from:1716,Label+ORG:181E,rel:0006
4. .retncheckConstSize,from:171C,Label+ORG:1824,rel:0006
5. .retncheckConstSize,from:1722,Label+ORG:1824,rel:0000
1726                ENDP
1726                
;entering: parse
1726                parse: PROC
1726                
1726                ;-678     LabelNamePtr  = &LabelNames;
1726                
1726 B8 5A 77        mov ax, LabelNames
1729 A3 46 01        mov word [LabelNamePtr], ax
172C                
172C                ;-679     JmpNamePtr= &JmpNames;
172C                
172C B8 7A 93        mov ax, JmpNames
172F A3 50 01        mov word [JmpNamePtr], ax
1732                
1732                ;-680     LabelMaxIx=0;
1732                
1732 B8 00 00        mov ax, 0
1735 A3 4A 01        mov word [LabelMaxIx], ax
1738                
1738                ;-681     JmpMaxIx=0;
1738                
1738 B8 00 00        mov ax, 0
173B A3 54 01        mov word [JmpMaxIx], ax
173E                
173E                ;-682     BinLen=0;
173E                
173E B8 00 00        mov ax, 0
1741 A3 58 01        mov word [BinLen], ax
1744                
1744                ;-683     isInProc=0;
1744                
1744 B8 00 00        mov ax, 0
1747 A2 0D 01        mov byte [isInProc], al
174A                
174A                ;-684 
174A                
174A                
174A                ;-685     do {//process a new line
174A                
174A                .parse170:
174A                
174A                ;-686         PCStart=PC;
174A                
174A A1 23 01        mov ax, [PC]
174D A3 29 01        mov word [PCStart], ax
1750                
1750                ;-687         OpSize=0;
1750                
1750 B8 00 00        mov ax, 0
1753 A2 37 01        mov byte [OpSize], al
1756                
1756                ;-688         OpPrintIndex=0;
1756                
1756 B8 00 00        mov ax, 0
1759 A3 41 01        mov word [OpPrintIndex], ax
175C                
175C                ;-689         PrintRA=' ';
175C                
175C B8 20 00        mov ax, 32
175F A2 45 01        mov byte [PrintRA], al
1762                
1762                ;-690         getLine();
1762                
1762 E8 B3 E9        call getLine
1765                
1765                ;-691         InputPtr = &InputBuf;
1765                
1765 B8 8D 75        mov ax, InputBuf
1768 A3 14 01        mov word [InputPtr], ax
176B                
176B                ;-692         getTokeType();//getCode in SymbolUpper,set TokeType,isLabel by getName
176B                
176B E8 00 00      R call getTokeType
176E                
176E                ;-693         if (TokeType == ALNUME) {
176E                
176E A0 2C 01        mov al, [TokeType]
1771 3C 03           cmp al, 3
1773 0F 85 00 00   r jne .parse171
1777                
1777                ;-694             if (isLabel) {//set in getName
1777                
1777 A0 2B 01        mov al, [isLabel]
177A 08 C0           or  al, al
177C 0F 84 00 00   r je .parse172
1780                
1780                ;-695               if (isInProc == 0)  strcpy(ProcName, Symbol);
1780                
1780 A0 0D 01        mov al, [isInProc]
1783 3C 00           cmp al, 0
1785 0F 85 00 00   r jne .parse173
1789 8D 06 30 75     lea  ax, [Symbol]
178D 50              push ax
178E 8D 06 6E 75     lea  ax, [ProcName]
1792 50              push ax
1793 E8 D7 EB        call strcpy
1796 83 C4 04        add  sp, 4
1799                
1799                ;-696                 storeLabel();
1799                
1799                .parse173:
1799 E8 00 00      R call storeLabel
179C                
179C                ;-697                 InputPtr++;//remove :
179C                
179C FF 06 14 01     inc  word[InputPtr]
17A0                
17A0                ;-698                 getTokeType();
17A0                
17A0 E8 00 00      R call getTokeType
17A3                
17A3                ;-699             }
17A3                
17A3                
17A3                ;-700         }
17A3                
17A3                .parse172:
17A3                
17A3                ;-701         if (TokeType == ALNUME) {
17A3                
17A3                .parse171:
17A3 A0 2C 01        mov al, [TokeType]
17A6 3C 03           cmp al, 3
17A8 0F 85 00 00   r jne .parse174
17AC                
17AC                ;-702             lookCode();// and OpCodePtr
17AC                
17AC E8 27 FA        call lookCode
17AF                
17AF                ;-703             if(CodeType) process();
17AF                
17AF A0 2F 01        mov al, [CodeType]
17B2 08 C0           or  al, al
17B4 0F 84 00 00   r je .parse175
17B8 E8 00 00      R call process
17BB                
17BB                ;-704             else getVariable();
17BB                
17BB E9 00 00      R jmp .parse176
17BE                .parse175:
17BE E8 00 00      R call getVariable
17C1                
17C1                ;-705             skipRest();
17C1                
17C1                .parse176:
17C1 E8 00 00      R call skipRest
17C4                
17C4                ;-706         }
17C4                
17C4                
17C4                ;-707         else if (TokeType >ALNUME) error1("Label or instruction expected");
17C4                
17C4 E9 00 00      R jmp .parse177
17C7                .parse174:
17C7 A0 2C 01        mov al, [TokeType]
17CA 3C 03           cmp al, 3
17CC 0F 8E 00 00   r jle .parse178
17D0 68 AA AA      A push parse_0
17D3 E8 8B F3        call error1
17D6 83 C4 02        add  sp, 2
17D9                
17D9                ;-708         else if (TokeType==DIGIT ) error1("No digit allowed at start of line");
17D9                
17D9 E9 00 00      R jmp .parse179
17DC                .parse178:
17DC A0 2C 01        mov al, [TokeType]
17DF 3C 01           cmp al, 1
17E1 0F 85 00 00   r jne .parse180
17E5 68 AA AA      A push parse_1
17E8 E8 76 F3        call error1
17EB 83 C4 02        add  sp, 2
17EE                
17EE                ;-709         printLine();
17EE                
17EE                .parse180:
17EE                .parse179:
17EE                .parse177:
17EE E8 25 F1        call printLine
17F1                
17F1                ;-710     } while (DOS_NoBytes != 0 );
17F1                
17F1 A1 20 01        mov ax, [DOS_NoBytes]
17F4 83 F8 00        cmp ax, 0
17F7 0F 84 00 00   r je  .parse181
17FB E9 4C FF        jmp .parse170
17FE                .parse181:
17FE                
17FE                ;-711 }
17FE                
17FE                
17FE                ;-712 
17FE                
17FE                
17FE                ;-713 int getTokeType() {
17FE                
17FE C3              ret
17FF 4C 61 62 65 6C parse_0 db "Label or instruction expected",0
181D 4E 6F 20 64 69 parse_1 db "No digit allowed at start of line",0
;leaving: parse. loc labels:14,loc jmp forward:19
;jmp to fix:19
1. getTokeType,from:176C
;***** ERROR: label not found: getTokeType ,Label+ORG:0447,rel:EBD9
2. .parse171,from:1775,Label+ORG:18A3,rel:002C
3. .parse172,from:177E,Label+ORG:18A3,rel:0023
4. .parse173,from:1787,Label+ORG:1899,rel:0010
5. storeLabel,from:179A
;***** ERROR: label not found: storeLabel ,Label+ORG:0447,rel:EBAB
6. getTokeType,from:17A1
;***** ERROR: label not found: getTokeType ,Label+ORG:0447,rel:EBA4
7. .parse174,from:17AA,Label+ORG:18C7,rel:001B
8. .parse175,from:17B6,Label+ORG:18BE,rel:0006
9. process,from:17B9
;***** ERROR: label not found: process ,Label+ORG:0447,rel:EB8C
10. .parse176,from:17BC,Label+ORG:18C1,rel:0003
11. getVariable,from:17BF
;***** ERROR: label not found: getVariable ,Label+ORG:0447,rel:EB86
12. skipRest,from:17C2
;***** ERROR: label not found: skipRest ,Label+ORG:0447,rel:EB83
13. .parse177,from:17C5,Label+ORG:18EE,rel:0027
14. .parse178,from:17CE,Label+ORG:18DC,rel:000C
15. parse_0,from:17D1,Label+ORG:18FF
16. .parse179,from:17DA,Label+ORG:18EE,rel:0012
17. .parse180,from:17E3,Label+ORG:18EE,rel:0009
18. parse_1,from:17E6,Label+ORG:191D
19. .parse181,from:17F9,Label+ORG:18FE,rel:0003
183F                ENDP
183F                
;entering: getTokeType
183F                getTokeType: PROC
183F                
183F                ;-714     char c;
183F                
183F                
183F                ;-715     skipBlank();
183F                
183F                ;Function : getTokeType, Number of local variables: 1
183F                ;   # type sign width addr used name   list of local variables
183F                ;  200 var sign byte   714 NULL c = bp-2;
183F C8 02 00 00     ENTER  2,0
1843 E8 F0 E9        call skipBlank
1846                
1846                ;-716     c = *InputPtr;
1846                
1846 8B 1E 14 01     mov bx, [InputPtr]
184A 8A 07           mov al, [bx]
184C B4 00           mov ah, 0
184E 88 46 FE        mov [bp-2], al
1851                
1851                ;-717     if (c == 0)   {TokeType=0; return; }//last line or empty line
1851                
1851 8A 46 FE        mov al, [bp-2]
1854 3C 00           cmp al, 0
1856 0F 85 00 00   r jne .getTokeType182
185A B8 00 00        mov ax, 0
185D A2 2C 01        mov byte [TokeType], al
1860 E9 00 00      R jmp .retngetTokeType
1863                
1863                ;-718     if (c == ';') {TokeType=0; return; }//comment
1863                
1863                .getTokeType182:
1863 8A 46 FE        mov al, [bp-2]
1866 3C 3B           cmp al, 59
1868 0F 85 00 00   r jne .getTokeType183
186C B8 00 00        mov ax, 0
186F A2 2C 01        mov byte [TokeType], al
1872 E9 00 00      R jmp .retngetTokeType
1875                
1875                ;-719     if (digit(c)) {getDigit(c); TokeType=DIGIT; return;}//ret:1=SymbolInt
1875                
1875                .getTokeType183:
1875 8A 46 FE        mov al, byte [bp-2]
1878 B4 00           mov ah, 0
187A 50              push ax
187B E8 9D EA        call digit
187E 83 C4 02        add  sp, 2
1881 08 C0           or  al, al
1883 0F 84 00 00   r je .getTokeType184
1887 8A 46 FE        mov al, byte [bp-2]
188A B4 00           mov ah, 0
188C 50              push ax
188D E8 C3 EB        call getDigit
1890 83 C4 02        add  sp, 2
1893 B8 01 00        mov ax, 1
1896 A2 2C 01        mov byte [TokeType], al
1899 E9 00 00      R jmp .retngetTokeType
189C                
189C                ;-720     if (letterE (c)) {getName(c); TokeType=ALNUME; return;}//ret:2=Symbol
189C                
189C                .getTokeType184:
189C 8A 46 FE        mov al, byte [bp-2]
189F B4 00           mov ah, 0
18A1 50              push ax
18A2 E8 BC E9        call letterE
18A5 83 C4 02        add  sp, 2
18A8 08 C0           or  al, al
18AA 0F 84 00 00   r je .getTokeType185
18AE 8A 46 FE        mov al, byte [bp-2]
18B1 B4 00           mov ah, 0
18B3 50              push ax
18B4 E8 EC EB        call getName
18B7 83 C4 02        add  sp, 2
18BA B8 03 00        mov ax, 3
18BD A2 2C 01        mov byte [TokeType], al
18C0 E9 00 00      R jmp .retngetTokeType
18C3                
18C3                ;-721     TokeType=NOALNUME;
18C3                
18C3                .getTokeType185:
18C3 B8 04 00        mov ax, 4
18C6 A2 2C 01        mov byte [TokeType], al
18C9                
18C9                ;-722 }
18C9                
18C9                
18C9                ;-723 
18C9                
18C9                
18C9                ;-724 int storeJmp() {
18C9                
18C9 C9              .retngetTokeType: LEAVE
18CA C3              ret
;leaving: getTokeType. loc labels:5,loc jmp forward:8
;jmp to fix:8
1. .getTokeType182,from:1858,Label+ORG:1963,rel:0009
2. .retngetTokeType,from:1861,Label+ORG:19C9,rel:0066
3. .getTokeType183,from:186A,Label+ORG:1975,rel:0009
4. .retngetTokeType,from:1873,Label+ORG:19C9,rel:0054
5. .getTokeType184,from:1885,Label+ORG:199C,rel:0015
6. .retngetTokeType,from:189A,Label+ORG:19C9,rel:002D
7. .getTokeType185,from:18AC,Label+ORG:19C3,rel:0015
8. .retngetTokeType,from:18C1,Label+ORG:19C9,rel:0006
18CB                ENDP
18CB                
;entering: storeJmp
18CB                storeJmp: PROC
18CB                
18CB                ;-725     unsigned int i;
18CB                
18CB                
18CB                ;-726     JmpMaxIx++;
18CB                
18CB                ;Function : storeJmp, Number of local variables: 1
18CB                ;   # type sign width addr used name   list of local variables
18CB                ;  200 var unsg word   725 NULL i = bp-2;
18CB C8 02 00 00     ENTER  2,0
18CF FF 06 54 01     inc  word[JmpMaxIx]
18D3                
18D3                ;-727     if (JmpMaxIx >= JMPMAX) errorexit("too many Jmp");
18D3                
18D3 A1 54 01        mov ax, [JmpMaxIx]
18D6 3D C8 00        cmp ax, 200 ;unsigned : 1
18D9 0F 8C 00 00   r jl  .storeJmp186
18DD 68 AA AA      A push storeJmp_0
18E0 E8 D2 F2        call errorexit
18E3 83 C4 02        add  sp, 2
18E6                
18E6                ;-728     JmpNamePtr=strcpy(JmpNamePtr, Symbol);
18E6                
18E6                .storeJmp186:
18E6 8D 06 30 75     lea  ax, [Symbol]
18EA 50              push ax
18EB FF 36 50 01     push word [JmpNamePtr]
18EF E8 7B EA        call strcpy
18F2 83 C4 04        add  sp, 4
18F5 A3 50 01        mov word [JmpNamePtr], ax
18F8                
18F8                ;-729     JmpNamePtr++;
18F8                
18F8 FF 06 50 01     inc  word[JmpNamePtr]
18FC                
18FC                ;-730     i = JmpNamePtr - &JmpNames;
18FC                
18FC A1 50 01        mov ax, [JmpNamePtr]
;***** next line ERROR: invalid or no operands, Symbol: JmpNames
;***** next line ERROR: syntax, Symbol: JmpNames
18FF                 sub ax, JmpNames
18FF 89 46 FE        mov [bp-2], ax
1902                
1902                ;-731     if ( i >= JMPNAMESMAX) errorexit("too many Jmp names");
1902                
1902 8B 46 FE        mov ax, [bp-2]
1905 3D 81 0F        cmp ax, 3969 ;unsigned : 0
1908 0F 82 00 00   r jb  .storeJmp187
190C 68 AA AA      A push storeJmp_1
190F E8 A3 F2        call errorexit
1912 83 C4 02        add  sp, 2
1915                
1915                ;-732     JmpAddr[JmpMaxIx] = PC;
1915                
1915                .storeJmp187:
1915 A1 23 01        mov ax, [PC]
1918 8B 1E 54 01     mov bx, [JmpMaxIx]
191C D1 E3           shl bx, 1
191E 89 47 1A        mov [JmpAddr+bx], ax
1921                
1921                ;-733 }
1921                
1921                
1921                ;-734 
1921                
1921                
1921                ;-735 int storeLabel() {
1921 C9              LEAVE
1922 C3              ret
1923 74 6F 6F 20 6D storeJmp_0 db "too many Jmp",0
1930 74 6F 6F 20 6D storeJmp_1 db "too many Jmp names",0
;leaving: storeJmp. loc labels:4,loc jmp forward:4
;jmp to fix:4
1. .storeJmp186,from:18DB,Label+ORG:19E6,rel:0009
2. storeJmp_0,from:18DE,Label+ORG:1A23
3. .storeJmp187,from:190A,Label+ORG:1A15,rel:0009
4. storeJmp_1,from:190D,Label+ORG:1A30
1943                ENDP
1943                
;entering: storeLabel
1943                storeLabel: PROC
1943                
1943                ;-736     unsigned int i;
1943                
1943                
1943                ;-737     if(searchLabel()) error1("duplicate label");
1943                
1943                ;Function : storeLabel, Number of local variables: 1
1943                ;   # type sign width addr used name   list of local variables
1943                ;  200 var unsg word   736 NULL i = bp-2;
1943 C8 02 00 00     ENTER  2,0
1947 E8 00 00      R call searchLabel
194A 08 C0           or  al, al
194C 0F 84 00 00   r je .storeLabel188
1950 68 AA AA      A push storeLabel_0
1953 E8 0B F2        call error1
1956 83 C4 02        add  sp, 2
1959                
1959                ;-738     LabelMaxIx++;
1959                
1959                .storeLabel188:
1959 FF 06 4A 01     inc  word[LabelMaxIx]
195D                
195D                ;-739     if (LabelMaxIx >= LABELADRMAX) errorexit("too many labels");
195D                
195D A1 4A 01        mov ax, [LabelMaxIx]
1960 3D 58 02        cmp ax, 600 ;unsigned : 1
1963 0F 8C 00 00   r jl  .storeLabel189
1967 68 AA AA      A push storeLabel_1
196A E8 48 F2        call errorexit
196D 83 C4 02        add  sp, 2
1970                
1970                ;-740     LabelNamePtr=strcpy(LabelNamePtr, Symbol);
1970                
1970                .storeLabel189:
1970 8D 06 30 75     lea  ax, [Symbol]
1974 50              push ax
1975 FF 36 46 01     push word [LabelNamePtr]
1979 E8 F1 E9        call strcpy
197C 83 C4 04        add  sp, 4
197F A3 46 01        mov word [LabelNamePtr], ax
1982                
1982                ;-741     LabelNamePtr++;
1982                
1982 FF 06 46 01     inc  word[LabelNamePtr]
1986                
1986                ;-742     i = LabelNamePtr - &LabelNames;
1986                
1986 A1 46 01        mov ax, [LabelNamePtr]
;***** next line ERROR: invalid or no operands, Symbol: LabelNames
;***** next line ERROR: syntax, Symbol: LabelNames
1989                 sub ax, LabelNames
1989 89 46 FE        mov [bp-2], ax
198C                
198C                ;-743     if (i >= LABELNAMESMAX) errorexit("too many label names");
198C                
198C 8B 46 FE        mov ax, [bp-2]
198F 3D 51 17        cmp ax, 5969 ;unsigned : 0
1992 0F 82 00 00   r jb  .storeLabel190
1996 68 AA AA      A push storeLabel_2
1999 E8 19 F2        call errorexit
199C 83 C4 02        add  sp, 2
199F                
199F                ;-744     LabelAddr[LabelMaxIx] = PC + Origin;
199F                
199F                .storeLabel190:
199F A1 23 01        mov ax, [PC]
19A2 03 06 25 01     add ax, [Origin]
19A6 8B 1E 4A 01     mov bx, [LabelMaxIx]
19AA D1 E3           shl bx, 1
19AC 89 47 CA        mov [LabelAddr+bx], ax
19AF                
19AF                ;-745 }
19AF                
19AF                
19AF                ;-746 
19AF                
19AF                
19AF                ;-747 int searchLabel() {
19AF C9              LEAVE
19B0 C3              ret
19B1 64 75 70 6C 69 storeLabel_0 db "duplicate label",0
19C1 74 6F 6F 20 6D storeLabel_1 db "too many labels",0
19D1 74 6F 6F 20 6D storeLabel_2 db "too many label names",0
;leaving: storeLabel. loc labels:6,loc jmp forward:7
;jmp to fix:7
1. searchLabel,from:1948
;***** ERROR: label not found: searchLabel ,Label+ORG:0447,rel:E9FD
2. .storeLabel188,from:194E,Label+ORG:1A59,rel:0009
3. storeLabel_0,from:1951,Label+ORG:1AB1
4. .storeLabel189,from:1965,Label+ORG:1A70,rel:0009
5. storeLabel_1,from:1968,Label+ORG:1AC1
6. .storeLabel190,from:1994,Label+ORG:1A9F,rel:0009
7. storeLabel_2,from:1997,Label+ORG:1AD1
19E6                ENDP
19E6                
;entering: searchLabel
19E6                searchLabel: PROC
19E6                
19E6                ;-748     int LIx; char *p;
19E6                
19E6                
19E6                ;-749     p = &LabelNames;
19E6                
19E6                ;Function : searchLabel, Number of local variables: 2
19E6                ;   # type sign width addr used name   list of local variables
19E6                ;  200 var sign word   748 NULL LIx = bp-2
19E6                ;  201 ptr sign byte   748 NULL p = bp-4;
19E6 C8 04 00 00     ENTER  4,0
19EA B8 5A 77        mov ax, LabelNames
19ED 89 46 FC        mov [bp-4], ax
19F0                
19F0                ;-750     LIx = 1;
19F0                
19F0 B8 01 00        mov ax, 1
19F3 89 46 FE        mov [bp-2], ax
19F6                
19F6                ;-751     while (LIx <= LabelMaxIx) {
19F6                
19F6                .searchLabel191:
19F6 8B 46 FE        mov ax, [bp-2]
19F9 3B 06 4A 01     cmp ax, [LabelMaxIx]
19FD 0F 8F 00 00   r jg  .searchLabel192
1A01                
1A01                ;-752         if (eqstr(p, Symbol)) return LIx;//pos of label
1A01                
1A01 8D 06 30 75     lea  ax, [Symbol]
1A05 50              push ax
1A06 55              push word [bp-4]
1A07 E8 99 E9        call eqstr
1A0A 83 C4 04        add  sp, 4
1A0D 08 C0           or  al, al
1A0F 0F 84 00 00   r je .searchLabel193
1A13 8B 46 FE        mov ax, [bp-2]
1A16 E9 00 00      R jmp .retnsearchLabel
1A19                
1A19                ;-753         p=strlen(p) + p;
1A19                
1A19                .searchLabel193:
1A19 55              push word [bp-4]
1A1A E8 28 E9        call strlen
1A1D 83 C4 02        add  sp, 2
1A20 03 46 FC        add ax, [bp-4]
1A23 89 46 FC        mov [bp-4], ax
1A26                
1A26                ;-754         p++;
1A26                
1A26 FF 46 FC        inc  word[bp-4]
1A29                
1A29                ;-755         LIx++;
1A29                
1A29 FF 46 FE        inc  word[bp-2]
1A2C                
1A2C                ;-756     }
1A2C                
1A2C                
1A2C                ;-757     return 0;
1A2C                
1A2C EB C8           jmp .searchLabel191
1A2E                .searchLabel192:
1A2E B8 00 00        mov ax, 0
1A31 E9 00 00      R jmp .retnsearchLabel
1A34                
1A34                ;-758 }
1A34                
1A34                
1A34                ;-759 
1A34                
1A34                
1A34                ;-760 int getVariable() {
1A34                
1A34 C9              .retnsearchLabel: LEAVE
1A35 C3              ret
;leaving: searchLabel. loc labels:4,loc jmp forward:4
;jmp to fix:4
1. .searchLabel192,from:19FF,Label+ORG:1B2E,rel:002D
2. .searchLabel193,from:1A11,Label+ORG:1B19,rel:0006
3. .retnsearchLabel,from:1A17,Label+ORG:1B34,rel:001B
4. .retnsearchLabel,from:1A32,Label+ORG:1B34,rel:0000
1A36                ENDP
1A36                
;entering: getVariable
1A36                getVariable: PROC
1A36                
1A36                ;-761     char c;
1A36                
1A36                
1A36                ;-762     storeLabel();
1A36                
1A36                ;Function : getVariable, Number of local variables: 1
1A36                ;   # type sign width addr used name   list of local variables
1A36                ;  200 var sign byte   761 NULL c = bp-2;
1A36 C8 02 00 00     ENTER  2,0
1A3A E8 06 FF        call storeLabel
1A3D                
1A3D                ;-763     getTokeType();
1A3D                
1A3D E8 FF FD        call getTokeType
1A40                
1A40                ;-764     if(TokeType==ALNUME) {//getName
1A40                
1A40 A0 2C 01        mov al, [TokeType]
1A43 3C 03           cmp al, 3
1A45 0F 85 00 00   r jne .getVariable194
1A49                
1A49                ;-765         lookCode();
1A49                
1A49 E8 8A F7        call lookCode
1A4C                
1A4C                ;-766         if (CodeType < 200) dataexit();
1A4C                
1A4C A0 2F 01        mov al, [CodeType]
1A4F 3C C8           cmp al, 200
1A51 0F 8D 00 00   r jge .getVariable195
1A55 E8 24 F3        call dataexit
1A58                
1A58                ;-767         if (CodeType > 205) dataexit();
1A58                
1A58                .getVariable195:
1A58 A0 2F 01        mov al, [CodeType]
1A5B 3C CD           cmp al, 205
1A5D 0F 8E 00 00   r jle .getVariable196
1A61 E8 18 F3        call dataexit
1A64                
1A64                ;-768         if (CodeType== 200) {//DB
1A64                
1A64                .getVariable196:
1A64 A0 2F 01        mov al, [CodeType]
1A67 3C C8           cmp al, 200
1A69 0F 85 00 00   r jne .getVariable197
1A6D                
1A6D                ;-769             do {
1A6D                
1A6D                .getVariable198:
1A6D                
1A6D                ;-770                 getTokeType();
1A6D                
1A6D E8 CF FD        call getTokeType
1A70                
1A70                ;-771                 if (TokeType == DIGIT) genCode8(SymbolInt);
1A70                
1A70 A0 2C 01        mov al, [TokeType]
1A73 3C 01           cmp al, 1
1A75 0F 85 00 00   r jne .getVariable199
1A79 FF 36 0E 01     push word [SymbolInt]
1A7D E8 00 00      R call genCode8
1A80 83 C4 02        add  sp, 2
1A83                
1A83                ;-772                 else {
1A83                
1A83 E9 00 00      R jmp .getVariable200
1A86                .getVariable199:
1A86                
1A86                ;-773                     skipBlank();
1A86                
1A86 E8 AD E7        call skipBlank
1A89                
1A89                ;-774                     if (isToken('"')) {
1A89                
1A89 6A 22           push 34
1A8B E8 00 00      R call isToken
1A8E 83 C4 02        add  sp, 2
1A91 08 C0           or  al, al
1A93 0F 84 00 00   r je .getVariable201
1A97                
1A97                ;-775                         do {
1A97                
1A97                .getVariable202:
1A97                
1A97                ;-776                             c= *InputPtr;
1A97                
1A97 8B 1E 14 01     mov bx, [InputPtr]
1A9B 8A 07           mov al, [bx]
1A9D B4 00           mov ah, 0
1A9F 88 46 FE        mov [bp-2], al
1AA2                
1AA2                ;-777                             genCode8(c);
1AA2                
1AA2 8A 46 FE        mov al, byte [bp-2]
1AA5 B4 00           mov ah, 0
1AA7 50              push ax
1AA8 E8 00 00      R call genCode8
1AAB 83 C4 02        add  sp, 2
1AAE                
1AAE                ;-778                             InputPtr++;
1AAE                
1AAE FF 06 14 01     inc  word[InputPtr]
1AB2                
1AB2                ;-779                         } while (*InputPtr != '"' );
1AB2                
1AB2 8B 1E 14 01     mov bx, [InputPtr]
1AB6 8A 07           mov al, [bx]
1AB8 B4 00           mov ah, 0
1ABA 83 F8 22        cmp ax, 34
1ABD 0F 84 00 00   r je  .getVariable203
1AC1 EB D4           jmp .getVariable202
1AC3                .getVariable203:
1AC3                
1AC3                ;-780                         InputPtr++;
1AC3                
1AC3 FF 06 14 01     inc  word[InputPtr]
1AC7                
1AC7                ;-781                     }
1AC7                
1AC7                
1AC7                ;-782                 }
1AC7                
1AC7                .getVariable201:
1AC7                
1AC7                ;-783             } while (isToken(','));
1AC7                
1AC7                .getVariable200:
1AC7 6A 2C           push 44
1AC9 E8 00 00      R call isToken
1ACC 83 C4 02        add  sp, 2
1ACF 08 C0           or  al, al
1AD1 0F 84 00 00   r je .getVariable204
1AD5 EB 96           jmp .getVariable198
1AD7                .getVariable204:
1AD7                
1AD7                ;-784         }
1AD7                
1AD7                
1AD7                ;-785         if (CodeType == 201) {//DW
1AD7                
1AD7                .getVariable197:
1AD7 A0 2F 01        mov al, [CodeType]
1ADA 3C C9           cmp al, 201
1ADC 0F 85 00 00   r jne .getVariable205
1AE0                
1AE0                ;-786             do {
1AE0                
1AE0                .getVariable206:
1AE0                
1AE0                ;-787                 getTokeType();
1AE0                
1AE0 E8 5C FD        call getTokeType
1AE3                
1AE3                ;-788                 if (TokeType ==DIGIT) genCode16(SymbolInt);
1AE3                
1AE3 A0 2C 01        mov al, [TokeType]
1AE6 3C 01           cmp al, 1
1AE8 0F 85 00 00   r jne .getVariable207
1AEC FF 36 0E 01     push word [SymbolInt]
1AF0 E8 00 00      R call genCode16
1AF3 83 C4 02        add  sp, 2
1AF6                
1AF6                ;-789             } while (isToken(','));
1AF6                
1AF6                .getVariable207:
1AF6 6A 2C           push 44
1AF8 E8 00 00      R call isToken
1AFB 83 C4 02        add  sp, 2
1AFE 08 C0           or  al, al
1B00 0F 84 00 00   r je .getVariable208
1B04 EB DA           jmp .getVariable206
1B06                .getVariable208:
1B06                
1B06                ;-790         }
1B06                
1B06                
1B06                ;-791         if (CodeType == 202) {//DD
1B06                
1B06                .getVariable205:
1B06 A0 2F 01        mov al, [CodeType]
1B09 3C CA           cmp al, 202
1B0B 0F 85 00 00   r jne .getVariable209
1B0F                
1B0F                ;-792             do {
1B0F                
1B0F                .getVariable210:
1B0F                
1B0F                ;-793                 getTokeType();
1B0F                
1B0F E8 2D FD        call getTokeType
1B12                
1B12                ;-794                 if (TokeType ==DIGIT) { genCode16(SymbolInt);
1B12                
1B12 A0 2C 01        mov al, [TokeType]
1B15 3C 01           cmp al, 1
1B17 0F 85 00 00   r jne .getVariable211
1B1B FF 36 0E 01     push word [SymbolInt]
1B1F E8 00 00      R call genCode16
1B22 83 C4 02        add  sp, 2
1B25                
1B25                ;-795                                     genCode16(0);}//todo genCode32(SymbolLong);
1B25                
1B25 6A 00           push 0
1B27 E8 00 00      R call genCode16
1B2A 83 C4 02        add  sp, 2
1B2D                
1B2D                ;-796             } while (isToken(','));
1B2D                
1B2D                .getVariable211:
1B2D 6A 2C           push 44
1B2F E8 00 00      R call isToken
1B32 83 C4 02        add  sp, 2
1B35 08 C0           or  al, al
1B37 0F 84 00 00   r je .getVariable212
1B3B EB D2           jmp .getVariable210
1B3D                .getVariable212:
1B3D                
1B3D                ;-797         }
1B3D                
1B3D                
1B3D                ;-798         if (CodeType >= 203) {//resb, resw, resd
1B3D                
1B3D                .getVariable209:
1B3D A0 2F 01        mov al, [CodeType]
1B40 3C CB           cmp al, 203 ;unsigned : 1
1B42 0F 8C 00 00   r jl  .getVariable213
1B46                
1B46                ;-799             getTokeType();
1B46                
1B46 E8 F6 FC        call getTokeType
1B49                
1B49                ;-800             if (TokeType == DIGIT) {
1B49                
1B49 A0 2C 01        mov al, [TokeType]
1B4C 3C 01           cmp al, 1
1B4E 0F 85 00 00   r jne .getVariable214
1B52                
1B52                ;-801                 if (SymbolInt <= 0) syntaxerror();
1B52                
1B52 A1 0E 01        mov ax, [SymbolInt]
1B55 83 F8 00        cmp ax, 0
1B58 0F 87 00 00   r ja  .getVariable215
1B5C E8 F2 F1        call syntaxerror
1B5F                
1B5F                ;-802                 if (AbsoluteLab == 0) error1("Absolute is null");
1B5F                
1B5F                .getVariable215:
1B5F A1 27 01        mov ax, [AbsoluteLab]
1B62 83 F8 00        cmp ax, 0
1B65 0F 85 00 00   r jne .getVariable216
1B69 68 AA AA      A push getVariable_0
1B6C E8 F2 EF        call error1
1B6F 83 C4 02        add  sp, 2
1B72                
1B72                ;-803                 LabelAddr[LabelMaxIx] = AbsoluteLab;
1B72                
1B72                .getVariable216:
1B72 A1 27 01        mov ax, [AbsoluteLab]
1B75 8B 1E 4A 01     mov bx, [LabelMaxIx]
1B79 D1 E3           shl bx, 1
1B7B 89 47 CA        mov [LabelAddr+bx], ax
1B7E                
1B7E                ;-804                 if (CodeType == 204) SymbolInt=SymbolInt+SymbolInt;//resw
1B7E                
1B7E A0 2F 01        mov al, [CodeType]
1B81 3C CC           cmp al, 204
1B83 0F 85 00 00   r jne .getVariable217
1B87 A1 0E 01        mov ax, [SymbolInt]
1B8A 03 06 0E 01     add ax, [SymbolInt]
1B8E A3 0E 01        mov word [SymbolInt], ax
1B91                
1B91                ;-805                 if (CodeType == 205) SymbolInt=SymbolInt * 4;//resd
1B91                
1B91                .getVariable217:
1B91 A0 2F 01        mov al, [CodeType]
1B94 3C CD           cmp al, 205
1B96 0F 85 00 00   r jne .getVariable218
1B9A A1 0E 01        mov ax, [SymbolInt]
1B9D BB 04 00        mov bx, 4
1BA0 F7 E3           mul bx
1BA2 A3 0E 01        mov word [SymbolInt], ax
1BA5                
1BA5                ;-806                 AbsoluteLab = AbsoluteLab + SymbolInt;
1BA5                
1BA5                .getVariable218:
1BA5 A1 27 01        mov ax, [AbsoluteLab]
1BA8 03 06 0E 01     add ax, [SymbolInt]
1BAC A3 27 01        mov word [AbsoluteLab], ax
1BAF                
1BAF                ;-807             } else numbererror();
1BAF                
1BAF E9 00 00      R jmp .getVariable219
1BB2                .getVariable214:
1BB2 E8 09 F1        call numbererror
1BB5                
1BB5                ;-808         }
1BB5                
1BB5                .getVariable219:
1BB5                
1BB5                ;-809     }
1BB5                
1BB5                .getVariable213:
1BB5                
1BB5                ;-810     else dataexit();
1BB5                
1BB5 E9 00 00      R jmp .getVariable220
1BB8                .getVariable194:
1BB8 E8 C1 F1        call dataexit
1BBB                
1BBB                ;-811 }
1BBB                
1BBB                .getVariable220:
1BBB                
1BBB                ;-812 
1BBB                
1BBB                
1BBB                ;-813 int getCodeSize() {
1BBB C9              LEAVE
1BBC C3              ret
1BBD 41 62 73 6F 6C getVariable_0 db "Absolute is null",0
;leaving: getVariable. loc labels:28,loc jmp forward:33
;jmp to fix:33
1. .getVariable194,from:1A47,Label+ORG:1CB8,rel:016F
2. .getVariable195,from:1A53,Label+ORG:1B58,rel:0003
3. .getVariable196,from:1A5F,Label+ORG:1B64,rel:0003
4. .getVariable197,from:1A6B,Label+ORG:1BD7,rel:006A
5. .getVariable199,from:1A77,Label+ORG:1B86,rel:000D
6. genCode8,from:1A7E
;***** ERROR: label not found: genCode8 ,Label+ORG:0447,rel:E8C7
7. .getVariable200,from:1A84,Label+ORG:1BC7,rel:0041
8. isToken,from:1A8C
;***** ERROR: label not found: isToken ,Label+ORG:0447,rel:E8B9
9. .getVariable201,from:1A95,Label+ORG:1BC7,rel:0030
10. genCode8,from:1AA9
;***** ERROR: label not found: genCode8 ,Label+ORG:0447,rel:E89C
11. .getVariable203,from:1ABF,Label+ORG:1BC3,rel:0002
12. isToken,from:1ACA
;***** ERROR: label not found: isToken ,Label+ORG:0447,rel:E87B
13. .getVariable204,from:1AD3,Label+ORG:1BD7,rel:0002
14. .getVariable205,from:1ADE,Label+ORG:1C06,rel:0026
15. .getVariable207,from:1AEA,Label+ORG:1BF6,rel:000A
16. genCode16,from:1AF1
;***** ERROR: label not found: genCode16 ,Label+ORG:0447,rel:E854
17. isToken,from:1AF9
;***** ERROR: label not found: isToken ,Label+ORG:0447,rel:E84C
18. .getVariable208,from:1B02,Label+ORG:1C06,rel:0002
19. .getVariable209,from:1B0D,Label+ORG:1C3D,rel:002E
20. .getVariable211,from:1B19,Label+ORG:1C2D,rel:0012
21. genCode16,from:1B20
;***** ERROR: label not found: genCode16 ,Label+ORG:0447,rel:E825
22. genCode16,from:1B28
;***** ERROR: label not found: genCode16 ,Label+ORG:0447,rel:E81D
23. isToken,from:1B30
;***** ERROR: label not found: isToken ,Label+ORG:0447,rel:E815
24. .getVariable212,from:1B39,Label+ORG:1C3D,rel:0002
25. .getVariable213,from:1B44,Label+ORG:1CB5,rel:006F
26. .getVariable214,from:1B50,Label+ORG:1CB2,rel:0060
27. .getVariable215,from:1B5A,Label+ORG:1C5F,rel:0003
28. .getVariable216,from:1B67,Label+ORG:1C72,rel:0009
29. getVariable_0,from:1B6A,Label+ORG:1CBD
30. .getVariable217,from:1B85,Label+ORG:1C91,rel:000A
31. .getVariable218,from:1B98,Label+ORG:1CA5,rel:000B
32. .getVariable219,from:1BB0,Label+ORG:1CB5,rel:0003
33. .getVariable220,from:1BB6,Label+ORG:1CBB,rel:0003
1BCE                ENDP
1BCE                
;entering: getCodeSize
1BCE                getCodeSize: PROC
1BCE                
1BCE                ;-814     if (TokeType ==ALNUME) {
1BCE                
1BCE A0 2C 01        mov al, [TokeType]
1BD1 3C 03           cmp al, 3
1BD3 0F 85 00 00   r jne .getCodeSize221
1BD7                
1BD7                ;-815         if (eqstr(SymbolUpper,"BYTE")) {getTokeType(); return BYTE;}
1BD7                
1BD7 68 AA AA      A push getCodeSize_0
1BDA 8D 06 4F 75     lea  ax, [SymbolUpper]
1BDE 50              push ax
1BDF E8 C1 E7        call eqstr
1BE2 83 C4 04        add  sp, 4
1BE5 08 C0           or  al, al
1BE7 0F 84 00 00   r je .getCodeSize222
1BEB E8 51 FC        call getTokeType
1BEE B8 01 00        mov ax, 1
1BF1 E9 00 00      R jmp .retngetCodeSize
1BF4                
1BF4                ;-816         if (eqstr(SymbolUpper,"WORD")) {getTokeType(); return WORD;}
1BF4                
1BF4                .getCodeSize222:
1BF4 68 AA AA      A push getCodeSize_1
1BF7 8D 06 4F 75     lea  ax, [SymbolUpper]
1BFB 50              push ax
1BFC E8 A4 E7        call eqstr
1BFF 83 C4 04        add  sp, 4
1C02 08 C0           or  al, al
1C04 0F 84 00 00   r je .getCodeSize223
1C08 E8 34 FC        call getTokeType
1C0B B8 02 00        mov ax, 2
1C0E E9 00 00      R jmp .retngetCodeSize
1C11                
1C11                ;-817         if (eqstr(SymbolUpper,"DWORD")){getTokeType(); return DWORD;}
1C11                
1C11                .getCodeSize223:
1C11 68 AA AA      A push getCodeSize_2
1C14 8D 06 4F 75     lea  ax, [SymbolUpper]
1C18 50              push ax
1C19 E8 87 E7        call eqstr
1C1C 83 C4 04        add  sp, 4
1C1F 08 C0           or  al, al
1C21 0F 84 00 00   r je .getCodeSize224
1C25 E8 17 FC        call getTokeType
1C28 B8 03 00        mov ax, 3
1C2B E9 00 00      R jmp .retngetCodeSize
1C2E                
1C2E                ;-818     }
1C2E                
1C2E                .getCodeSize224:
1C2E                
1C2E                ;-819     return 0;
1C2E                
1C2E                .getCodeSize221:
1C2E B8 00 00        mov ax, 0
1C31 E9 00 00      R jmp .retngetCodeSize
1C34                
1C34                ;-820 }
1C34                
1C34                
1C34                ;-821 int isToken(char c) {
1C34                
1C34                 .retngetCodeSize:
1C34 C3              ret
1C35 42 59 54 45 00 getCodeSize_0 db "BYTE",0
1C3A 57 4F 52 44 00 getCodeSize_1 db "WORD",0
1C3F 44 57 4F 52 44 getCodeSize_2 db "DWORD",0
;leaving: getCodeSize. loc labels:8,loc jmp forward:11
;jmp to fix:11
1. .getCodeSize221,from:1BD5,Label+ORG:1D2E,rel:0057
2. getCodeSize_0,from:1BD8,Label+ORG:1D35
3. .getCodeSize222,from:1BE9,Label+ORG:1CF4,rel:0009
4. .retngetCodeSize,from:1BF2,Label+ORG:1D34,rel:0040
5. getCodeSize_1,from:1BF5,Label+ORG:1D3A
6. .getCodeSize223,from:1C06,Label+ORG:1D11,rel:0009
7. .retngetCodeSize,from:1C0F,Label+ORG:1D34,rel:0023
8. getCodeSize_2,from:1C12,Label+ORG:1D3F
9. .getCodeSize224,from:1C23,Label+ORG:1D2E,rel:0009
10. .retngetCodeSize,from:1C2C,Label+ORG:1D34,rel:0006
11. .retngetCodeSize,from:1C32,Label+ORG:1D34,rel:0000
1C45                ENDP
1C45                
;entering: isToken
1C45                isToken: PROC
1C45                
1C45                ;-822     skipBlank();
1C45                
1C45                ;Function : isToken, Number of local variables: 1
1C45                ;   # type sign width addr used name   list of local variables
1C45                ;  200 var sign byte   821 NULL c = bp+4;
1C45 C8 00 00 00     ENTER  0,0
1C49 E8 EA E5        call skipBlank
1C4C                
1C4C                ;-823     if (*InputPtr == c) {
1C4C                
1C4C 8B 1E 14 01     mov bx, [InputPtr]
1C50 8A 07           mov al, [bx]
1C52 B4 00           mov ah, 0
1C54 3A 46 04        cmp al, [bp+4]
1C57 0F 85 00 00   r jne .isToken225
1C5B                
1C5B                ;-824         InputPtr++;
1C5B                
1C5B FF 06 14 01     inc  word[InputPtr]
1C5F                
1C5F                ;-825         return 1;
1C5F                
1C5F B8 01 00        mov ax, 1
1C62 E9 00 00      R jmp .retnisToken
1C65                
1C65                ;-826         }
1C65                
1C65                
1C65                ;-827     return 0;
1C65                
1C65                .isToken225:
1C65 B8 00 00        mov ax, 0
1C68 E9 00 00      R jmp .retnisToken
1C6B                
1C6B                ;-828 }
1C6B                
1C6B                
1C6B                ;-829 int need(char c) {
1C6B                
1C6B C9              .retnisToken: LEAVE
1C6C C3              ret
;leaving: isToken. loc labels:2,loc jmp forward:3
;jmp to fix:3
1. .isToken225,from:1C59,Label+ORG:1D65,rel:000A
2. .retnisToken,from:1C63,Label+ORG:1D6B,rel:0006
3. .retnisToken,from:1C69,Label+ORG:1D6B,rel:0000
1C6D                ENDP
1C6D                
;entering: need
1C6D                need: PROC
1C6D                
1C6D                ;-830     if (isToken(c)) {
1C6D                
1C6D                ;Function : need, Number of local variables: 1
1C6D                ;   # type sign width addr used name   list of local variables
1C6D                ;  200 var sign byte   829 NULL c = bp+4;
1C6D C8 00 00 00     ENTER  0,0
1C71 8A 46 04        mov al, byte [bp+4]
1C74 B4 00           mov ah, 0
1C76 50              push ax
1C77 E8 CB FF        call isToken
1C7A 83 C4 02        add  sp, 2
1C7D 08 C0           or  al, al
1C7F 0F 84 00 00   r je .need226
1C83                
1C83                ;-831         getTokeType();
1C83                
1C83 E8 B9 FB        call getTokeType
1C86                
1C86                ;-832         return;
1C86                
1C86 E9 00 00      R jmp .retnneed
1C89                
1C89                ;-833         }
1C89                
1C89                
1C89                ;-834     error1();
1C89                
1C89                .need226:
1C89 E8 D5 EE        call error1
1C8C                
1C8C                ;-835     prs(". need: ");
1C8C                
1C8C 68 AA AA      A push need_0
1C8F E8 85 ED        call prs
1C92 83 C4 02        add  sp, 2
1C95                
1C95                ;-836     prc(c);
1C95                
1C95 8A 46 04        mov al, byte [bp+4]
1C98 B4 00           mov ah, 0
1C9A 50              push ax
1C9B E8 21 ED        call prc
1C9E 83 C4 02        add  sp, 2
1CA1                
1CA1                ;-837 }
1CA1                
1CA1                
1CA1                ;-838 int skipRest() {
1CA1                
1CA1 C9              .retnneed: LEAVE
1CA2 C3              ret
1CA3 2E 20 6E 65 65 need_0 db ". need: ",0
;leaving: need. loc labels:3,loc jmp forward:3
;jmp to fix:3
1. .need226,from:1C81,Label+ORG:1D89,rel:0006
2. .retnneed,from:1C87,Label+ORG:1DA1,rel:0018
3. need_0,from:1C8D,Label+ORG:1DA3
1CAC                ENDP
1CAC                
;entering: skipRest
1CAC                skipRest: PROC
1CAC                
1CAC                ;-839     getTokeType();
1CAC                
1CAC E8 90 FB        call getTokeType
1CAF                
1CAF                ;-840     if(TokeType)error1("extra char ignored");
1CAF                
1CAF A0 2C 01        mov al, [TokeType]
1CB2 08 C0           or  al, al
1CB4 0F 84 00 00   r je .skipRest227
1CB8 68 AA AA      A push skipRest_0
1CBB E8 A3 EE        call error1
1CBE 83 C4 02        add  sp, 2
1CC1                
1CC1                ;-841 }
1CC1                
1CC1                .skipRest227:
1CC1                
1CC1                ;-842 
1CC1                
1CC1                
1CC1                ;-843 
1CC1                
1CC1                
1CC1                ;-844 
1CC1                
1CC1                
1CC1                ;-845 int getarg() {
1CC1                
1CC1 C3              ret
1CC2 65 78 74 72 61 skipRest_0 db "extra char ignored",0
;leaving: skipRest. loc labels:2,loc jmp forward:2
;jmp to fix:2
1. .skipRest227,from:1CB6,Label+ORG:1DC1,rel:0009
2. skipRest_0,from:1CB9,Label+ORG:1DC2
1CD5                ENDP
1CD5                
;entering: getarg
1CD5                getarg: PROC
1CD5                
1CD5                ;-846     int arglen1; int i; char *c;
1CD5                
1CD5                
1CD5                ;-847     arglen1=*arglen;
1CD5                
1CD5                ;Function : getarg, Number of local variables: 3
1CD5                ;   # type sign width addr used name   list of local variables
1CD5                ;  200 var sign word   846 NULL arglen1 = bp-2
1CD5                ;  201 var sign word   846 NULL i = bp-4
1CD5                ;  202 ptr sign byte   846 NULL c = bp-6;
1CD5 C8 06 00 00     ENTER  6,0
1CD9 8B 1E 5A 01     mov bx, [arglen]
1CDD 8A 07           mov al, [bx]
1CDF B4 00           mov ah, 0
1CE1 89 46 FE        mov [bp-2], ax
1CE4                
1CE4                ;-848     if (arglen1==0) {
1CE4                
1CE4 8B 46 FE        mov ax, [bp-2]
1CE7 83 F8 00        cmp ax, 0
1CEA 0F 85 00 00   r jne .getarg228
1CEE                
1CEE                ;-849         cputs(Version1);
1CEE                
1CEE 8D 06 03 01     lea  ax, [Version1]
1CF2 50              push ax
1CF3 E8 87 E3        call cputs
1CF6 83 C4 02        add  sp, 2
1CF9                
1CF9                ;-850         cputs(", Usage: AS.COM filename [w/o .S] : ");
1CF9                
1CF9 68 AA AA      A push getarg_0
1CFC E8 7E E3        call cputs
1CFF 83 C4 02        add  sp, 2
1D02                
1D02                ;-851         exitR(3);
1D02                
1D02 6A 03           push 3
1D04 E8 D9 E3        call exitR
1D07 83 C4 02        add  sp, 2
1D0A                
1D0A                ;-852     }
1D0A                
1D0A                
1D0A                ;-853     i=arglen1+129;
1D0A                
1D0A                .getarg228:
1D0A 8B 46 FE        mov ax, [bp-2]
1D0D 05 81 00        add ax, 129
1D10 89 46 FC        mov [bp-4], ax
1D13                
1D13                ;-854     *i=0;
1D13                
1D13 B8 00 00        mov ax, 0
1D16 8B 5E FC        mov  bx, [bp-4]
1D19 89 07           mov  [bx], ax
1D1B                
1D1B                ;-855     arglen1--;
1D1B                
1D1B FF 4E FE        dec  word[bp-2]
1D1E                
1D1E                ;-856     toupper(argv);
1D1E                
1D1E FF 36 5C 01     push word [argv]
1D22 E8 EB E6        call toupper
1D25 83 C4 02        add  sp, 2
1D28                
1D28                ;-857 
1D28                
1D28                
1D28                ;-858     strcpy(namein, argv); strcat1(namein, ".S");
1D28                
1D28 FF 36 5C 01     push word [argv]
1D2C 8D 06 8C 76     lea  ax, [namein]
1D30 50              push ax
1D31 E8 39 E6        call strcpy
1D34 83 C4 04        add  sp, 4
1D37 68 AA AA      A push getarg_1
1D3A 8D 06 8C 76     lea  ax, [namein]
1D3E 50              push ax
1D3F E8 AD E6        call strcat1
1D42 83 C4 04        add  sp, 4
1D45                
1D45                ;-859     strcpy(namelst,argv); strcat1(namelst,".LST");
1D45                
1D45 FF 36 5C 01     push word [argv]
1D49 8D 06 CF 76     lea  ax, [namelst]
1D4D 50              push ax
1D4E E8 1C E6        call strcpy
1D51 83 C4 04        add  sp, 4
1D54 68 AA AA      A push getarg_2
1D57 8D 06 CF 76     lea  ax, [namelst]
1D5B 50              push ax
1D5C E8 90 E6        call strcat1
1D5F 83 C4 04        add  sp, 4
1D62                
1D62                ;-860     strcpy(namebin,argv); strcat1(namebin,".COM");
1D62                
1D62 FF 36 5C 01     push word [argv]
1D66 8D 06 12 77     lea  ax, [namebin]
1D6A 50              push ax
1D6B E8 FF E5        call strcpy
1D6E 83 C4 04        add  sp, 4
1D71 68 AA AA      A push getarg_3
1D74 8D 06 12 77     lea  ax, [namebin]
1D78 50              push ax
1D79 E8 73 E6        call strcat1
1D7C 83 C4 04        add  sp, 4
1D7F                
1D7F                ;-861 
1D7F                
1D7F                
1D7F                ;-862   DOS_ERR=0; PC=0; ErrorCount=0;
1D7F                
1D7F B8 00 00        mov ax, 0
1D82 A3 1C 01        mov word [DOS_ERR], ax
1D85 B8 00 00        mov ax, 0
1D88 A3 23 01        mov word [PC], ax
1D8B B8 00 00        mov ax, 0
1D8E A3 1E 01        mov word [ErrorCount], ax
1D91                
1D91                ;-863 
1D91                
1D91                
1D91                ;-864     asm_fd=openR (namein);
1D91                
1D91 8D 06 8C 76     lea  ax, [namein]
1D95 50              push ax
1D96 E8 17 E3        call openR
1D99 83 C4 02        add  sp, 2
1D9C A3 16 01        mov word [asm_fd], ax
1D9F                
1D9F                ;-865     if(DOS_ERR){cputs("Source file missing: ") ;cputs(namein );exitR(1);}
1D9F                
1D9F A1 1C 01        mov ax, [DOS_ERR]
1DA2 08 C0           or  al, al
1DA4 0F 84 00 00   r je .getarg229
1DA8 68 AA AA      A push getarg_4
1DAB E8 CF E2        call cputs
1DAE 83 C4 02        add  sp, 2
1DB1 8D 06 8C 76     lea  ax, [namein]
1DB5 50              push ax
1DB6 E8 C4 E2        call cputs
1DB9 83 C4 02        add  sp, 2
1DBC 6A 01           push 1
1DBE E8 1F E3        call exitR
1DC1 83 C4 02        add  sp, 2
1DC4                
1DC4                ;-866     lst_fd=creatR(namelst);
1DC4                
1DC4                .getarg229:
1DC4 8D 06 CF 76     lea  ax, [namelst]
1DC8 50              push ax
1DC9 E8 F3 E2        call creatR
1DCC 83 C4 02        add  sp, 2
1DCF A3 18 01        mov word [lst_fd], ax
1DD2                
1DD2                ;-867     if(DOS_ERR){cputs("List file not create: ");cputs(namelst);exitR(2);}
1DD2                
1DD2 A1 1C 01        mov ax, [DOS_ERR]
1DD5 08 C0           or  al, al
1DD7 0F 84 00 00   r je .getarg230
1DDB 68 AA AA      A push getarg_5
1DDE E8 9C E2        call cputs
1DE1 83 C4 02        add  sp, 2
1DE4 8D 06 CF 76     lea  ax, [namelst]
1DE8 50              push ax
1DE9 E8 91 E2        call cputs
1DEC 83 C4 02        add  sp, 2
1DEF 6A 02           push 2
1DF1 E8 EC E2        call exitR
1DF4 83 C4 02        add  sp, 2
1DF7                
1DF7                ;-868     bin_fd=creatR(namebin);
1DF7                
1DF7                .getarg230:
1DF7 8D 06 12 77     lea  ax, [namebin]
1DFB 50              push ax
1DFC E8 C0 E2        call creatR
1DFF 83 C4 02        add  sp, 2
1E02 A3 1A 01        mov word [bin_fd], ax
1E05                
1E05                ;-869     if(DOS_ERR){cputs("COM file not create: ") ;cputs(namebin);exitR(2);}
1E05                
1E05 A1 1C 01        mov ax, [DOS_ERR]
1E08 08 C0           or  al, al
1E0A 0F 84 00 00   r je .getarg231
1E0E 68 AA AA      A push getarg_6
1E11 E8 69 E2        call cputs
1E14 83 C4 02        add  sp, 2
1E17 8D 06 12 77     lea  ax, [namebin]
1E1B 50              push ax
1E1C E8 5E E2        call cputs
1E1F 83 C4 02        add  sp, 2
1E22 6A 02           push 2
1E24 E8 B9 E2        call exitR
1E27 83 C4 02        add  sp, 2
1E2A                
1E2A                ;-870 
1E2A                
1E2A                
1E2A                ;-871     prs(";");
1E2A                
1E2A                .getarg231:
1E2A 68 AA AA      A push getarg_7
1E2D E8 E7 EB        call prs
1E30 83 C4 02        add  sp, 2
1E33                
1E33                ;-872     prs(Version1);
1E33                
1E33 8D 06 03 01     lea  ax, [Version1]
1E37 50              push ax
1E38 E8 DC EB        call prs
1E3B 83 C4 02        add  sp, 2
1E3E                
1E3E                ;-873     prs(", Source: "); prs(namein);
1E3E                
1E3E 68 AA AA      A push getarg_8
1E41 E8 D3 EB        call prs
1E44 83 C4 02        add  sp, 2
1E47 8D 06 8C 76     lea  ax, [namein]
1E4B 50              push ax
1E4C E8 C8 EB        call prs
1E4F 83 C4 02        add  sp, 2
1E52                
1E52                ;-874     prs(", Output: "); prs(namelst);
1E52                
1E52 68 AA AA      A push getarg_9
1E55 E8 BF EB        call prs
1E58 83 C4 02        add  sp, 2
1E5B 8D 06 CF 76     lea  ax, [namelst]
1E5F 50              push ax
1E60 E8 B4 EB        call prs
1E63 83 C4 02        add  sp, 2
1E66                
1E66                ;-875     prs(", "); prs(namebin);
1E66                
1E66 68 AA AA      A push getarg_10
1E69 E8 AB EB        call prs
1E6C 83 C4 02        add  sp, 2
1E6F 8D 06 12 77     lea  ax, [namebin]
1E73 50              push ax
1E74 E8 A0 EB        call prs
1E77 83 C4 02        add  sp, 2
1E7A                
1E7A                ;-876     prs("\n");
1E7A                
1E7A 68 AA AA      A push getarg_11
1E7D E8 97 EB        call prs
1E80 83 C4 02        add  sp, 2
1E83                
1E83                ;-877 }
1E83                
1E83                
1E83                ;-878 
1E83                
1E83                
1E83                ;-879 int fixJmp() {   
1E83 C9              LEAVE
1E84 C3              ret
1E85 2C 20 55 73 61 getarg_0 db ", Usage: AS.COM filename [w/o .S] : ",0
1EAA 2E 53 00       getarg_1 db ".S",0
1EAD 2E 4C 53 54 00 getarg_2 db ".LST",0
1EB2 2E 43 4F 4D 00 getarg_3 db ".COM",0
1EB7 53 6F 75 72 63 getarg_4 db "Source file missing: ",0
1ECD 4C 69 73 74 20 getarg_5 db "List file not create: ",0
1EE4 43 4F 4D 20 66 getarg_6 db "COM file not create: ",0
1EFA 3B 00          getarg_7 db ";",0
1EFC 2C 20 53 6F 75 getarg_8 db ", Source: ",0
1F07 2C 20 4F 75 74 getarg_9 db ", Output: ",0
1F12 2C 20 00       getarg_10 db ", ",0
1F15 5C 6E 00       getarg_11 db "\n",0
;leaving: getarg. loc labels:16,loc jmp forward:16
;jmp to fix:16
1. .getarg228,from:1CEC,Label+ORG:1E0A,rel:001C
2. getarg_0,from:1CFA,Label+ORG:1F85
3. getarg_1,from:1D38,Label+ORG:1FAA
4. getarg_2,from:1D55,Label+ORG:1FAD
5. getarg_3,from:1D72,Label+ORG:1FB2
6. .getarg229,from:1DA6,Label+ORG:1EC4,rel:001C
7. getarg_4,from:1DA9,Label+ORG:1FB7
8. .getarg230,from:1DD9,Label+ORG:1EF7,rel:001C
9. getarg_5,from:1DDC,Label+ORG:1FCD
10. .getarg231,from:1E0C,Label+ORG:1F2A,rel:001C
11. getarg_6,from:1E0F,Label+ORG:1FE4
12. getarg_7,from:1E2B,Label+ORG:1FFA
13. getarg_8,from:1E3F,Label+ORG:1FFC
14. getarg_9,from:1E53,Label+ORG:2007
15. getarg_10,from:1E67,Label+ORG:2012
16. getarg_11,from:1E7B,Label+ORG:2015
1F18                ENDP
1F18                
;entering: fixJmp
1F18                fixJmp: PROC
1F18                
1F18                ;-880     //todo ENDP: search backwards until tmpJmpMaxIx    
1F18                
1F18                
1F18                ;-881     unsigned int hex; int i;
1F18                
1F18                
1F18                ;-882     char *p; int Ix; char c;
1F18                
1F18                
1F18                ;-883     if (isInProc) i = tmpJmpMaxIx;
1F18                
1F18                ;Function : fixJmp, Number of local variables: 5
1F18                ;   # type sign width addr used name   list of local variables
1F18                ;  200 var unsg word   881 NULL hex = bp-2
1F18                ;  201 var sign word   881 NULL i = bp-4
1F18                ;  202 ptr sign byte   882 NULL p = bp-6
1F18                ;  203 var sign word   882 NULL Ix = bp-8
1F18                ;  204 var sign byte   882 NULL c = bp-10;
1F18 C8 0A 00 00     ENTER  10,0
1F1C A0 0D 01        mov al, [isInProc]
1F1F 08 C0           or  al, al
1F21 0F 84 00 00   r je .fixJmp232
1F25 A1 56 01        mov ax, [tmpJmpMaxIx]
1F28 89 46 FC        mov [bp-4], ax
1F2B                
1F2B                ;-884     else i = 1;//at the end look at all open jmp   
1F2B                
1F2B E9 00 00      R jmp .fixJmp233
1F2E                .fixJmp232:
1F2E B8 01 00        mov ax, 1
1F31 89 46 FC        mov [bp-4], ax
1F34                
1F34                ;-885     prs("\n;jmp to fix:");
1F34                
1F34                .fixJmp233:
1F34 68 AA AA      A push fixJmp_0
1F37 E8 DD EA        call prs
1F3A 83 C4 02        add  sp, 2
1F3D                
1F3D                ;-886     printIntU(JmpMaxIx);
1F3D                
1F3D FF 36 54 01     push word [JmpMaxIx]
1F41 E8 DF EB        call printIntU
1F44 83 C4 02        add  sp, 2
1F47                
1F47                ;-887     p = &JmpNames;
1F47                
1F47 B8 7A 93        mov ax, JmpNames
1F4A 89 46 FA        mov [bp-6], ax
1F4D                
1F4D                ;-888     while (i <= JmpMaxIx) {
1F4D                
1F4D                .fixJmp234:
1F4D 8B 46 FC        mov ax, [bp-4]
1F50 3B 06 54 01     cmp ax, [JmpMaxIx]
1F54 0F 8F 00 00   r jg  .fixJmp235
1F58                
1F58                ;-889         strcpy(Symbol, p);
1F58                
1F58 55              push word [bp-6]
1F59 8D 06 30 75     lea  ax, [Symbol]
1F5D 50              push ax
1F5E E8 0C E4        call strcpy
1F61 83 C4 04        add  sp, 4
1F64                
1F64                ;-890         p = strlen(Symbol) + p;
1F64                
1F64 8D 06 30 75     lea  ax, [Symbol]
1F68 50              push ax
1F69 E8 D9 E3        call strlen
1F6C 83 C4 02        add  sp, 2
1F6F 03 46 FA        add ax, [bp-6]
1F72 89 46 FA        mov [bp-6], ax
1F75                
1F75                ;-891         p++;
1F75                
1F75 FF 46 FA        inc  word[bp-6]
1F78                
1F78                ;-892         hex = JmpAddr[i];
1F78                
1F78 8B 5E FC        mov bx, [bp-4]
1F7B D1 E3           shl bx, 1
1F7D 8B 47 1A        mov ax, [JmpAddr + bx]
1F80 89 46 FE        mov [bp-2], ax
1F83                
1F83                ;-893 //prs("\nSymbol:"); prs(Symbol); prs(",from:");                                       
1F83                
1F83                
1F83                ;-894 //printhex16(hex);//debug
1F83                
1F83                
1F83                ;-895         
1F83                
1F83                
1F83                ;-896         Ix=searchLabel();
1F83                
1F83 E8 60 FA        call searchLabel
1F86 89 46 F8        mov [bp-8], ax
1F89                
1F89                ;-897         if (Ix == 0) notfounderror();
1F89                
1F89 8B 46 F8        mov ax, [bp-8]
1F8C 83 F8 00        cmp ax, 0
1F8F 0F 85 00 00   r jne .fixJmp236
1F93 E8 37 EC        call notfounderror
1F96                
1F96                ;-898         disp = LabelAddr[Ix];   
1F96                
1F96                .fixJmp236:
1F96 8B 5E F8        mov bx, [bp-8]
1F99 D1 E3           shl bx, 1
1F9B 8B 47 CA        mov ax, [LabelAddr + bx]
1F9E A3 3D 01        mov word [disp], ax
1FA1                
1FA1                ;-899         c = FileBin[hex];//look for 'A' push Absolute 
1FA1                
1FA1 8B 5E FE        mov bx, [bp-2]
1FA4 8A 47 AA        mov al, [FileBin + bx]
1FA7 88 46 F6        mov [bp-10], al
1FAA                
1FAA                ;-900 //prs(",=00/AA:["); printhex8a(c);
1FAA                
1FAA                
1FAA                ;-901 //prs("],Lab:"); printhex16(disp);
1FAA                
1FAA                
1FAA                ;-902         if (c != 0xAA) {
1FAA                
1FAA 8A 46 F6        mov al, [bp-10]
1FAD 3C AA           cmp al, 170
1FAF 0F 84 00 00   r je  .fixJmp237
1FB3                
1FB3                ;-903             disp = disp - hex;
1FB3                
1FB3 A1 3D 01        mov ax, [disp]
1FB6 2B 46 FE        sub ax, [bp-2]
1FB9 A3 3D 01        mov word [disp], ax
1FBC                
1FBC                ;-904             disp = disp -2;//PC points to next instruction
1FBC                
1FBC A1 3D 01        mov ax, [disp]
1FBF 83 E8 02        sub ax, 2
1FC2 A3 3D 01        mov word [disp], ax
1FC5                
1FC5                ;-905             disp = disp - Origin;
1FC5                
1FC5 A1 3D 01        mov ax, [disp]
1FC8 2B 06 25 01     sub ax, [Origin]
1FCC A3 3D 01        mov word [disp], ax
1FCF                
1FCF                ;-906         }
1FCF                
1FCF                
1FCF                ;-907             FileBin[hex] = disp;//fix low byte
1FCF                
1FCF                .fixJmp237:
1FCF A1 3D 01        mov ax, [disp]
1FD2 8B 5E FE        mov bx, [bp-2]
1FD5 88 47 AA        mov [FileBin+bx], al
1FD8                
1FD8                ;-908             hex++;
1FD8                
1FD8 FF 46 FE        inc  word[bp-2]
1FDB                
1FDB                ;-909             disp = disp >> 8;
1FDB                
1FDB A1 3D 01        mov ax, [disp]
1FDE C1 E8 08        shr ax, 8
1FE1 A3 3D 01        mov word [disp], ax
1FE4                
1FE4                ;-910             FileBin[hex] = disp; 
1FE4                
1FE4 A1 3D 01        mov ax, [disp]
1FE7 8B 5E FE        mov bx, [bp-2]
1FEA 88 47 AA        mov [FileBin+bx], al
1FED                
1FED                ;-911         i++;
1FED                
1FED FF 46 FC        inc  word[bp-4]
1FF0                
1FF0                ;-912     }
1FF0                
1FF0                
1FF0                ;-913 }
1FF0                
1FF0 E9 5A FF        jmp .fixJmp234
1FF3                .fixJmp235:
1FF3                
1FF3                ;-914 
1FF3                
1FF3                
1FF3                ;-915 int epilog() {
1FF3 C9              LEAVE
1FF4 C3              ret
1FF5 5C 6E 3B 6A 6D fixJmp_0 db "\n;jmp to fix:",0
;leaving: fixJmp. loc labels:7,loc jmp forward:6
;jmp to fix:6
1. .fixJmp232,from:1F23,Label+ORG:202E,rel:0009
2. .fixJmp233,from:1F2C,Label+ORG:2034,rel:0006
3. fixJmp_0,from:1F35,Label+ORG:20F5
4. .fixJmp235,from:1F56,Label+ORG:20F3,rel:009B
5. .fixJmp236,from:1F91,Label+ORG:2096,rel:0003
6. .fixJmp237,from:1FB1,Label+ORG:20CF,rel:001C
2004                ENDP
2004                
;entering: epilog
2004                epilog: PROC
2004                
2004                ;-916     unsigned int i; char c;     int j;
2004                
2004                
2004                ;-917     prs("\n Errors: ");
2004                
2004                ;Function : epilog, Number of local variables: 3
2004                ;   # type sign width addr used name   list of local variables
2004                ;  200 var unsg word   916 NULL i = bp-2
2004                ;  201 var sign byte   916 NULL c = bp-4
2004                ;  202 var sign word   916 NULL j = bp-6;
2004 C8 06 00 00     ENTER  6,0
2008 68 AA AA      A push epilog_0
200B E8 09 EA        call prs
200E 83 C4 02        add  sp, 2
2011                
2011                ;-918     printIntU(ErrorCount);
2011                
2011 FF 36 1E 01     push word [ErrorCount]
2015 E8 0B EB        call printIntU
2018 83 C4 02        add  sp, 2
201B                
201B                ;-919     if (ErrorCount) prs(" ***ERROR*** ");
201B                
201B A1 1E 01        mov ax, [ErrorCount]
201E 08 C0           or  al, al
2020 0F 84 00 00   r je .epilog238
2024 68 AA AA      A push epilog_1
2027 E8 ED E9        call prs
202A 83 C4 02        add  sp, 2
202D                
202D                ;-920     prs(", Out: ");
202D                
202D                .epilog238:
202D 68 AA AA      A push epilog_2
2030 E8 E4 E9        call prs
2033 83 C4 02        add  sp, 2
2036                
2036                ;-921     prs(namelst);
2036                
2036 8D 06 CF 76     lea  ax, [namelst]
203A 50              push ax
203B E8 D9 E9        call prs
203E 83 C4 02        add  sp, 2
2041                
2041                ;-922     prs(", ");
2041                
2041 68 AA AA      A push epilog_3
2044 E8 D0 E9        call prs
2047 83 C4 02        add  sp, 2
204A                
204A                ;-923     prs(namebin);
204A                
204A 8D 06 12 77     lea  ax, [namebin]
204E 50              push ax
204F E8 C5 E9        call prs
2052 83 C4 02        add  sp, 2
2055                
2055                ;-924     prs("= ");
2055                
2055 68 AA AA      A push epilog_4
2058 E8 BC E9        call prs
205B 83 C4 02        add  sp, 2
205E                
205E                ;-925     printIntU(BinLen);
205E                
205E FF 36 58 01     push word [BinLen]
2062 E8 BE EA        call printIntU
2065 83 C4 02        add  sp, 2
2068                
2068                ;-926     prs(" bytes.");
2068                
2068 68 AA AA      A push epilog_5
206B E8 A9 E9        call prs
206E 83 C4 02        add  sp, 2
2071                
2071                ;-927     prs(" Labels: ");
2071                
2071 68 AA AA      A push epilog_6
2074 E8 A0 E9        call prs
2077 83 C4 02        add  sp, 2
207A                
207A                ;-928     printIntU(LabelMaxIx);
207A                
207A FF 36 4A 01     push word [LabelMaxIx]
207E E8 A2 EA        call printIntU
2081 83 C4 02        add  sp, 2
2084                
2084                ;-929 // prs(", code:\n ");//debug
2084                
2084                
2084                ;-930 
2084                
2084                
2084                ;-931     i=0;
2084                
2084 B8 00 00        mov ax, 0
2087 89 46 FE        mov [bp-2], ax
208A                
208A                ;-932     do {
208A                
208A                .epilog239:
208A                
208A                ;-933         c = FileBin[i];
208A                
208A 8B 5E FE        mov bx, [bp-2]
208D 8A 47 AA        mov al, [FileBin + bx]
2090 88 46 FC        mov [bp-4], al
2093                
2093                ;-934         fputcR(c, bin_fd);
2093                
2093 FF 36 1A 01     push word [bin_fd]
2097 8A 46 FC        mov al, byte [bp-4]
209A B4 00           mov ah, 0
209C 50              push ax
209D E8 63 E0        call fputcR
20A0 83 C4 04        add  sp, 4
20A3                
20A3                ;-935 // printhex8a(c); prc(' ');//debug
20A3                
20A3                
20A3                ;-936         i++;
20A3                
20A3 FF 46 FE        inc  word[bp-2]
20A6                
20A6                ;-937     } while (i < BinLen);
20A6                
20A6 8B 46 FE        mov ax, [bp-2]
20A9 3B 06 58 01     cmp ax, [BinLen]
20AD 0F 8D 00 00   r jge .epilog240
20B1 EB D7           jmp .epilog239
20B3                .epilog240:
20B3                
20B3                ;-938 
20B3                
20B3                
20B3                ;-939 /* 
20B3                
20B3                
20B3                ;-940   prs("\n\n LabelNamePtr:"); printIntU(LabelNamePtr);
20B3                
20B3                
20B3                ;-941   i= &LabelNames;
20B3                
20B3                
20B3                ;-942   prs(" &LabelNames:"); printIntU(i);
20B3                
20B3                
20B3                ;-943   i=LabelNamePtr-i;
20B3                
20B3                
20B3                ;-944   prs(", size: ");
20B3                
20B3                
20B3                ;-945   printIntU(i);
20B3                
20B3                
20B3                ;-946   prs(".\n >>");
20B3                
20B3                
20B3                ;-947   i= &LabelNames;
20B3                
20B3                
20B3                ;-948   do { c=*i; if (c==0) c=' '; prc(c); i++;
20B3                
20B3                
20B3                ;-949   } while (i < LabelNamePtr); prs("<< \n");
20B3                
20B3                
20B3                ;-950    i = 1;
20B3                
20B3                
20B3                ;-951     LabelNamePtr= &LabelNames;
20B3                
20B3                
20B3                ;-952     do {
20B3                
20B3                
20B3                ;-953       prs(LabelNamePtr); prc(' ');
20B3                
20B3                
20B3                ;-954       j=LabelAddr[i]; printhex16(j); prs(", ");
20B3                
20B3                
20B3                ;-955       j=strlen(LabelNamePtr);//get end of actual name
20B3                
20B3                
20B3                ;-956       LabelNamePtr=LabelNamePtr+j;
20B3                
20B3                
20B3                ;-957       LabelNamePtr++;
20B3                
20B3                
20B3                ;-958       i++;
20B3                
20B3                
20B3                ;-959     } while (i <= LabelMaxIx);
20B3                
20B3                
20B3                ;-960 */
20B3                
20B3                
20B3                ;-961 }
20B3                
20B3                
20B3                ;-962 
20B3                
20B3                
20B3                ;-963 int end1(int n) {
20B3 C9              LEAVE
20B4 C3              ret
20B5 5C 6E 20 45 72 epilog_0 db "\n Errors: ",0
20C1 20 2A 2A 2A 45 epilog_1 db " ***ERROR*** ",0
20CF 2C 20 4F 75 74 epilog_2 db ", Out: ",0
20D7 2C 20 00       epilog_3 db ", ",0
20DA 3D 20 00       epilog_4 db "= ",0
20DD 20 62 79 74 65 epilog_5 db " bytes.",0
20E5 20 4C 61 62 65 epilog_6 db " Labels: ",0
;leaving: epilog. loc labels:10,loc jmp forward:9
;jmp to fix:9
1. epilog_0,from:2009,Label+ORG:21B5
2. .epilog238,from:2022,Label+ORG:212D,rel:0009
3. epilog_1,from:2025,Label+ORG:21C1
4. epilog_2,from:202E,Label+ORG:21CF
5. epilog_3,from:2042,Label+ORG:21D7
6. epilog_4,from:2056,Label+ORG:21DA
7. epilog_5,from:2069,Label+ORG:21DD
8. epilog_6,from:2072,Label+ORG:21E5
9. .epilog240,from:20AF,Label+ORG:21B3,rel:0002
20EF                ENDP
20EF                
;entering: end1
20EF                end1: PROC
20EF                
20EF                ;-964     fcloseR(asm_fd);
20EF                
20EF                ;Function : end1, Number of local variables: 1
20EF                ;   # type sign width addr used name   list of local variables
20EF                ;  200 var sign word   963 NULL n = bp+4;
20EF C8 00 00 00     ENTER  0,0
20F3 FF 36 16 01     push word [asm_fd]
20F7 E8 D7 DF        call fcloseR
20FA 83 C4 02        add  sp, 2
20FD                
20FD                ;-965     fcloseR(lst_fd);
20FD                
20FD FF 36 18 01     push word [lst_fd]
2101 E8 CD DF        call fcloseR
2104 83 C4 02        add  sp, 2
2107                
2107                ;-966     fcloseR(bin_fd);
2107                
2107 FF 36 1A 01     push word [bin_fd]
210B E8 C3 DF        call fcloseR
210E 83 C4 02        add  sp, 2
2111                
2111                ;-967     exitR(n);
2111                
2111 55              push word [bp+4]
2112 E8 CB DF        call exitR
2115 83 C4 02        add  sp, 2
2118                
2118                ;-968 }
2118                
2118                
2118                ;-969 
2118                
2118                
2118                ;-970 
2118                
2118                
2118                ;-971 //#include "GENCODE.C"
2118                
2118                
2118                ;-972 // generate code
2118                
2118                
2118                ;-973 int getCodes() {
2118 C9              LEAVE
2119 C3              ret
;leaving: end1. loc labels:0,loc jmp forward:0
;jmp to fix:0
211A                ENDP
211A                
;entering: getCodes
211A                getCodes: PROC
211A                
211A                ;-974     OpCodePtr ++; Code1 = *OpCodePtr;
211A                
211A FF 06 43 01     inc  word[OpCodePtr]
211E 8B 1E 43 01     mov bx, [OpCodePtr]
2122 8A 07           mov al, [bx]
2124 B4 00           mov ah, 0
2126 A2 30 01        mov byte [Code1], al
2129                
2129                ;-975     OpCodePtr ++; Code2 = *OpCodePtr;
2129                
2129 FF 06 43 01     inc  word[OpCodePtr]
212D 8B 1E 43 01     mov bx, [OpCodePtr]
2131 8A 07           mov al, [bx]
2133 B4 00           mov ah, 0
2135 A2 31 01        mov byte [Code2], al
2138                
2138                ;-976     OpCodePtr ++; Code3 = *OpCodePtr;
2138                
2138 FF 06 43 01     inc  word[OpCodePtr]
213C 8B 1E 43 01     mov bx, [OpCodePtr]
2140 8A 07           mov al, [bx]
2142 B4 00           mov ah, 0
2144 A2 32 01        mov byte [Code3], al
2147                
2147                ;-977 }
2147                
2147                
2147                ;-978 int gen66h() {genCode8(0x66);
2147                
2147 C3              ret
;leaving: getCodes. loc labels:0,loc jmp forward:0
;jmp to fix:0
2148                ENDP
2148                
;entering: gen66h
2148                gen66h: PROC
2148 6A 66           push 102
214A E8 00 00      R call genCode8
214D 83 C4 02        add  sp, 2
2150                
2150                ;-979 }
2150                
2150                
2150                ;-980 int genCode2(char c, char d) {
2150                
2150 C3              ret
;leaving: gen66h. loc labels:0,loc jmp forward:1
;jmp to fix:1
1. genCode8,from:214B
;***** ERROR: label not found: genCode8 ,Label+ORG:0447,rel:E1FA
2151                ENDP
2151                
;entering: genCode2
2151                genCode2: PROC
2151                
2151                ;-981     c = c + d;
2151                
2151                ;Function : genCode2, Number of local variables: 2
2151                ;   # type sign width addr used name   list of local variables
2151                ;  200 var sign byte   980 NULL c = bp+4
2151                ;  201 var sign byte   980 NULL d = bp+6;
2151 C8 00 00 00     ENTER  0,0
2155 8A 46 04        mov al, [bp+4]
2158 02 46 06        add al, [bp+6]
215B 88 46 04        mov [bp+4], al
215E                
215E                ;-982     genCode8(c);
215E                
215E 8A 46 04        mov al, byte [bp+4]
2161 B4 00           mov ah, 0
2163 50              push ax
2164 E8 00 00      R call genCode8
2167 83 C4 02        add  sp, 2
216A                
216A                ;-983 }
216A                
216A                
216A                ;-984 int genCodeW(char c) {
216A C9              LEAVE
216B C3              ret
;leaving: genCode2. loc labels:0,loc jmp forward:1
;jmp to fix:1
1. genCode8,from:2165
;***** ERROR: label not found: genCode8 ,Label+ORG:0447,rel:E1E0
216C                ENDP
216C                
;entering: genCodeW
216C                genCodeW: PROC
216C                
216C                ;-985     c = c + wflag;
216C                
216C                ;Function : genCodeW, Number of local variables: 1
216C                ;   # type sign width addr used name   list of local variables
216C                ;  200 var sign byte   984 NULL c = bp+4;
216C C8 00 00 00     ENTER  0,0
2170 8A 46 04        mov al, [bp+4]
2173 02 06 38 01     add al, [wflag]
2177 88 46 04        mov [bp+4], al
217A                
217A                ;-986     genCode8(c);
217A                
217A 8A 46 04        mov al, byte [bp+4]
217D B4 00           mov ah, 0
217F 50              push ax
2180 E8 00 00      R call genCode8
2183 83 C4 02        add  sp, 2
2186                
2186                ;-987 }
2186                
2186                
2186                ;-988 int genCode8(char c) {
2186 C9              LEAVE
2187 C3              ret
;leaving: genCodeW. loc labels:0,loc jmp forward:1
;jmp to fix:1
1. genCode8,from:2181
;***** ERROR: label not found: genCode8 ,Label+ORG:0447,rel:E1C4
2188                ENDP
2188                
;entering: genCode8
2188                genCode8: PROC
2188                
2188                ;-989 //set: BinLen++, OpPrintIndex++
2188                
2188                
2188                ;-990     FileBin[BinLen]=c;
2188                
2188                ;Function : genCode8, Number of local variables: 1
2188                ;   # type sign width addr used name   list of local variables
2188                ;  200 var sign byte   988 NULL c = bp+4;
2188 C8 00 00 00     ENTER  0,0
218C 8A 46 04        mov al, [bp+4]
218F 8B 1E 58 01     mov bx, [BinLen]
2193 88 47 AA        mov [FileBin+bx], al
2196                
2196                ;-991     BinLen++;
2196                
2196 FF 06 58 01     inc  word[BinLen]
219A                
219A                ;-992     PC++;
219A                
219A FF 06 23 01     inc  word[PC]
219E                
219E                ;-993     if (BinLen >= FILEBINMAX) errorexit("COM file too long");
219E                
219E A1 58 01        mov ax, [BinLen]
21A1 3D 68 42        cmp ax, 17000 ;unsigned : 0
21A4 0F 82 00 00   r jb  .genCode8241
21A8 68 AA AA      A push genCode8_0
21AB E8 07 EA        call errorexit
21AE 83 C4 02        add  sp, 2
21B1                
21B1                ;-994     if (OpPrintIndex < OPMAXLEN) {
21B1                
21B1                .genCode8241:
21B1 A1 41 01        mov ax, [OpPrintIndex]
21B4 83 F8 05        cmp ax, 5
21B7 0F 8D 00 00   r jge .genCode8242
21BB                
21BB                ;-995         OpPos[OpPrintIndex]=c;
21BB                
21BB 8A 46 04        mov al, [bp+4]
21BE 8B 1E 41 01     mov bx, [OpPrintIndex]
21C2 88 87 55 77     mov [OpPos+bx], al
21C6                
21C6                ;-996         OpPrintIndex++;
21C6                
21C6 FF 06 41 01     inc  word[OpPrintIndex]
21CA                
21CA                ;-997     }
21CA                
21CA                
21CA                ;-998 }
21CA                
21CA                .genCode8242:
21CA                
21CA                ;-999 int genCode16(unsigned int i) {
21CA C9              LEAVE
21CB C3              ret
21CC 43 4F 4D 20 66 genCode8_0 db "COM file too long",0
;leaving: genCode8. loc labels:3,loc jmp forward:3
;jmp to fix:3
1. .genCode8241,from:21A6,Label+ORG:22B1,rel:0009
2. genCode8_0,from:21A9,Label+ORG:22CC
3. .genCode8242,from:21B9,Label+ORG:22CA,rel:000F
21DE                ENDP
21DE                
;entering: genCode16
21DE                genCode16: PROC
21DE                
21DE                ;-1000     genCode8(i); i=i >> 8;
21DE                
21DE                ;Function : genCode16, Number of local variables: 1
21DE                ;   # type sign width addr used name   list of local variables
21DE                ;  200 var unsg word   999 NULL i = bp+4;
21DE C8 00 00 00     ENTER  0,0
21E2 55              push word [bp+4]
21E3 E8 A2 FF        call genCode8
21E6 83 C4 02        add  sp, 2
21E9 8B 46 04        mov ax, [bp+4]
21EC C1 E8 08        shr ax, 8
21EF 89 46 04        mov [bp+4], ax
21F2                
21F2                ;-1001     genCode8(i);
21F2                
21F2 55              push word [bp+4]
21F3 E8 92 FF        call genCode8
21F6 83 C4 02        add  sp, 2
21F9                
21F9                ;-1002 }
21F9                
21F9                
21F9                ;-1003 int genCode32(unsigned long L) {
21F9 C9              LEAVE
21FA C3              ret
;leaving: genCode16. loc labels:0,loc jmp forward:0
;jmp to fix:0
21FB                ENDP
21FB                
;entering: genCode32
21FB                genCode32: PROC
21FB                
21FB                ;-1004     genCode16(L); L=L >>16;
21FB                
21FB                ;Function : genCode32, Number of local variables: 1
21FB                ;   # type sign width addr used name   list of local variables
21FB                ;  200 var unsg dwrd  1003 NULL L = bp+4;
21FB C8 00 00 00     ENTER  0,0
21FF 8A 46 04        mov al, byte [bp+4]
2202 B4 00           mov ah, 0
2204 50              push ax
2205 E8 D6 FF        call genCode16
2208 83 C4 02        add  sp, 2
220B 66 8B 46 04     mov eax, [bp+4]
220F 66 C1 E8 10     shr eax, 16
2213 66 89 46 04     mov [bp+4], eax
2217                
2217                ;-1005     genCode16(L);
2217                
2217 8A 46 04        mov al, byte [bp+4]
221A B4 00           mov ah, 0
221C 50              push ax
221D E8 BE FF        call genCode16
2220 83 C4 02        add  sp, 2
2223                
2223                ;-1006 }
2223                
2223                
2223                ;-1007 int writeEA(char xxx) {//value for reg/operand
2223 C9              LEAVE
2224 C3              ret
;leaving: genCode32. loc labels:0,loc jmp forward:0
;jmp to fix:0
2225                ENDP
2225                
;entering: writeEA
2225                writeEA: PROC
2225                
2225                ;-1008 //need: Op, Op2, disp, R1No, R2No, rm, isDirect
2225                
2225                
2225                ;-1009 //mod-bits: mode76, reg/opcode543, r/m210
2225                
2225                
2225                ;-1010 //Op: 0, IMM, REG, ADR, MEM
2225                
2225                
2225                ;-1011     char len;
2225                
2225                
2225                ;-1012     len=0;
2225                
2225                ;Function : writeEA, Number of local variables: 2
2225                ;   # type sign width addr used name   list of local variables
2225                ;  200 var sign byte  1007 NULL xxx = bp+4
2225                ;  201 var sign byte  1011 NULL len = bp-2;
2225 C8 02 00 00     ENTER  2,0
2229 B8 00 00        mov ax, 0
222C 88 46 FE        mov [bp-2], al
222F                
222F                ;-1013     xxx = xxx << 3;//in reg/opcode field
222F                
222F 8A 46 04        mov al, [bp+4]
2232 C0 E0 03        shl al, 3
2235 88 46 04        mov [bp+4], al
2238                
2238                ;-1014     if (Op == REG) {
2238                
2238 A0 2D 01        mov al, [Op]
223B 3C 02           cmp al, 2
223D 0F 85 00 00   r jne .writeEA243
2241                
2241                ;-1015         xxx |= 0xC0;
2241                
2241 80 4E 04 C0     or  byte[bp+4], 192
2245                
2245                ;-1016         if (Op2 <= IMM) xxx = xxx + R1No;//empty or IMM
2245                
2245 A0 2E 01        mov al, [Op2]
2248 3C 01           cmp al, 1
224A 0F 8F 00 00   r jg  .writeEA244
224E 8A 46 04        mov al, [bp+4]
2251 02 06 34 01     add al, [R1No]
2255 88 46 04        mov [bp+4], al
2258                
2258                ;-1017             else {
2258                
2258 E9 00 00      R jmp .writeEA245
225B                .writeEA244:
225B                
225B                ;-1018                 if (Op2 == REG) xxx = xxx + R1No;
225B                
225B A0 2E 01        mov al, [Op2]
225E 3C 02           cmp al, 2
2260 0F 85 00 00   r jne .writeEA246
2264 8A 46 04        mov al, [bp+4]
2267 02 06 34 01     add al, [R1No]
226B 88 46 04        mov [bp+4], al
226E                
226E                ;-1019                 else            xxx = xxx + R2No;
226E                
226E E9 00 00      R jmp .writeEA247
2271                .writeEA246:
2271 8A 46 04        mov al, [bp+4]
2274 02 06 33 01     add al, [R2No]
2278 88 46 04        mov [bp+4], al
227B                
227B                ;-1020             }
227B                
227B                .writeEA247:
227B                
227B                ;-1021         }
227B                
227B                .writeEA245:
227B                
227B                ;-1022     if (Op == MEM) {
227B                
227B                .writeEA243:
227B A0 2D 01        mov al, [Op]
227E 3C 04           cmp al, 4
2280 0F 85 00 00   r jne .writeEA248
2284                
2284                ;-1023         if (isDirect) {
2284                
2284 A0 3C 01        mov al, [isDirect]
2287 08 C0           or  al, al
2289 0F 84 00 00   r je .writeEA249
228D                
228D                ;-1024             xxx |= 6;
228D                
228D 80 4E 04 06     or  byte[bp+4], 6
2291                
2291                ;-1025             len = 2;
2291                
2291 B8 02 00        mov ax, 2
2294 88 46 FE        mov [bp-2], al
2297                
2297                ;-1026         }
2297                
2297                
2297                ;-1027         else {
2297                
2297 E9 00 00      R jmp .writeEA250
229A                .writeEA249:
229A                
229A                ;-1028             xxx = xxx + rm;
229A                
229A 8A 46 04        mov al, [bp+4]
229D 02 06 3B 01     add al, [rm]
22A1 88 46 04        mov [bp+4], al
22A4                
22A4                ;-1029             if (rm == 6) {//make [BP+00]
22A4                
22A4 A0 3B 01        mov al, [rm]
22A7 3C 06           cmp al, 6
22A9 0F 85 00 00   r jne .writeEA251
22AD                
22AD                ;-1030                 len=1;
22AD                
22AD B8 01 00        mov ax, 1
22B0 88 46 FE        mov [bp-2], al
22B3                
22B3                ;-1031                 if (disp == 0) xxx |= 0x40;
22B3                
22B3 A1 3D 01        mov ax, [disp]
22B6 83 F8 00        cmp ax, 0
22B9 0F 85 00 00   r jne .writeEA252
22BD 80 4E 04 40     or  byte[bp+4], 64
22C1                
22C1                ;-1032             }
22C1                
22C1                .writeEA252:
22C1                
22C1                ;-1033 
22C1                
22C1                
22C1                ;-1034             if (disp) {
22C1                
22C1                .writeEA251:
22C1 A1 3D 01        mov ax, [disp]
22C4 08 C0           or  al, al
22C6 0F 84 00 00   r je .writeEA253
22CA                
22CA                ;-1035                 ax = disp;
22CA                
22CA A1 3D 01        mov  ax, [disp]
22CD                
22CD                ;-1036                 if(ax > 127) len=2;
22CD                
22CD 83 F8 7F        cmp  ax, 127
22D0 0F 8E 00 00   r jle .writeEA254
22D4 B8 02 00        mov ax, 2
22D7 88 46 FE        mov [bp-2], al
22DA                
22DA                ;-1037                 else len=1;
22DA                
22DA E9 00 00      R jmp .writeEA255
22DD                .writeEA254:
22DD B8 01 00        mov ax, 1
22E0 88 46 FE        mov [bp-2], al
22E3                
22E3                ;-1038                 if (len == 1) xxx |= 0x40;
22E3                
22E3                .writeEA255:
22E3 8A 46 FE        mov al, [bp-2]
22E6 3C 01           cmp al, 1
22E8 0F 85 00 00   r jne .writeEA256
22EC 80 4E 04 40     or  byte[bp+4], 64
22F0                
22F0                ;-1039                 else xxx |= 0x80;
22F0                
22F0 E9 00 00      R jmp .writeEA257
22F3                .writeEA256:
22F3 80 4E 04 80     or  byte[bp+4], 128
22F7                
22F7                ;-1040             }
22F7                
22F7                .writeEA257:
22F7                
22F7                ;-1041         }
22F7                
22F7                .writeEA253:
22F7                
22F7                ;-1042     }
22F7                
22F7                .writeEA250:
22F7                
22F7                ;-1043 
22F7                
22F7                
22F7                ;-1044     genCode8(xxx);// gen second byte
22F7                
22F7                .writeEA248:
22F7 8A 46 04        mov al, byte [bp+4]
22FA B4 00           mov ah, 0
22FC 50              push ax
22FD E8 88 FE        call genCode8
2300 83 C4 02        add  sp, 2
2303                
2303                ;-1045     if (len == 1) genCode8 (disp);
2303                
2303 8A 46 FE        mov al, [bp-2]
2306 3C 01           cmp al, 1
2308 0F 85 00 00   r jne .writeEA258
230C FF 36 3D 01     push word [disp]
2310 E8 75 FE        call genCode8
2313 83 C4 02        add  sp, 2
2316                
2316                ;-1046     if (len == 2) genCode16(disp);
2316                
2316                .writeEA258:
2316 8A 46 FE        mov al, [bp-2]
2319 3C 02           cmp al, 2
231B 0F 85 00 00   r jne .writeEA259
231F FF 36 3D 01     push word [disp]
2323 E8 B8 FE        call genCode16
2326 83 C4 02        add  sp, 2
2329                
2329                ;-1047 }
2329                
2329                .writeEA259:
2329                
2329                ;-1048 
2329                
2329                
2329                ;-1049 int genImmediate() {
2329 C9              LEAVE
232A C3              ret
;leaving: writeEA. loc labels:17,loc jmp forward:17
;jmp to fix:17
1. .writeEA243,from:223F,Label+ORG:237B,rel:003A
2. .writeEA244,from:224C,Label+ORG:235B,rel:000D
3. .writeEA245,from:2259,Label+ORG:237B,rel:0020
4. .writeEA246,from:2262,Label+ORG:2371,rel:000D
5. .writeEA247,from:226F,Label+ORG:237B,rel:000A
6. .writeEA248,from:2282,Label+ORG:23F7,rel:0073
7. .writeEA249,from:228B,Label+ORG:239A,rel:000D
8. .writeEA250,from:2298,Label+ORG:23F7,rel:005D
9. .writeEA251,from:22AB,Label+ORG:23C1,rel:0014
10. .writeEA252,from:22BB,Label+ORG:23C1,rel:0004
11. .writeEA253,from:22C8,Label+ORG:23F7,rel:002D
12. .writeEA254,from:22D2,Label+ORG:23DD,rel:0009
13. .writeEA255,from:22DB,Label+ORG:23E3,rel:0006
14. .writeEA256,from:22EA,Label+ORG:23F3,rel:0007
15. .writeEA257,from:22F1,Label+ORG:23F7,rel:0004
16. .writeEA258,from:230A,Label+ORG:2416,rel:000A
17. .writeEA259,from:231D,Label+ORG:2429,rel:000A
232B                ENDP
232B                
;entering: genImmediate
232B                genImmediate: PROC
232B                
232B                ;-1050     if (wflag) if (OpSize == DWORD) genCode32(imme);//todo imme long
232B                
232B A0 38 01        mov al, [wflag]
232E 08 C0           or  al, al
2330 0F 84 00 00   r je .genImmediate260
2334 A0 37 01        mov al, [OpSize]
2337 3C 03           cmp al, 3
2339 0F 85 00 00   r jne .genImmediate261
233D FF 36 3F 01     push word [imme]
2341 E8 B7 FE        call genCode32
2344 83 C4 02        add  sp, 2
2347                
2347                ;-1051         else genCode16(imme);
2347                
2347 E9 00 00      R jmp .genImmediate262
234A                .genImmediate261:
234A FF 36 3F 01     push word [imme]
234E E8 8D FE        call genCode16
2351 83 C4 02        add  sp, 2
2354                
2354                ;-1052     else       genCode8 (imme);
2354                
2354                .genImmediate262:
2354 E9 00 00      R jmp .genImmediate263
2357                .genImmediate260:
2357 FF 36 3F 01     push word [imme]
235B E8 2A FE        call genCode8
235E 83 C4 02        add  sp, 2
2361                
2361                ;-1053 }
2361                
2361                .genImmediate263:
2361                
2361                ;-1054 
2361                
2361                
2361                ;-1055 //AS.C
2361                
2361                
2361                ;-1056 int process() {
2361                
2361 C3              ret
;leaving: genImmediate. loc labels:4,loc jmp forward:4
;jmp to fix:4
1. .genImmediate260,from:2332,Label+ORG:2457,rel:0023
2. .genImmediate261,from:233B,Label+ORG:244A,rel:000D
3. .genImmediate262,from:2348,Label+ORG:2454,rel:000A
4. .genImmediate263,from:2355,Label+ORG:2461,rel:000A
2362                ENDP
2362                
;entering: process
2362                process: PROC
2362                
2362                ;-1057     char c;
2362                
2362                
2362                ;-1058     int i;
2362                
2362                
2362                ;-1059     Op=Op2=R1Type=R2Type=R1No=R2No=dflag=wflag=rm=0;//char
2362                
2362                ;Function : process, Number of local variables: 2
2362                ;   # type sign width addr used name   list of local variables
2362                ;  200 var sign byte  1057 NULL c = bp-2
2362                ;  201 var sign word  1058 NULL i = bp-4;
2362 C8 04 00 00     ENTER  4,0
2366 B8 00 00        mov ax, 0
2369 A2 3B 01        mov byte [rm], al
236C A2 38 01        mov byte [wflag], al
236F A2 39 01        mov byte [dflag], al
2372 A2 33 01        mov byte [R2No], al
2375 A2 34 01        mov byte [R1No], al
2378 A2 35 01        mov byte [R2Type], al
237B A2 36 01        mov byte [R1Type], al
237E A2 2E 01        mov byte [Op2], al
2381 A2 2D 01        mov byte [Op], al
2384                
2384                ;-1060     disp=imme=0;//int
2384                
2384 B8 00 00        mov ax, 0
2387 A3 3F 01        mov word [imme], ax
238A A3 3D 01        mov word [disp], ax
238D                
238D                ;-1061     isDirect=1; //set in getMeM=0, need in WriteEA
238D                
238D B8 01 00        mov ax, 1
2390 A2 3C 01        mov byte [isDirect], al
2393                
2393                ;-1062     getTokeType();//0, DIGIT, ALNUME, NOALNUME
2393                
2393 E8 A9 F4        call getTokeType
2396                
2396                ;-1063     OpSize=getCodeSize();//0, BYTE, WORD, DWORD
2396                
2396 E8 35 F8        call getCodeSize
2399 A2 37 01        mov byte [OpSize], al
239C                
239C                ;-1064     getCodes();//set: Code1, Code2, Code3
239C                
239C E8 7B FD        call getCodes
239F                
239F                ;-1065 
239F                
239F                
239F                ;-1066     if (CodeType ==  1) {//1 byte opcode
239F                
239F A0 2F 01        mov al, [CodeType]
23A2 3C 01           cmp al, 1
23A4 0F 85 00 00   r jne .process264
23A8                
23A8                ;-1067         genCode8(Code1);
23A8                
23A8 A0 30 01        mov al, byte [Code1]
23AB B4 00           mov ah, 0
23AD 50              push ax
23AE E8 D7 FD        call genCode8
23B1 83 C4 02        add  sp, 2
23B4                
23B4                ;-1068         return;
23B4                
23B4 E9 00 00      R jmp .retnprocess
23B7                
23B7                ;-1069     }
23B7                
23B7                
23B7                ;-1070 
23B7                
23B7                
23B7                ;-1071     if (CodeType ==  2) {//inc,dec,not,neg,mul,imul,div,idiv
23B7                
23B7                .process264:
23B7 A0 2F 01        mov al, [CodeType]
23BA 3C 02           cmp al, 2
23BC 0F 85 00 00   r jne .process265
23C0                
23C0                ;-1072         getOpL();
23C0                
23C0 E8 A9 EF        call getOpL
23C3                
23C3                ;-1073         checkOpL();
23C3                
23C3 E8 C9 EE        call checkOpL
23C6                
23C6                ;-1074         if (Code2 <= 1) {//inc,dec
23C6                
23C6 A0 31 01        mov al, [Code2]
23C9 3C 01           cmp al, 1
23CB 0F 8F 00 00   r jg  .process266
23CF                
23CF                ;-1075   	        if (Op == REG) {//short
23CF                
23CF A0 2D 01        mov al, [Op]
23D2 3C 02           cmp al, 2
23D4 0F 85 00 00   r jne .process267
23D8                
23D8                ;-1076                 if (wflag) {genCode2(Code3, R1No); return; }
23D8                
23D8 A0 38 01        mov al, [wflag]
23DB 08 C0           or  al, al
23DD 0F 84 00 00   r je .process268
23E1 A0 34 01        mov al, byte [R1No]
23E4 B4 00           mov ah, 0
23E6 50              push ax
23E7 A0 32 01        mov al, byte [Code3]
23EA B4 00           mov ah, 0
23EC 50              push ax
23ED E8 61 FD        call genCode2
23F0 83 C4 04        add  sp, 4
23F3 E9 00 00      R jmp .retnprocess
23F6                
23F6                ;-1077             }
23F6                
23F6                .process268:
23F6                
23F6                ;-1078         }
23F6                
23F6                .process267:
23F6                
23F6                ;-1079         if (Code2 == 5) {//imul extension?
23F6                
23F6                .process266:
23F6 A0 31 01        mov al, [Code2]
23F9 3C 05           cmp al, 5
23FB 0F 85 00 00   r jne .process269
23FF                
23FF                ;-1080             getTokeType();
23FF                
23FF E8 3D F4        call getTokeType
2402                
2402                ;-1081             if (TokeType) implerror();
2402                
2402 A0 2C 01        mov al, [TokeType]
2405 08 C0           or  al, al
2407 0F 84 00 00   r je .process270
240B E8 54 E8        call implerror
240E                
240E                ;-1082         }
240E                
240E                .process270:
240E                
240E                ;-1083         genCodeW(Code1);
240E                
240E                .process269:
240E A0 30 01        mov al, byte [Code1]
2411 B4 00           mov ah, 0
2413 50              push ax
2414 E8 55 FD        call genCodeW
2417 83 C4 02        add  sp, 2
241A                
241A                ;-1084         writeEA(Code2);
241A                
241A A0 31 01        mov al, byte [Code2]
241D B4 00           mov ah, 0
241F 50              push ax
2420 E8 02 FE        call writeEA
2423 83 C4 02        add  sp, 2
2426                
2426                ;-1085         return;
2426                
2426 E9 00 00      R jmp .retnprocess
2429                
2429                ;-1086     }
2429                
2429                
2429                ;-1087 
2429                
2429                
2429                ;-1088     if (CodeType == 3) {//les,lds,lea,lss,lfs,lgs
2429                
2429                .process265:
2429 A0 2F 01        mov al, [CodeType]
242C 3C 03           cmp al, 3
242E 0F 85 00 00   r jne .process271
2432                
2432                ;-1089         check2Ops();    //setwflag not applicable
2432                
2432 E8 DC EE        call check2Ops
2435                
2435                ;-1090         if (R1Type != WORD) reg16error();//only r16
2435                
2435 A0 36 01        mov al, [R1Type]
2438 3C 02           cmp al, 2
243A 0F 84 00 00   r je  .process272
243E E8 C1 E8        call reg16error
2441                
2441                ;-1091         if (Op2 != MEM) addrerror();//only m16
2441                
2441                .process272:
2441 A0 2E 01        mov al, [Op2]
2444 3C 04           cmp al, 4
2446 0F 84 00 00   r je  .process273
244A E8 D6 E7        call addrerror
244D                
244D                ;-1092 
244D                
244D                
244D                ;-1093         genCode8(Code1);//les,lds,lea
244D                
244D                .process273:
244D A0 30 01        mov al, byte [Code1]
2450 B4 00           mov ah, 0
2452 50              push ax
2453 E8 32 FD        call genCode8
2456 83 C4 02        add  sp, 2
2459                
2459                ;-1094         if (Code1 == 0x0F) genCode8(Code2);//lss,lfs,lgs
2459                
2459 A0 30 01        mov al, [Code1]
245C 3C 0F           cmp al, 15
245E 0F 85 00 00   r jne .process274
2462 A0 31 01        mov al, byte [Code2]
2465 B4 00           mov ah, 0
2467 50              push ax
2468 E8 1D FD        call genCode8
246B 83 C4 02        add  sp, 2
246E                
246E                ;-1095         Op=Op2;//set MEM for writeEA
246E                
246E                .process274:
246E A0 2E 01        mov al, [Op2]
2471 A2 2D 01        mov byte [Op], al
2474                
2474                ;-1096         writeEA(R1No);
2474                
2474 A0 34 01        mov al, byte [R1No]
2477 B4 00           mov ah, 0
2479 50              push ax
247A E8 A8 FD        call writeEA
247D 83 C4 02        add  sp, 2
2480                
2480                ;-1097         return;
2480                
2480 E9 00 00      R jmp .retnprocess
2483                
2483                ;-1098     }
2483                
2483                
2483                ;-1099 
2483                
2483                
2483                ;-1100     if (CodeType == 4) {//add,or,adc,sbb,and,sub,xor,cmp,->test
2483                
2483                .process271:
2483 A0 2F 01        mov al, [CodeType]
2486 3C 04           cmp al, 4
2488 0F 85 00 00   r jne .process275
248C                
248C                ;-1101         check2Ops();
248C                
248C E8 82 EE        call check2Ops
248F                
248F                ;-1102         if (Op2 == IMM) {//second operand is imm
248F                
248F A0 2E 01        mov al, [Op2]
2492 3C 01           cmp al, 1
2494 0F 85 00 00   r jne .process276
2498                
2498                ;-1103             setsflag();
2498                
2498 E8 03 F2        call setsflag
249B                
249B                ;-1104             if (Op == REG) {
249B                
249B A0 2D 01        mov al, [Op]
249E 3C 02           cmp al, 2
24A0 0F 85 00 00   r jne .process277
24A4                
24A4                ;-1105                 if (R1No == 0) {// acc,imm
24A4                
24A4 A0 34 01        mov al, [R1No]
24A7 3C 00           cmp al, 0
24A9 0F 85 00 00   r jne .process278
24AD                
24AD                ;-1106                     if (sflag == 0) {
24AD                
24AD A0 3A 01        mov al, [sflag]
24B0 3C 00           cmp al, 0
24B2 0F 85 00 00   r jne .process279
24B6                
24B6                ;-1107                         c = Code1 << 3;
24B6                
24B6 A0 30 01        mov al, [Code1]
24B9 C0 E0 03        shl al, 3
24BC 88 46 FE        mov [bp-2], al
24BF                
24BF                ;-1108                         c += 4;
24BF                
24BF 80 46 FE 04     add  byte[bp-2], 4
24C3                
24C3                ;-1109                         genCodeW(c);
24C3                
24C3 8A 46 FE        mov al, byte [bp-2]
24C6 B4 00           mov ah, 0
24C8 50              push ax
24C9 E8 A0 FC        call genCodeW
24CC 83 C4 02        add  sp, 2
24CF                
24CF                ;-1110                         genImmediate();
24CF                
24CF E8 59 FE        call genImmediate
24D2                
24D2                ;-1111                         return;
24D2                
24D2 E9 00 00      R jmp .retnprocess
24D5                
24D5                ;-1112                     }
24D5                
24D5                
24D5                ;-1113                 }
24D5                
24D5                .process279:
24D5                
24D5                ;-1114             }
24D5                
24D5                .process278:
24D5                
24D5                ;-1115             //r/m, imm: 80 sign-extended,TTT,imm
24D5                
24D5                
24D5                ;-1116             c = sflag + 0x80;
24D5                
24D5                .process277:
24D5 A0 3A 01        mov al, [sflag]
24D8 04 80           add al, 128
24DA 88 46 FE        mov [bp-2], al
24DD                
24DD                ;-1117             genCodeW(c);
24DD                
24DD 8A 46 FE        mov al, byte [bp-2]
24E0 B4 00           mov ah, 0
24E2 50              push ax
24E3 E8 86 FC        call genCodeW
24E6 83 C4 02        add  sp, 2
24E9                
24E9                ;-1118             writeEA(Code1);
24E9                
24E9 A0 30 01        mov al, byte [Code1]
24EC B4 00           mov ah, 0
24EE 50              push ax
24EF E8 33 FD        call writeEA
24F2 83 C4 02        add  sp, 2
24F5                
24F5                ;-1119             if (sflag) genCode8(imme);
24F5                
24F5 A0 3A 01        mov al, [sflag]
24F8 08 C0           or  al, al
24FA 0F 84 00 00   r je .process280
24FE FF 36 3F 01     push word [imme]
2502 E8 83 FC        call genCode8
2505 83 C4 02        add  sp, 2
2508                
2508                ;-1120             else genImmediate();
2508                
2508 E9 00 00      R jmp .process281
250B                .process280:
250B E8 1D FE        call genImmediate
250E                
250E                ;-1121             return;
250E                
250E                .process281:
250E E9 00 00      R jmp .retnprocess
2511                
2511                ;-1122         }
2511                
2511                
2511                ;-1123         c = Code1 << 3;//r/m, r/r
2511                
2511                .process276:
2511 A0 30 01        mov al, [Code1]
2514 C0 E0 03        shl al, 3
2517 88 46 FE        mov [bp-2], al
251A                
251A                ;-1124         if (Op == REG) {
251A                
251A A0 2D 01        mov al, [Op]
251D 3C 02           cmp al, 2
251F 0F 85 00 00   r jne .process282
2523                
2523                ;-1125             if (Op2 == MEM) {//reg, mem
2523                
2523 A0 2E 01        mov al, [Op2]
2526 3C 04           cmp al, 4
2528 0F 85 00 00   r jne .process283
252C                
252C                ;-1126                 c += 2;//add direction flag
252C                
252C 80 46 FE 02     add  byte[bp-2], 2
2530                
2530                ;-1127                 genCodeW(c);
2530                
2530 8A 46 FE        mov al, byte [bp-2]
2533 B4 00           mov ah, 0
2535 50              push ax
2536 E8 33 FC        call genCodeW
2539 83 C4 02        add  sp, 2
253C                
253C                ;-1128                 Op=Op2;//set MEM for writeEA
253C                
253C A0 2E 01        mov al, [Op2]
253F A2 2D 01        mov byte [Op], al
2542                
2542                ;-1129                 writeEA(R1No);
2542                
2542 A0 34 01        mov al, byte [R1No]
2545 B4 00           mov ah, 0
2547 50              push ax
2548 E8 DA FC        call writeEA
254B 83 C4 02        add  sp, 2
254E                
254E                ;-1130                 return;
254E                
254E E9 00 00      R jmp .retnprocess
2551                
2551                ;-1131             }
2551                
2551                
2551                ;-1132         }
2551                
2551                .process283:
2551                
2551                ;-1133         if (Op2 == REG) {//mem,reg    reg,reg
2551                
2551                .process282:
2551 A0 2E 01        mov al, [Op2]
2554 3C 02           cmp al, 2
2556 0F 85 00 00   r jne .process284
255A                
255A                ;-1134             genCodeW(c);
255A                
255A 8A 46 FE        mov al, byte [bp-2]
255D B4 00           mov ah, 0
255F 50              push ax
2560 E8 09 FC        call genCodeW
2563 83 C4 02        add  sp, 2
2566                
2566                ;-1135             writeEA(R2No);//2. Op in reg-field
2566                
2566 A0 33 01        mov al, byte [R2No]
2569 B4 00           mov ah, 0
256B 50              push ax
256C E8 B6 FC        call writeEA
256F 83 C4 02        add  sp, 2
2572                
2572                ;-1136             return;
2572                
2572 E9 00 00      R jmp .retnprocess
2575                
2575                ;-1137         }
2575                
2575                
2575                ;-1138         syntaxerror();
2575                
2575                .process284:
2575 E8 D9 E7        call syntaxerror
2578                
2578                ;-1139         return;
2578                
2578 E9 00 00      R jmp .retnprocess
257B                
257B                ;-1140     }
257B                
257B                
257B                ;-1141 
257B                
257B                
257B                ;-1142     if (CodeType == 5) {//mov (movsx, movzx=51)
257B                
257B                .process275:
257B A0 2F 01        mov al, [CodeType]
257E 3C 05           cmp al, 5
2580 0F 85 00 00   r jne .process285
2584                
2584                ;-1143         check2Ops();
2584                
2584 E8 8A ED        call check2Ops
2587                
2587                ;-1144 /*    prs("\n Op:"); printhex8a(Op);
2587                
2587                
2587                ;-1145     prs(", Op2:"); printhex8a(Op2);
2587                
2587                
2587                ;-1146     prs(", R1No:"); printhex8a(R1No);
2587                
2587                
2587                ;-1147     prs(", R2No:"); printhex8a(R2No);   */
2587                
2587                
2587                ;-1148         if (Op2 == ADR) {
2587                
2587 A0 2E 01        mov al, [Op2]
258A 3C 03           cmp al, 3
258C 0F 85 00 00   r jne .process286
2590                
2590                ;-1149             if (disp) imme=disp;
2590                
2590 A1 3D 01        mov ax, [disp]
2593 08 C0           or  al, al
2595 0F 84 00 00   r je .process287
2599 A1 3D 01        mov ax, [disp]
259C A3 3F 01        mov word [imme], ax
259F                
259F                ;-1150             else notfounderror();
259F                
259F E9 00 00      R jmp .process288
25A2                .process287:
25A2 E8 28 E6        call notfounderror
25A5                
25A5                ;-1151             Op2=IMM;//continue with IMM
25A5                
25A5                .process288:
25A5 B8 01 00        mov ax, 1
25A8 A2 2E 01        mov byte [Op2], al
25AB                
25AB                ;-1152         }
25AB                
25AB                
25AB                ;-1153         if (Op2 == IMM) {// r,i
25AB                
25AB                .process286:
25AB A0 2E 01        mov al, [Op2]
25AE 3C 01           cmp al, 1
25B0 0F 85 00 00   r jne .process289
25B4                
25B4                ;-1154             if (Op == REG) {
25B4                
25B4 A0 2D 01        mov al, [Op]
25B7 3C 02           cmp al, 2
25B9 0F 85 00 00   r jne .process290
25BD                
25BD                ;-1155                 c = wflag << 3;
25BD                
25BD A0 38 01        mov al, [wflag]
25C0 C0 E0 03        shl al, 3
25C3 88 46 FE        mov [bp-2], al
25C6                
25C6                ;-1156                 c += 0xB0;
25C6                
25C6 80 46 FE B0     add  byte[bp-2], 176
25CA                
25CA                ;-1157                 genCode2(c, R1No);
25CA                
25CA A0 34 01        mov al, byte [R1No]
25CD B4 00           mov ah, 0
25CF 50              push ax
25D0 8A 46 FE        mov al, byte [bp-2]
25D3 B4 00           mov ah, 0
25D5 50              push ax
25D6 E8 78 FB        call genCode2
25D9 83 C4 04        add  sp, 4
25DC                
25DC                ;-1158                 genImmediate();
25DC                
25DC E8 4C FD        call genImmediate
25DF                
25DF                ;-1159                 return;
25DF                
25DF E9 00 00      R jmp .retnprocess
25E2                
25E2                ;-1160             }
25E2                
25E2                
25E2                ;-1161             if (Op == MEM) {// m,i
25E2                
25E2                .process290:
25E2 A0 2D 01        mov al, [Op]
25E5 3C 04           cmp al, 4
25E7 0F 85 00 00   r jne .process291
25EB                
25EB                ;-1162                 genCodeW(0xC6);
25EB                
25EB 68 C6 00        push 198
25EE E8 7B FB        call genCodeW
25F1 83 C4 02        add  sp, 2
25F4                
25F4                ;-1163                 writeEA( 0 );
25F4                
25F4 6A 00           push 0
25F6 E8 2C FC        call writeEA
25F9 83 C4 02        add  sp, 2
25FC                
25FC                ;-1164                 genImmediate();
25FC                
25FC E8 2C FD        call genImmediate
25FF                
25FF                ;-1165                 return;
25FF                
25FF E9 00 00      R jmp .retnprocess
2602                
2602                ;-1166             }
2602                
2602                
2602                ;-1167             regmemerror();
2602                
2602                .process291:
2602 E8 D3 E6        call regmemerror
2605                
2605                ;-1168             return;
2605                
2605 E9 00 00      R jmp .retnprocess
2608                
2608                ;-1169         }
2608                
2608                
2608                ;-1170         if (R1Type == SEGREG) ChangeDirection();//sreg,rm
2608                
2608                .process289:
2608 A0 36 01        mov al, [R1Type]
260B 3C 04           cmp al, 4
260D 0F 85 00 00   r jne .process292
2611 E8 39 EC        call ChangeDirection
2614                
2614                ;-1171         if (R2Type == SEGREG) {//rm,sreg
2614                
2614                .process292:
2614 A0 35 01        mov al, [R2Type]
2617 3C 04           cmp al, 4
2619 0F 85 00 00   r jne .process293
261D                
261D                ;-1172             if (OpSize != WORD) reg16error();
261D                
261D A0 37 01        mov al, [OpSize]
2620 3C 02           cmp al, 2
2622 0F 84 00 00   r je  .process294
2626 E8 D9 E6        call reg16error
2629                
2629                ;-1173                 genCode2(0x8C, dflag);
2629                
2629                .process294:
2629 A0 39 01        mov al, byte [dflag]
262C B4 00           mov ah, 0
262E 50              push ax
262F 68 8C 00        push 140
2632 E8 1C FB        call genCode2
2635 83 C4 04        add  sp, 4
2638                
2638                ;-1174                 writeEA(R2No);
2638                
2638 A0 33 01        mov al, byte [R2No]
263B B4 00           mov ah, 0
263D 50              push ax
263E E8 E4 FB        call writeEA
2641 83 C4 02        add  sp, 2
2644                
2644                ;-1175                 return;
2644                
2644 E9 00 00      R jmp .retnprocess
2647                
2647                ;-1176         }
2647                
2647                
2647                ;-1177         if (Op2 == MEM) {//acc, moffs16
2647                
2647                .process293:
2647 A0 2E 01        mov al, [Op2]
264A 3C 04           cmp al, 4
264C 0F 85 00 00   r jne .process295
2650                
2650                ;-1178             if (Op == REG) {
2650                
2650 A0 2D 01        mov al, [Op]
2653 3C 02           cmp al, 2
2655 0F 85 00 00   r jne .process296
2659                
2659                ;-1179                 if (R1No == 0) {
2659                
2659 A0 34 01        mov al, [R1No]
265C 3C 00           cmp al, 0
265E 0F 85 00 00   r jne .process297
2662                
2662                ;-1180                     if (isDirect) {
2662                
2662 A0 3C 01        mov al, [isDirect]
2665 08 C0           or  al, al
2667 0F 84 00 00   r je .process298
266B                
266B                ;-1181                         genCodeW(0xA0);
266B                
266B 68 A0 00        push 160
266E E8 FB FA        call genCodeW
2671 83 C4 02        add  sp, 2
2674                
2674                ;-1182                         genCode16(disp);
2674                
2674 FF 36 3D 01     push word [disp]
2678 E8 63 FB        call genCode16
267B 83 C4 02        add  sp, 2
267E                
267E                ;-1183                         return;
267E                
267E E9 00 00      R jmp .retnprocess
2681                
2681                ;-1184                     }
2681                
2681                
2681                ;-1185                 }
2681                
2681                .process298:
2681                
2681                ;-1186             }
2681                
2681                .process297:
2681                
2681                ;-1187         }
2681                
2681                .process296:
2681                
2681                ;-1188         if (Op == MEM) {//moffs16, acc
2681                
2681                .process295:
2681 A0 2D 01        mov al, [Op]
2684 3C 04           cmp al, 4
2686 0F 85 00 00   r jne .process299
268A                
268A                ;-1189             if (Op2 == REG) {
268A                
268A A0 2E 01        mov al, [Op2]
268D 3C 02           cmp al, 2
268F 0F 85 00 00   r jne .process300
2693                
2693                ;-1190                 if (R2No == 0) {
2693                
2693 A0 33 01        mov al, [R2No]
2696 3C 00           cmp al, 0
2698 0F 85 00 00   r jne .process301
269C                
269C                ;-1191                     if (isDirect) {
269C                
269C A0 3C 01        mov al, [isDirect]
269F 08 C0           or  al, al
26A1 0F 84 00 00   r je .process302
26A5                
26A5                ;-1192                         genCodeW(0xA2);
26A5                
26A5 68 A2 00        push 162
26A8 E8 C1 FA        call genCodeW
26AB 83 C4 02        add  sp, 2
26AE                
26AE                ;-1193                         genCode16(disp);
26AE                
26AE FF 36 3D 01     push word [disp]
26B2 E8 29 FB        call genCode16
26B5 83 C4 02        add  sp, 2
26B8                
26B8                ;-1194                         return;
26B8                
26B8 E9 00 00      R jmp .retnprocess
26BB                
26BB                ;-1195                     }
26BB                
26BB                
26BB                ;-1196                 }
26BB                
26BB                .process302:
26BB                
26BB                ;-1197             }
26BB                
26BB                .process301:
26BB                
26BB                ;-1198 
26BB                
26BB                
26BB                ;-1199         }
26BB                
26BB                .process300:
26BB                
26BB                ;-1200         if (Op2 == REG) {//rm, r
26BB                
26BB                .process299:
26BB A0 2E 01        mov al, [Op2]
26BE 3C 02           cmp al, 2
26C0 0F 85 00 00   r jne .process303
26C4                
26C4                ;-1201             genCodeW(0x88);
26C4                
26C4 68 88 00        push 136
26C7 E8 A2 FA        call genCodeW
26CA 83 C4 02        add  sp, 2
26CD                
26CD                ;-1202             writeEA(R2No);
26CD                
26CD A0 33 01        mov al, byte [R2No]
26D0 B4 00           mov ah, 0
26D2 50              push ax
26D3 E8 4F FB        call writeEA
26D6 83 C4 02        add  sp, 2
26D9                
26D9                ;-1203             return;
26D9                
26D9 E9 00 00      R jmp .retnprocess
26DC                
26DC                ;-1204         }
26DC                
26DC                
26DC                ;-1205         if (Op2 == MEM) {//r, m
26DC                
26DC                .process303:
26DC A0 2E 01        mov al, [Op2]
26DF 3C 04           cmp al, 4
26E1 0F 85 00 00   r jne .process304
26E5                
26E5                ;-1206             if (Op == REG) {
26E5                
26E5 A0 2D 01        mov al, [Op]
26E8 3C 02           cmp al, 2
26EA 0F 85 00 00   r jne .process305
26EE                
26EE                ;-1207                 ChangeDirection();
26EE                
26EE E8 5C EB        call ChangeDirection
26F1                
26F1                ;-1208                 genCodeW(0x8A);
26F1                
26F1 68 8A 00        push 138
26F4 E8 75 FA        call genCodeW
26F7 83 C4 02        add  sp, 2
26FA                
26FA                ;-1209                 writeEA(R2No);
26FA                
26FA A0 33 01        mov al, byte [R2No]
26FD B4 00           mov ah, 0
26FF 50              push ax
2700 E8 22 FB        call writeEA
2703 83 C4 02        add  sp, 2
2706                
2706                ;-1210                 return;
2706                
2706 E9 00 00      R jmp .retnprocess
2709                
2709                ;-1211             }
2709                
2709                
2709                ;-1212         }
2709                
2709                .process305:
2709                
2709                ;-1213         syntaxerror();
2709                
2709                .process304:
2709 E8 45 E6        call syntaxerror
270C                
270C                ;-1214         return;
270C                
270C E9 00 00      R jmp .retnprocess
270F                
270F                ;-1215     }
270F                
270F                
270F                ;-1216 
270F                
270F                
270F                ;-1217     if (CodeType == 6) {//Jcc
270F                
270F                .process285:
270F A0 2F 01        mov al, [CodeType]
2712 3C 06           cmp al, 6
2714 0F 85 00 00   r jne .process306
2718                
2718                ;-1218         if (TokeType == ALNUME) {
2718                
2718 A0 2C 01        mov al, [TokeType]
271B 3C 03           cmp al, 3
271D 0F 85 00 00   r jne .process307
2721                
2721                ;-1219             LabelIx=searchLabel();
2721                
2721 E8 C2 F2        call searchLabel
2724 A3 4E 01        mov word [LabelIx], ax
2727                
2727                ;-1220             if (LabelIx > 0) {
2727                
2727 A1 4E 01        mov ax, [LabelIx]
272A 83 F8 00        cmp ax, 0
272D 0F 8E 00 00   r jle .process308
2731                
2731                ;-1221                 disp=LabelAddr[LabelIx];
2731                
2731 8B 1E 4E 01     mov bx, [LabelIx]
2735 D1 E3           shl bx, 1
2737 8B 47 CA        mov ax, [LabelAddr + bx]
273A A3 3D 01        mov word [disp], ax
273D                
273D                ;-1222                 disp = disp - PC;
273D                
273D A1 3D 01        mov ax, [disp]
2740 2B 06 23 01     sub ax, [PC]
2744 A3 3D 01        mov word [disp], ax
2747                
2747                ;-1223                 disp = disp - Origin;
2747                
2747 A1 3D 01        mov ax, [disp]
274A 2B 06 25 01     sub ax, [Origin]
274E A3 3D 01        mov word [disp], ax
2751                
2751                ;-1224                 if (checkConstSize(disp) ) {
2751                
2751 FF 36 3D 01     push word [disp]
2755 E8 A2 EF        call checkConstSize
2758 83 C4 02        add  sp, 2
275B 08 C0           or  al, al
275D 0F 84 00 00   r je .process309
2761                
2761                ;-1225                     genCode2(Code1, 0x70);//short
2761                
2761 6A 70           push 112
2763 A0 30 01        mov al, byte [Code1]
2766 B4 00           mov ah, 0
2768 50              push ax
2769 E8 E5 F9        call genCode2
276C 83 C4 04        add  sp, 4
276F                
276F                ;-1226                     disp -= 2;
276F                
276F 83 2E 3D 01 02  sub  word[disp], 2
2774                
2774                ;-1227                     genCode8(disp);
2774                
2774 FF 36 3D 01     push word [disp]
2778 E8 0D FA        call genCode8
277B 83 C4 02        add  sp, 2
277E                
277E                ;-1228                 } else {
277E                
277E E9 00 00      R jmp .process310
2781                .process309:
2781                
2781                ;-1229                     genCode8(0x0F);
2781                
2781 6A 0F           push 15
2783 E8 02 FA        call genCode8
2786 83 C4 02        add  sp, 2
2789                
2789                ;-1230                     genCode2(Code1, 0x80);//near
2789                
2789 68 80 00        push 128
278C A0 30 01        mov al, byte [Code1]
278F B4 00           mov ah, 0
2791 50              push ax
2792 E8 BC F9        call genCode2
2795 83 C4 04        add  sp, 4
2798                
2798                ;-1231                     disp -= 4;
2798                
2798 83 2E 3D 01 04  sub  word[disp], 4
279D                
279D                ;-1232                     genCode16(disp);
279D                
279D FF 36 3D 01     push word [disp]
27A1 E8 3A FA        call genCode16
27A4 83 C4 02        add  sp, 2
27A7                
27A7                ;-1233                 }
27A7                
27A7                
27A7                ;-1234             }
27A7                
27A7                .process310:
27A7                
27A7                ;-1235             else {//jump forward, near only
27A7                
27A7 E9 00 00      R jmp .process311
27AA                .process308:
27AA                
27AA                ;-1236                 genCode8(0x0F);
27AA                
27AA 6A 0F           push 15
27AC E8 D9 F9        call genCode8
27AF 83 C4 02        add  sp, 2
27B2                
27B2                ;-1237                 genCode2(Code1, 0x80);
27B2                
27B2 68 80 00        push 128
27B5 A0 30 01        mov al, byte [Code1]
27B8 B4 00           mov ah, 0
27BA 50              push ax
27BB E8 93 F9        call genCode2
27BE 83 C4 04        add  sp, 4
27C1                
27C1                ;-1238                 storeJmp();
27C1                
27C1 E8 07 F1        call storeJmp
27C4                
27C4                ;-1239                 genCode16(0);
27C4                
27C4 6A 00           push 0
27C6 E8 15 FA        call genCode16
27C9 83 C4 02        add  sp, 2
27CC                
27CC                ;-1240                 PrintRA='r';
27CC                
27CC B8 72 00        mov ax, 114
27CF A2 45 01        mov byte [PrintRA], al
27D2                
27D2                ;-1241             }
27D2                
27D2                
27D2                ;-1242         return;
27D2                
27D2                .process311:
27D2 E9 00 00      R jmp .retnprocess
27D5                
27D5                ;-1243         }
27D5                
27D5                
27D5                ;-1244     }
27D5                
27D5                .process307:
27D5                
27D5                ;-1245 
27D5                
27D5                
27D5                ;-1246     if (CodeType == 7) {//jmp, call
27D5                
27D5                .process306:
27D5 A0 2F 01        mov al, [CodeType]
27D8 3C 07           cmp al, 7
27DA 0F 85 00 00   r jne .process312
27DE                
27DE                ;-1247         if (TokeType == ALNUME) {
27DE                
27DE A0 2C 01        mov al, [TokeType]
27E1 3C 03           cmp al, 3
27E3 0F 85 00 00   r jne .process313
27E7                
27E7                ;-1248             LabelIx=searchLabel();
27E7                
27E7 E8 FC F1        call searchLabel
27EA A3 4E 01        mov word [LabelIx], ax
27ED                
27ED                ;-1249             if (LabelIx > 0) {
27ED                
27ED A1 4E 01        mov ax, [LabelIx]
27F0 83 F8 00        cmp ax, 0
27F3 0F 8E 00 00   r jle .process314
27F7                
27F7                ;-1250                 disp=LabelAddr[LabelIx];
27F7                
27F7 8B 1E 4E 01     mov bx, [LabelIx]
27FB D1 E3           shl bx, 1
27FD 8B 47 CA        mov ax, [LabelAddr + bx]
2800 A3 3D 01        mov word [disp], ax
2803                
2803                ;-1251                 disp = disp - PC;
2803                
2803 A1 3D 01        mov ax, [disp]
2806 2B 06 23 01     sub ax, [PC]
280A A3 3D 01        mov word [disp], ax
280D                
280D                ;-1252                 disp = disp - Origin;
280D                
280D A1 3D 01        mov ax, [disp]
2810 2B 06 25 01     sub ax, [Origin]
2814 A3 3D 01        mov word [disp], ax
2817                
2817                ;-1253                 if (checkConstSize(disp) ) {
2817                
2817 FF 36 3D 01     push word [disp]
281B E8 DC EE        call checkConstSize
281E 83 C4 02        add  sp, 2
2821 08 C0           or  al, al
2823 0F 84 00 00   r je .process315
2827                
2827                ;-1254                     if (Code1 == 0xE9) {//jmp only
2827                
2827 A0 30 01        mov al, [Code1]
282A 3C E9           cmp al, 233
282C 0F 85 00 00   r jne .process316
2830                
2830                ;-1255                         genCode8(0xEB);//short
2830                
2830 68 EB 00        push 235
2833 E8 52 F9        call genCode8
2836 83 C4 02        add  sp, 2
2839                
2839                ;-1256                         disp -= 2;
2839                
2839 83 2E 3D 01 02  sub  word[disp], 2
283E                
283E                ;-1257                         genCode8(disp);
283E                
283E FF 36 3D 01     push word [disp]
2842 E8 43 F9        call genCode8
2845 83 C4 02        add  sp, 2
2848                
2848                ;-1258                     }
2848                
2848                
2848                ;-1259                     else {
2848                
2848 E9 00 00      R jmp .process317
284B                .process316:
284B                
284B                ;-1260                         genCode8(Code1);//near
284B                
284B A0 30 01        mov al, byte [Code1]
284E B4 00           mov ah, 0
2850 50              push ax
2851 E8 34 F9        call genCode8
2854 83 C4 02        add  sp, 2
2857                
2857                ;-1261                         disp -= 3;
2857                
2857 83 2E 3D 01 03  sub  word[disp], 3
285C                
285C                ;-1262                         genCode16(disp);
285C                
285C FF 36 3D 01     push word [disp]
2860 E8 7B F9        call genCode16
2863 83 C4 02        add  sp, 2
2866                
2866                ;-1263                     }
2866                
2866                
2866                ;-1264                 }
2866                
2866                .process317:
2866                
2866                ;-1265                 else {
2866                
2866 E9 00 00      R jmp .process318
2869                .process315:
2869                
2869                ;-1266                     genCode8(Code1);//near
2869                
2869 A0 30 01        mov al, byte [Code1]
286C B4 00           mov ah, 0
286E 50              push ax
286F E8 16 F9        call genCode8
2872 83 C4 02        add  sp, 2
2875                
2875                ;-1267                     disp -= 3;
2875                
2875 83 2E 3D 01 03  sub  word[disp], 3
287A                
287A                ;-1268                     genCode16(disp);
287A                
287A FF 36 3D 01     push word [disp]
287E E8 5D F9        call genCode16
2881 83 C4 02        add  sp, 2
2884                
2884                ;-1269                 }
2884                
2884                
2884                ;-1270             }
2884                
2884                .process318:
2884                
2884                ;-1271             else {//jump forward, near only
2884                
2884 E9 00 00      R jmp .process319
2887                .process314:
2887                
2887                ;-1272                 genCode8(Code1);
2887                
2887 A0 30 01        mov al, byte [Code1]
288A B4 00           mov ah, 0
288C 50              push ax
288D E8 F8 F8        call genCode8
2890 83 C4 02        add  sp, 2
2893                
2893                ;-1273                 storeJmp();
2893                
2893 E8 35 F0        call storeJmp
2896                
2896                ;-1274                 genCode16(0);
2896                
2896 6A 00           push 0
2898 E8 43 F9        call genCode16
289B 83 C4 02        add  sp, 2
289E                
289E                ;-1275                 PrintRA='R';
289E                
289E B8 52 00        mov ax, 82
28A1 A2 45 01        mov byte [PrintRA], al
28A4                
28A4                ;-1276             }
28A4                
28A4                
28A4                ;-1277         return;
28A4                
28A4                .process319:
28A4 E9 00 00      R jmp .retnprocess
28A7                
28A7                ;-1278         }
28A7                
28A7                
28A7                ;-1279     }
28A7                
28A7                .process313:
28A7                
28A7                ;-1280 
28A7                
28A7                
28A7                ;-1281     if (CodeType ==  8) {//ret,retf
28A7                
28A7                .process312:
28A7 A0 2F 01        mov al, [CodeType]
28AA 3C 08           cmp al, 8
28AC 0F 85 00 00   r jne .process320
28B0                
28B0                ;-1282         if (TokeType == DIGIT) {
28B0                
28B0 A0 2C 01        mov al, [TokeType]
28B3 3C 01           cmp al, 1
28B5 0F 85 00 00   r jne .process321
28B9                
28B9                ;-1283             genCode8(Code2);
28B9                
28B9 A0 31 01        mov al, byte [Code2]
28BC B4 00           mov ah, 0
28BE 50              push ax
28BF E8 C6 F8        call genCode8
28C2 83 C4 02        add  sp, 2
28C5                
28C5                ;-1284             genCode16(SymbolInt);
28C5                
28C5 FF 36 0E 01     push word [SymbolInt]
28C9 E8 12 F9        call genCode16
28CC 83 C4 02        add  sp, 2
28CF                
28CF                ;-1285             return;
28CF                
28CF E9 00 00      R jmp .retnprocess
28D2                
28D2                ;-1286         }
28D2                
28D2                
28D2                ;-1287         genCode8(Code1);
28D2                
28D2                .process321:
28D2 A0 30 01        mov al, byte [Code1]
28D5 B4 00           mov ah, 0
28D7 50              push ax
28D8 E8 AD F8        call genCode8
28DB 83 C4 02        add  sp, 2
28DE                
28DE                ;-1288         return;
28DE                
28DE E9 00 00      R jmp .retnprocess
28E1                
28E1                ;-1289     }
28E1                
28E1                
28E1                ;-1290 
28E1                
28E1                
28E1                ;-1291     if (CodeType == 9) {//push, pop
28E1                
28E1                .process320:
28E1 A0 2F 01        mov al, [CodeType]
28E4 3C 09           cmp al, 9
28E6 0F 85 00 00   r jne .process322
28EA                
28EA                ;-1292         getOpL();
28EA                
28EA E8 7F EA        call getOpL
28ED                
28ED                ;-1293         if (Code1 == 0x50) {//push only
28ED                
28ED A0 30 01        mov al, [Code1]
28F0 3C 50           cmp al, 80
28F2 0F 85 00 00   r jne .process323
28F6                
28F6                ;-1294             if (Op == IMM) {//push imm8,16
28F6                
28F6 A0 2D 01        mov al, [Op]
28F9 3C 01           cmp al, 1
28FB 0F 85 00 00   r jne .process324
28FF                
28FF                ;-1295                 setsflag();
28FF                
28FF E8 9C ED        call setsflag
2902                
2902                ;-1296                 genCode2(0x68, sflag);
2902                
2902 A0 3A 01        mov al, byte [sflag]
2905 B4 00           mov ah, 0
2907 50              push ax
2908 6A 68           push 104
290A E8 44 F8        call genCode2
290D 83 C4 04        add  sp, 4
2910                
2910                ;-1297                 if (sflag) genCode8 (imme);
2910                
2910 A0 3A 01        mov al, [sflag]
2913 08 C0           or  al, al
2915 0F 84 00 00   r je .process325
2919 FF 36 3F 01     push word [imme]
291D E8 68 F8        call genCode8
2920 83 C4 02        add  sp, 2
2923                
2923                ;-1298                 else       genCode16(imme);
2923                
2923 E9 00 00      R jmp .process326
2926                .process325:
2926 FF 36 3F 01     push word [imme]
292A E8 B1 F8        call genCode16
292D 83 C4 02        add  sp, 2
2930                
2930                ;-1299                 return;
2930                
2930                .process326:
2930 E9 00 00      R jmp .retnprocess
2933                
2933                ;-1300             }
2933                
2933                
2933                ;-1301             if (Op == ADR) {//push string ABSOLUTE i16 
2933                
2933                .process324:
2933 A0 2D 01        mov al, [Op]
2936 3C 03           cmp al, 3
2938 0F 85 00 00   r jne .process327
293C                
293C                ;-1302 //prscomment("\n push disp: "); printhex16 (disp);
293C                
293C                
293C                ;-1303                 if (disp) {
293C                
293C A1 3D 01        mov ax, [disp]
293F 08 C0           or  al, al
2941 0F 84 00 00   r je .process328
2945                
2945                ;-1304                     genCode8(0x68);
2945                
2945 6A 68           push 104
2947 E8 3E F8        call genCode8
294A 83 C4 02        add  sp, 2
294D                
294D                ;-1305                     genCode16(disp);
294D                
294D FF 36 3D 01     push word [disp]
2951 E8 8A F8        call genCode16
2954 83 C4 02        add  sp, 2
2957                
2957                ;-1306                     return;
2957                
2957 E9 00 00      R jmp .retnprocess
295A                
295A                ;-1307                 }
295A                
295A                
295A                ;-1308                 else {
295A                
295A E9 00 00      R jmp .process329
295D                .process328:
295D                
295D                ;-1309                     genCode8(0x68);
295D                
295D 6A 68           push 104
295F E8 26 F8        call genCode8
2962 83 C4 02        add  sp, 2
2965                
2965                ;-1310                     storeJmp();
2965                
2965 E8 63 EF        call storeJmp
2968                
2968                ;-1311                     genCode16(0xAAAA);//magic for abs ADR
2968                
2968 68 AA AA        push 43690
296B E8 70 F8        call genCode16
296E 83 C4 02        add  sp, 2
2971                
2971                ;-1312                     PrintRA='A';
2971                
2971 B8 41 00        mov ax, 65
2974 A2 45 01        mov byte [PrintRA], al
2977                
2977                ;-1313                     return;
2977                
2977 E9 00 00      R jmp .retnprocess
297A                
297A                ;-1314                 }
297A                
297A                
297A                ;-1315             }
297A                
297A                .process329:
297A                
297A                ;-1316         }
297A                
297A                .process327:
297A                
297A                ;-1317         if (R1Type == SEGREG) {
297A                
297A                .process323:
297A A0 36 01        mov al, [R1Type]
297D 3C 04           cmp al, 4
297F 0F 85 00 00   r jne .process330
2983                
2983                ;-1318             if (Code1 == 0x58) {//pop only
2983                
2983 A0 30 01        mov al, [Code1]
2986 3C 58           cmp al, 88
2988 0F 85 00 00   r jne .process331
298C                
298C                ;-1319                 if (R1No == 1) error1("pop cs not allowed");
298C                
298C A0 34 01        mov al, [R1No]
298F 3C 01           cmp al, 1
2991 0F 85 00 00   r jne .process332
2995 68 AA AA      A push process_0
2998 E8 C6 E1        call error1
299B 83 C4 02        add  sp, 2
299E                
299E                ;-1320             }
299E                
299E                .process332:
299E                
299E                ;-1321             c = R1No <<3;
299E                
299E                .process331:
299E A0 34 01        mov al, [R1No]
29A1 C0 E0 03        shl al, 3
29A4 88 46 FE        mov [bp-2], al
29A7                
29A7                ;-1322             if (R1No > 3) {//FS, GS
29A7                
29A7 A0 34 01        mov al, [R1No]
29AA 3C 03           cmp al, 3
29AC 0F 8E 00 00   r jle .process333
29B0                
29B0                ;-1323                 c += 122;
29B0                
29B0 80 46 FE 7A     add  byte[bp-2], 122
29B4                
29B4                ;-1324                 genCode8(0x0F);
29B4                
29B4 6A 0F           push 15
29B6 E8 CF F7        call genCode8
29B9 83 C4 02        add  sp, 2
29BC                
29BC                ;-1325             }
29BC                
29BC                
29BC                ;-1326             OpCodePtr++;
29BC                
29BC                .process333:
29BC FF 06 43 01     inc  word[OpCodePtr]
29C0                
29C0                ;-1327             c = c + *OpCodePtr;////////////////is Code4
29C0                
29C0 8A 46 FE        mov al, [bp-2]
29C3 8B 1E 43 01     mov bx, [OpCodePtr]
29C7 02 07           add al, [bx]
29C9 B4 00           mov ah, 0
29CB 88 46 FE        mov [bp-2], al
29CE                
29CE                ;-1328             genCode8(c);
29CE                
29CE 8A 46 FE        mov al, byte [bp-2]
29D1 B4 00           mov ah, 0
29D3 50              push ax
29D4 E8 B1 F7        call genCode8
29D7 83 C4 02        add  sp, 2
29DA                
29DA                ;-1329             return;
29DA                
29DA E9 00 00      R jmp .retnprocess
29DD                
29DD                ;-1330         }
29DD                
29DD                
29DD                ;-1331         checkOpL();//no ADR, SEGREG
29DD                
29DD                .process330:
29DD E8 AF E8        call checkOpL
29E0                
29E0                ;-1332         if (R1Type == BYTE) reg16error();
29E0                
29E0 A0 36 01        mov al, [R1Type]
29E3 3C 01           cmp al, 1
29E5 0F 85 00 00   r jne .process334
29E9 E8 16 E3        call reg16error
29EC                
29EC                ;-1333         if (R1Type == WORD) {
29EC                
29EC                .process334:
29EC A0 36 01        mov al, [R1Type]
29EF 3C 02           cmp al, 2
29F1 0F 85 00 00   r jne .process335
29F5                
29F5                ;-1334             genCode2(Code1, R1No);
29F5                
29F5 A0 34 01        mov al, byte [R1No]
29F8 B4 00           mov ah, 0
29FA 50              push ax
29FB A0 30 01        mov al, byte [Code1]
29FE B4 00           mov ah, 0
2A00 50              push ax
2A01 E8 4D F7        call genCode2
2A04 83 C4 04        add  sp, 4
2A07                
2A07                ;-1335             return;
2A07                
2A07 E9 00 00      R jmp .retnprocess
2A0A                
2A0A                ;-1336         }
2A0A                
2A0A                
2A0A                ;-1337         if (Op == MEM) {
2A0A                
2A0A                .process335:
2A0A A0 2D 01        mov al, [Op]
2A0D 3C 04           cmp al, 4
2A0F 0F 85 00 00   r jne .process336
2A13                
2A13                ;-1338             genCode8(Code2);
2A13                
2A13 A0 31 01        mov al, byte [Code2]
2A16 B4 00           mov ah, 0
2A18 50              push ax
2A19 E8 6C F7        call genCode8
2A1C 83 C4 02        add  sp, 2
2A1F                
2A1F                ;-1339             writeEA(Code3);//////////////////Code3
2A1F                
2A1F A0 32 01        mov al, byte [Code3]
2A22 B4 00           mov ah, 0
2A24 50              push ax
2A25 E8 FD F7        call writeEA
2A28 83 C4 02        add  sp, 2
2A2B                
2A2B                ;-1340             return;
2A2B                
2A2B E9 00 00      R jmp .retnprocess
2A2E                
2A2E                ;-1341         }
2A2E                
2A2E                
2A2E                ;-1342         syntaxerror();
2A2E                
2A2E                .process336:
2A2E E8 20 E3        call syntaxerror
2A31                
2A31                ;-1343         return;
2A31                
2A31 E9 00 00      R jmp .retnprocess
2A34                
2A34                ;-1344     }
2A34                
2A34                
2A34                ;-1345 
2A34                
2A34                
2A34                ;-1346     if (CodeType == 11) {//shift, rotate
2A34                
2A34                .process322:
2A34 A0 2F 01        mov al, [CodeType]
2A37 3C 0B           cmp al, 11
2A39 0F 85 00 00   r jne .process337
2A3D                
2A3D                ;-1347         check2Ops();
2A3D                
2A3D E8 D1 E8        call check2Ops
2A40                
2A40                ;-1348         if (Op2 == IMM) {
2A40                
2A40 A0 2E 01        mov al, [Op2]
2A43 3C 01           cmp al, 1
2A45 0F 85 00 00   r jne .process338
2A49                
2A49                ;-1349             if (imme == 1) {
2A49                
2A49 A1 3F 01        mov ax, [imme]
2A4C 83 F8 01        cmp ax, 1
2A4F 0F 85 00 00   r jne .process339
2A53                
2A53                ;-1350                 genCodeW(0xD0);
2A53                
2A53 68 D0 00        push 208
2A56 E8 13 F7        call genCodeW
2A59 83 C4 02        add  sp, 2
2A5C                
2A5C                ;-1351                 writeEA(Code1);
2A5C                
2A5C A0 30 01        mov al, byte [Code1]
2A5F B4 00           mov ah, 0
2A61 50              push ax
2A62 E8 C0 F7        call writeEA
2A65 83 C4 02        add  sp, 2
2A68                
2A68                ;-1352                 return;
2A68                
2A68 E9 00 00      R jmp .retnprocess
2A6B                
2A6B                ;-1353             }
2A6B                
2A6B                
2A6B                ;-1354             genCodeW(0xC0);//80186
2A6B                
2A6B                .process339:
2A6B 68 C0 00        push 192
2A6E E8 FB F6        call genCodeW
2A71 83 C4 02        add  sp, 2
2A74                
2A74                ;-1355             writeEA(Code1);
2A74                
2A74 A0 30 01        mov al, byte [Code1]
2A77 B4 00           mov ah, 0
2A79 50              push ax
2A7A E8 A8 F7        call writeEA
2A7D 83 C4 02        add  sp, 2
2A80                
2A80                ;-1356             genCode8(imme);
2A80                
2A80 FF 36 3F 01     push word [imme]
2A84 E8 01 F7        call genCode8
2A87 83 C4 02        add  sp, 2
2A8A                
2A8A                ;-1357             return;
2A8A                
2A8A E9 00 00      R jmp .retnprocess
2A8D                
2A8D                ;-1358         }
2A8D                
2A8D                
2A8D                ;-1359         if (Op2 == REG) {
2A8D                
2A8D                .process338:
2A8D A0 2E 01        mov al, [Op2]
2A90 3C 02           cmp al, 2
2A92 0F 85 00 00   r jne .process340
2A96                
2A96                ;-1360             if (R2Type == BYTE) {
2A96                
2A96 A0 35 01        mov al, [R2Type]
2A99 3C 01           cmp al, 1
2A9B 0F 85 00 00   r jne .process341
2A9F                
2A9F                ;-1361                 if (R2No == 1) {//CL-REG
2A9F                
2A9F A0 33 01        mov al, [R2No]
2AA2 3C 01           cmp al, 1
2AA4 0F 85 00 00   r jne .process342
2AA8                
2AA8                ;-1362                     if (R1Type == WORD) wflag=1;//hack
2AA8                
2AA8 A0 36 01        mov al, [R1Type]
2AAB 3C 02           cmp al, 2
2AAD 0F 85 00 00   r jne .process343
2AB1 B8 01 00        mov ax, 1
2AB4 A2 38 01        mov byte [wflag], al
2AB7                
2AB7                ;-1363                     genCodeW(0xD2);
2AB7                
2AB7                .process343:
2AB7 68 D2 00        push 210
2ABA E8 AF F6        call genCodeW
2ABD 83 C4 02        add  sp, 2
2AC0                
2AC0                ;-1364                     writeEA(Code1);
2AC0                
2AC0 A0 30 01        mov al, byte [Code1]
2AC3 B4 00           mov ah, 0
2AC5 50              push ax
2AC6 E8 5C F7        call writeEA
2AC9 83 C4 02        add  sp, 2
2ACC                
2ACC                ;-1365                     return;
2ACC                
2ACC E9 00 00      R jmp .retnprocess
2ACF                
2ACF                ;-1366                 }
2ACF                
2ACF                
2ACF                ;-1367             }
2ACF                
2ACF                .process342:
2ACF                
2ACF                ;-1368         }
2ACF                
2ACF                .process341:
2ACF                
2ACF                ;-1369     }
2ACF                
2ACF                .process340:
2ACF                
2ACF                ;-1370 
2ACF                
2ACF                
2ACF                ;-1371     if (CodeType == 12) {//int
2ACF                
2ACF                .process337:
2ACF A0 2F 01        mov al, [CodeType]
2AD2 3C 0C           cmp al, 12
2AD4 0F 85 00 00   r jne .process344
2AD8                
2AD8                ;-1372         if (TokeType == DIGIT) {
2AD8                
2AD8 A0 2C 01        mov al, [TokeType]
2ADB 3C 01           cmp al, 1
2ADD 0F 85 00 00   r jne .process345
2AE1                
2AE1                ;-1373             genCode8(Code1);
2AE1                
2AE1 A0 30 01        mov al, byte [Code1]
2AE4 B4 00           mov ah, 0
2AE6 50              push ax
2AE7 E8 9E F6        call genCode8
2AEA 83 C4 02        add  sp, 2
2AED                
2AED                ;-1374             genCode8(SymbolInt);
2AED                
2AED FF 36 0E 01     push word [SymbolInt]
2AF1 E8 94 F6        call genCode8
2AF4 83 C4 02        add  sp, 2
2AF7                
2AF7                ;-1375             return;
2AF7                
2AF7 E9 00 00      R jmp .retnprocess
2AFA                
2AFA                ;-1376         }
2AFA                
2AFA                
2AFA                ;-1377     }
2AFA                
2AFA                .process345:
2AFA                
2AFA                ;-1378 
2AFA                
2AFA                
2AFA                ;-1379     if (CodeType == 30) {//enter i18,i8
2AFA                
2AFA                .process344:
2AFA A0 2F 01        mov al, [CodeType]
2AFD 3C 1E           cmp al, 30
2AFF 0F 85 00 00   r jne .process346
2B03                
2B03                ;-1380         genCode8(0xC8);
2B03                
2B03 68 C8 00        push 200
2B06 E8 7F F6        call genCode8
2B09 83 C4 02        add  sp, 2
2B0C                
2B0C                ;-1381         Op=getOp1();
2B0C                
2B0C E8 20 E9        call getOp1
2B0F A2 2D 01        mov byte [Op], al
2B12                
2B12                ;-1382         if (Op == IMM) genCode16(SymbolInt);
2B12                
2B12 A0 2D 01        mov al, [Op]
2B15 3C 01           cmp al, 1
2B17 0F 85 00 00   r jne .process347
2B1B FF 36 0E 01     push word [SymbolInt]
2B1F E8 BC F6        call genCode16
2B22 83 C4 02        add  sp, 2
2B25                
2B25                ;-1383         else numbererror();
2B25                
2B25 E9 00 00      R jmp .process348
2B28                .process347:
2B28 E8 93 E1        call numbererror
2B2B                
2B2B                ;-1384         need(',');
2B2B                
2B2B                .process348:
2B2B 6A 2C           push 44
2B2D E8 3D F1        call need
2B30 83 C4 02        add  sp, 2
2B33                
2B33                ;-1385         Op=getOp1();
2B33                
2B33 E8 F9 E8        call getOp1
2B36 A2 2D 01        mov byte [Op], al
2B39                
2B39                ;-1386         if (Op == IMM) genCode8 (SymbolInt);
2B39                
2B39 A0 2D 01        mov al, [Op]
2B3C 3C 01           cmp al, 1
2B3E 0F 85 00 00   r jne .process349
2B42 FF 36 0E 01     push word [SymbolInt]
2B46 E8 3F F6        call genCode8
2B49 83 C4 02        add  sp, 2
2B4C                
2B4C                ;-1387         else numbererror();
2B4C                
2B4C E9 00 00      R jmp .process350
2B4F                .process349:
2B4F E8 6C E1        call numbererror
2B52                
2B52                ;-1388         return;
2B52                
2B52                .process350:
2B52 E9 00 00      R jmp .retnprocess
2B55                
2B55                ;-1389     }
2B55                
2B55                
2B55                ;-1390 
2B55                
2B55                
2B55                ;-1391     if (CodeType==101) {//ORG nn
2B55                
2B55                .process346:
2B55 A0 2F 01        mov al, [CodeType]
2B58 3C 65           cmp al, 101
2B5A 0F 85 00 00   r jne .process351
2B5E                
2B5E                ;-1392         if (TokeType != DIGIT) numbererror();
2B5E                
2B5E A0 2C 01        mov al, [TokeType]
2B61 3C 01           cmp al, 1
2B63 0F 84 00 00   r je  .process352
2B67 E8 54 E1        call numbererror
2B6A                
2B6A                ;-1393         Origin=SymbolInt;
2B6A                
2B6A                .process352:
2B6A A1 0E 01        mov ax, [SymbolInt]
2B6D A3 25 01        mov word [Origin], ax
2B70                
2B70                ;-1394         return;
2B70                
2B70 E9 00 00      R jmp .retnprocess
2B73                
2B73                ;-1395     }
2B73                
2B73                
2B73                ;-1396 
2B73                
2B73                
2B73                ;-1397     if (CodeType == 102) {//section, segment
2B73                
2B73                .process351:
2B73 A0 2F 01        mov al, [CodeType]
2B76 3C 66           cmp al, 102
2B78 0F 85 00 00   r jne .process353
2B7C                
2B7C                ;-1398         //getTokeType();//ignore .bss .text .data
2B7C                
2B7C                
2B7C                ;-1399         AbsoluteLab=0;//nasm resets erevy time
2B7C                
2B7C B8 00 00        mov ax, 0
2B7F A3 27 01        mov word [AbsoluteLab], ax
2B82                
2B82                ;-1400         return;
2B82                
2B82 E9 00 00      R jmp .retnprocess
2B85                
2B85                ;-1401     }
2B85                
2B85                
2B85                ;-1402 
2B85                
2B85                
2B85                ;-1403     if (CodeType == 110) {//absolute
2B85                
2B85                .process353:
2B85 A0 2F 01        mov al, [CodeType]
2B88 3C 6E           cmp al, 110
2B8A 0F 85 00 00   r jne .process354
2B8E                
2B8E                ;-1404         if (TokeType != DIGIT) numbererror();
2B8E                
2B8E A0 2C 01        mov al, [TokeType]
2B91 3C 01           cmp al, 1
2B93 0F 84 00 00   r je  .process355
2B97 E8 24 E1        call numbererror
2B9A                
2B9A                ;-1405         AbsoluteLab=SymbolInt;
2B9A                
2B9A                .process355:
2B9A A1 0E 01        mov ax, [SymbolInt]
2B9D A3 27 01        mov word [AbsoluteLab], ax
2BA0                
2BA0                ;-1406         return;
2BA0                
2BA0 E9 00 00      R jmp .retnprocess
2BA3                
2BA3                ;-1407     }
2BA3                
2BA3                
2BA3                ;-1408     if (CodeType == 111) {//name: PROC
2BA3                
2BA3                .process354:
2BA3 A0 2F 01        mov al, [CodeType]
2BA6 3C 6F           cmp al, 111
2BA8 0F 85 00 00   r jne .process356
2BAC                
2BAC                ;-1409         if (isInProc == 0)  {
2BAC                
2BAC A0 0D 01        mov al, [isInProc]
2BAF 3C 00           cmp al, 0
2BB1 0F 85 00 00   r jne .process357
2BB5                
2BB5                ;-1410             prs("\n;entering: ");
2BB5                
2BB5 68 AA AA      A push process_1
2BB8 E8 5C DE        call prs
2BBB 83 C4 02        add  sp, 2
2BBE                
2BBE                ;-1411             prs(ProcName);
2BBE                
2BBE 8D 06 6E 75     lea  ax, [ProcName]
2BC2 50              push ax
2BC3 E8 51 DE        call prs
2BC6 83 C4 02        add  sp, 2
2BC9                
2BC9                ;-1412             isInProc=1;
2BC9                
2BC9 B8 01 00        mov ax, 1
2BCC A2 0D 01        mov byte [isInProc], al
2BCF                
2BCF                ;-1413             tmpLabelNamePtr = LabelNamePtr;
2BCF                
2BCF A1 46 01        mov ax, [LabelNamePtr]
2BD2 A3 48 01        mov word [tmpLabelNamePtr], ax
2BD5                
2BD5                ;-1414             tmpLabelMaxIx   = LabelMaxIx;
2BD5                
2BD5 A1 4A 01        mov ax, [LabelMaxIx]
2BD8 A3 4C 01        mov word [tmpLabelMaxIx], ax
2BDB                
2BDB                ;-1415             tmpJmpNamePtr   = JmpNamePtr;
2BDB                
2BDB A1 50 01        mov ax, [JmpNamePtr]
2BDE A3 52 01        mov word [tmpJmpNamePtr], ax
2BE1                
2BE1                ;-1416             tmpJmpMaxIx     = JmpMaxIx;
2BE1                
2BE1 A1 54 01        mov ax, [JmpMaxIx]
2BE4 A3 56 01        mov word [tmpJmpMaxIx], ax
2BE7                
2BE7                ;-1417         } else error1("already in PROC");
2BE7                
2BE7 E9 00 00      R jmp .process358
2BEA                .process357:
2BEA 68 AA AA      A push process_2
2BED E8 71 DF        call error1
2BF0 83 C4 02        add  sp, 2
2BF3                
2BF3                ;-1418         return;
2BF3                
2BF3                .process358:
2BF3 E9 00 00      R jmp .retnprocess
2BF6                
2BF6                ;-1419     }
2BF6                
2BF6                
2BF6                ;-1420     if (CodeType == 112) {//ENDP 
2BF6                
2BF6                .process356:
2BF6 A0 2F 01        mov al, [CodeType]
2BF9 3C 70           cmp al, 112
2BFB 0F 85 00 00   r jne .process359
2BFF                
2BFF                ;-1421         if (isInProc == 0) error1("not in PROC");
2BFF                
2BFF A0 0D 01        mov al, [isInProc]
2C02 3C 00           cmp al, 0
2C04 0F 85 00 00   r jne .process360
2C08 68 AA AA      A push process_3
2C0B E8 53 DF        call error1
2C0E 83 C4 02        add  sp, 2
2C11                
2C11                ;-1422         prs("\n;leaving: ");
2C11                
2C11                .process360:
2C11 68 AA AA      A push process_4
2C14 E8 00 DE        call prs
2C17 83 C4 02        add  sp, 2
2C1A                
2C1A                ;-1423         prs(ProcName);
2C1A                
2C1A 8D 06 6E 75     lea  ax, [ProcName]
2C1E 50              push ax
2C1F E8 F5 DD        call prs
2C22 83 C4 02        add  sp, 2
2C25                
2C25                ;-1424         prs(". loc labels:");
2C25                
2C25 68 AA AA      A push process_5
2C28 E8 EC DD        call prs
2C2B 83 C4 02        add  sp, 2
2C2E                
2C2E                ;-1425         i = LabelMaxIx - tmpLabelMaxIx;
2C2E                
2C2E A1 4A 01        mov ax, [LabelMaxIx]
2C31 2B 06 4C 01     sub ax, [tmpLabelMaxIx]
2C35 89 46 FC        mov [bp-4], ax
2C38                
2C38                ;-1426         printIntU(i);
2C38                
2C38 55              push word [bp-4]
2C39 E8 E7 DE        call printIntU
2C3C 83 C4 02        add  sp, 2
2C3F                
2C3F                ;-1427         prs(",loc jmp forward:");
2C3F                
2C3F 68 AA AA      A push process_6
2C42 E8 D2 DD        call prs
2C45 83 C4 02        add  sp, 2
2C48                
2C48                ;-1428         i = JmpMaxIx - tmpJmpMaxIx;
2C48                
2C48 A1 54 01        mov ax, [JmpMaxIx]
2C4B 2B 06 56 01     sub ax, [tmpJmpMaxIx]
2C4F 89 46 FC        mov [bp-4], ax
2C52                
2C52                ;-1429         printIntU(i);        
2C52                
2C52 55              push word [bp-4]
2C53 E8 CD DE        call printIntU
2C56 83 C4 02        add  sp, 2
2C59                
2C59                ;-1430         fixJmp();
2C59                
2C59 E8 BC F2        call fixJmp
2C5C                
2C5C                ;-1431         isInProc=0;
2C5C                
2C5C B8 00 00        mov ax, 0
2C5F A2 0D 01        mov byte [isInProc], al
2C62                
2C62                ;-1432         LabelNamePtr = tmpLabelNamePtr;//delete local Labels
2C62                
2C62 A1 48 01        mov ax, [tmpLabelNamePtr]
2C65 A3 46 01        mov word [LabelNamePtr], ax
2C68                
2C68                ;-1433         LabelMaxIx   = tmpLabelMaxIx;                       
2C68                
2C68 A1 4C 01        mov ax, [tmpLabelMaxIx]
2C6B A3 4A 01        mov word [LabelMaxIx], ax
2C6E                
2C6E                ;-1434         JmpNamePtr   = tmpJmpNamePtr;//delete local Jmp
2C6E                
2C6E A1 52 01        mov ax, [tmpJmpNamePtr]
2C71 A3 50 01        mov word [JmpNamePtr], ax
2C74                
2C74                ;-1435         JmpMaxIx     = tmpJmpMaxIx;
2C74                
2C74 A1 56 01        mov ax, [tmpJmpMaxIx]
2C77 A3 54 01        mov word [JmpMaxIx], ax
2C7A                
2C7A                ;-1436         return;
2C7A                
2C7A E9 00 00      R jmp .retnprocess
2C7D                
2C7D                ;-1437     }
2C7D                
2C7D                
2C7D                ;-1438     error1("Command not implemented or syntax error");
2C7D                
2C7D                .process359:
2C7D 68 AA AA      A push process_7
2C80 E8 DE DE        call error1
2C83 83 C4 02        add  sp, 2
2C86                
2C86                ;-1439 }
2C86                
2C86                
2C86                ;-1440 
2C86                
2C86                
2C86                ;-1441 int main() {
2C86                
2C86 C9              .retnprocess: LEAVE
2C87 C3              ret
2C88 70 6F 70 20 63 process_0 db "pop cs not allowed",0
2C9B 5C 6E 3B 65 6E process_1 db "\n;entering: ",0
2CA9 61 6C 72 65 61 process_2 db "already in PROC",0
2CB9 6E 6F 74 20 69 process_3 db "not in PROC",0
2CC5 5C 6E 3B 6C 65 process_4 db "\n;leaving: ",0
2CD2 2E 20 6C 6F 63 process_5 db ". loc labels:",0
2CE0 2C 6C 6F 63 20 process_6 db ",loc jmp forward:",0
2CF2 43 6F 6D 6D 61 process_7 db "Command not implemented or syntax error",0
;leaving: process. loc labels:106,loc jmp forward:144
;jmp to fix:144
1. .process264,from:23A6,Label+ORG:24B7,rel:000F
2. .retnprocess,from:23B5,Label+ORG:2D86,rel:08CF
3. .process265,from:23BE,Label+ORG:2529,rel:0069
4. .process266,from:23CD,Label+ORG:24F6,rel:0027
5. .process267,from:23D6,Label+ORG:24F6,rel:001E
6. .process268,from:23DF,Label+ORG:24F6,rel:0015
7. .retnprocess,from:23F4,Label+ORG:2D86,rel:0890
8. .process269,from:23FD,Label+ORG:250E,rel:000F
9. .process270,from:2409,Label+ORG:250E,rel:0003
10. .retnprocess,from:2427,Label+ORG:2D86,rel:085D
11. .process271,from:2430,Label+ORG:2583,rel:0051
12. .process272,from:243C,Label+ORG:2541,rel:0003
13. .process273,from:2448,Label+ORG:254D,rel:0003
14. .process274,from:2460,Label+ORG:256E,rel:000C
15. .retnprocess,from:2481,Label+ORG:2D86,rel:0803
16. .process275,from:248A,Label+ORG:267B,rel:00EF
17. .process276,from:2496,Label+ORG:2611,rel:0079
18. .process277,from:24A2,Label+ORG:25D5,rel:0031
19. .process278,from:24AB,Label+ORG:25D5,rel:0028
20. .process279,from:24B4,Label+ORG:25D5,rel:001F
21. .retnprocess,from:24D3,Label+ORG:2D86,rel:07B1
22. .process280,from:24FC,Label+ORG:260B,rel:000D
23. .process281,from:2509,Label+ORG:260E,rel:0003
24. .retnprocess,from:250F,Label+ORG:2D86,rel:0775
25. .process282,from:2521,Label+ORG:2651,rel:002E
26. .process283,from:252A,Label+ORG:2651,rel:0025
27. .retnprocess,from:254F,Label+ORG:2D86,rel:0735
28. .process284,from:2558,Label+ORG:2675,rel:001B
29. .retnprocess,from:2573,Label+ORG:2D86,rel:0711
30. .retnprocess,from:2579,Label+ORG:2D86,rel:070B
31. .process285,from:2582,Label+ORG:280F,rel:018B
32. .process286,from:258E,Label+ORG:26AB,rel:001B
33. .process287,from:2597,Label+ORG:26A2,rel:0009
34. .process288,from:25A0,Label+ORG:26A5,rel:0003
35. .process289,from:25B2,Label+ORG:2708,rel:0054
36. .process290,from:25BB,Label+ORG:26E2,rel:0025
37. .retnprocess,from:25E0,Label+ORG:2D86,rel:06A4
38. .process291,from:25E9,Label+ORG:2702,rel:0017
39. .retnprocess,from:2600,Label+ORG:2D86,rel:0684
40. .retnprocess,from:2606,Label+ORG:2D86,rel:067E
41. .process292,from:260F,Label+ORG:2714,rel:0003
42. .process293,from:261B,Label+ORG:2747,rel:002A
43. .process294,from:2624,Label+ORG:2729,rel:0003
44. .retnprocess,from:2645,Label+ORG:2D86,rel:063F
45. .process295,from:264E,Label+ORG:2781,rel:0031
46. .process296,from:2657,Label+ORG:2781,rel:0028
47. .process297,from:2660,Label+ORG:2781,rel:001F
48. .process298,from:2669,Label+ORG:2781,rel:0016
49. .retnprocess,from:267F,Label+ORG:2D86,rel:0605
50. .process299,from:2688,Label+ORG:27BB,rel:0031
51. .process300,from:2691,Label+ORG:27BB,rel:0028
52. .process301,from:269A,Label+ORG:27BB,rel:001F
53. .process302,from:26A3,Label+ORG:27BB,rel:0016
54. .retnprocess,from:26B9,Label+ORG:2D86,rel:05CB
55. .process303,from:26C2,Label+ORG:27DC,rel:0018
56. .retnprocess,from:26DA,Label+ORG:2D86,rel:05AA
57. .process304,from:26E3,Label+ORG:2809,rel:0024
58. .process305,from:26EC,Label+ORG:2809,rel:001B
59. .retnprocess,from:2707,Label+ORG:2D86,rel:057D
60. .retnprocess,from:270D,Label+ORG:2D86,rel:0577
61. .process306,from:2716,Label+ORG:28D5,rel:00BD
62. .process307,from:271F,Label+ORG:28D5,rel:00B4
63. .process308,from:272F,Label+ORG:28AA,rel:0079
64. .process309,from:275F,Label+ORG:2881,rel:0020
65. .process310,from:277F,Label+ORG:28A7,rel:0026
66. .process311,from:27A8,Label+ORG:28D2,rel:0028
67. .retnprocess,from:27D3,Label+ORG:2D86,rel:04B1
68. .process312,from:27DC,Label+ORG:29A7,rel:00C9
69. .process313,from:27E5,Label+ORG:29A7,rel:00C0
70. .process314,from:27F5,Label+ORG:2987,rel:0090
71. .process315,from:2825,Label+ORG:2969,rel:0042
72. .process316,from:282E,Label+ORG:294B,rel:001B
73. .process317,from:2849,Label+ORG:2966,rel:001B
74. .process318,from:2867,Label+ORG:2984,rel:001B
75. .process319,from:2885,Label+ORG:29A4,rel:001D
76. .retnprocess,from:28A5,Label+ORG:2D86,rel:03DF
77. .process320,from:28AE,Label+ORG:29E1,rel:0031
78. .process321,from:28B7,Label+ORG:29D2,rel:0019
79. .retnprocess,from:28D0,Label+ORG:2D86,rel:03B4
80. .retnprocess,from:28DF,Label+ORG:2D86,rel:03A5
81. .process322,from:28E8,Label+ORG:2B34,rel:014A
82. .process323,from:28F4,Label+ORG:2A7A,rel:0084
83. .process324,from:28FD,Label+ORG:2A33,rel:0034
84. .process325,from:2917,Label+ORG:2A26,rel:000D
85. .process326,from:2924,Label+ORG:2A30,rel:000A
86. .retnprocess,from:2931,Label+ORG:2D86,rel:0353
87. .process327,from:293A,Label+ORG:2A7A,rel:003E
88. .process328,from:2943,Label+ORG:2A5D,rel:0018
89. .retnprocess,from:2958,Label+ORG:2D86,rel:032C
90. .process329,from:295B,Label+ORG:2A7A,rel:001D
91. .retnprocess,from:2978,Label+ORG:2D86,rel:030C
92. .process330,from:2981,Label+ORG:2ADD,rel:005A
93. .process331,from:298A,Label+ORG:2A9E,rel:0012
94. .process332,from:2993,Label+ORG:2A9E,rel:0009
95. process_0,from:2996,Label+ORG:2D88
96. .process333,from:29AE,Label+ORG:2ABC,rel:000C
97. .retnprocess,from:29DB,Label+ORG:2D86,rel:02A9
98. .process334,from:29E7,Label+ORG:2AEC,rel:0003
99. .process335,from:29F3,Label+ORG:2B0A,rel:0015
100. .retnprocess,from:2A08,Label+ORG:2D86,rel:027C
101. .process336,from:2A11,Label+ORG:2B2E,rel:001B
102. .retnprocess,from:2A2C,Label+ORG:2D86,rel:0258
103. .retnprocess,from:2A32,Label+ORG:2D86,rel:0252
104. .process337,from:2A3B,Label+ORG:2BCF,rel:0092
105. .process338,from:2A47,Label+ORG:2B8D,rel:0044
106. .process339,from:2A51,Label+ORG:2B6B,rel:0018
107. .retnprocess,from:2A69,Label+ORG:2D86,rel:021B
108. .retnprocess,from:2A8B,Label+ORG:2D86,rel:01F9
109. .process340,from:2A94,Label+ORG:2BCF,rel:0039
110. .process341,from:2A9D,Label+ORG:2BCF,rel:0030
111. .process342,from:2AA6,Label+ORG:2BCF,rel:0027
112. .process343,from:2AAF,Label+ORG:2BB7,rel:0006
113. .retnprocess,from:2ACD,Label+ORG:2D86,rel:01B7
114. .process344,from:2AD6,Label+ORG:2BFA,rel:0022
115. .process345,from:2ADF,Label+ORG:2BFA,rel:0019
116. .retnprocess,from:2AF8,Label+ORG:2D86,rel:018C
117. .process346,from:2B01,Label+ORG:2C55,rel:0052
118. .process347,from:2B19,Label+ORG:2C28,rel:000D
119. .process348,from:2B26,Label+ORG:2C2B,rel:0003
120. .process349,from:2B40,Label+ORG:2C4F,rel:000D
121. .process350,from:2B4D,Label+ORG:2C52,rel:0003
122. .retnprocess,from:2B53,Label+ORG:2D86,rel:0131
123. .process351,from:2B5C,Label+ORG:2C73,rel:0015
124. .process352,from:2B65,Label+ORG:2C6A,rel:0003
125. .retnprocess,from:2B71,Label+ORG:2D86,rel:0113
126. .process353,from:2B7A,Label+ORG:2C85,rel:0009
127. .retnprocess,from:2B83,Label+ORG:2D86,rel:0101
128. .process354,from:2B8C,Label+ORG:2CA3,rel:0015
129. .process355,from:2B95,Label+ORG:2C9A,rel:0003
130. .retnprocess,from:2BA1,Label+ORG:2D86,rel:00E3
131. .process356,from:2BAA,Label+ORG:2CF6,rel:004A
132. .process357,from:2BB3,Label+ORG:2CEA,rel:0035
133. process_1,from:2BB6,Label+ORG:2D9B
134. .process358,from:2BE8,Label+ORG:2CF3,rel:0009
135. process_2,from:2BEB,Label+ORG:2DA9
136. .retnprocess,from:2BF4,Label+ORG:2D86,rel:0090
137. .process359,from:2BFD,Label+ORG:2D7D,rel:007E
138. .process360,from:2C06,Label+ORG:2D11,rel:0009
139. process_3,from:2C09,Label+ORG:2DB9
140. process_4,from:2C12,Label+ORG:2DC5
141. process_5,from:2C26,Label+ORG:2DD2
142. process_6,from:2C40,Label+ORG:2DE0
143. .retnprocess,from:2C7B,Label+ORG:2D86,rel:0009
144. process_7,from:2C7E,Label+ORG:2DF2
2D1A                ENDP
2D1A                
;entering: main
2D1A                main: PROC
2D1A                
2D1A                ;-1442     getarg();
2D1A                
2D1A E8 B8 EF        call getarg
2D1D                
2D1D                ;-1443     parse();
2D1D                
2D1D E8 06 EA        call parse
2D20                
2D20                ;-1444     fixJmp();
2D20                
2D20 E8 F5 F1        call fixJmp
2D23                
2D23                ;-1445     epilog();
2D23                
2D23 E8 DE F2        call epilog
2D26                
2D26                ;-1446     end1();
2D26                
2D26 E8 C6 F3        call end1
2D29                
2D29                ;-1447 }
2D29                
2D29 C3              ret
;leaving: main. loc labels:0,loc jmp forward:0
;jmp to fix:0
2D2A                ENDP
2D2A                 
2D2A                ; missing functions: 
2D2A                ; Number of unresolved CALLs :    0 All FUNCTIONs in place
;***** next line ERROR: Command not implemented or syntax error, Symbol: db
;***** next line ERROR: extra char ignored, Symbol: E8h
2D2A                LastFunctionByt:db 0E8h, 0, 0
2D2A 58             pop ax
2D2B C3             ret
2D2C                 
2D2C                ;   # type sign width  adr used name   list of global variables
2D2C                
2D2C                ;    1 arr sign byte     1    2 Version1[9]
2D2C                ;    2 def unsg byte     3    - SYMBOLMAX=31
2D2C                ;    3 arr sign byte     4   13 Symbol[31]
2D2C                ;    4 arr sign byte     5   36 SymbolUpper[31]
2D2C                ;    5 arr sign byte     6    3 ProcName[31]
2D2C                ;    6 var sign byte     7    7 isInProc
2D2C                ;    7 var unsg word     8   24 SymbolInt
2D2C                ;    8 var unsg dwrd     9 NULL SymbolLong
2D2C                ;    9 def unsg byte    10    - INPUTBUFMAX=255
2D2C                ;   10 arr sign byte    11    4 InputBuf[255]
2D2C                ;   11 ptr unsg byte    12   24 InputPtr
2D2C                ;   12 arr sign byte    13    5 namein[67]
2D2C                ;   13 arr sign byte    14    6 namelst[67]
2D2C                ;   14 arr sign byte    15    6 namebin[67]
2D2C                ;   15 var sign word    16    4 asm_fd
2D2C                ;   16 var sign word    17    3 lst_fd
2D2C                ;   17 var sign word    18    3 bin_fd
2D2C                ;   18 var sign word    19    6 DOS_ERR
2D2C                ;   19 var sign word    20    5 ErrorCount
2D2C                ;   20 var sign word    21    4 DOS_NoBytes
2D2C                ;   21 var sign byte    22    5 DOS_ByteRead
2D2C                ;   22 var unsg word    24    7 PC
2D2C                ;   23 var unsg word    25    5 Origin
2D2C                ;   24 var unsg word    26    6 AbsoluteLab
2D2C                ;   25 var unsg word    27    2 PCStart
2D2C                ;   26 var sign byte    28    3 isLabel
2D2C                ;   27 def unsg byte    29    - DIGIT=1
2D2C                ;   28 def unsg byte    30    - LETTERE=2
2D2C                ;   29 def unsg byte    31    - ALNUME=3
2D2C                ;   30 def unsg byte    32    - NOALNUME=4
2D2C                ;   31 var sign byte    33   27 TokeType
2D2C                ;   32 def unsg byte    34    - BYTE=1
2D2C                ;   33 def unsg byte    35    - WORD=2
2D2C                ;   34 def unsg byte    36    - DWORD=3
2D2C                ;   35 def unsg byte    37    - SEGREG=4
2D2C                ;   36 def unsg byte    38    - IMM=1
2D2C                ;   37 def unsg byte    39    - REG=2
2D2C                ;   38 def unsg byte    40    - ADR=3
2D2C                ;   39 def unsg byte    41    - MEM=4
2D2C                ;   40 var sign byte    42   29 Op
2D2C                ;   41 var sign byte    43   31 Op2
2D2C                ;   42 var sign byte    44   29 CodeType
2D2C                ;   43 var sign byte    45   23 Code1
2D2C                ;   44 var sign byte    46    7 Code2
2D2C                ;   45 var sign byte    47    3 Code3
2D2C                ;   46 var sign byte    48   19 R2No
2D2C                ;   47 var sign byte    49   16 R1No
2D2C                ;   48 var sign byte    50   18 R2Type
2D2C                ;   49 var sign byte    51   15 R1Type
2D2C                ;   50 var sign byte    52   14 OpSize
2D2C                ;   51 var sign byte    53    9 wflag
2D2C                ;   52 var sign byte    54    3 dflag
2D2C                ;   53 var sign byte    55    8 sflag
2D2C                ;   54 var sign byte    56   15 rm
2D2C                ;   55 var sign byte    57    5 isDirect
2D2C                ;   56 var sign word    58   54 disp
2D2C                ;   57 var unsg word    59   13 imme
2D2C                ;   58 def unsg byte    61    - OPMAXLEN=5
2D2C                ;   59 arr sign byte    62    2 OpPos[5]
2D2C                ;   60 var sign word    63    6 OpPrintIndex
2D2C                ;   61 ptr sign byte    64   19 OpCodePtr
2D2C                ;   62 var sign byte    65    5 PrintRA
2D2C                ;   63 def unsg byte    67    - LABELNAMESMAX=5969
2D2C                ;   64 arr sign byte    68    3 LabelNames[6000]
2D2C                ;   65 ptr sign byte    69    7 LabelNamePtr
2D2C                ;   66 ptr sign byte    70    2 tmpLabelNamePtr
2D2C                ;   67 def unsg byte    72    - LABELADRMAX=600
2D2C                ;   68 arr unsg word    73    7 LabelAddr[600]
2D2C                ;   69 var sign word    74   10 LabelMaxIx
2D2C                ;   70 var sign word    75    3 tmpLabelMaxIx
2D2C                ;   71 var sign word    76   11 LabelIx
2D2C                ;   72 def unsg byte    78    - JMPNAMESMAX=3969
2D2C                ;   73 arr sign byte    79    3 JmpNames[4000]
2D2C                ;   74 ptr sign byte    80    7 JmpNamePtr
2D2C                ;   75 ptr sign byte    81    2 tmpJmpNamePtr
2D2C                ;   76 def unsg byte    83    - JMPMAX=200
2D2C                ;   77 arr unsg word    84    2 JmpAddr[200]
2D2C                ;   78 var sign word    85    9 JmpMaxIx
2D2C                ;   79 var sign word    86    4 tmpJmpMaxIx
2D2C                ;   80 def unsg byte    88    - FILEBINMAX=17000
2D2C                ;   81 arr sign byte    89    5 FileBin[17000]
2D2C                ;   82 var unsg word    90    6 BinLen
2D2C                ;   83 ptr sign byte    92    1 arglen
2D2C                ;   84 ptr sign byte    93    4 argv
2D2C                ;   85 var sign byte   393    1 I_START
2D2C                ;   86 arr sign byte   396 NULL I_PUSHA[8125]
2D2C                ;   87 arr sign byte   397 NULL I_NOP[24260]
2D2C                ;   88 arr sign byte   398 NULL I_CWDE[9734]
2D2C                ;   89 arr sign byte   399 NULL I_CDQ[1931]
2D2C                ;   90 arr sign byte   400 NULL I_PUSHF[35622]
2D2C                ;   91 arr sign byte   401 NULL I_SAHF[599]
2D2C                ;   92 arr sign byte   402 NULL I_MOVSB[53495]
2D2C                ;   93 arr sign byte   403 NULL I_CMPSB[54007]
2D2C                ;   94 arr sign byte   404 NULL I_STOSB[37]
2D2C                ;   95 arr sign byte   405 NULL I_LODSB[33600]
2D2C                ;   96 arr sign byte   406 NULL I_SCASB[8418]
2D2C                ;   97 arr sign byte   407 NULL I_LEAVE[53259]
2D2C                ;   98 arr sign byte   408 NULL I_INTO[12917]
2D2C                ;   99 arr sign byte   409 NULL I_XLAT[35622]
2D2C                ;  100 arr sign byte   410 NULL I_REPNE[2119]
2D2C                ;  101 arr sign byte   411 NULL I_REPE[18057]
2D2C                ;  102 arr sign byte   412 NULL I_HLT[9982]
2D2C                ;  103 arr sign byte   413 NULL I_STC[18315]
2D2C                ;  104 arr sign byte   414 NULL I_STI[9734]
2D2C                ;  105 arr sign byte   415 NULL I_STD[32643]
2D2C                ;  106 arr sign byte   417 NULL I_INC[10]
2D2C                ;  107 arr sign byte   418 NULL I_DEC[1397]
2D2C                ;  108 arr sign byte   419 NULL I_NOT[18119]
2D2C                ;  109 arr sign byte   420 NULL I_NEG[65534]
2D2C                ;  110 arr sign byte   421 NULL I_MUL[33791]
2D2C                ;  111 arr sign byte   422 NULL I_IMUL[65150]
2D2C                ;  112 arr sign byte   423 NULL I_DIV[30207]
2D2C                ;  113 arr sign byte   424 NULL I_IDIV[15642]
2D2C                ;  114 arr sign byte   426 NULL I_LES[65535]
2D2C                ;  115 arr sign byte   427 NULL I_LDS[5493]
2D2C                ;  116 arr sign byte   428 NULL I_LEA[33574]
2D2C                ;  117 arr sign byte   429 NULL I_LSS[1151]
2D2C                ;  118 arr sign byte   430 NULL I_LFS[29696]
2D2C                ;  119 arr sign byte   431 NULL I_LGS[35593]
2D2C                ;  120 arr sign byte   433 NULL I_ADD[2630]
2D2C                ;  121 arr sign byte   434 NULL I_OR[14630]
2D2C                ;  122 arr sign byte   435 NULL I_ADC[1095]
2D2C                ;  123 arr sign byte   436 NULL I_SBB[26997]
2D2C                ;  124 arr sign byte   437 NULL I_AND[49203]
2D2C                ;  125 arr sign byte   438 NULL I_SUB[52169]
2D2C                ;  126 arr sign byte   439 NULL I_XOR[33680]
2D2C                ;  127 arr sign byte   440 NULL I_CMP[65150]
2D2C                ;  128 arr sign byte   441 NULL I_TEST[29729]
2D2C                ;  129 arr sign byte   443 NULL I_MOV[33618]
2D2C                ;  130 arr sign byte   444 NULL I_MOVSX[65150]
2D2C                ;  131 arr sign byte   445 NULL I_MOVZX[29731]
2D2C                ;  132 arr sign byte   447 NULL I_JO[33612]
2D2C                ;  133 arr sign byte   448 NULL I_JNO[65150]
2D2C                ;  134 arr sign byte   449 NULL I_JB[29732]
2D2C                ;  135 arr sign byte   450 NULL I_JNB[33606]
2D2C                ;  136 arr sign byte   451 NULL I_JAE[65150]
2D2C                ;  137 arr sign byte   452 NULL I_JE[29734]
2D2C                ;  138 arr sign byte   453 NULL I_JNE[33600]
2D2C                ;  139 arr sign byte   454 NULL I_JBE[65150]
2D2C                ;  140 arr sign byte   455 NULL I_JA[29730]
2D2C                ;  141 arr sign byte   456 NULL I_JS[33594]
2D2C                ;  142 arr sign byte   457 NULL I_JNS[65150]
2D2C                ;  143 arr sign byte   458 NULL I_JP[29737]
2D2C                ;  144 arr sign byte   459 NULL I_JNP[33588]
2D2C                ;  145 arr sign byte   460 NULL I_JL[65150]
2D2C                ;  146 arr sign byte   461 NULL I_JNL[29736]
2D2C                ;  147 arr sign byte   462 NULL I_JLE[33582]
2D2C                ;  148 arr sign byte   463 NULL I_JG[65150]
2D2C                ;  149 arr sign byte   465 NULL I_JMP[29733]
2D2C                ;  150 arr sign byte   466 NULL I_CALL[15656]
2D2C                ;  151 arr sign byte   468 NULL I_RET[33]
2D2C                ;  152 arr sign byte   469 NULL I_RETF[9076]
2D2C                ;  153 arr sign byte   471 NULL I_PUSH[9021]
2D2C                ;  154 arr sign byte   472 NULL I_POP[29696]
2D2C                ;  155 arr sign byte   474 NULL I_ROL[15646]
2D2C                ;  156 arr sign byte   475 NULL I_RCL[36]
2D2C                ;  157 arr sign byte   476 NULL I_SHL[6516]
2D2C                ;  158 arr sign byte   477 NULL I_SHR[9789]
2D2C                ;  159 arr sign byte   479 NULL I_INT[29696]
2D2C                ;  160 arr sign byte   481 NULL I_IN[15636]
2D2C                ;  161 arr sign byte   482 NULL I_INSB[34]
2D2C                ;  162 arr sign byte   483 NULL I_INSW[3956]
2D2C                ;  163 arr sign byte   484 NULL I_INSD[10557]
2D2C                ;  164 arr sign byte   485 NULL I_OUT[29696]
2D2C                ;  165 arr sign byte   486 NULL I_OUTSB[15626]
2D2C                ;  166 arr sign byte   487 NULL I_OUTSW[40]
2D2C                ;  167 arr sign byte   488 NULL I_OUTSD[1396]
2D2C                ;  168 arr sign byte   490 NULL I_XCHG[9533]
2D2C                ;  169 arr sign byte   492 NULL I_LOOPNZ[29952]
2D2C                ;  170 arr sign byte   493 NULL I_LOOPNE[33542]
2D2C                ;  171 arr sign byte   494 NULL I_LOOPZ[2686]
2D2C                ;  172 arr sign byte   495 NULL I_LOOPE[60176]
2D2C                ;  173 arr sign byte   496 NULL I_LOOP[33540]
2D2C                ;  174 arr sign byte   497 NULL I_JCXZ[2686]
2D2C                ;  175 arr sign byte   498 NULL I_JECXZ[29984]
2D2C                ;  176 arr sign byte   500 NULL I_ENTER[47255]
2D2C                ;  177 arr sign byte   502 NULL I_ORG[1]
2D2C                ;  178 arr sign byte   504 NULL I_SECTION[52169]
2D2C                ;  179 arr sign byte   505 NULL I_SEGMENT[21904]
2D2C                ;  180 arr sign byte   506 NULL I_ABSOLUTE[60555]
2D2C                ;  181 arr sign byte   507 NULL I_PROC[5816]
2D2C                ;  182 arr sign byte   508 NULL I_ENDP[39424]
2D2C                ;  183 arr sign byte   509 NULL I_DB[674]
2D2C                ;  184 arr sign byte   510 NULL I_DW[8125]
2D2C                ;  185 arr sign byte   511 NULL I_DD[51030]
2D2C                ;  186 arr sign byte   512 NULL I_RESB[65094]
2D2C                ;  187 arr sign byte   513 NULL I_RESW[0]
2D2C                ;  188 arr sign byte   514 NULL I_RESD[1678]
2D2C                ;  189 var sign byte   515 NULL I_END
2D2C                
2D2C                
2D2C                ;   # Calls Line Width  Name   list of functions
2D2C                
2D2C                ;    0    4   97   writetty
2D2C                ;    1    1   98   putch
2D2C                ;    2    8   99   cputs
2D2C                ;    3    6  101   DosInt
2D2C                ;    4    1  106   openR
2D2C                ;    5    2  107   creatR
2D2C                ;    6    3  108   fcloseR
2D2C                ;    7    5  109   exitR
2D2C                ;    8    2  110   readRL
2D2C                ;    9    2  111   fputcR
2D2C                ;   10    1  114   getLine
2D2C                ;   11    1  130   ifEOL
2D2C                ;   12    3  139   skipBlank
2D2C                ;   13    2  144   letterE
2D2C                ;   14    1  154   alnumE
2D2C                ;   15    3  159   digit
2D2C                ;   16    4  164   strlen
2D2C                ;   17    9  169   strcpy
2D2C                ;   18   35  175   eqstr
2D2C                ;   19    3  184   strcat1
2D2C                ;   20    2  188   toupper
2D2C                ;   21    1  195   getDigit
2D2C                ;   22    1  207   getName
2D2C                ;   23    1  226   testReg
2D2C                ;   24    1  270   printLine
2D2C                ;   25    7  292   prc
2D2C                ;   26    1  302   prscomment
2D2C                ;   27   35  310   prs
2D2C                ;   28    3  332   printhex8a
2D2C                ;   29    2  337   printhex4
2D2C                ;   30    1  342   printhex16
2D2C                ;   31    7  347   printIntU
2D2C                ;   32   26  358   error1
2D2C                ;   33   13  365   errorexit
2D2C                ;   34    3  370   notfounderror
2D2C                ;   35 NULL  375   allowederror
2D2C                ;   36    3  376   addrerror
2D2C                ;   37    1  377   immeerror
2D2C                ;   38    2  378   implerror
2D2C                ;   39    4  379   indexerror
2D2C                ;   40    3  380   invaloperror
2D2C                ;   41    6  381   numbererror
2D2C                ;   42    1  382   regmemerror
2D2C                ;   43    3  383   reg16error
2D2C                ;   44    1  384   segregerror
2D2C                ;   45    5  385   syntaxerror
2D2C                ;   46 NULL  387   addrexit
2D2C                ;   47    3  388   dataexit
2D2C                ;   48 NULL  389   internexit
2D2C                ;   49    2  517   lookCode
2D2C                ;   50    2  534   ChangeDirection
2D2C                ;   51    2  542   checkOpL
2D2C                ;   52    4  551   check2Ops
2D2C                ;   53    1  560   get2Ops
2D2C                ;   54    3  566   getOpL
2D2C                ;   55    2  574   getOpR
2D2C                ;   56    4  587   getOp1
2D2C                ;   57    1  604   getMEM
2D2C                ;   58    1  630   getIndReg1
2D2C                ;   59    1  638   getIndReg2
2D2C                ;   60    2  648   setwflag
2D2C                ;   61    2  659   setsflag
2D2C                ;   62    2  669   checkConstSize
2D2C                ;   63    1  677   parse
2D2C                ;   64   16  713   getTokeType
2D2C                ;   65    3  724   storeJmp
2D2C                ;   66    2  735   storeLabel
2D2C                ;   67    5  747   searchLabel
2D2C                ;   68    1  760   getVariable
2D2C                ;   69    1  813   getCodeSize
2D2C                ;   70    9  821   isToken
2D2C                ;   71    2  829   need
2D2C                ;   72    1  838   skipRest
2D2C                ;   73    1  845   getarg
2D2C                ;   74    2  879   fixJmp
2D2C                ;   75    2  915   epilog
2D2C                ;   76    2  963   end1
2D2C                ;   77    1  973   getCodes
2D2C                ;   78    1  978   gen66h
2D2C                ;   79    8  980   genCode2
2D2C                ;   80   13  984   genCodeW
2D2C                ;   81   35  988   genCode8
2D2C                ;   82   19  999   genCode16
2D2C                ;   83    1 1003   genCode32
2D2C                ;   84   13 1007   writeEA
2D2C                ;   85    4 1049   genImmediate
2D2C                ;   86    1 1056   process
2D2C                ;   87 NULL 1441   main
2D2C                ;   88 NULL 1447   LastFunctionByt
2D2C                
2D2C                ;    #  addr name   list of CALLs
2D2C                
2D2C                ;    0     0 writetty
2D2C                ;    1     9 writetty
2D2C                ;    2    18 putch
2D2C                ;    3    24 DosInt
2D2C                ;    4    31 DosInt
2D2C                ;    5    38 DosInt
2D2C                ;    6    45 DosInt
2D2C                ;    7    52 DosInt
2D2C                ;    8    59 DosInt
2D2C                ;    9    66 readRL
2D2C                ;   10    73 errorexit
2D2C                ;   11    83 errorexit
2D2C                ;   12    93 ifEOL
2D2C                ;   13    99 readRL
2D2C                ;   14   106 errorexit
2D2C                ;   15   116 digit
2D2C                ;   16   122 letterE
2D2C                ;   17   130 strcpy
2D2C                ;   18   137 digit
2D2C                ;   19   143 alnumE
2D2C                ;   20   150 errorexit
2D2C                ;   21   160 strcpy
2D2C                ;   22   167 toupper
2D2C                ;   23   175 strlen
2D2C                ;   24   182 strlen
2D2C                ;   25   189 eqstr
2D2C                ;   26   195 eqstr
2D2C                ;   27   201 eqstr
2D2C                ;   28   207 eqstr
2D2C                ;   29   213 eqstr
2D2C                ;   30   219 eqstr
2D2C                ;   31   225 eqstr
2D2C                ;   32   231 eqstr
2D2C                ;   33   237 eqstr
2D2C                ;   34   243 eqstr
2D2C                ;   35   249 eqstr
2D2C                ;   36   255 eqstr
2D2C                ;   37   261 eqstr
2D2C                ;   38   267 eqstr
2D2C                ;   39   273 eqstr
2D2C                ;   40   279 eqstr
2D2C                ;   41   285 eqstr
2D2C                ;   42   291 eqstr
2D2C                ;   43   297 eqstr
2D2C                ;   44   303 eqstr
2D2C                ;   45   309 eqstr
2D2C                ;   46   315 eqstr
2D2C                ;   47   321 eqstr
2D2C                ;   48   327 eqstr
2D2C                ;   49   333 eqstr
2D2C                ;   50   339 eqstr
2D2C                ;   51   345 eqstr
2D2C                ;   52   351 eqstr
2D2C                ;   53   357 eqstr
2D2C                ;   54   363 eqstr
2D2C                ;   55   369 prs
2D2C                ;   56   373 printhex16
2D2C                ;   57   384 prs
2D2C                ;   58   388 prc
2D2C                ;   59   392 printhex8a
2D2C                ;   60   403 prs
2D2C                ;   61   407 prc
2D2C                ;   62   411 prscomment
2D2C                ;   63   422 writetty
2D2C                ;   64   431 writetty
2D2C                ;   65   440 fputcR
2D2C                ;   66   447 prc
2D2C                ;   67   451 prc
2D2C                ;   68   455 printhex4
2D2C                ;   69   465 printhex4
2D2C                ;   70   475 prc
2D2C                ;   71   479 printhex8a
2D2C                ;   72   490 printhex8a
2D2C                ;   73   501 printIntU
2D2C                ;   74   511 prc
2D2C                ;   75   515 prs
2D2C                ;   76   519 prs
2D2C                ;   77   523 prs
2D2C                ;   78   527 prs
2D2C                ;   79   531 error1
2D2C                ;   80   538 epilog
2D2C                ;   81   545 end1
2D2C                ;   82   550 prs
2D2C                ;   83   554 prs
2D2C                ;   84   558 error1
2D2C                ;   85   565 error1
2D2C                ;   86   572 error1
2D2C                ;   87   579 error1
2D2C                ;   88   586 error1
2D2C                ;   89   593 error1
2D2C                ;   90   600 error1
2D2C                ;   91   607 error1
2D2C                ;   92   614 error1
2D2C                ;   93   621 error1
2D2C                ;   94   628 error1
2D2C                ;   95   635 errorexit
2D2C                ;   96   645 errorexit
2D2C                ;   97   655 errorexit
2D2C                ;   98   665 eqstr
2D2C                ;   99   671 implerror
2D2C                ;  100   681 segregerror
2D2C                ;  101   693 setwflag
2D2C                ;  102   702 error1
2D2C                ;  103   709 error1
2D2C                ;  104   716 get2Ops
2D2C                ;  105   724 addrerror
2D2C                ;  106   734 invaloperror
2D2C                ;  107   747 immeerror
2D2C                ;  108   757 addrerror
2D2C                ;  109   767 invaloperror
2D2C                ;  110   780 setwflag
2D2C                ;  111   789 getOpL
2D2C                ;  112   796 need
2D2C                ;  113   801 getOpR
2D2C                ;  114   808 getOpR
2D2C                ;  115   815 getOp1
2D2C                ;  116   822 isToken
2D2C                ;  117   830 getMEM
2D2C                ;  118   837 invaloperror
2D2C                ;  119   850 error1
2D2C                ;  120   857 testReg
2D2C                ;  121   865 searchLabel
2D2C                ;  122   877 getTokeType
2D2C                ;  123   889 getOp1
2D2C                ;  124   896 syntaxerror
2D2C                ;  125   908 getIndReg2
2D2C                ;  126   919 getIndReg1
2D2C                ;  127   930 notfounderror
2D2C                ;  128   944 isToken
2D2C                ;  129   952 getTokeType
2D2C                ;  130   964 numbererror
2D2C                ;  131   976 isToken
2D2C                ;  132   984 isToken
2D2C                ;  133   992 errorexit
2D2C                ;  134  1002 indexerror
2D2C                ;  135  1013 indexerror
2D2C                ;  136  1024 indexerror
2D2C                ;  137  1035 indexerror
2D2C                ;  138  1046 gen66h
2D2C                ;  139  1053 error1
2D2C                ;  140  1060 getLine
2D2C                ;  141  1068 getTokeType
2D2C                ;  142  1080 strcpy
2D2C                ;  143  1087 storeLabel
2D2C                ;  144  1098 getTokeType
2D2C                ;  145  1110 lookCode
2D2C                ;  146  1119 process
2D2C                ;  147  1127 getVariable
2D2C                ;  148  1139 skipRest
2D2C                ;  149  1148 error1
2D2C                ;  150  1155 error1
2D2C                ;  151  1162 printLine
2D2C                ;  152  1172 skipBlank
2D2C                ;  153  1182 digit
2D2C                ;  154  1188 getDigit
2D2C                ;  155  1197 letterE
2D2C                ;  156  1205 getName
2D2C                ;  157  1213 errorexit
2D2C                ;  158  1223 strcpy
2D2C                ;  159  1230 errorexit
2D2C                ;  160  1240 searchLabel
2D2C                ;  161  1252 error1
2D2C                ;  162  1259 errorexit
2D2C                ;  163  1269 strcpy
2D2C                ;  164  1276 errorexit
2D2C                ;  165  1286 eqstr
2D2C                ;  166  1292 strlen
2D2C                ;  167  1299 storeLabel
2D2C                ;  168  1310 getTokeType
2D2C                ;  169  1322 lookCode
2D2C                ;  170  1331 dataexit
2D2C                ;  171  1340 dataexit
2D2C                ;  172  1349 getTokeType
2D2C                ;  173  1361 genCode8
2D2C                ;  174  1370 skipBlank
2D2C                ;  175  1380 isToken
2D2C                ;  176  1388 genCode8
2D2C                ;  177  1397 isToken
2D2C                ;  178  1405 getTokeType
2D2C                ;  179  1417 genCode16
2D2C                ;  180  1427 isToken
2D2C                ;  181  1435 getTokeType
2D2C                ;  182  1447 genCode16
2D2C                ;  183  1457 genCode16
2D2C                ;  184  1467 isToken
2D2C                ;  185  1475 getTokeType
2D2C                ;  186  1487 syntaxerror
2D2C                ;  187  1499 error1
2D2C                ;  188  1506 numbererror
2D2C                ;  189  1518 dataexit
2D2C                ;  190  1527 eqstr
2D2C                ;  191  1533 getTokeType
2D2C                ;  192  1545 eqstr
2D2C                ;  193  1551 getTokeType
2D2C                ;  194  1563 eqstr
2D2C                ;  195  1569 getTokeType
2D2C                ;  196  1581 skipBlank
2D2C                ;  197  1591 isToken
2D2C                ;  198  1599 getTokeType
2D2C                ;  199  1611 error1
2D2C                ;  200  1618 prs
2D2C                ;  201  1622 prc
2D2C                ;  202  1626 getTokeType
2D2C                ;  203  1638 error1
2D2C                ;  204  1645 cputs
2D2C                ;  205  1651 cputs
2D2C                ;  206  1657 exitR
2D2C                ;  207  1663 toupper
2D2C                ;  208  1671 strcpy
2D2C                ;  209  1678 strcat1
2D2C                ;  210  1686 strcpy
2D2C                ;  211  1693 strcat1
2D2C                ;  212  1701 strcpy
2D2C                ;  213  1708 strcat1
2D2C                ;  214  1716 openR
2D2C                ;  215  1722 cputs
2D2C                ;  216  1728 cputs
2D2C                ;  217  1734 exitR
2D2C                ;  218  1740 creatR
2D2C                ;  219  1747 cputs
2D2C                ;  220  1753 cputs
2D2C                ;  221  1759 exitR
2D2C                ;  222  1765 creatR
2D2C                ;  223  1772 cputs
2D2C                ;  224  1778 cputs
2D2C                ;  225  1784 exitR
2D2C                ;  226  1790 prs
2D2C                ;  227  1794 prs
2D2C                ;  228  1798 prs
2D2C                ;  229  1802 prs
2D2C                ;  230  1806 prs
2D2C                ;  231  1810 prs
2D2C                ;  232  1814 prs
2D2C                ;  233  1818 prs
2D2C                ;  234  1822 prs
2D2C                ;  235  1826 prs
2D2C                ;  236  1830 printIntU
2D2C                ;  237  1840 strcpy
2D2C                ;  238  1847 strlen
2D2C                ;  239  1854 searchLabel
2D2C                ;  240  1866 notfounderror
2D2C                ;  241  1880 prs
2D2C                ;  242  1884 printIntU
2D2C                ;  243  1894 prs
2D2C                ;  244  1898 prs
2D2C                ;  245  1902 prs
2D2C                ;  246  1906 prs
2D2C                ;  247  1910 prs
2D2C                ;  248  1914 prs
2D2C                ;  249  1918 printIntU
2D2C                ;  250  1928 prs
2D2C                ;  251  1932 prs
2D2C                ;  252  1936 printIntU
2D2C                ;  253  1946 fputcR
2D2C                ;  254  1953 fcloseR
2D2C                ;  255  1961 fcloseR
2D2C                ;  256  1969 fcloseR
2D2C                ;  257  1977 exitR
2D2C                ;  258  1983 genCode8
2D2C                ;  259  1992 genCode8
2D2C                ;  260  2001 genCode8
2D2C                ;  261  2010 errorexit
2D2C                ;  262  2020 genCode8
2D2C                ;  263  2029 genCode8
2D2C                ;  264  2038 genCode16
2D2C                ;  265  2048 genCode16
2D2C                ;  266  2058 genCode8
2D2C                ;  267  2067 genCode8
2D2C                ;  268  2076 genCode16
2D2C                ;  269  2086 genCode32
2D2C                ;  270  2096 genCode16
2D2C                ;  271  2106 genCode8
2D2C                ;  272  2115 getTokeType
2D2C                ;  273  2127 getCodeSize
2D2C                ;  274  2139 getCodes
2D2C                ;  275  2148 genCode8
2D2C                ;  276  2157 getOpL
2D2C                ;  277  2164 checkOpL
2D2C                ;  278  2173 genCode2
2D2C                ;  279  2182 getTokeType
2D2C                ;  280  2194 implerror
2D2C                ;  281  2204 genCodeW
2D2C                ;  282  2213 writeEA
2D2C                ;  283  2221 check2Ops
2D2C                ;  284  2231 reg16error
2D2C                ;  285  2242 addrerror
2D2C                ;  286  2252 genCode8
2D2C                ;  287  2261 genCode8
2D2C                ;  288  2270 writeEA
2D2C                ;  289  2278 check2Ops
2D2C                ;  290  2288 setsflag
2D2C                ;  291  2297 genCodeW
2D2C                ;  292  2306 genImmediate
2D2C                ;  293  2319 genCodeW
2D2C                ;  294  2328 writeEA
2D2C                ;  295  2336 genCode8
2D2C                ;  296  2345 genImmediate
2D2C                ;  297  2358 genCodeW
2D2C                ;  298  2367 writeEA
2D2C                ;  299  2375 genCodeW
2D2C                ;  300  2384 writeEA
2D2C                ;  301  2392 syntaxerror
2D2C                ;  302  2404 check2Ops
2D2C                ;  303  2414 notfounderror
2D2C                ;  304  2428 genCode2
2D2C                ;  305  2437 genImmediate
2D2C                ;  306  2450 genCodeW
2D2C                ;  307  2459 writeEA
2D2C                ;  308  2467 genImmediate
2D2C                ;  309  2480 regmemerror
2D2C                ;  310  2492 ChangeDirection
2D2C                ;  311  2508 reg16error
2D2C                ;  312  2519 genCode2
2D2C                ;  313  2528 writeEA
2D2C                ;  314  2536 genCodeW
2D2C                ;  315  2545 genCode16
2D2C                ;  316  2555 genCodeW
2D2C                ;  317  2564 genCode16
2D2C                ;  318  2574 genCodeW
2D2C                ;  319  2583 writeEA
2D2C                ;  320  2591 ChangeDirection
2D2C                ;  321  2607 genCodeW
2D2C                ;  322  2616 writeEA
2D2C                ;  323  2624 syntaxerror
2D2C                ;  324  2636 searchLabel
2D2C                ;  325  2648 checkConstSize
2D2C                ;  326  2663 genCode2
2D2C                ;  327  2672 genCode8
2D2C                ;  328  2681 genCode8
2D2C                ;  329  2690 genCode2
2D2C                ;  330  2699 genCode16
2D2C                ;  331  2709 genCode8
2D2C                ;  332  2718 genCode2
2D2C                ;  333  2727 storeJmp
2D2C                ;  334  2736 genCode16
2D2C                ;  335  2746 searchLabel
2D2C                ;  336  2758 checkConstSize
2D2C                ;  337  2773 genCode8
2D2C                ;  338  2782 genCode8
2D2C                ;  339  2791 genCode8
2D2C                ;  340  2800 genCode16
2D2C                ;  341  2810 genCode8
2D2C                ;  342  2819 genCode16
2D2C                ;  343  2829 genCode8
2D2C                ;  344  2838 storeJmp
2D2C                ;  345  2847 genCode16
2D2C                ;  346  2857 genCode8
2D2C                ;  347  2866 genCode16
2D2C                ;  348  2876 genCode8
2D2C                ;  349  2885 getOpL
2D2C                ;  350  2892 setsflag
2D2C                ;  351  2901 genCode2
2D2C                ;  352  2910 genCode8
2D2C                ;  353  2919 genCode16
2D2C                ;  354  2929 genCode8
2D2C                ;  355  2938 genCode16
2D2C                ;  356  2948 genCode8
2D2C                ;  357  2957 storeJmp
2D2C                ;  358  2966 genCode16
2D2C                ;  359  2976 error1
2D2C                ;  360  2983 genCode8
2D2C                ;  361  2992 genCode8
2D2C                ;  362  3001 checkOpL
2D2C                ;  363  3010 reg16error
2D2C                ;  364  3021 genCode2
2D2C                ;  365  3030 genCode8
2D2C                ;  366  3039 writeEA
2D2C                ;  367  3047 syntaxerror
2D2C                ;  368  3059 check2Ops
2D2C                ;  369  3069 genCodeW
2D2C                ;  370  3078 writeEA
2D2C                ;  371  3086 genCodeW
2D2C                ;  372  3095 writeEA
2D2C                ;  373  3103 genCode8
2D2C                ;  374  3112 genCodeW
2D2C                ;  375  3121 writeEA
2D2C                ;  376  3129 genCode8
2D2C                ;  377  3138 genCode8
2D2C                ;  378  3147 genCode8
2D2C                ;  379  3156 getOp1
2D2C                ;  380  3163 genCode16
2D2C                ;  381  3173 numbererror
2D2C                ;  382  3185 need
2D2C                ;  383  3190 getOp1
2D2C                ;  384  3197 genCode8
2D2C                ;  385  3206 numbererror
2D2C                ;  386  3218 numbererror
2D2C                ;  387  3230 numbererror
2D2C                ;  388  3242 prs
2D2C                ;  389  3246 prs
2D2C                ;  390  3250 error1
2D2C                ;  391  3257 error1
2D2C                ;  392  3264 prs
2D2C                ;  393  3268 prs
2D2C                ;  394  3272 prs
2D2C                ;  395  3276 printIntU
2D2C                ;  396  3286 prs
2D2C                ;  397  3290 printIntU
2D2C                ;  398  3300 fixJmp
2D2C                ;  399  3307 error1
2D2C                ;  400  3314 getarg
2D2C                ;  401  3321 parse
2D2C                ;  402  3327 fixJmp
2D2C                ;  403  3334 epilog
2D2C                ;  404  3341 end1
2D2C                ;Input: AS.C, List: AS.S,  Lines: 1448
2D2C                ;Glob. variables:  189 max.:  200
2D2C                ;Functions      :   89 max.:  300
2D2C                ;Calls          :  405 max.: 2000, NameField: 3346 max.:    65535
2D2C                ;Code until     :21667 max.: 30000, free: 8333
2D2C                ;Data (HeapEnd) :59154, resting stacksize:  6381
2D2C                ;Max. Const in 'testReg' :  658 max. 3000, free: 2342x.:    65535
;fix jmp to main. resting global jmp:0
;***** next line ERROR:  too many resting global jmp, Symbol: ret
only one global variable: main,from:0001,Label+ORG:2E1A,rel:2D17
 Errors: 73 ***ERROR*** , Out: TE.LST, TE.COM= 11564 bytes. Labels: 258