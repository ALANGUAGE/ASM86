;AS.C V0.1, Source: AS.S, Output: AS.LST, AS.COM

0000                
0000                ; A.COM CComp V0.7, Arglen: 5, Argv: AS.C, Source: AS.C, Output asm: AS.S
0000                ;PROTECTED: 0 V86 OFF.  32bit: ON. 
0000                org  256 ; NASM ON
0000 E9 00 00      *jmp main
0003                
0003                ;-1 char Version1[]="AS.C V0.1";//BAS.BAT, AS TE, NAS.BAT
0003                
0003 41 53 2E 43 20 Version1 db "AS.C V0.1",0
000D                
000D                ;-2 #include "DECL.C"
000D                
000D                ;Use include file: DECL.C
000D                
000D                ;-1 char LIST;              //listing on/off     
000D                
000D 00             LIST db 0
000E                
000E                ;-2 #define SYMBOLMAX    31
000E                
000E                
000E                ;-3 char Symbol[SYMBOLMAX]; //next symbol to decode
000E                
000E 00 00 00 00 00 Symbol resb 31
002D                
002D                ;-4 char SymbolUpper[SYMBOLMAX];//set toupper in getName
002D                
002D 00 00 00 00 00 SymbolUpper resb 31
004C                
004C                ;-5 unsigned int SymbolInt; //integer value set in getDigit
004C                
004C 00 00          SymbolInt dw 0
004E                
004E                ;-6 #define INPUTBUFMAX 127
004E                
004E                
004E                ;-7 char InputBuf[INPUTBUFMAX];//filled in getLine, no overflow test
004E                
004E 00 00 00 00 00 InputBuf resb 127
00CD                
00CD                ;-8 unsigned char *InputPtr;//position in InputBuf
00CD                
00CD 00 00          InputPtr dw 0
00CF                
00CF                ;-9 char namein [67];       //input file name  .S
00CF                
00CF 00 00 00 00 00 namein resb 67
0112                
0112                ;-10 char namelst[67];       //list file name   .LST
0112                
0112 00 00 00 00 00 namelst resb 67
0155                
0155                ;-11 char namebin[67];       //output file name .COM
0155                
0155 00 00 00 00 00 namebin resb 67
0198                
0198                ;-12 int  asm_fd;            //input file descriptor
0198                
0198 00 00          asm_fd dw 0
019A                
019A                ;-13 int lst_fd;             //list file descriptor
019A                
019A 00 00          lst_fd dw 0
019C                
019C                ;-14 int bin_fd;             //output file descriptor
019C                
019C 00 00          bin_fd dw 0
019E                
019E                ;-15 int DOS_ERR=0;          //global var
019E                
019E 00 00          DOS_ERR dw 0
01A0                
01A0                ;-16 int ErrorCount=0;       //number of errors
01A0                
01A0 00 00          ErrorCount dw 0
01A2                
01A2                ;-17 int DOS_NoBytes;        //number of bytes read (0 or 1)
01A2                
01A2 00 00          DOS_NoBytes dw 0
01A4                
01A4                ;-18 char DOS_ByteRead;      //the byte just read by DOS
01A4                
01A4 00             DOS_ByteRead db 0
01A5                
01A5                ;-19 
01A5                
01A5                
01A5                ;-20 unsigned int PC=0;      //program counter
01A5                
01A5 00 00          PC dw 0
01A7                
01A7                ;-21 unsigned int Origin=0;  //ORG nn
01A7                
01A7 00 00          Origin dw 0
01A9                
01A9                ;-22 unsigned int PCStart;   //PC at start of line by PrintLine()
01A9                
01A9 00 00          PCStart dw 0
01AB                
01AB                ;-23 char isLabel;           //by getName()
01AB                
01AB 00             isLabel db 0
01AC                
01AC                ;-24 #define DIGIT    1      //0-9
01AC                
01AC                
01AC                ;-25 #define LETTERE  2      //a-z A-Z @ . _
01AC                
01AC                
01AC                ;-26 #define ALNUME   3      //a-z A-Z @ . _  0-9
01AC                
01AC                
01AC                ;-27 #define NOALNUME 4      //other char
01AC                
01AC                
01AC                ;-28 char TokeType;          //0, DIGIT, LETTERE, ALNUME, NOALNUME
01AC                
01AC 00             TokeType db 0
01AD                
01AD                ;-29 #define BYTE     1
01AD                
01AD                
01AD                ;-30 #define WORD     2
01AD                
01AD                
01AD                ;-31 #define DWORD    3
01AD                
01AD                
01AD                ;-32 #define SEGREG   4
01AD                
01AD                
01AD                ;-33 #define IMM      1      //const  ,123
01AD                
01AD                
01AD                ;-34 #define REG      2      //       ,BX    mode=11
01AD                
01AD                
01AD                ;-35 #define ADR      3      //DIRECT: VALUE  ,var1  mod=00, r/m=110
01AD                
01AD                
01AD                ;-36 #define MEM      4      //[var1],[BX+SI],[table+BX],[bp-4] disp0,8,16
01AD                
01AD                
01AD                ;-37 char Op;                //1. operand: 0, IMM, REG, ADR, MEM  
01AD                
01AD 00             Op db 0
01AE                
01AE                ;-38 char Op2;               //2. operand
01AE                
01AE 00             Op2 db 0
01AF                
01AF                ;-39 char CodeType;          //1-207 by searchSymbol(), must be byte size
01AF                
01AF 00             CodeType db 0
01B0                
01B0                ;-40 char Code1;             //1. Opcode
01B0                
01B0 00             Code1 db 0
01B1                
01B1                ;-41 char Code2;             //2. Opcode
01B1                
01B1 00             Code2 db 0
01B2                
01B2                ;-42 char Code3;             //3. Opcode
01B2                
01B2 00             Code3 db 0
01B3                
01B3                ;-43 char R2No;              //0 - 7 AL, CL, ...  set in testReg()  
01B3                
01B3 00             R2No db 0
01B4                
01B4                ;-44 char R1No;              //temp for 1. register
01B4                
01B4 00             R1No db 0
01B5                
01B5                ;-45 char R2Type;            //0=no reg, BYTE, WORD, DWORD, SEGREG
01B5                
01B5 00             R2Type db 0
01B6                
01B6                ;-46 char R1Type;            //temp for 1. register 
01B6                
01B6 00             R1Type db 0
01B7                
01B7                ;-47 char OpSize;            //0, BYTE, WORD, DWORD by getCodeSize()
01B7                
01B7 00             OpSize db 0
01B8                
01B8                ;-48 char wflag;             //wordflag: 0=byte, 1=word/dword
01B8                
01B8 00             wflag db 0
01B9                
01B9                ;-49 char dflag;             //directionflag: 1=to reg MOV,ALU    
01B9                
01B9 00             dflag db 0
01BA                
01BA                ;-50 char sflag;             //sign extended, imm8 to word PUSH,ALU,IMUL3 
01BA                
01BA 00             sflag db 0
01BB                
01BB                ;-51 char rm;                //combination of index and base reg
01BB                
01BB 00             rm db 0
01BC                
01BC                ;-52 char isDirect;          //set in process and getMeM, need in WriteEA
01BC                
01BC 00             isDirect db 0
01BD                
01BD                ;-53 int disp;               //displacement      0-8 bytes
01BD                
01BD 00 00          disp dw 0
01BF                
01BF                ;-54 unsigned int imme;      //immediate         0-8 bytes
01BF                
01BF 00 00          imme dw 0
01C1                
01C1                ;-55 
01C1                
01C1                
01C1                ;-56 #define OPMAXLEN 5
01C1                
01C1                
01C1                ;-57 char OpPos[OPMAXLEN];   //array for one opcode to list
01C1                
01C1 00 00 00 00 00 OpPos resb 5
01C6                
01C6                ;-58 int OpPrintIndex;       //0-OPMAXLEN, pos to print opcode, by genCode8
01C6                
01C6 00 00          OpPrintIndex dw 0
01C8                
01C8                ;-59 char *OpCodePtr;        //position in OpCodeTable by searchSymbol
01C8                
01C8 00 00          OpCodePtr dw 0
01CA                
01CA                ;-60 char PrintRA;           //print * for forward relocative jmp
01CA                
01CA 00             PrintRA db 0
01CB                
01CB                ;-61 
01CB                
01CB                
01CB                ;-62 #define LABELNAMESMAX 3969//next number - SYMBOLMAX
01CB                
01CB                
01CB                ;-63 char LabelNames[4000];  //space for names of all labels
01CB                
01CB 00 00 00 00 00 LabelNames resb 4000
116B                
116B                ;-64 char *LabelNamePtr;     //first free position
116B                
116B 00 00          LabelNamePtr dw 0
116D                
116D                ;-65 #define LABELADRMAX 600
116D                
116D                
116D                ;-66 unsigned int LabelAddr[LABELADRMAX];//addr of each label
116D                
116D 00 00 00 00 00 LabelAddr resw 600
161D                
161D                ;-67 int LabelMaxIx=0;       //actual # of stored labels. 1 to LABELADRMAX-1
161D                
161D 00 00          LabelMaxIx dw 0
161F                
161F                ;-68 int LabelIx;            //actual # of just searched label
161F                
161F 00 00          LabelIx dw 0
1621                
1621                ;-69 
1621                
1621                
1621                ;-70 #define JMPCALLNAMESMAX 1969//next number - SYMBOLMAX
1621                
1621                
1621                ;-71 char JmpCallNames[2000];//space for names of jmp, call
1621                
1621 00 00 00 00 00 JmpCallNames resb 2000
1DF1                
1DF1                ;-72 char *JmpCallNamePtr;   //first free position 
1DF1                
1DF1 00 00          JmpCallNamePtr dw 0
1DF3                
1DF3                ;-73 #define JMPCALLMAX 500  //max. jmp and call
1DF3                
1DF3                
1DF3                ;-74 unsigned int JmpCallAddr[JMPCALLMAX];//addr to be fixed
1DF3                
1DF3 00 00 00 00 00 JmpCallAddr resw 500
21DB                
21DB                ;-75 int JmpCallMaxIx=0;     //actual # of jmp, call. 1 to JMPCALLMAX-1
21DB                
21DB 00 00          JmpCallMaxIx dw 0
21DD                
21DD                ;-76  
21DD                
21DD                
21DD                ;-77 #define FILEBINMAX 20000 
21DD                
21DD                
21DD                ;-78 char FileBin  [FILEBINMAX];//output binary file
21DD                
;***** next line ERROR: COM file too long, Symbol: resb